<html>
<head>
<title>resolvers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolvers.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
This module converts requested URLs to callback view functions. 
 
URLResolver is the main class here. Its resolve() method takes a URL (as 
a string) and returns a ResolverMatch object which provides access to all 
attributes of the resolved URL match. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">string</span>
<span class="s2">from </span><span class="s1">importlib </span><span class="s2">import </span><span class="s1">import_module</span>
<span class="s2">from </span><span class="s1">pickle </span><span class="s2">import </span><span class="s1">PicklingError</span>
<span class="s2">from </span><span class="s1">urllib.parse </span><span class="s2">import </span><span class="s1">quote</span>

<span class="s2">from </span><span class="s1">asgiref.local </span><span class="s2">import </span><span class="s1">Local</span>

<span class="s2">from </span><span class="s1">django.conf </span><span class="s2">import </span><span class="s1">settings</span>
<span class="s2">from </span><span class="s1">django.core.checks </span><span class="s2">import </span><span class="s1">Error</span><span class="s2">, </span><span class="s1">Warning</span>
<span class="s2">from </span><span class="s1">django.core.checks.urls </span><span class="s2">import </span><span class="s1">check_resolver</span>
<span class="s2">from </span><span class="s1">django.core.exceptions </span><span class="s2">import </span><span class="s1">ImproperlyConfigured</span><span class="s2">, </span><span class="s1">ViewDoesNotExist</span>
<span class="s2">from </span><span class="s1">django.utils.datastructures </span><span class="s2">import </span><span class="s1">MultiValueDict</span>
<span class="s2">from </span><span class="s1">django.utils.functional </span><span class="s2">import </span><span class="s1">cached_property</span>
<span class="s2">from </span><span class="s1">django.utils.http </span><span class="s2">import </span><span class="s1">RFC3986_SUBDELIMS</span><span class="s2">, </span><span class="s1">escape_leading_slashes</span>
<span class="s2">from </span><span class="s1">django.utils.regex_helper </span><span class="s2">import </span><span class="s1">_lazy_re_compile</span><span class="s2">, </span><span class="s1">normalize</span>
<span class="s2">from </span><span class="s1">django.utils.translation </span><span class="s2">import </span><span class="s1">get_language</span>

<span class="s2">from </span><span class="s1">.converters </span><span class="s2">import </span><span class="s1">get_converter</span>
<span class="s2">from </span><span class="s1">.exceptions </span><span class="s2">import </span><span class="s1">NoReverseMatch</span><span class="s2">, </span><span class="s1">Resolver404</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">get_callable</span>


<span class="s2">class </span><span class="s1">ResolverMatch:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">url_name=</span><span class="s2">None, </span><span class="s1">app_names=</span><span class="s2">None, </span><span class="s1">namespaces=</span><span class="s2">None, </span><span class="s1">route=</span><span class="s2">None, </span><span class="s1">tried=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.func = func</span>
        <span class="s1">self.args = args</span>
        <span class="s1">self.kwargs = kwargs</span>
        <span class="s1">self.url_name = url_name</span>
        <span class="s1">self.route = route</span>
        <span class="s1">self.tried = tried</span>

        <span class="s3"># If a URLRegexResolver doesn't have a namespace or app_name, it passes</span>
        <span class="s3"># in an empty value.</span>
        <span class="s1">self.app_names = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">app_names </span><span class="s2">if </span><span class="s1">x] </span><span class="s2">if </span><span class="s1">app_names </span><span class="s2">else </span><span class="s1">[]</span>
        <span class="s1">self.app_name = </span><span class="s4">':'</span><span class="s1">.join(self.app_names)</span>
        <span class="s1">self.namespaces = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">namespaces </span><span class="s2">if </span><span class="s1">x] </span><span class="s2">if </span><span class="s1">namespaces </span><span class="s2">else </span><span class="s1">[]</span>
        <span class="s1">self.namespace = </span><span class="s4">':'</span><span class="s1">.join(self.namespaces)</span>

        <span class="s2">if not </span><span class="s1">hasattr(func</span><span class="s2">, </span><span class="s4">'__name__'</span><span class="s1">):</span>
            <span class="s3"># A class-based view</span>
            <span class="s1">self._func_path = func.__class__.__module__ + </span><span class="s4">'.' </span><span class="s1">+ func.__class__.__name__</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># A function-based view</span>
            <span class="s1">self._func_path = func.__module__ + </span><span class="s4">'.' </span><span class="s1">+ func.__name__</span>

        <span class="s1">view_path = url_name </span><span class="s2">or </span><span class="s1">self._func_path</span>
        <span class="s1">self.view_name = </span><span class="s4">':'</span><span class="s1">.join(self.namespaces + [view_path])</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">index):</span>
        <span class="s2">return </span><span class="s1">(self.func</span><span class="s2">, </span><span class="s1">self.args</span><span class="s2">, </span><span class="s1">self.kwargs)[index]</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">if </span><span class="s1">isinstance(self.func</span><span class="s2">, </span><span class="s1">functools.partial):</span>
            <span class="s1">func = repr(self.func)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">func = self._func_path</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">'ResolverMatch(func=%s, args=%r, kwargs=%r, url_name=%r, '</span>
            <span class="s4">'app_names=%r, namespaces=%r, route=%r)' </span><span class="s1">% (</span>
                <span class="s1">func</span><span class="s2">, </span><span class="s1">self.args</span><span class="s2">, </span><span class="s1">self.kwargs</span><span class="s2">, </span><span class="s1">self.url_name</span><span class="s2">,</span>
                <span class="s1">self.app_names</span><span class="s2">, </span><span class="s1">self.namespaces</span><span class="s2">, </span><span class="s1">self.route</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__reduce_ex__(self</span><span class="s2">, </span><span class="s1">protocol):</span>
        <span class="s2">raise </span><span class="s1">PicklingError(</span><span class="s4">f'Cannot pickle </span><span class="s2">{</span><span class="s1">self.__class__.__qualname__</span><span class="s2">}</span><span class="s4">.'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_resolver(urlconf=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">urlconf </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">urlconf = settings.ROOT_URLCONF</span>
    <span class="s2">return </span><span class="s1">_get_cached_resolver(urlconf)</span>


<span class="s1">@functools.lru_cache(maxsize=</span><span class="s2">None</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">_get_cached_resolver(urlconf=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">return </span><span class="s1">URLResolver(RegexPattern(</span><span class="s4">r'^/'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">urlconf)</span>


<span class="s1">@functools.lru_cache(maxsize=</span><span class="s2">None</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">get_ns_resolver(ns_pattern</span><span class="s2">, </span><span class="s1">resolver</span><span class="s2">, </span><span class="s1">converters):</span>
    <span class="s3"># Build a namespaced resolver for the given parent URLconf pattern.</span>
    <span class="s3"># This makes it possible to have captured parameters in the parent</span>
    <span class="s3"># URLconf pattern.</span>
    <span class="s1">pattern = RegexPattern(ns_pattern)</span>
    <span class="s1">pattern.converters = dict(converters)</span>
    <span class="s1">ns_resolver = URLResolver(pattern</span><span class="s2">, </span><span class="s1">resolver.url_patterns)</span>
    <span class="s2">return </span><span class="s1">URLResolver(RegexPattern(</span><span class="s4">r'^/'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[ns_resolver])</span>


<span class="s2">class </span><span class="s1">LocaleRegexDescriptor:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">attr):</span>
        <span class="s1">self.attr = attr</span>

    <span class="s2">def </span><span class="s1">__get__(self</span><span class="s2">, </span><span class="s1">instance</span><span class="s2">, </span><span class="s1">cls=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a compiled regular expression based on the active language. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">instance </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s3"># As a performance optimization, if the given regex string is a regular</span>
        <span class="s3"># string (not a lazily-translated string proxy), compile it once and</span>
        <span class="s3"># avoid per-language compilation.</span>
        <span class="s1">pattern = getattr(instance</span><span class="s2">, </span><span class="s1">self.attr)</span>
        <span class="s2">if </span><span class="s1">isinstance(pattern</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">instance.__dict__[</span><span class="s4">'regex'</span><span class="s1">] = instance._compile(pattern)</span>
            <span class="s2">return </span><span class="s1">instance.__dict__[</span><span class="s4">'regex'</span><span class="s1">]</span>
        <span class="s1">language_code = get_language()</span>
        <span class="s2">if </span><span class="s1">language_code </span><span class="s2">not in </span><span class="s1">instance._regex_dict:</span>
            <span class="s1">instance._regex_dict[language_code] = instance._compile(str(pattern))</span>
        <span class="s2">return </span><span class="s1">instance._regex_dict[language_code]</span>


<span class="s2">class </span><span class="s1">CheckURLMixin:</span>
    <span class="s2">def </span><span class="s1">describe(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Format the URL pattern for display in warning messages. 
        &quot;&quot;&quot;</span>
        <span class="s1">description = </span><span class="s4">&quot;'{}'&quot;</span><span class="s1">.format(self)</span>
        <span class="s2">if </span><span class="s1">self.name:</span>
            <span class="s1">description += </span><span class="s4">&quot; [name='{}']&quot;</span><span class="s1">.format(self.name)</span>
        <span class="s2">return </span><span class="s1">description</span>

    <span class="s2">def </span><span class="s1">_check_pattern_startswith_slash(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check that the pattern does not begin with a forward slash. 
        &quot;&quot;&quot;</span>
        <span class="s1">regex_pattern = self.regex.pattern</span>
        <span class="s2">if not </span><span class="s1">settings.APPEND_SLASH:</span>
            <span class="s3"># Skip check as it can be useful to start a URL pattern with a slash</span>
            <span class="s3"># when APPEND_SLASH=False.</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">if </span><span class="s1">regex_pattern.startswith((</span><span class="s4">'/'</span><span class="s2">, </span><span class="s4">'^/'</span><span class="s2">, </span><span class="s4">'^</span><span class="s2">\\</span><span class="s4">/'</span><span class="s1">)) </span><span class="s2">and not </span><span class="s1">regex_pattern.endswith(</span><span class="s4">'/'</span><span class="s1">):</span>
            <span class="s1">warning = Warning(</span>
                <span class="s4">&quot;Your URL pattern {} has a route beginning with a '/'. Remove this &quot;</span>
                <span class="s4">&quot;slash as it is unnecessary. If this pattern is targeted in an &quot;</span>
                <span class="s4">&quot;include(), ensure the include() pattern has a trailing '/'.&quot;</span><span class="s1">.format(</span>
                    <span class="s1">self.describe()</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s4">&quot;urls.W002&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[warning]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>


<span class="s2">class </span><span class="s1">RegexPattern(CheckURLMixin):</span>
    <span class="s1">regex = LocaleRegexDescriptor(</span><span class="s4">'_regex'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">regex</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">is_endpoint=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self._regex = regex</span>
        <span class="s1">self._regex_dict = {}</span>
        <span class="s1">self._is_endpoint = is_endpoint</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.converters = {}</span>

    <span class="s2">def </span><span class="s1">match(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">match = (</span>
            <span class="s1">self.regex.fullmatch(path)</span>
            <span class="s2">if </span><span class="s1">self._is_endpoint </span><span class="s2">and </span><span class="s1">self.regex.pattern.endswith(</span><span class="s4">'$'</span><span class="s1">)</span>
            <span class="s2">else </span><span class="s1">self.regex.search(path)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s3"># If there are any named groups, use those as kwargs, ignoring</span>
            <span class="s3"># non-named groups. Otherwise, pass all non-named arguments as</span>
            <span class="s3"># positional arguments.</span>
            <span class="s1">kwargs = match.groupdict()</span>
            <span class="s1">args = () </span><span class="s2">if </span><span class="s1">kwargs </span><span class="s2">else </span><span class="s1">match.groups()</span>
            <span class="s1">kwargs = {k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items() </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is not None</span><span class="s1">}</span>
            <span class="s2">return </span><span class="s1">path[match.end():]</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">check(self):</span>
        <span class="s1">warnings = []</span>
        <span class="s1">warnings.extend(self._check_pattern_startswith_slash())</span>
        <span class="s2">if not </span><span class="s1">self._is_endpoint:</span>
            <span class="s1">warnings.extend(self._check_include_trailing_dollar())</span>
        <span class="s2">return </span><span class="s1">warnings</span>

    <span class="s2">def </span><span class="s1">_check_include_trailing_dollar(self):</span>
        <span class="s1">regex_pattern = self.regex.pattern</span>
        <span class="s2">if </span><span class="s1">regex_pattern.endswith(</span><span class="s4">'$'</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">regex_pattern.endswith(</span><span class="s4">r'\$'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">[Warning(</span>
                <span class="s4">&quot;Your URL pattern {} uses include with a route ending with a '$'. &quot;</span>
                <span class="s4">&quot;Remove the dollar from the route to avoid problems including &quot;</span>
                <span class="s4">&quot;URLs.&quot;</span><span class="s1">.format(self.describe())</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s4">'urls.W001'</span><span class="s2">,</span>
            <span class="s1">)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">_compile(self</span><span class="s2">, </span><span class="s1">regex):</span>
        <span class="s0">&quot;&quot;&quot;Compile and return the given regular expression.&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">re.compile(regex)</span>
        <span class="s2">except </span><span class="s1">re.error </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ImproperlyConfigured(</span>
                <span class="s4">'&quot;%s&quot; is not a valid regular expression: %s' </span><span class="s1">% (regex</span><span class="s2">, </span><span class="s1">e)</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">str(self._regex)</span>


<span class="s1">_PATH_PARAMETER_COMPONENT_RE = _lazy_re_compile(</span>
    <span class="s4">r'&lt;(?:(?P&lt;converter&gt;[^&gt;:]+):)?(?P&lt;parameter&gt;[^&gt;]+)&gt;'</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_route_to_regex(route</span><span class="s2">, </span><span class="s1">is_endpoint=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a path pattern into a regular expression. Return the regular 
    expression and a dictionary mapping the capture names to the converters. 
    For example, 'foo/&lt;int:pk&gt;' returns '^foo\\/(?P&lt;pk&gt;[0-9]+)' 
    and {'pk': &lt;django.urls.converters.IntConverter&gt;}. 
    &quot;&quot;&quot;</span>
    <span class="s1">original_route = route</span>
    <span class="s1">parts = [</span><span class="s4">'^'</span><span class="s1">]</span>
    <span class="s1">converters = {}</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">match = _PATH_PARAMETER_COMPONENT_RE.search(route)</span>
        <span class="s2">if not </span><span class="s1">match:</span>
            <span class="s1">parts.append(re.escape(route))</span>
            <span class="s2">break</span>
        <span class="s2">elif not </span><span class="s1">set(match.group()).isdisjoint(string.whitespace):</span>
            <span class="s2">raise </span><span class="s1">ImproperlyConfigured(</span>
                <span class="s4">&quot;URL route '%s' cannot contain whitespace in angle brackets &quot;</span>
                <span class="s4">&quot;&lt;â€¦&gt;.&quot; </span><span class="s1">% original_route</span>
            <span class="s1">)</span>
        <span class="s1">parts.append(re.escape(route[:match.start()]))</span>
        <span class="s1">route = route[match.end():]</span>
        <span class="s1">parameter = match[</span><span class="s4">'parameter'</span><span class="s1">]</span>
        <span class="s2">if not </span><span class="s1">parameter.isidentifier():</span>
            <span class="s2">raise </span><span class="s1">ImproperlyConfigured(</span>
                <span class="s4">&quot;URL route '%s' uses parameter name %r which isn't a valid &quot;</span>
                <span class="s4">&quot;Python identifier.&quot; </span><span class="s1">% (original_route</span><span class="s2">, </span><span class="s1">parameter)</span>
            <span class="s1">)</span>
        <span class="s1">raw_converter = match[</span><span class="s4">'converter'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">raw_converter </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># If a converter isn't specified, the default is `str`.</span>
            <span class="s1">raw_converter = </span><span class="s4">'str'</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">converter = get_converter(raw_converter)</span>
        <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ImproperlyConfigured(</span>
                <span class="s4">'URL route %r uses invalid converter %r.'</span>
                <span class="s1">% (original_route</span><span class="s2">, </span><span class="s1">raw_converter)</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s1">converters[parameter] = converter</span>
        <span class="s1">parts.append(</span><span class="s4">'(?P&lt;' </span><span class="s1">+ parameter + </span><span class="s4">'&gt;' </span><span class="s1">+ converter.regex + </span><span class="s4">')'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">is_endpoint:</span>
        <span class="s1">parts.append(</span><span class="s4">r'\Z'</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s4">''</span><span class="s1">.join(parts)</span><span class="s2">, </span><span class="s1">converters</span>


<span class="s2">class </span><span class="s1">RoutePattern(CheckURLMixin):</span>
    <span class="s1">regex = LocaleRegexDescriptor(</span><span class="s4">'_route'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">route</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None, </span><span class="s1">is_endpoint=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">self._route = route</span>
        <span class="s1">self._regex_dict = {}</span>
        <span class="s1">self._is_endpoint = is_endpoint</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.converters = _route_to_regex(str(route)</span><span class="s2">, </span><span class="s1">is_endpoint)[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">match(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">match = self.regex.search(path)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s3"># RoutePattern doesn't allow non-named groups so args are ignored.</span>
            <span class="s1">kwargs = match.groupdict()</span>
            <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">kwargs.items():</span>
                <span class="s1">converter = self.converters[key]</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">kwargs[key] = converter.to_python(value)</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">return None</span>
            <span class="s2">return </span><span class="s1">path[match.end():]</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">kwargs</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">check(self):</span>
        <span class="s1">warnings = self._check_pattern_startswith_slash()</span>
        <span class="s1">route = self._route</span>
        <span class="s2">if </span><span class="s4">'(?P&lt;' </span><span class="s2">in </span><span class="s1">route </span><span class="s2">or </span><span class="s1">route.startswith(</span><span class="s4">'^'</span><span class="s1">) </span><span class="s2">or </span><span class="s1">route.endswith(</span><span class="s4">'$'</span><span class="s1">):</span>
            <span class="s1">warnings.append(Warning(</span>
                <span class="s4">&quot;Your URL pattern {} has a route that contains '(?P&lt;', begins &quot;</span>
                <span class="s4">&quot;with a '^', or ends with a '$'. This was likely an oversight &quot;</span>
                <span class="s4">&quot;when migrating to django.urls.path().&quot;</span><span class="s1">.format(self.describe())</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s4">'2_0.W001'</span><span class="s2">,</span>
            <span class="s1">))</span>
        <span class="s2">return </span><span class="s1">warnings</span>

    <span class="s2">def </span><span class="s1">_compile(self</span><span class="s2">, </span><span class="s1">route):</span>
        <span class="s2">return </span><span class="s1">re.compile(_route_to_regex(route</span><span class="s2">, </span><span class="s1">self._is_endpoint)[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">str(self._route)</span>


<span class="s2">class </span><span class="s1">LocalePrefixPattern:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">prefix_default_language=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">self.prefix_default_language = prefix_default_language</span>
        <span class="s1">self.converters = {}</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">regex(self):</span>
        <span class="s3"># This is only used by reverse() and cached in _reverse_dict.</span>
        <span class="s2">return </span><span class="s1">re.compile(self.language_prefix)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">language_prefix(self):</span>
        <span class="s1">language_code = get_language() </span><span class="s2">or </span><span class="s1">settings.LANGUAGE_CODE</span>
        <span class="s2">if </span><span class="s1">language_code == settings.LANGUAGE_CODE </span><span class="s2">and not </span><span class="s1">self.prefix_default_language:</span>
            <span class="s2">return </span><span class="s4">''</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">'%s/' </span><span class="s1">% language_code</span>

    <span class="s2">def </span><span class="s1">match(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">language_prefix = self.language_prefix</span>
        <span class="s2">if </span><span class="s1">path.startswith(language_prefix):</span>
            <span class="s2">return </span><span class="s1">path[len(language_prefix):]</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">{}</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">check(self):</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">describe(self):</span>
        <span class="s2">return </span><span class="s4">&quot;'{}'&quot;</span><span class="s1">.format(self)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">self.language_prefix</span>


<span class="s2">class </span><span class="s1">URLPattern:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">, </span><span class="s1">default_args=</span><span class="s2">None, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.pattern = pattern</span>
        <span class="s1">self.callback = callback  </span><span class="s3"># the view</span>
        <span class="s1">self.default_args = default_args </span><span class="s2">or </span><span class="s1">{}</span>
        <span class="s1">self.name = name</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'&lt;%s %s&gt;' </span><span class="s1">% (self.__class__.__name__</span><span class="s2">, </span><span class="s1">self.pattern.describe())</span>

    <span class="s2">def </span><span class="s1">check(self):</span>
        <span class="s1">warnings = self._check_pattern_name()</span>
        <span class="s1">warnings.extend(self.pattern.check())</span>
        <span class="s1">warnings.extend(self._check_callback())</span>
        <span class="s2">return </span><span class="s1">warnings</span>

    <span class="s2">def </span><span class="s1">_check_pattern_name(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check that the pattern name does not contain a colon. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.pattern.name </span><span class="s2">is not None and </span><span class="s4">&quot;:&quot; </span><span class="s2">in </span><span class="s1">self.pattern.name:</span>
            <span class="s1">warning = Warning(</span>
                <span class="s4">&quot;Your URL pattern {} has a name including a ':'. Remove the colon, to &quot;</span>
                <span class="s4">&quot;avoid ambiguous namespace references.&quot;</span><span class="s1">.format(self.pattern.describe())</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s4">&quot;urls.W003&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[warning]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">_check_callback(self):</span>
        <span class="s2">from </span><span class="s1">django.views </span><span class="s2">import </span><span class="s1">View</span>

        <span class="s1">view = self.callback</span>
        <span class="s2">if </span><span class="s1">inspect.isclass(view) </span><span class="s2">and </span><span class="s1">issubclass(view</span><span class="s2">, </span><span class="s1">View):</span>
            <span class="s2">return </span><span class="s1">[Error(</span>
                <span class="s4">'Your URL pattern %s has an invalid view, pass %s.as_view() '</span>
                <span class="s4">'instead of %s.' </span><span class="s1">% (</span>
                    <span class="s1">self.pattern.describe()</span><span class="s2">,</span>
                    <span class="s1">view.__name__</span><span class="s2">,</span>
                    <span class="s1">view.__name__</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s4">'urls.E009'</span><span class="s2">,</span>
            <span class="s1">)]</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s2">def </span><span class="s1">resolve(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">match = self.pattern.match(path)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">new_path</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs = match</span>
            <span class="s3"># Pass any extra_kwargs as **kwargs.</span>
            <span class="s1">kwargs.update(self.default_args)</span>
            <span class="s2">return </span><span class="s1">ResolverMatch(self.callback</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">self.pattern.name</span><span class="s2">, </span><span class="s1">route=str(self.pattern))</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">lookup_str(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        A string that identifies the view (e.g. 'path.to.view_function' or 
        'path.to.ClassBasedView'). 
        &quot;&quot;&quot;</span>
        <span class="s1">callback = self.callback</span>
        <span class="s2">if </span><span class="s1">isinstance(callback</span><span class="s2">, </span><span class="s1">functools.partial):</span>
            <span class="s1">callback = callback.func</span>
        <span class="s2">if </span><span class="s1">hasattr(callback</span><span class="s2">, </span><span class="s4">'view_class'</span><span class="s1">):</span>
            <span class="s1">callback = callback.view_class</span>
        <span class="s2">elif not </span><span class="s1">hasattr(callback</span><span class="s2">, </span><span class="s4">'__name__'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">callback.__module__ + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ callback.__class__.__name__</span>
        <span class="s2">return </span><span class="s1">callback.__module__ + </span><span class="s4">&quot;.&quot; </span><span class="s1">+ callback.__qualname__</span>


<span class="s2">class </span><span class="s1">URLResolver:</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">urlconf_name</span><span class="s2">, </span><span class="s1">default_kwargs=</span><span class="s2">None, </span><span class="s1">app_name=</span><span class="s2">None, </span><span class="s1">namespace=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.pattern = pattern</span>
        <span class="s3"># urlconf_name is the dotted Python path to the module defining</span>
        <span class="s3"># urlpatterns. It may also be an object with an urlpatterns attribute</span>
        <span class="s3"># or urlpatterns itself.</span>
        <span class="s1">self.urlconf_name = urlconf_name</span>
        <span class="s1">self.callback = </span><span class="s2">None</span>
        <span class="s1">self.default_kwargs = default_kwargs </span><span class="s2">or </span><span class="s1">{}</span>
        <span class="s1">self.namespace = namespace</span>
        <span class="s1">self.app_name = app_name</span>
        <span class="s1">self._reverse_dict = {}</span>
        <span class="s1">self._namespace_dict = {}</span>
        <span class="s1">self._app_dict = {}</span>
        <span class="s3"># set of dotted paths to all functions and classes that are used in</span>
        <span class="s3"># urlpatterns</span>
        <span class="s1">self._callback_strs = set()</span>
        <span class="s1">self._populated = </span><span class="s2">False</span>
        <span class="s1">self._local = Local()</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">if </span><span class="s1">isinstance(self.urlconf_name</span><span class="s2">, </span><span class="s1">list) </span><span class="s2">and </span><span class="s1">self.urlconf_name:</span>
            <span class="s3"># Don't bother to output the whole list, it can be huge</span>
            <span class="s1">urlconf_repr = </span><span class="s4">'&lt;%s list&gt;' </span><span class="s1">% self.urlconf_name[</span><span class="s5">0</span><span class="s1">].__class__.__name__</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">urlconf_repr = repr(self.urlconf_name)</span>
        <span class="s2">return </span><span class="s4">'&lt;%s %s (%s:%s) %s&gt;' </span><span class="s1">% (</span>
            <span class="s1">self.__class__.__name__</span><span class="s2">, </span><span class="s1">urlconf_repr</span><span class="s2">, </span><span class="s1">self.app_name</span><span class="s2">,</span>
            <span class="s1">self.namespace</span><span class="s2">, </span><span class="s1">self.pattern.describe()</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">check(self):</span>
        <span class="s1">messages = []</span>
        <span class="s2">for </span><span class="s1">pattern </span><span class="s2">in </span><span class="s1">self.url_patterns:</span>
            <span class="s1">messages.extend(check_resolver(pattern))</span>
        <span class="s1">messages.extend(self._check_custom_error_handlers())</span>
        <span class="s2">return </span><span class="s1">messages </span><span class="s2">or </span><span class="s1">self.pattern.check()</span>

    <span class="s2">def </span><span class="s1">_check_custom_error_handlers(self):</span>
        <span class="s1">messages = []</span>
        <span class="s3"># All handlers take (request, exception) arguments except handler500</span>
        <span class="s3"># which takes (request).</span>
        <span class="s2">for </span><span class="s1">status_code</span><span class="s2">, </span><span class="s1">num_parameters </span><span class="s2">in </span><span class="s1">[(</span><span class="s5">400</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">403</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">404</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">500</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)]:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">handler = self.resolve_error_handler(status_code)</span>
            <span class="s2">except </span><span class="s1">(ImportError</span><span class="s2">, </span><span class="s1">ViewDoesNotExist) </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s1">path = getattr(self.urlconf_module</span><span class="s2">, </span><span class="s4">'handler%s' </span><span class="s1">% status_code)</span>
                <span class="s1">msg = (</span>
                    <span class="s4">&quot;The custom handler{status_code} view '{path}' could not be imported.&quot;</span>
                <span class="s1">).format(status_code=status_code</span><span class="s2">, </span><span class="s1">path=path)</span>
                <span class="s1">messages.append(Error(msg</span><span class="s2">, </span><span class="s1">hint=str(e)</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">'urls.E008'</span><span class="s1">))</span>
                <span class="s2">continue</span>
            <span class="s1">signature = inspect.signature(handler)</span>
            <span class="s1">args = [</span><span class="s2">None</span><span class="s1">] * num_parameters</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">signature.bind(*args)</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s1">msg = (</span>
                    <span class="s4">&quot;The custom handler{status_code} view '{path}' does not &quot;</span>
                    <span class="s4">&quot;take the correct number of arguments ({args}).&quot;</span>
                <span class="s1">).format(</span>
                    <span class="s1">status_code=status_code</span><span class="s2">,</span>
                    <span class="s1">path=handler.__module__ + </span><span class="s4">'.' </span><span class="s1">+ handler.__qualname__</span><span class="s2">,</span>
                    <span class="s1">args=</span><span class="s4">'request, exception' </span><span class="s2">if </span><span class="s1">num_parameters == </span><span class="s5">2 </span><span class="s2">else </span><span class="s4">'request'</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">messages.append(Error(msg</span><span class="s2">, </span><span class="s1">id=</span><span class="s4">'urls.E007'</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">messages</span>

    <span class="s2">def </span><span class="s1">_populate(self):</span>
        <span class="s3"># Short-circuit if called recursively in this thread to prevent</span>
        <span class="s3"># infinite recursion. Concurrent threads may call this at the same</span>
        <span class="s3"># time and will need to continue, so set 'populating' on a</span>
        <span class="s3"># thread-local variable.</span>
        <span class="s2">if </span><span class="s1">getattr(self._local</span><span class="s2">, </span><span class="s4">'populating'</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self._local.populating = </span><span class="s2">True</span>
            <span class="s1">lookups = MultiValueDict()</span>
            <span class="s1">namespaces = {}</span>
            <span class="s1">apps = {}</span>
            <span class="s1">language_code = get_language()</span>
            <span class="s2">for </span><span class="s1">url_pattern </span><span class="s2">in </span><span class="s1">reversed(self.url_patterns):</span>
                <span class="s1">p_pattern = url_pattern.pattern.regex.pattern</span>
                <span class="s2">if </span><span class="s1">p_pattern.startswith(</span><span class="s4">'^'</span><span class="s1">):</span>
                    <span class="s1">p_pattern = p_pattern[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s2">if </span><span class="s1">isinstance(url_pattern</span><span class="s2">, </span><span class="s1">URLPattern):</span>
                    <span class="s1">self._callback_strs.add(url_pattern.lookup_str)</span>
                    <span class="s1">bits = normalize(url_pattern.pattern.regex.pattern)</span>
                    <span class="s1">lookups.appendlist(</span>
                        <span class="s1">url_pattern.callback</span><span class="s2">,</span>
                        <span class="s1">(bits</span><span class="s2">, </span><span class="s1">p_pattern</span><span class="s2">, </span><span class="s1">url_pattern.default_args</span><span class="s2">, </span><span class="s1">url_pattern.pattern.converters)</span>
                    <span class="s1">)</span>
                    <span class="s2">if </span><span class="s1">url_pattern.name </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">lookups.appendlist(</span>
                            <span class="s1">url_pattern.name</span><span class="s2">,</span>
                            <span class="s1">(bits</span><span class="s2">, </span><span class="s1">p_pattern</span><span class="s2">, </span><span class="s1">url_pattern.default_args</span><span class="s2">, </span><span class="s1">url_pattern.pattern.converters)</span>
                        <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:  </span><span class="s3"># url_pattern is a URLResolver.</span>
                    <span class="s1">url_pattern._populate()</span>
                    <span class="s2">if </span><span class="s1">url_pattern.app_name:</span>
                        <span class="s1">apps.setdefault(url_pattern.app_name</span><span class="s2">, </span><span class="s1">[]).append(url_pattern.namespace)</span>
                        <span class="s1">namespaces[url_pattern.namespace] = (p_pattern</span><span class="s2">, </span><span class="s1">url_pattern)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">url_pattern.reverse_dict:</span>
                            <span class="s2">for </span><span class="s1">matches</span><span class="s2">, </span><span class="s1">pat</span><span class="s2">, </span><span class="s1">defaults</span><span class="s2">, </span><span class="s1">converters </span><span class="s2">in </span><span class="s1">url_pattern.reverse_dict.getlist(name):</span>
                                <span class="s1">new_matches = normalize(p_pattern + pat)</span>
                                <span class="s1">lookups.appendlist(</span>
                                    <span class="s1">name</span><span class="s2">,</span>
                                    <span class="s1">(</span>
                                        <span class="s1">new_matches</span><span class="s2">,</span>
                                        <span class="s1">p_pattern + pat</span><span class="s2">,</span>
                                        <span class="s1">{**defaults</span><span class="s2">, </span><span class="s1">**url_pattern.default_kwargs}</span><span class="s2">,</span>
                                        <span class="s1">{**self.pattern.converters</span><span class="s2">, </span><span class="s1">**url_pattern.pattern.converters</span><span class="s2">, </span><span class="s1">**converters}</span>
                                    <span class="s1">)</span>
                                <span class="s1">)</span>
                        <span class="s2">for </span><span class="s1">namespace</span><span class="s2">, </span><span class="s1">(prefix</span><span class="s2">, </span><span class="s1">sub_pattern) </span><span class="s2">in </span><span class="s1">url_pattern.namespace_dict.items():</span>
                            <span class="s1">current_converters = url_pattern.pattern.converters</span>
                            <span class="s1">sub_pattern.pattern.converters.update(current_converters)</span>
                            <span class="s1">namespaces[namespace] = (p_pattern + prefix</span><span class="s2">, </span><span class="s1">sub_pattern)</span>
                        <span class="s2">for </span><span class="s1">app_name</span><span class="s2">, </span><span class="s1">namespace_list </span><span class="s2">in </span><span class="s1">url_pattern.app_dict.items():</span>
                            <span class="s1">apps.setdefault(app_name</span><span class="s2">, </span><span class="s1">[]).extend(namespace_list)</span>
                    <span class="s1">self._callback_strs.update(url_pattern._callback_strs)</span>
            <span class="s1">self._namespace_dict[language_code] = namespaces</span>
            <span class="s1">self._app_dict[language_code] = apps</span>
            <span class="s1">self._reverse_dict[language_code] = lookups</span>
            <span class="s1">self._populated = </span><span class="s2">True</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self._local.populating = </span><span class="s2">False</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">reverse_dict(self):</span>
        <span class="s1">language_code = get_language()</span>
        <span class="s2">if </span><span class="s1">language_code </span><span class="s2">not in </span><span class="s1">self._reverse_dict:</span>
            <span class="s1">self._populate()</span>
        <span class="s2">return </span><span class="s1">self._reverse_dict[language_code]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">namespace_dict(self):</span>
        <span class="s1">language_code = get_language()</span>
        <span class="s2">if </span><span class="s1">language_code </span><span class="s2">not in </span><span class="s1">self._namespace_dict:</span>
            <span class="s1">self._populate()</span>
        <span class="s2">return </span><span class="s1">self._namespace_dict[language_code]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">app_dict(self):</span>
        <span class="s1">language_code = get_language()</span>
        <span class="s2">if </span><span class="s1">language_code </span><span class="s2">not in </span><span class="s1">self._app_dict:</span>
            <span class="s1">self._populate()</span>
        <span class="s2">return </span><span class="s1">self._app_dict[language_code]</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_extend_tried(tried</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">sub_tried=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">sub_tried </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">tried.append([pattern])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tried.extend([pattern</span><span class="s2">, </span><span class="s1">*t] </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">sub_tried)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_join_route(route1</span><span class="s2">, </span><span class="s1">route2):</span>
        <span class="s0">&quot;&quot;&quot;Join two routes, without the starting ^ in the second route.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">route1:</span>
            <span class="s2">return </span><span class="s1">route2</span>
        <span class="s2">if </span><span class="s1">route2.startswith(</span><span class="s4">'^'</span><span class="s1">):</span>
            <span class="s1">route2 = route2[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">route1 + route2</span>

    <span class="s2">def </span><span class="s1">_is_callback(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s2">if not </span><span class="s1">self._populated:</span>
            <span class="s1">self._populate()</span>
        <span class="s2">return </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._callback_strs</span>

    <span class="s2">def </span><span class="s1">resolve(self</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s1">path = str(path)  </span><span class="s3"># path may be a reverse_lazy object</span>
        <span class="s1">tried = []</span>
        <span class="s1">match = self.pattern.match(path)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">new_path</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs = match</span>
            <span class="s2">for </span><span class="s1">pattern </span><span class="s2">in </span><span class="s1">self.url_patterns:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">sub_match = pattern.resolve(new_path)</span>
                <span class="s2">except </span><span class="s1">Resolver404 </span><span class="s2">as </span><span class="s1">e:</span>
                    <span class="s1">self._extend_tried(tried</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">e.args[</span><span class="s5">0</span><span class="s1">].get(</span><span class="s4">'tried'</span><span class="s1">))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">sub_match:</span>
                        <span class="s3"># Merge captured arguments in match with submatch</span>
                        <span class="s1">sub_match_dict = {**kwargs</span><span class="s2">, </span><span class="s1">**self.default_kwargs}</span>
                        <span class="s3"># Update the sub_match_dict with the kwargs from the sub_match.</span>
                        <span class="s1">sub_match_dict.update(sub_match.kwargs)</span>
                        <span class="s3"># If there are *any* named groups, ignore all non-named groups.</span>
                        <span class="s3"># Otherwise, pass all non-named arguments as positional arguments.</span>
                        <span class="s1">sub_match_args = sub_match.args</span>
                        <span class="s2">if not </span><span class="s1">sub_match_dict:</span>
                            <span class="s1">sub_match_args = args + sub_match.args</span>
                        <span class="s1">current_route = </span><span class="s4">'' </span><span class="s2">if </span><span class="s1">isinstance(pattern</span><span class="s2">, </span><span class="s1">URLPattern) </span><span class="s2">else </span><span class="s1">str(pattern.pattern)</span>
                        <span class="s1">self._extend_tried(tried</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">sub_match.tried)</span>
                        <span class="s2">return </span><span class="s1">ResolverMatch(</span>
                            <span class="s1">sub_match.func</span><span class="s2">,</span>
                            <span class="s1">sub_match_args</span><span class="s2">,</span>
                            <span class="s1">sub_match_dict</span><span class="s2">,</span>
                            <span class="s1">sub_match.url_name</span><span class="s2">,</span>
                            <span class="s1">[self.app_name] + sub_match.app_names</span><span class="s2">,</span>
                            <span class="s1">[self.namespace] + sub_match.namespaces</span><span class="s2">,</span>
                            <span class="s1">self._join_route(current_route</span><span class="s2">, </span><span class="s1">sub_match.route)</span><span class="s2">,</span>
                            <span class="s1">tried</span><span class="s2">,</span>
                        <span class="s1">)</span>
                    <span class="s1">tried.append([pattern])</span>
            <span class="s2">raise </span><span class="s1">Resolver404({</span><span class="s4">'tried'</span><span class="s1">: tried</span><span class="s2">, </span><span class="s4">'path'</span><span class="s1">: new_path})</span>
        <span class="s2">raise </span><span class="s1">Resolver404({</span><span class="s4">'path'</span><span class="s1">: path})</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">urlconf_module(self):</span>
        <span class="s2">if </span><span class="s1">isinstance(self.urlconf_name</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">import_module(self.urlconf_name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.urlconf_name</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">url_patterns(self):</span>
        <span class="s3"># urlconf_module might be a valid set of patterns, so we default to it</span>
        <span class="s1">patterns = getattr(self.urlconf_module</span><span class="s2">, </span><span class="s4">&quot;urlpatterns&quot;</span><span class="s2">, </span><span class="s1">self.urlconf_module)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">iter(patterns)</span>
        <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;The included URLconf '{name}' does not appear to have &quot;</span>
                <span class="s4">&quot;any patterns in it. If you see the 'urlpatterns' variable &quot;</span>
                <span class="s4">&quot;with valid patterns in the file then the issue is probably &quot;</span>
                <span class="s4">&quot;caused by a circular import.&quot;</span>
            <span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">ImproperlyConfigured(msg.format(name=self.urlconf_name)) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">return </span><span class="s1">patterns</span>

    <span class="s2">def </span><span class="s1">resolve_error_handler(self</span><span class="s2">, </span><span class="s1">view_type):</span>
        <span class="s1">callback = getattr(self.urlconf_module</span><span class="s2">, </span><span class="s4">'handler%s' </span><span class="s1">% view_type</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">callback:</span>
            <span class="s3"># No handler specified in file; use lazy import, since</span>
            <span class="s3"># django.conf.urls imports this file.</span>
            <span class="s2">from </span><span class="s1">django.conf </span><span class="s2">import </span><span class="s1">urls</span>
            <span class="s1">callback = getattr(urls</span><span class="s2">, </span><span class="s4">'handler%s' </span><span class="s1">% view_type)</span>
        <span class="s2">return </span><span class="s1">get_callable(callback)</span>

    <span class="s2">def </span><span class="s1">reverse(self</span><span class="s2">, </span><span class="s1">lookup_view</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self._reverse_with_prefix(lookup_view</span><span class="s2">, </span><span class="s4">''</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_reverse_with_prefix(self</span><span class="s2">, </span><span class="s1">lookup_view</span><span class="s2">, </span><span class="s1">_prefix</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if </span><span class="s1">args </span><span class="s2">and </span><span class="s1">kwargs:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Don't mix *args and **kwargs in call to reverse()!&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">self._populated:</span>
            <span class="s1">self._populate()</span>

        <span class="s1">possibilities = self.reverse_dict.getlist(lookup_view)</span>

        <span class="s2">for </span><span class="s1">possibility</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">defaults</span><span class="s2">, </span><span class="s1">converters </span><span class="s2">in </span><span class="s1">possibilities:</span>
            <span class="s2">for </span><span class="s1">result</span><span class="s2">, </span><span class="s1">params </span><span class="s2">in </span><span class="s1">possibility:</span>
                <span class="s2">if </span><span class="s1">args:</span>
                    <span class="s2">if </span><span class="s1">len(args) != len(params):</span>
                        <span class="s2">continue</span>
                    <span class="s1">candidate_subs = dict(zip(params</span><span class="s2">, </span><span class="s1">args))</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">set(kwargs).symmetric_difference(params).difference(defaults):</span>
                        <span class="s2">continue</span>
                    <span class="s2">if </span><span class="s1">any(kwargs.get(k</span><span class="s2">, </span><span class="s1">v) != v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">defaults.items()):</span>
                        <span class="s2">continue</span>
                    <span class="s1">candidate_subs = kwargs</span>
                <span class="s3"># Convert the candidate subs to text using Converter.to_url().</span>
                <span class="s1">text_candidate_subs = {}</span>
                <span class="s1">match = </span><span class="s2">True</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">candidate_subs.items():</span>
                    <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">converters:</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s1">text_candidate_subs[k] = converters[k].to_url(v)</span>
                        <span class="s2">except </span><span class="s1">ValueError:</span>
                            <span class="s1">match = </span><span class="s2">False</span>
                            <span class="s2">break</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">text_candidate_subs[k] = str(v)</span>
                <span class="s2">if not </span><span class="s1">match:</span>
                    <span class="s2">continue</span>
                <span class="s3"># WSGI provides decoded URLs, without %xx escapes, and the URL</span>
                <span class="s3"># resolver operates on such URLs. First substitute arguments</span>
                <span class="s3"># without quoting to build a decoded URL and look for a match.</span>
                <span class="s3"># Then, if we have a match, redo the substitution with quoted</span>
                <span class="s3"># arguments in order to return a properly encoded URL.</span>
                <span class="s1">candidate_pat = _prefix.replace(</span><span class="s4">'%'</span><span class="s2">, </span><span class="s4">'%%'</span><span class="s1">) + result</span>
                <span class="s2">if </span><span class="s1">re.search(</span><span class="s4">'^%s%s' </span><span class="s1">% (re.escape(_prefix)</span><span class="s2">, </span><span class="s1">pattern)</span><span class="s2">, </span><span class="s1">candidate_pat % text_candidate_subs):</span>
                    <span class="s3"># safe characters from `pchar` definition of RFC 3986</span>
                    <span class="s1">url = quote(candidate_pat % text_candidate_subs</span><span class="s2">, </span><span class="s1">safe=RFC3986_SUBDELIMS + </span><span class="s4">'/~:@'</span><span class="s1">)</span>
                    <span class="s3"># Don't allow construction of scheme relative urls.</span>
                    <span class="s2">return </span><span class="s1">escape_leading_slashes(url)</span>
        <span class="s3"># lookup_view can be URL name or callable, but callables are not</span>
        <span class="s3"># friendly in error messages.</span>
        <span class="s1">m = getattr(lookup_view</span><span class="s2">, </span><span class="s4">'__module__'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">n = getattr(lookup_view</span><span class="s2">, </span><span class="s4">'__name__'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None and </span><span class="s1">n </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">lookup_view_s = </span><span class="s4">&quot;%s.%s&quot; </span><span class="s1">% (m</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lookup_view_s = lookup_view</span>

        <span class="s1">patterns = [pattern </span><span class="s2">for </span><span class="s1">(_</span><span class="s2">, </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_) </span><span class="s2">in </span><span class="s1">possibilities]</span>
        <span class="s2">if </span><span class="s1">patterns:</span>
            <span class="s2">if </span><span class="s1">args:</span>
                <span class="s1">arg_msg = </span><span class="s4">&quot;arguments '%s'&quot; </span><span class="s1">% (args</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">kwargs:</span>
                <span class="s1">arg_msg = </span><span class="s4">&quot;keyword arguments '%s'&quot; </span><span class="s1">% kwargs</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">arg_msg = </span><span class="s4">&quot;no arguments&quot;</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;Reverse for '%s' with %s not found. %d pattern(s) tried: %s&quot; </span><span class="s1">%</span>
                <span class="s1">(lookup_view_s</span><span class="s2">, </span><span class="s1">arg_msg</span><span class="s2">, </span><span class="s1">len(patterns)</span><span class="s2">, </span><span class="s1">patterns)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;Reverse for '%(view)s' not found. '%(view)s' is not &quot;</span>
                <span class="s4">&quot;a valid view function or pattern name.&quot; </span><span class="s1">% {</span><span class="s4">'view'</span><span class="s1">: lookup_view_s}</span>
            <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">NoReverseMatch(msg)</span>
</pre>
</body>
</html>