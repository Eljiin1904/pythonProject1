<html>
<head>
<title>_ast_util.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ast_util.py</font>
</center></td></tr></table>
<pre><span class="s0"># mako/_ast_util.py</span>
<span class="s0"># Copyright 2006-2020 the Mako authors and contributors &lt;see AUTHORS file&gt;</span>
<span class="s0">#</span>
<span class="s0"># This module is part of Mako and is released under</span>
<span class="s0"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>

<span class="s2">&quot;&quot;&quot; 
    ast 
    ~~~ 
 
    This is a stripped down version of Armin Ronacher's ast module. 
 
    :copyright: Copyright 2008 by Armin Ronacher. 
    :license: Python License. 
&quot;&quot;&quot;</span>


<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Add</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">And</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">AST</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">BitAnd</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">BitOr</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">BitXor</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Div</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Eq</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">FloorDiv</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Gt</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">GtE</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">If</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">In</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Invert</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Is</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">IsNot</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">LShift</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Lt</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">LtE</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Mod</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Mult</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Name</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Not</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">NotEq</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">NotIn</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Or</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">PyCF_ONLY_AST</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">RShift</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">Sub</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">UAdd</span>
<span class="s3">from </span><span class="s1">_ast </span><span class="s3">import </span><span class="s1">USub</span>

<span class="s3">from </span><span class="s1">mako.compat </span><span class="s3">import </span><span class="s1">arg_stringname</span>

<span class="s1">BOOLOP_SYMBOLS = {And: </span><span class="s4">&quot;and&quot;</span><span class="s3">, </span><span class="s1">Or: </span><span class="s4">&quot;or&quot;</span><span class="s1">}</span>

<span class="s1">BINOP_SYMBOLS = {</span>
    <span class="s1">Add: </span><span class="s4">&quot;+&quot;</span><span class="s3">,</span>
    <span class="s1">Sub: </span><span class="s4">&quot;-&quot;</span><span class="s3">,</span>
    <span class="s1">Mult: </span><span class="s4">&quot;*&quot;</span><span class="s3">,</span>
    <span class="s1">Div: </span><span class="s4">&quot;/&quot;</span><span class="s3">,</span>
    <span class="s1">FloorDiv: </span><span class="s4">&quot;//&quot;</span><span class="s3">,</span>
    <span class="s1">Mod: </span><span class="s4">&quot;%&quot;</span><span class="s3">,</span>
    <span class="s1">LShift: </span><span class="s4">&quot;&lt;&lt;&quot;</span><span class="s3">,</span>
    <span class="s1">RShift: </span><span class="s4">&quot;&gt;&gt;&quot;</span><span class="s3">,</span>
    <span class="s1">BitOr: </span><span class="s4">&quot;|&quot;</span><span class="s3">,</span>
    <span class="s1">BitAnd: </span><span class="s4">&quot;&amp;&quot;</span><span class="s3">,</span>
    <span class="s1">BitXor: </span><span class="s4">&quot;^&quot;</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">CMPOP_SYMBOLS = {</span>
    <span class="s1">Eq: </span><span class="s4">&quot;==&quot;</span><span class="s3">,</span>
    <span class="s1">Gt: </span><span class="s4">&quot;&gt;&quot;</span><span class="s3">,</span>
    <span class="s1">GtE: </span><span class="s4">&quot;&gt;=&quot;</span><span class="s3">,</span>
    <span class="s1">In: </span><span class="s4">&quot;in&quot;</span><span class="s3">,</span>
    <span class="s1">Is: </span><span class="s4">&quot;is&quot;</span><span class="s3">,</span>
    <span class="s1">IsNot: </span><span class="s4">&quot;is not&quot;</span><span class="s3">,</span>
    <span class="s1">Lt: </span><span class="s4">&quot;&lt;&quot;</span><span class="s3">,</span>
    <span class="s1">LtE: </span><span class="s4">&quot;&lt;=&quot;</span><span class="s3">,</span>
    <span class="s1">NotEq: </span><span class="s4">&quot;!=&quot;</span><span class="s3">,</span>
    <span class="s1">NotIn: </span><span class="s4">&quot;not in&quot;</span><span class="s3">,</span>
<span class="s1">}</span>

<span class="s1">UNARYOP_SYMBOLS = {Invert: </span><span class="s4">&quot;~&quot;</span><span class="s3">, </span><span class="s1">Not: </span><span class="s4">&quot;not&quot;</span><span class="s3">, </span><span class="s1">UAdd: </span><span class="s4">&quot;+&quot;</span><span class="s3">, </span><span class="s1">USub: </span><span class="s4">&quot;-&quot;</span><span class="s1">}</span>

<span class="s1">ALL_SYMBOLS = {}</span>
<span class="s1">ALL_SYMBOLS.update(BOOLOP_SYMBOLS)</span>
<span class="s1">ALL_SYMBOLS.update(BINOP_SYMBOLS)</span>
<span class="s1">ALL_SYMBOLS.update(CMPOP_SYMBOLS)</span>
<span class="s1">ALL_SYMBOLS.update(UNARYOP_SYMBOLS)</span>


<span class="s3">def </span><span class="s1">parse(expr</span><span class="s3">, </span><span class="s1">filename=</span><span class="s4">&quot;&lt;unknown&gt;&quot;</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">&quot;exec&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Parse an expression into an AST node.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">compile(expr</span><span class="s3">, </span><span class="s1">filename</span><span class="s3">, </span><span class="s1">mode</span><span class="s3">, </span><span class="s1">PyCF_ONLY_AST)</span>


<span class="s3">def </span><span class="s1">iter_fields(node):</span>
    <span class="s2">&quot;&quot;&quot;Iterate over all fields of a node, only yielding existing fields.&quot;&quot;&quot;</span>
    <span class="s0"># CPython 2.5 compat</span>
    <span class="s3">if not </span><span class="s1">hasattr(node</span><span class="s3">, </span><span class="s4">&quot;_fields&quot;</span><span class="s1">) </span><span class="s3">or not </span><span class="s1">node._fields:</span>
        <span class="s3">return</span>
    <span class="s3">for </span><span class="s1">field </span><span class="s3">in </span><span class="s1">node._fields:</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">yield </span><span class="s1">field</span><span class="s3">, </span><span class="s1">getattr(node</span><span class="s3">, </span><span class="s1">field)</span>
        <span class="s3">except </span><span class="s1">AttributeError:</span>
            <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">NodeVisitor(object):</span>

    <span class="s2">&quot;&quot;&quot; 
    Walks the abstract syntax tree and call visitor functions for every node 
    found.  The visitor functions may return values which will be forwarded 
    by the `visit` method. 
 
    Per default the visitor functions for the nodes are ``'visit_'`` + 
    class name of the node.  So a `TryFinally` node visit function would 
    be `visit_TryFinally`.  This behavior can be changed by overriding 
    the `get_visitor` function.  If no visitor function exists for a node 
    (return value `None`) the `generic_visit` visitor is used instead. 
 
    Don't use the `NodeVisitor` if you want to apply changes to nodes during 
    traversing.  For this a special visitor exists (`NodeTransformer`) that 
    allows modifications. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">get_visitor(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return the visitor function for this node or `None` if no visitor 
        exists for this node.  In that case the generic visit function is 
        used instead. 
        &quot;&quot;&quot;</span>
        <span class="s1">method = </span><span class="s4">&quot;visit_&quot; </span><span class="s1">+ node.__class__.__name__</span>
        <span class="s3">return </span><span class="s1">getattr(self</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s2">&quot;&quot;&quot;Visit a node.&quot;&quot;&quot;</span>
        <span class="s1">f = self.get_visitor(node)</span>
        <span class="s3">if </span><span class="s1">f </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">f(node)</span>
        <span class="s3">return </span><span class="s1">self.generic_visit(node)</span>

    <span class="s3">def </span><span class="s1">generic_visit(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s2">&quot;&quot;&quot;Called if no explicit visitor function exists for a node.&quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">field</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">iter_fields(node):</span>
            <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">list):</span>
                <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">value:</span>
                    <span class="s3">if </span><span class="s1">isinstance(item</span><span class="s3">, </span><span class="s1">AST):</span>
                        <span class="s1">self.visit(item)</span>
            <span class="s3">elif </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">AST):</span>
                <span class="s1">self.visit(value)</span>


<span class="s3">class </span><span class="s1">NodeTransformer(NodeVisitor):</span>

    <span class="s2">&quot;&quot;&quot; 
    Walks the abstract syntax tree and allows modifications of nodes. 
 
    The `NodeTransformer` will walk the AST and use the return value of the 
    visitor functions to replace or remove the old node.  If the return 
    value of the visitor function is `None` the node will be removed 
    from the previous location otherwise it's replaced with the return 
    value.  The return value may be the original node in which case no 
    replacement takes place. 
 
    Here an example transformer that rewrites all `foo` to `data['foo']`:: 
 
        class RewriteName(NodeTransformer): 
 
            def visit_Name(self, node): 
                return copy_location(Subscript( 
                    value=Name(id='data', ctx=Load()), 
                    slice=Index(value=Str(s=node.id)), 
                    ctx=node.ctx 
                ), node) 
 
    Keep in mind that if the node you're operating on has child nodes 
    you must either transform the child nodes yourself or call the generic 
    visit function for the node first. 
 
    Nodes that were part of a collection of statements (that applies to 
    all statement nodes) may also return a list of nodes rather than just 
    a single node. 
 
    Usually you use the transformer like this:: 
 
        node = YourTransformer().visit(node) 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">generic_visit(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s3">for </span><span class="s1">field</span><span class="s3">, </span><span class="s1">old_value </span><span class="s3">in </span><span class="s1">iter_fields(node):</span>
            <span class="s1">old_value = getattr(node</span><span class="s3">, </span><span class="s1">field</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">isinstance(old_value</span><span class="s3">, </span><span class="s1">list):</span>
                <span class="s1">new_values = []</span>
                <span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">old_value:</span>
                    <span class="s3">if </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">AST):</span>
                        <span class="s1">value = self.visit(value)</span>
                        <span class="s3">if </span><span class="s1">value </span><span class="s3">is None</span><span class="s1">:</span>
                            <span class="s3">continue</span>
                        <span class="s3">elif not </span><span class="s1">isinstance(value</span><span class="s3">, </span><span class="s1">AST):</span>
                            <span class="s1">new_values.extend(value)</span>
                            <span class="s3">continue</span>
                    <span class="s1">new_values.append(value)</span>
                <span class="s1">old_value[:] = new_values</span>
            <span class="s3">elif </span><span class="s1">isinstance(old_value</span><span class="s3">, </span><span class="s1">AST):</span>
                <span class="s1">new_node = self.visit(old_value)</span>
                <span class="s3">if </span><span class="s1">new_node </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">delattr(node</span><span class="s3">, </span><span class="s1">field)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">setattr(node</span><span class="s3">, </span><span class="s1">field</span><span class="s3">, </span><span class="s1">new_node)</span>
        <span class="s3">return </span><span class="s1">node</span>


<span class="s3">class </span><span class="s1">SourceGenerator(NodeVisitor):</span>

    <span class="s2">&quot;&quot;&quot; 
    This visitor is able to transform a well formed syntax tree into python 
    sourcecode.  For more details have a look at the docstring of the 
    `node_to_source` function. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">indent_with):</span>
        <span class="s1">self.result = []</span>
        <span class="s1">self.indent_with = indent_with</span>
        <span class="s1">self.indentation = </span><span class="s5">0</span>
        <span class="s1">self.new_lines = </span><span class="s5">0</span>

    <span class="s3">def </span><span class="s1">write(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">if </span><span class="s1">self.new_lines:</span>
            <span class="s3">if </span><span class="s1">self.result:</span>
                <span class="s1">self.result.append(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">* self.new_lines)</span>
            <span class="s1">self.result.append(self.indent_with * self.indentation)</span>
            <span class="s1">self.new_lines = </span><span class="s5">0</span>
        <span class="s1">self.result.append(x)</span>

    <span class="s3">def </span><span class="s1">newline(self</span><span class="s3">, </span><span class="s1">n=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">self.new_lines = max(self.new_lines</span><span class="s3">, </span><span class="s1">n)</span>

    <span class="s3">def </span><span class="s1">body(self</span><span class="s3">, </span><span class="s1">statements):</span>
        <span class="s1">self.new_line = </span><span class="s3">True</span>
        <span class="s1">self.indentation += </span><span class="s5">1</span>
        <span class="s3">for </span><span class="s1">stmt </span><span class="s3">in </span><span class="s1">statements:</span>
            <span class="s1">self.visit(stmt)</span>
        <span class="s1">self.indentation -= </span><span class="s5">1</span>

    <span class="s3">def </span><span class="s1">body_or_else(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.body(node.body)</span>
        <span class="s3">if </span><span class="s1">node.orelse:</span>
            <span class="s1">self.newline()</span>
            <span class="s1">self.write(</span><span class="s4">&quot;else:&quot;</span><span class="s1">)</span>
            <span class="s1">self.body(node.orelse)</span>

    <span class="s3">def </span><span class="s1">signature(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">want_comma = []</span>

        <span class="s3">def </span><span class="s1">write_comma():</span>
            <span class="s3">if </span><span class="s1">want_comma:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">want_comma.append(</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">padding = [</span><span class="s3">None</span><span class="s1">] * (len(node.args) - len(node.defaults))</span>
        <span class="s3">for </span><span class="s1">arg</span><span class="s3">, </span><span class="s1">default </span><span class="s3">in </span><span class="s1">zip(node.args</span><span class="s3">, </span><span class="s1">padding + node.defaults):</span>
            <span class="s1">write_comma()</span>
            <span class="s1">self.visit(arg)</span>
            <span class="s3">if </span><span class="s1">default </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;=&quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(default)</span>
        <span class="s3">if </span><span class="s1">node.vararg </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">write_comma()</span>
            <span class="s1">self.write(</span><span class="s4">&quot;*&quot; </span><span class="s1">+ arg_stringname(node.vararg))</span>
        <span class="s3">if </span><span class="s1">node.kwarg </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">write_comma()</span>
            <span class="s1">self.write(</span><span class="s4">&quot;**&quot; </span><span class="s1">+ arg_stringname(node.kwarg))</span>

    <span class="s3">def </span><span class="s1">decorators(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s3">for </span><span class="s1">decorator </span><span class="s3">in </span><span class="s1">node.decorator_list:</span>
            <span class="s1">self.newline()</span>
            <span class="s1">self.write(</span><span class="s4">&quot;@&quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(decorator)</span>

    <span class="s0"># Statements</span>

    <span class="s3">def </span><span class="s1">visit_Assign(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">target </span><span class="s3">in </span><span class="s1">enumerate(node.targets):</span>
            <span class="s3">if </span><span class="s1">idx:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(target)</span>
        <span class="s1">self.write(</span><span class="s4">&quot; = &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.value)</span>

    <span class="s3">def </span><span class="s1">visit_AugAssign(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.visit(node.target)</span>
        <span class="s1">self.write(BINOP_SYMBOLS[type(node.op)] + </span><span class="s4">&quot;=&quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.value)</span>

    <span class="s3">def </span><span class="s1">visit_ImportFrom(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;from %s%s import &quot; </span><span class="s1">% (</span><span class="s4">&quot;.&quot; </span><span class="s1">* node.level</span><span class="s3">, </span><span class="s1">node.module))</span>
        <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">item </span><span class="s3">in </span><span class="s1">enumerate(node.names):</span>
            <span class="s3">if </span><span class="s1">idx:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self.write(item)</span>

    <span class="s3">def </span><span class="s1">visit_Import(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">node.names:</span>
            <span class="s1">self.write(</span><span class="s4">&quot;import &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(item)</span>

    <span class="s3">def </span><span class="s1">visit_Expr(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.generic_visit(node)</span>

    <span class="s3">def </span><span class="s1">visit_FunctionDef(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline(n=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.decorators(node)</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;def %s(&quot; </span><span class="s1">% node.name)</span>
        <span class="s1">self.signature(node.args)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;):&quot;</span><span class="s1">)</span>
        <span class="s1">self.body(node.body)</span>

    <span class="s3">def </span><span class="s1">visit_ClassDef(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">have_args = []</span>

        <span class="s3">def </span><span class="s1">paren_or_comma():</span>
            <span class="s3">if </span><span class="s1">have_args:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">have_args.append(</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s1">self.write(</span><span class="s4">&quot;(&quot;</span><span class="s1">)</span>

        <span class="s1">self.newline(n=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">self.decorators(node)</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;class %s&quot; </span><span class="s1">% node.name)</span>
        <span class="s3">for </span><span class="s1">base </span><span class="s3">in </span><span class="s1">node.bases:</span>
            <span class="s1">paren_or_comma()</span>
            <span class="s1">self.visit(base)</span>
        <span class="s0"># XXX: the if here is used to keep this module compatible</span>
        <span class="s0">#      with python 2.6.</span>
        <span class="s3">if </span><span class="s1">hasattr(node</span><span class="s3">, </span><span class="s4">&quot;keywords&quot;</span><span class="s1">):</span>
            <span class="s3">for </span><span class="s1">keyword </span><span class="s3">in </span><span class="s1">node.keywords:</span>
                <span class="s1">paren_or_comma()</span>
                <span class="s1">self.write(keyword.arg + </span><span class="s4">&quot;=&quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(keyword.value)</span>
            <span class="s3">if </span><span class="s1">getattr(node</span><span class="s3">, </span><span class="s4">&quot;starargs&quot;</span><span class="s3">, None</span><span class="s1">):</span>
                <span class="s1">paren_or_comma()</span>
                <span class="s1">self.write(</span><span class="s4">&quot;*&quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(node.starargs)</span>
            <span class="s3">if </span><span class="s1">getattr(node</span><span class="s3">, </span><span class="s4">&quot;kwargs&quot;</span><span class="s3">, None</span><span class="s1">):</span>
                <span class="s1">paren_or_comma()</span>
                <span class="s1">self.write(</span><span class="s4">&quot;**&quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(node.kwargs)</span>
        <span class="s1">self.write(have_args </span><span class="s3">and </span><span class="s4">&quot;):&quot; </span><span class="s3">or </span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body(node.body)</span>

    <span class="s3">def </span><span class="s1">visit_If(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;if &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.test)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body(node.body)</span>
        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s1">else_ = node.orelse</span>
            <span class="s3">if </span><span class="s1">len(else_) == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">isinstance(else_[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">If):</span>
                <span class="s1">node = else_[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">self.newline()</span>
                <span class="s1">self.write(</span><span class="s4">&quot;elif &quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(node.test)</span>
                <span class="s1">self.write(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
                <span class="s1">self.body(node.body)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self.newline()</span>
                <span class="s1">self.write(</span><span class="s4">&quot;else:&quot;</span><span class="s1">)</span>
                <span class="s1">self.body(else_)</span>
                <span class="s3">break</span>

    <span class="s3">def </span><span class="s1">visit_For(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;for &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.target)</span>
        <span class="s1">self.write(</span><span class="s4">&quot; in &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.iter)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body_or_else(node)</span>

    <span class="s3">def </span><span class="s1">visit_While(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;while &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.test)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body_or_else(node)</span>

    <span class="s3">def </span><span class="s1">visit_With(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;with &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.context_expr)</span>
        <span class="s3">if </span><span class="s1">node.optional_vars </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.write(</span><span class="s4">&quot; as &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(node.optional_vars)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body(node.body)</span>

    <span class="s3">def </span><span class="s1">visit_Pass(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;pass&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_Print(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s0"># XXX: python 2.6 only</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;print &quot;</span><span class="s1">)</span>
        <span class="s1">want_comma = </span><span class="s3">False</span>
        <span class="s3">if </span><span class="s1">node.dest </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.write(</span><span class="s4">&quot; &gt;&gt; &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(node.dest)</span>
            <span class="s1">want_comma = </span><span class="s3">True</span>
        <span class="s3">for </span><span class="s1">value </span><span class="s3">in </span><span class="s1">node.values:</span>
            <span class="s3">if </span><span class="s1">want_comma:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(value)</span>
            <span class="s1">want_comma = </span><span class="s3">True</span>
        <span class="s3">if not </span><span class="s1">node.nl:</span>
            <span class="s1">self.write(</span><span class="s4">&quot;,&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_Delete(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;del &quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">target </span><span class="s3">in </span><span class="s1">enumerate(node):</span>
            <span class="s3">if </span><span class="s1">idx:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(target)</span>

    <span class="s3">def </span><span class="s1">visit_TryExcept(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;try:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body(node.body)</span>
        <span class="s3">for </span><span class="s1">handler </span><span class="s3">in </span><span class="s1">node.handlers:</span>
            <span class="s1">self.visit(handler)</span>

    <span class="s3">def </span><span class="s1">visit_TryFinally(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;try:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body(node.body)</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;finally:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body(node.finalbody)</span>

    <span class="s3">def </span><span class="s1">visit_Global(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;global &quot; </span><span class="s1">+ </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(node.names))</span>

    <span class="s3">def </span><span class="s1">visit_Nonlocal(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;nonlocal &quot; </span><span class="s1">+ </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(node.names))</span>

    <span class="s3">def </span><span class="s1">visit_Return(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;return &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.value)</span>

    <span class="s3">def </span><span class="s1">visit_Break(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;break&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_Continue(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;continue&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_Raise(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s0"># XXX: Python 2.6 / 3.0 compatibility</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;raise&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">hasattr(node</span><span class="s3">, </span><span class="s4">&quot;exc&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s1">node.exc </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.write(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(node.exc)</span>
            <span class="s3">if </span><span class="s1">node.cause </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.write(</span><span class="s4">&quot; from &quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(node.cause)</span>
        <span class="s3">elif </span><span class="s1">hasattr(node</span><span class="s3">, </span><span class="s4">&quot;type&quot;</span><span class="s1">) </span><span class="s3">and </span><span class="s1">node.type </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.visit(node.type)</span>
            <span class="s3">if </span><span class="s1">node.inst </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(node.inst)</span>
            <span class="s3">if </span><span class="s1">node.tback </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(node.tback)</span>

    <span class="s0"># Expressions</span>

    <span class="s3">def </span><span class="s1">visit_Attribute(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.visit(node.value)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;.&quot; </span><span class="s1">+ node.attr)</span>

    <span class="s3">def </span><span class="s1">visit_Call(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">want_comma = []</span>

        <span class="s3">def </span><span class="s1">write_comma():</span>
            <span class="s3">if </span><span class="s1">want_comma:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">want_comma.append(</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">self.visit(node.func)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;(&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">node.args:</span>
            <span class="s1">write_comma()</span>
            <span class="s1">self.visit(arg)</span>
        <span class="s3">for </span><span class="s1">keyword </span><span class="s3">in </span><span class="s1">node.keywords:</span>
            <span class="s1">write_comma()</span>
            <span class="s1">self.write(keyword.arg + </span><span class="s4">&quot;=&quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(keyword.value)</span>
        <span class="s3">if </span><span class="s1">getattr(node</span><span class="s3">, </span><span class="s4">&quot;starargs&quot;</span><span class="s3">, None</span><span class="s1">):</span>
            <span class="s1">write_comma()</span>
            <span class="s1">self.write(</span><span class="s4">&quot;*&quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(node.starargs)</span>
        <span class="s3">if </span><span class="s1">getattr(node</span><span class="s3">, </span><span class="s4">&quot;kwargs&quot;</span><span class="s3">, None</span><span class="s1">):</span>
            <span class="s1">write_comma()</span>
            <span class="s1">self.write(</span><span class="s4">&quot;**&quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(node.kwargs)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;)&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_Name(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(node.id)</span>

    <span class="s3">def </span><span class="s1">visit_NameConstant(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(str(node.value))</span>

    <span class="s3">def </span><span class="s1">visit_arg(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(node.arg)</span>

    <span class="s3">def </span><span class="s1">visit_Str(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(repr(node.s))</span>

    <span class="s3">def </span><span class="s1">visit_Bytes(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(repr(node.s))</span>

    <span class="s3">def </span><span class="s1">visit_Num(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(repr(node.n))</span>

    <span class="s0"># newly needed in Python 3.8</span>
    <span class="s3">def </span><span class="s1">visit_Constant(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(repr(node.value))</span>

    <span class="s3">def </span><span class="s1">visit_Tuple(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;(&quot;</span><span class="s1">)</span>
        <span class="s1">idx = -</span><span class="s5">1</span>
        <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">item </span><span class="s3">in </span><span class="s1">enumerate(node.elts):</span>
            <span class="s3">if </span><span class="s1">idx:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(item)</span>
        <span class="s1">self.write(idx </span><span class="s3">and </span><span class="s4">&quot;)&quot; </span><span class="s3">or </span><span class="s4">&quot;,)&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">sequence_visit(left</span><span class="s3">, </span><span class="s1">right):</span>
        <span class="s3">def </span><span class="s1">visit(self</span><span class="s3">, </span><span class="s1">node):</span>
            <span class="s1">self.write(left)</span>
            <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">item </span><span class="s3">in </span><span class="s1">enumerate(node.elts):</span>
                <span class="s3">if </span><span class="s1">idx:</span>
                    <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(item)</span>
            <span class="s1">self.write(right)</span>

        <span class="s3">return </span><span class="s1">visit</span>

    <span class="s1">visit_List = sequence_visit(</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s1">)</span>
    <span class="s1">visit_Set = sequence_visit(</span><span class="s4">&quot;{&quot;</span><span class="s3">, </span><span class="s4">&quot;}&quot;</span><span class="s1">)</span>
    <span class="s3">del </span><span class="s1">sequence_visit</span>

    <span class="s3">def </span><span class="s1">visit_Dict(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;{&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">(key</span><span class="s3">, </span><span class="s1">value) </span><span class="s3">in </span><span class="s1">enumerate(zip(node.keys</span><span class="s3">, </span><span class="s1">node.values)):</span>
            <span class="s3">if </span><span class="s1">idx:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(key)</span>
            <span class="s1">self.write(</span><span class="s4">&quot;: &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(value)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;}&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_BinOp(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;(&quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.left)</span>
        <span class="s1">self.write(</span><span class="s4">&quot; %s &quot; </span><span class="s1">% BINOP_SYMBOLS[type(node.op)])</span>
        <span class="s1">self.visit(node.right)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;)&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_BoolOp(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;(&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">enumerate(node.values):</span>
            <span class="s3">if </span><span class="s1">idx:</span>
                <span class="s1">self.write(</span><span class="s4">&quot; %s &quot; </span><span class="s1">% BOOLOP_SYMBOLS[type(node.op)])</span>
            <span class="s1">self.visit(value)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;)&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_Compare(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;(&quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.left)</span>
        <span class="s3">for </span><span class="s1">op</span><span class="s3">, </span><span class="s1">right </span><span class="s3">in </span><span class="s1">zip(node.ops</span><span class="s3">, </span><span class="s1">node.comparators):</span>
            <span class="s1">self.write(</span><span class="s4">&quot; %s &quot; </span><span class="s1">% CMPOP_SYMBOLS[type(op)])</span>
            <span class="s1">self.visit(right)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;)&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_UnaryOp(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;(&quot;</span><span class="s1">)</span>
        <span class="s1">op = UNARYOP_SYMBOLS[type(node.op)]</span>
        <span class="s1">self.write(op)</span>
        <span class="s3">if </span><span class="s1">op == </span><span class="s4">&quot;not&quot;</span><span class="s1">:</span>
            <span class="s1">self.write(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.operand)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;)&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_Subscript(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.visit(node.value)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;[&quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.slice)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;]&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_Slice(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s3">if </span><span class="s1">node.lower </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.visit(node.lower)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">node.upper </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.visit(node.upper)</span>
        <span class="s3">if </span><span class="s1">node.step </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.write(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
            <span class="s3">if not </span><span class="s1">(isinstance(node.step</span><span class="s3">, </span><span class="s1">Name) </span><span class="s3">and </span><span class="s1">node.step.id == </span><span class="s4">&quot;None&quot;</span><span class="s1">):</span>
                <span class="s1">self.visit(node.step)</span>

    <span class="s3">def </span><span class="s1">visit_ExtSlice(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">item </span><span class="s3">in </span><span class="s1">node.dims:</span>
            <span class="s3">if </span><span class="s1">idx:</span>
                <span class="s1">self.write(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(item)</span>

    <span class="s3">def </span><span class="s1">visit_Yield(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;yield &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.value)</span>

    <span class="s3">def </span><span class="s1">visit_Lambda(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;lambda &quot;</span><span class="s1">)</span>
        <span class="s1">self.signature(node.args)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;: &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.body)</span>

    <span class="s3">def </span><span class="s1">visit_Ellipsis(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;Ellipsis&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">generator_visit(left</span><span class="s3">, </span><span class="s1">right):</span>
        <span class="s3">def </span><span class="s1">visit(self</span><span class="s3">, </span><span class="s1">node):</span>
            <span class="s1">self.write(left)</span>
            <span class="s1">self.visit(node.elt)</span>
            <span class="s3">for </span><span class="s1">comprehension </span><span class="s3">in </span><span class="s1">node.generators:</span>
                <span class="s1">self.visit(comprehension)</span>
            <span class="s1">self.write(right)</span>

        <span class="s3">return </span><span class="s1">visit</span>

    <span class="s1">visit_ListComp = generator_visit(</span><span class="s4">&quot;[&quot;</span><span class="s3">, </span><span class="s4">&quot;]&quot;</span><span class="s1">)</span>
    <span class="s1">visit_GeneratorExp = generator_visit(</span><span class="s4">&quot;(&quot;</span><span class="s3">, </span><span class="s4">&quot;)&quot;</span><span class="s1">)</span>
    <span class="s1">visit_SetComp = generator_visit(</span><span class="s4">&quot;{&quot;</span><span class="s3">, </span><span class="s4">&quot;}&quot;</span><span class="s1">)</span>
    <span class="s3">del </span><span class="s1">generator_visit</span>

    <span class="s3">def </span><span class="s1">visit_DictComp(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;{&quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.key)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;: &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.value)</span>
        <span class="s3">for </span><span class="s1">comprehension </span><span class="s3">in </span><span class="s1">node.generators:</span>
            <span class="s1">self.visit(comprehension)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;}&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">visit_IfExp(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.visit(node.body)</span>
        <span class="s1">self.write(</span><span class="s4">&quot; if &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.test)</span>
        <span class="s1">self.write(</span><span class="s4">&quot; else &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.orelse)</span>

    <span class="s3">def </span><span class="s1">visit_Starred(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot;*&quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.value)</span>

    <span class="s3">def </span><span class="s1">visit_Repr(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s0"># XXX: python 2.6 only</span>
        <span class="s1">self.write(</span><span class="s4">&quot;`&quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.value)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;`&quot;</span><span class="s1">)</span>

    <span class="s0"># Helper Nodes</span>

    <span class="s3">def </span><span class="s1">visit_alias(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(node.name)</span>
        <span class="s3">if </span><span class="s1">node.asname </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.write(</span><span class="s4">&quot; as &quot; </span><span class="s1">+ node.asname)</span>

    <span class="s3">def </span><span class="s1">visit_comprehension(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.write(</span><span class="s4">&quot; for &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.target)</span>
        <span class="s1">self.write(</span><span class="s4">&quot; in &quot;</span><span class="s1">)</span>
        <span class="s1">self.visit(node.iter)</span>
        <span class="s3">if </span><span class="s1">node.ifs:</span>
            <span class="s3">for </span><span class="s1">if_ </span><span class="s3">in </span><span class="s1">node.ifs:</span>
                <span class="s1">self.write(</span><span class="s4">&quot; if &quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(if_)</span>

    <span class="s3">def </span><span class="s1">visit_excepthandler(self</span><span class="s3">, </span><span class="s1">node):</span>
        <span class="s1">self.newline()</span>
        <span class="s1">self.write(</span><span class="s4">&quot;except&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">node.type </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.write(</span><span class="s4">&quot; &quot;</span><span class="s1">)</span>
            <span class="s1">self.visit(node.type)</span>
            <span class="s3">if </span><span class="s1">node.name </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">self.write(</span><span class="s4">&quot; as &quot;</span><span class="s1">)</span>
                <span class="s1">self.visit(node.name)</span>
        <span class="s1">self.write(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
        <span class="s1">self.body(node.body)</span>
</pre>
</body>
</html>