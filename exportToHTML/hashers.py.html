<html>
<head>
<title>hashers.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hashers.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">base64</span>
<span class="s0">import </span><span class="s1">binascii</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">hashlib</span>
<span class="s0">import </span><span class="s1">importlib</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">from </span><span class="s1">django.conf </span><span class="s0">import </span><span class="s1">settings</span>
<span class="s0">from </span><span class="s1">django.core.exceptions </span><span class="s0">import </span><span class="s1">ImproperlyConfigured</span>
<span class="s0">from </span><span class="s1">django.core.signals </span><span class="s0">import </span><span class="s1">setting_changed</span>
<span class="s0">from </span><span class="s1">django.dispatch </span><span class="s0">import </span><span class="s1">receiver</span>
<span class="s0">from </span><span class="s1">django.utils.crypto </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">RANDOM_STRING_CHARS</span><span class="s0">, </span><span class="s1">constant_time_compare</span><span class="s0">, </span><span class="s1">get_random_string</span><span class="s0">, </span><span class="s1">pbkdf2</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">django.utils.module_loading </span><span class="s0">import </span><span class="s1">import_string</span>
<span class="s0">from </span><span class="s1">django.utils.translation </span><span class="s0">import </span><span class="s1">gettext_noop </span><span class="s0">as </span><span class="s1">_</span>

<span class="s1">UNUSABLE_PASSWORD_PREFIX = </span><span class="s2">'!'  </span><span class="s3"># This will never be a valid encoded hash</span>
<span class="s1">UNUSABLE_PASSWORD_SUFFIX_LENGTH = </span><span class="s4">40  </span><span class="s3"># number of random chars to add after UNUSABLE_PASSWORD_PREFIX</span>


<span class="s0">def </span><span class="s1">is_password_usable(encoded):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return True if this password wasn't generated by 
    User.set_unusable_password(), i.e. make_password(None). 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">encoded </span><span class="s0">is None or not </span><span class="s1">encoded.startswith(UNUSABLE_PASSWORD_PREFIX)</span>


<span class="s0">def </span><span class="s1">check_password(password</span><span class="s0">, </span><span class="s1">encoded</span><span class="s0">, </span><span class="s1">setter=</span><span class="s0">None, </span><span class="s1">preferred=</span><span class="s2">'default'</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return a boolean of whether the raw password matches the three 
    part encoded digest. 
 
    If setter is specified, it'll be called when you need to 
    regenerate the password. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">password </span><span class="s0">is None or not </span><span class="s1">is_password_usable(encoded):</span>
        <span class="s0">return False</span>

    <span class="s1">preferred = get_hasher(preferred)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">hasher = identify_hasher(encoded)</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s3"># encoded is gibberish or uses a hasher that's no longer installed.</span>
        <span class="s0">return False</span>

    <span class="s1">hasher_changed = hasher.algorithm != preferred.algorithm</span>
    <span class="s1">must_update = hasher_changed </span><span class="s0">or </span><span class="s1">preferred.must_update(encoded)</span>
    <span class="s1">is_correct = hasher.verify(password</span><span class="s0">, </span><span class="s1">encoded)</span>

    <span class="s3"># If the hasher didn't change (we don't protect against enumeration if it</span>
    <span class="s3"># does) and the password should get updated, try to close the timing gap</span>
    <span class="s3"># between the work factor of the current encoded password and the default</span>
    <span class="s3"># work factor.</span>
    <span class="s0">if not </span><span class="s1">is_correct </span><span class="s0">and not </span><span class="s1">hasher_changed </span><span class="s0">and </span><span class="s1">must_update:</span>
        <span class="s1">hasher.harden_runtime(password</span><span class="s0">, </span><span class="s1">encoded)</span>

    <span class="s0">if </span><span class="s1">setter </span><span class="s0">and </span><span class="s1">is_correct </span><span class="s0">and </span><span class="s1">must_update:</span>
        <span class="s1">setter(password)</span>
    <span class="s0">return </span><span class="s1">is_correct</span>


<span class="s0">def </span><span class="s1">make_password(password</span><span class="s0">, </span><span class="s1">salt=</span><span class="s0">None, </span><span class="s1">hasher=</span><span class="s2">'default'</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Turn a plain-text password into a hash for database storage 
 
    Same as encode() but generate a new random salt. If password is None then 
    return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string, 
    which disallows logins. Additional random string reduces chances of gaining 
    access to staff or superuser accounts. See ticket #20079 for more info. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">password </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)</span>
    <span class="s0">if not </span><span class="s1">isinstance(password</span><span class="s0">, </span><span class="s1">(bytes</span><span class="s0">, </span><span class="s1">str)):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s2">'Password must be a string or bytes, got %s.'</span>
            <span class="s1">% type(password).__qualname__</span>
        <span class="s1">)</span>
    <span class="s1">hasher = get_hasher(hasher)</span>
    <span class="s1">salt = salt </span><span class="s0">or </span><span class="s1">hasher.salt()</span>
    <span class="s0">return </span><span class="s1">hasher.encode(password</span><span class="s0">, </span><span class="s1">salt)</span>


<span class="s1">@functools.lru_cache()</span>
<span class="s0">def </span><span class="s1">get_hashers():</span>
    <span class="s1">hashers = []</span>
    <span class="s0">for </span><span class="s1">hasher_path </span><span class="s0">in </span><span class="s1">settings.PASSWORD_HASHERS:</span>
        <span class="s1">hasher_cls = import_string(hasher_path)</span>
        <span class="s1">hasher = hasher_cls()</span>
        <span class="s0">if not </span><span class="s1">getattr(hasher</span><span class="s0">, </span><span class="s2">'algorithm'</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ImproperlyConfigured(</span><span class="s2">&quot;hasher doesn't specify an &quot;</span>
                                       <span class="s2">&quot;algorithm name: %s&quot; </span><span class="s1">% hasher_path)</span>
        <span class="s1">hashers.append(hasher)</span>
    <span class="s0">return </span><span class="s1">hashers</span>


<span class="s1">@functools.lru_cache()</span>
<span class="s0">def </span><span class="s1">get_hashers_by_algorithm():</span>
    <span class="s0">return </span><span class="s1">{hasher.algorithm: hasher </span><span class="s0">for </span><span class="s1">hasher </span><span class="s0">in </span><span class="s1">get_hashers()}</span>


<span class="s1">@receiver(setting_changed)</span>
<span class="s0">def </span><span class="s1">reset_hashers(**kwargs):</span>
    <span class="s0">if </span><span class="s1">kwargs[</span><span class="s2">'setting'</span><span class="s1">] == </span><span class="s2">'PASSWORD_HASHERS'</span><span class="s1">:</span>
        <span class="s1">get_hashers.cache_clear()</span>
        <span class="s1">get_hashers_by_algorithm.cache_clear()</span>


<span class="s0">def </span><span class="s1">get_hasher(algorithm=</span><span class="s2">'default'</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return an instance of a loaded password hasher. 
 
    If algorithm is 'default', return the default hasher. Lazily import hashers 
    specified in the project's settings file if needed. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">hasattr(algorithm</span><span class="s0">, </span><span class="s2">'algorithm'</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">algorithm</span>

    <span class="s0">elif </span><span class="s1">algorithm == </span><span class="s2">'default'</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">get_hashers()[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">hashers = get_hashers_by_algorithm()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">hashers[algorithm]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Unknown password hashing algorithm '%s'. &quot;</span>
                             <span class="s2">&quot;Did you specify it in the PASSWORD_HASHERS &quot;</span>
                             <span class="s2">&quot;setting?&quot; </span><span class="s1">% algorithm)</span>


<span class="s0">def </span><span class="s1">identify_hasher(encoded):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return an instance of a loaded password hasher. 
 
    Identify hasher algorithm by examining encoded hash, and call 
    get_hasher() to return hasher. Raise ValueError if 
    algorithm cannot be identified, or if hasher is not loaded. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Ancient versions of Django created plain MD5 passwords and accepted</span>
    <span class="s3"># MD5 passwords with an empty salt.</span>
    <span class="s0">if </span><span class="s1">((len(encoded) == </span><span class="s4">32 </span><span class="s0">and </span><span class="s2">'$' </span><span class="s0">not in </span><span class="s1">encoded) </span><span class="s0">or</span>
            <span class="s1">(len(encoded) == </span><span class="s4">37 </span><span class="s0">and </span><span class="s1">encoded.startswith(</span><span class="s2">'md5$$'</span><span class="s1">))):</span>
        <span class="s1">algorithm = </span><span class="s2">'unsalted_md5'</span>
    <span class="s3"># Ancient versions of Django accepted SHA1 passwords with an empty salt.</span>
    <span class="s0">elif </span><span class="s1">len(encoded) == </span><span class="s4">46 </span><span class="s0">and </span><span class="s1">encoded.startswith(</span><span class="s2">'sha1$$'</span><span class="s1">):</span>
        <span class="s1">algorithm = </span><span class="s2">'unsalted_sha1'</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">algorithm = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">get_hasher(algorithm)</span>


<span class="s0">def </span><span class="s1">mask_hash(hash</span><span class="s0">, </span><span class="s1">show=</span><span class="s4">6</span><span class="s0">, </span><span class="s1">char=</span><span class="s2">&quot;*&quot;</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return the given hash, with only the first ``show`` number shown. The 
    rest are masked with ``char`` for security reasons. 
    &quot;&quot;&quot;</span>
    <span class="s1">masked = hash[:show]</span>
    <span class="s1">masked += char * len(hash[show:])</span>
    <span class="s0">return </span><span class="s1">masked</span>


<span class="s0">def </span><span class="s1">must_update_salt(salt</span><span class="s0">, </span><span class="s1">expected_entropy):</span>
    <span class="s3"># Each character in the salt provides log_2(len(alphabet)) bits of entropy.</span>
    <span class="s0">return </span><span class="s1">len(salt) * math.log2(len(RANDOM_STRING_CHARS)) &lt; expected_entropy</span>


<span class="s0">class </span><span class="s1">BasePasswordHasher:</span>
    <span class="s5">&quot;&quot;&quot; 
    Abstract base class for password hashers 
 
    When creating your own hasher, you need to override algorithm, 
    verify(), encode() and safe_summary(). 
 
    PasswordHasher objects are immutable. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s0">None</span>
    <span class="s1">library = </span><span class="s0">None</span>
    <span class="s1">salt_entropy = </span><span class="s4">128</span>

    <span class="s0">def </span><span class="s1">_load_library(self):</span>
        <span class="s0">if </span><span class="s1">self.library </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(self.library</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
                <span class="s1">name</span><span class="s0">, </span><span class="s1">mod_path = self.library</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">mod_path = self.library</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">module = importlib.import_module(mod_path)</span>
            <span class="s0">except </span><span class="s1">ImportError </span><span class="s0">as </span><span class="s1">e:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Couldn't load %r algorithm library: %s&quot; </span><span class="s1">%</span>
                                 <span class="s1">(self.__class__.__name__</span><span class="s0">, </span><span class="s1">e))</span>
            <span class="s0">return </span><span class="s1">module</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Hasher %r doesn't specify a library attribute&quot; </span><span class="s1">%</span>
                         <span class="s1">self.__class__.__name__)</span>

    <span class="s0">def </span><span class="s1">salt(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Generate a cryptographically secure nonce salt in ASCII with an entropy 
        of at least `salt_entropy` bits. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Each character in the salt provides</span>
        <span class="s3"># log_2(len(alphabet)) bits of entropy.</span>
        <span class="s1">char_count = math.ceil(self.salt_entropy / math.log2(len(RANDOM_STRING_CHARS)))</span>
        <span class="s0">return </span><span class="s1">get_random_string(char_count</span><span class="s0">, </span><span class="s1">allowed_chars=RANDOM_STRING_CHARS)</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s5">&quot;&quot;&quot;Check if the given password is correct.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">'subclasses of BasePasswordHasher must provide a verify() method'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_check_encode_args(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s0">if </span><span class="s1">password </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">'password must be provided.'</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">salt </span><span class="s0">or </span><span class="s2">'$' </span><span class="s0">in </span><span class="s1">salt:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'salt must be provided and cannot contain $.'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s5">&quot;&quot;&quot; 
        Create an encoded database value. 
 
        The result is normally formatted as &quot;algorithm$salt$hash&quot; and 
        must be fewer than 128 characters. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">'subclasses of BasePasswordHasher must provide an encode() method'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a decoded database value. 
 
        The result is a dictionary and should contain `algorithm`, `hash`, and 
        `salt`. Extra keys can be algorithm specific like `iterations` or 
        `work_factor`. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s2">'subclasses of BasePasswordHasher must provide a decode() method.'</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a summary of safe values. 
 
        The result is a dictionary and will be used where the password field 
        must be displayed to construct a safe representation of the password. 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">'subclasses of BasePasswordHasher must provide a safe_summary() method'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">must_update(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s5">&quot;&quot;&quot; 
        Bridge the runtime gap between the work factor supplied in `encoded` 
        and the work factor suggested by this hasher. 
 
        Taking PBKDF2 as an example, if `encoded` contains 20000 iterations and 
        `self.iterations` is 30000, this method should run password through 
        another 10000 iterations of PBKDF2. Similar approaches should exist 
        for any hasher that has a work factor. If not, this method should be 
        defined as a no-op to silence the warning. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(</span><span class="s2">'subclasses of BasePasswordHasher should provide a harden_runtime() method'</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">PBKDF2PasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Secure password hashing using the PBKDF2 algorithm (recommended) 
 
    Configured to use PBKDF2 + HMAC + SHA256. 
    The result is a 64 byte binary string.  Iterations may be changed 
    safely but you must rename the algorithm if you change SHA256. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;pbkdf2_sha256&quot;</span>
    <span class="s1">iterations = </span><span class="s4">320000</span>
    <span class="s1">digest = hashlib.sha256</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">iterations=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self._check_encode_args(password</span><span class="s0">, </span><span class="s1">salt)</span>
        <span class="s1">iterations = iterations </span><span class="s0">or </span><span class="s1">self.iterations</span>
        <span class="s1">hash = pbkdf2(password</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">iterations</span><span class="s0">, </span><span class="s1">digest=self.digest)</span>
        <span class="s1">hash = base64.b64encode(hash).decode(</span><span class="s2">'ascii'</span><span class="s1">).strip()</span>
        <span class="s0">return </span><span class="s2">&quot;%s$%d$%s$%s&quot; </span><span class="s1">% (self.algorithm</span><span class="s0">, </span><span class="s1">iterations</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">hash)</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">iterations</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">hash = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: algorithm</span><span class="s0">,</span>
            <span class="s2">'hash'</span><span class="s1">: hash</span><span class="s0">,</span>
            <span class="s2">'iterations'</span><span class="s1">: int(iterations)</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: salt</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s1">encoded_2 = self.encode(password</span><span class="s0">, </span><span class="s1">decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decoded[</span><span class="s2">'iterations'</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">constant_time_compare(encoded</span><span class="s0">, </span><span class="s1">encoded_2)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'iterations'</span><span class="s1">): decoded[</span><span class="s2">'iterations'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'salt'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'salt'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'hash'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'hash'</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">must_update(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s1">update_salt = must_update_salt(decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.salt_entropy)</span>
        <span class="s0">return </span><span class="s1">(decoded[</span><span class="s2">'iterations'</span><span class="s1">] != self.iterations) </span><span class="s0">or </span><span class="s1">update_salt</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s1">extra_iterations = self.iterations - decoded[</span><span class="s2">'iterations'</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">extra_iterations &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.encode(password</span><span class="s0">, </span><span class="s1">decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">extra_iterations)</span>


<span class="s0">class </span><span class="s1">PBKDF2SHA1PasswordHasher(PBKDF2PasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Alternate PBKDF2 hasher which uses SHA1, the default PRF 
    recommended by PKCS #5. This is compatible with other 
    implementations of PBKDF2, such as openssl's 
    PKCS5_PBKDF2_HMAC_SHA1(). 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;pbkdf2_sha1&quot;</span>
    <span class="s1">digest = hashlib.sha1</span>


<span class="s0">class </span><span class="s1">Argon2PasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Secure password hashing using the argon2 algorithm. 
 
    This is the winner of the Password Hashing Competition 2013-2015 
    (https://password-hashing.net). It requires the argon2-cffi library which 
    depends on native C code and might cause portability issues. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">'argon2'</span>
    <span class="s1">library = </span><span class="s2">'argon2'</span>

    <span class="s1">time_cost = </span><span class="s4">2</span>
    <span class="s1">memory_cost = </span><span class="s4">102400</span>
    <span class="s1">parallelism = </span><span class="s4">8</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s1">argon2 = self._load_library()</span>
        <span class="s1">params = self.params()</span>
        <span class="s1">data = argon2.low_level.hash_secret(</span>
            <span class="s1">password.encode()</span><span class="s0">,</span>
            <span class="s1">salt.encode()</span><span class="s0">,</span>
            <span class="s1">time_cost=params.time_cost</span><span class="s0">,</span>
            <span class="s1">memory_cost=params.memory_cost</span><span class="s0">,</span>
            <span class="s1">parallelism=params.parallelism</span><span class="s0">,</span>
            <span class="s1">hash_len=params.hash_len</span><span class="s0">,</span>
            <span class="s1">type=params.type</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self.algorithm + data.decode(</span><span class="s2">'ascii'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">argon2 = self._load_library()</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">rest = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s1">params = argon2.extract_parameters(</span><span class="s2">'$' </span><span class="s1">+ rest)</span>
        <span class="s1">variety</span><span class="s0">, </span><span class="s1">*_</span><span class="s0">, </span><span class="s1">b64salt</span><span class="s0">, </span><span class="s1">hash = rest.split(</span><span class="s2">'$'</span><span class="s1">)</span>
        <span class="s3"># Add padding.</span>
        <span class="s1">b64salt += </span><span class="s2">'=' </span><span class="s1">* (-len(b64salt) % </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">salt = base64.b64decode(b64salt).decode(</span><span class="s2">'latin1'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: algorithm</span><span class="s0">,</span>
            <span class="s2">'hash'</span><span class="s1">: hash</span><span class="s0">,</span>
            <span class="s2">'memory_cost'</span><span class="s1">: params.memory_cost</span><span class="s0">,</span>
            <span class="s2">'parallelism'</span><span class="s1">: params.parallelism</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: salt</span><span class="s0">,</span>
            <span class="s2">'time_cost'</span><span class="s1">: params.time_cost</span><span class="s0">,</span>
            <span class="s2">'variety'</span><span class="s1">: variety</span><span class="s0">,</span>
            <span class="s2">'version'</span><span class="s1">: params.version</span><span class="s0">,</span>
            <span class="s2">'params'</span><span class="s1">: params</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">argon2 = self._load_library()</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">rest = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">argon2.PasswordHasher().verify(</span><span class="s2">'$' </span><span class="s1">+ rest</span><span class="s0">, </span><span class="s1">password)</span>
        <span class="s0">except </span><span class="s1">argon2.exceptions.VerificationError:</span>
            <span class="s0">return False</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'variety'</span><span class="s1">): decoded[</span><span class="s2">'variety'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'version'</span><span class="s1">): decoded[</span><span class="s2">'version'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'memory cost'</span><span class="s1">): decoded[</span><span class="s2">'memory_cost'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'time cost'</span><span class="s1">): decoded[</span><span class="s2">'time_cost'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'parallelism'</span><span class="s1">): decoded[</span><span class="s2">'parallelism'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'salt'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'salt'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'hash'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'hash'</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">must_update(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s1">current_params = decoded[</span><span class="s2">'params'</span><span class="s1">]</span>
        <span class="s1">new_params = self.params()</span>
        <span class="s3"># Set salt_len to the salt_len of the current parameters because salt</span>
        <span class="s3"># is explicitly passed to argon2.</span>
        <span class="s1">new_params.salt_len = current_params.salt_len</span>
        <span class="s1">update_salt = must_update_salt(decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.salt_entropy)</span>
        <span class="s0">return </span><span class="s1">(current_params != new_params) </span><span class="s0">or </span><span class="s1">update_salt</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s3"># The runtime for Argon2 is too complicated to implement a sensible</span>
        <span class="s3"># hardening algorithm.</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">params(self):</span>
        <span class="s1">argon2 = self._load_library()</span>
        <span class="s3"># salt_len is a noop, because we provide our own salt.</span>
        <span class="s0">return </span><span class="s1">argon2.Parameters(</span>
            <span class="s1">type=argon2.low_level.Type.ID</span><span class="s0">,</span>
            <span class="s1">version=argon2.low_level.ARGON2_VERSION</span><span class="s0">,</span>
            <span class="s1">salt_len=argon2.DEFAULT_RANDOM_SALT_LENGTH</span><span class="s0">,</span>
            <span class="s1">hash_len=argon2.DEFAULT_HASH_LENGTH</span><span class="s0">,</span>
            <span class="s1">time_cost=self.time_cost</span><span class="s0">,</span>
            <span class="s1">memory_cost=self.memory_cost</span><span class="s0">,</span>
            <span class="s1">parallelism=self.parallelism</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s0">class </span><span class="s1">BCryptSHA256PasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Secure password hashing using the bcrypt algorithm (recommended) 
 
    This is considered by many to be the most secure algorithm but you 
    must first install the bcrypt library.  Please be warned that 
    this library depends on native C code and might cause portability 
    issues. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;bcrypt_sha256&quot;</span>
    <span class="s1">digest = hashlib.sha256</span>
    <span class="s1">library = (</span><span class="s2">&quot;bcrypt&quot;</span><span class="s0">, </span><span class="s2">&quot;bcrypt&quot;</span><span class="s1">)</span>
    <span class="s1">rounds = </span><span class="s4">12</span>

    <span class="s0">def </span><span class="s1">salt(self):</span>
        <span class="s1">bcrypt = self._load_library()</span>
        <span class="s0">return </span><span class="s1">bcrypt.gensalt(self.rounds)</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s1">bcrypt = self._load_library()</span>
        <span class="s1">password = password.encode()</span>
        <span class="s3"># Hash the password prior to using bcrypt to prevent password</span>
        <span class="s3"># truncation as described in #20138.</span>
        <span class="s0">if </span><span class="s1">self.digest </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s3"># Use binascii.hexlify() because a hex encoded bytestring is str.</span>
            <span class="s1">password = binascii.hexlify(self.digest(password).digest())</span>

        <span class="s1">data = bcrypt.hashpw(password</span><span class="s0">, </span><span class="s1">salt)</span>
        <span class="s0">return </span><span class="s2">&quot;%s$%s&quot; </span><span class="s1">% (self.algorithm</span><span class="s0">, </span><span class="s1">data.decode(</span><span class="s2">'ascii'</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">empty</span><span class="s0">, </span><span class="s1">algostr</span><span class="s0">, </span><span class="s1">work_factor</span><span class="s0">, </span><span class="s1">data = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: algorithm</span><span class="s0">,</span>
            <span class="s2">'algostr'</span><span class="s1">: algostr</span><span class="s0">,</span>
            <span class="s2">'checksum'</span><span class="s1">: data[</span><span class="s4">22</span><span class="s1">:]</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: data[:</span><span class="s4">22</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">'work_factor'</span><span class="s1">: int(work_factor)</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">data = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s1">encoded_2 = self.encode(password</span><span class="s0">, </span><span class="s1">data.encode(</span><span class="s2">'ascii'</span><span class="s1">))</span>
        <span class="s0">return </span><span class="s1">constant_time_compare(encoded</span><span class="s0">, </span><span class="s1">encoded_2)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'work factor'</span><span class="s1">): decoded[</span><span class="s2">'work_factor'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'salt'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'salt'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'checksum'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'checksum'</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">must_update(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">decoded[</span><span class="s2">'work_factor'</span><span class="s1">] != self.rounds</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">data = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">salt = data[:</span><span class="s4">29</span><span class="s1">]  </span><span class="s3"># Length of the salt in bcrypt.</span>
        <span class="s1">rounds = data.split(</span><span class="s2">'$'</span><span class="s1">)[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s3"># work factor is logarithmic, adding one doubles the load.</span>
        <span class="s1">diff = </span><span class="s4">2</span><span class="s1">**(self.rounds - int(rounds)) - </span><span class="s4">1</span>
        <span class="s0">while </span><span class="s1">diff &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.encode(password</span><span class="s0">, </span><span class="s1">salt.encode(</span><span class="s2">'ascii'</span><span class="s1">))</span>
            <span class="s1">diff -= </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">BCryptPasswordHasher(BCryptSHA256PasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Secure password hashing using the bcrypt algorithm 
 
    This is considered by many to be the most secure algorithm but you 
    must first install the bcrypt library.  Please be warned that 
    this library depends on native C code and might cause portability 
    issues. 
 
    This hasher does not first hash the password which means it is subject to 
    bcrypt's 72 bytes password truncation. Most use cases should prefer the 
    BCryptSHA256PasswordHasher. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;bcrypt&quot;</span>
    <span class="s1">digest = </span><span class="s0">None</span>


<span class="s0">class </span><span class="s1">ScryptPasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Secure password hashing using the Scrypt algorithm. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">'scrypt'</span>
    <span class="s1">block_size = </span><span class="s4">8</span>
    <span class="s1">maxmem = </span><span class="s4">0</span>
    <span class="s1">parallelism = </span><span class="s4">1</span>
    <span class="s1">work_factor = </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">14</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">n=</span><span class="s0">None, </span><span class="s1">r=</span><span class="s0">None, </span><span class="s1">p=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self._check_encode_args(password</span><span class="s0">, </span><span class="s1">salt)</span>
        <span class="s1">n = n </span><span class="s0">or </span><span class="s1">self.work_factor</span>
        <span class="s1">r = r </span><span class="s0">or </span><span class="s1">self.block_size</span>
        <span class="s1">p = p </span><span class="s0">or </span><span class="s1">self.parallelism</span>
        <span class="s1">hash_ = hashlib.scrypt(</span>
            <span class="s1">password.encode()</span><span class="s0">,</span>
            <span class="s1">salt=salt.encode()</span><span class="s0">,</span>
            <span class="s1">n=n</span><span class="s0">,</span>
            <span class="s1">r=r</span><span class="s0">,</span>
            <span class="s1">p=p</span><span class="s0">,</span>
            <span class="s1">maxmem=self.maxmem</span><span class="s0">,</span>
            <span class="s1">dklen=</span><span class="s4">64</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">hash_ = base64.b64encode(hash_).decode(</span><span class="s2">'ascii'</span><span class="s1">).strip()</span>
        <span class="s0">return </span><span class="s2">'%s$%d$%s$%d$%d$%s' </span><span class="s1">% (self.algorithm</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">hash_)</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">work_factor</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">block_size</span><span class="s0">, </span><span class="s1">parallelism</span><span class="s0">, </span><span class="s1">hash_ = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: algorithm</span><span class="s0">,</span>
            <span class="s2">'work_factor'</span><span class="s1">: int(work_factor)</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: salt</span><span class="s0">,</span>
            <span class="s2">'block_size'</span><span class="s1">: int(block_size)</span><span class="s0">,</span>
            <span class="s2">'parallelism'</span><span class="s1">: int(parallelism)</span><span class="s0">,</span>
            <span class="s2">'hash'</span><span class="s1">: hash_</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s1">encoded_2 = self.encode(</span>
            <span class="s1">password</span><span class="s0">,</span>
            <span class="s1">decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">decoded[</span><span class="s2">'work_factor'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">decoded[</span><span class="s2">'block_size'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">decoded[</span><span class="s2">'parallelism'</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">constant_time_compare(encoded</span><span class="s0">, </span><span class="s1">encoded_2)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'work factor'</span><span class="s1">): decoded[</span><span class="s2">'work_factor'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'block size'</span><span class="s1">): decoded[</span><span class="s2">'block_size'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'parallelism'</span><span class="s1">): decoded[</span><span class="s2">'parallelism'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'salt'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'salt'</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'hash'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'hash'</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">must_update(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">decoded[</span><span class="s2">'work_factor'</span><span class="s1">] != self.work_factor </span><span class="s0">or</span>
            <span class="s1">decoded[</span><span class="s2">'block_size'</span><span class="s1">] != self.block_size </span><span class="s0">or</span>
            <span class="s1">decoded[</span><span class="s2">'parallelism'</span><span class="s1">] != self.parallelism</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s3"># The runtime for Scrypt is too complicated to implement a sensible</span>
        <span class="s3"># hardening algorithm.</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">SHA1PasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    The SHA1 password hashing algorithm (not recommended) 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;sha1&quot;</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s1">self._check_encode_args(password</span><span class="s0">, </span><span class="s1">salt)</span>
        <span class="s1">hash = hashlib.sha1((salt + password).encode()).hexdigest()</span>
        <span class="s0">return </span><span class="s2">&quot;%s$%s$%s&quot; </span><span class="s1">% (self.algorithm</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">hash)</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">hash = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: algorithm</span><span class="s0">,</span>
            <span class="s2">'hash'</span><span class="s1">: hash</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: salt</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s1">encoded_2 = self.encode(password</span><span class="s0">, </span><span class="s1">decoded[</span><span class="s2">'salt'</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">constant_time_compare(encoded</span><span class="s0">, </span><span class="s1">encoded_2)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'salt'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">show=</span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'hash'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'hash'</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">must_update(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">must_update_salt(decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.salt_entropy)</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">MD5PasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    The Salted MD5 password hashing algorithm (not recommended) 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;md5&quot;</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s1">self._check_encode_args(password</span><span class="s0">, </span><span class="s1">salt)</span>
        <span class="s1">hash = hashlib.md5((salt + password).encode()).hexdigest()</span>
        <span class="s0">return </span><span class="s2">&quot;%s$%s$%s&quot; </span><span class="s1">% (self.algorithm</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">hash)</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">hash = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: algorithm</span><span class="s0">,</span>
            <span class="s2">'hash'</span><span class="s1">: hash</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: salt</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s1">encoded_2 = self.encode(password</span><span class="s0">, </span><span class="s1">decoded[</span><span class="s2">'salt'</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">constant_time_compare(encoded</span><span class="s0">, </span><span class="s1">encoded_2)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'salt'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">show=</span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'hash'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'hash'</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">must_update(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">must_update_salt(decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">self.salt_entropy)</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">UnsaltedSHA1PasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Very insecure algorithm that you should *never* use; store SHA1 hashes 
    with an empty salt. 
 
    This class is implemented because Django used to accept such password 
    hashes. Some older Django installs still have these values lingering 
    around so we need to handle and upgrade them properly. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;unsalted_sha1&quot;</span>

    <span class="s0">def </span><span class="s1">salt(self):</span>
        <span class="s0">return </span><span class="s2">''</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s0">if </span><span class="s1">salt != </span><span class="s2">''</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'salt must be empty.'</span><span class="s1">)</span>
        <span class="s1">hash = hashlib.sha1(password.encode()).hexdigest()</span>
        <span class="s0">return </span><span class="s2">'sha1$$%s' </span><span class="s1">% hash</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">assert </span><span class="s1">encoded.startswith(</span><span class="s2">'sha1$$'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: self.algorithm</span><span class="s0">,</span>
            <span class="s2">'hash'</span><span class="s1">: encoded[</span><span class="s4">6</span><span class="s1">:]</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">encoded_2 = self.encode(password</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">constant_time_compare(encoded</span><span class="s0">, </span><span class="s1">encoded_2)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'hash'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'hash'</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">UnsaltedMD5PasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Incredibly insecure algorithm that you should *never* use; stores unsalted 
    MD5 hashes without the algorithm prefix, also accepts MD5 hashes with an 
    empty salt. 
 
    This class is implemented because Django used to store passwords this way 
    and to accept such password hashes. Some older Django installs still have 
    these values lingering around so we need to handle and upgrade them 
    properly. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;unsalted_md5&quot;</span>

    <span class="s0">def </span><span class="s1">salt(self):</span>
        <span class="s0">return </span><span class="s2">''</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s0">if </span><span class="s1">salt != </span><span class="s2">''</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'salt must be empty.'</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">hashlib.md5(password.encode()).hexdigest()</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: self.algorithm</span><span class="s0">,</span>
            <span class="s2">'hash'</span><span class="s1">: encoded</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: </span><span class="s0">None,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">if </span><span class="s1">len(encoded) == </span><span class="s4">37 </span><span class="s0">and </span><span class="s1">encoded.startswith(</span><span class="s2">'md5$$'</span><span class="s1">):</span>
            <span class="s1">encoded = encoded[</span><span class="s4">5</span><span class="s1">:]</span>
        <span class="s1">encoded_2 = self.encode(password</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">constant_time_compare(encoded</span><span class="s0">, </span><span class="s1">encoded_2)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'hash'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'hash'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">show=</span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">pass</span>


<span class="s0">class </span><span class="s1">CryptPasswordHasher(BasePasswordHasher):</span>
    <span class="s5">&quot;&quot;&quot; 
    Password hashing using UNIX crypt (not recommended) 
 
    The crypt module is not supported on all platforms. 
    &quot;&quot;&quot;</span>
    <span class="s1">algorithm = </span><span class="s2">&quot;crypt&quot;</span>
    <span class="s1">library = </span><span class="s2">&quot;crypt&quot;</span>

    <span class="s0">def </span><span class="s1">salt(self):</span>
        <span class="s0">return </span><span class="s1">get_random_string(</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">encode(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">salt):</span>
        <span class="s1">crypt = self._load_library()</span>
        <span class="s0">if </span><span class="s1">len(salt) != </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'salt must be of length 2.'</span><span class="s1">)</span>
        <span class="s1">hash = crypt.crypt(password</span><span class="s0">, </span><span class="s1">salt)</span>
        <span class="s0">if </span><span class="s1">hash </span><span class="s0">is None</span><span class="s1">:  </span><span class="s3"># A platform like OpenBSD with a dummy crypt module.</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">'hash must be provided.'</span><span class="s1">)</span>
        <span class="s3"># we don't need to store the salt, but Django used to do this</span>
        <span class="s0">return </span><span class="s2">'%s$%s$%s' </span><span class="s1">% (self.algorithm</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, </span><span class="s1">hash)</span>

    <span class="s0">def </span><span class="s1">decode(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">algorithm</span><span class="s0">, </span><span class="s1">salt</span><span class="s0">, </span><span class="s1">hash = encoded.split(</span><span class="s2">'$'</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">algorithm == self.algorithm</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s2">'algorithm'</span><span class="s1">: algorithm</span><span class="s0">,</span>
            <span class="s2">'hash'</span><span class="s1">: hash</span><span class="s0">,</span>
            <span class="s2">'salt'</span><span class="s1">: salt</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">crypt = self._load_library()</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s1">data = crypt.crypt(password</span><span class="s0">, </span><span class="s1">decoded[</span><span class="s2">'hash'</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">constant_time_compare(decoded[</span><span class="s2">'hash'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data)</span>

    <span class="s0">def </span><span class="s1">safe_summary(self</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s1">decoded = self.decode(encoded)</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">_(</span><span class="s2">'algorithm'</span><span class="s1">): decoded[</span><span class="s2">'algorithm'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'salt'</span><span class="s1">): decoded[</span><span class="s2">'salt'</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">_(</span><span class="s2">'hash'</span><span class="s1">): mask_hash(decoded[</span><span class="s2">'hash'</span><span class="s1">]</span><span class="s0">, </span><span class="s1">show=</span><span class="s4">3</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">harden_runtime(self</span><span class="s0">, </span><span class="s1">password</span><span class="s0">, </span><span class="s1">encoded):</span>
        <span class="s0">pass</span>
</pre>
</body>
</html>