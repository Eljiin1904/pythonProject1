<html>
<head>
<title>system_info.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
system_info.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: SystemInfo (experimental)</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>

<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">GPUDevice:</span>
    <span class="s3">''' 
    Describes a single graphics processor (GPU). 
    '''</span>
    <span class="s0">#: PCI ID of the GPU vendor, if available; 0 otherwise.</span>
    <span class="s1">vendor_id: float</span>

    <span class="s0">#: PCI ID of the GPU device, if available; 0 otherwise.</span>
    <span class="s1">device_id: float</span>

    <span class="s0">#: String description of the GPU vendor, if the PCI ID is not available.</span>
    <span class="s1">vendor_string: str</span>

    <span class="s0">#: String description of the GPU device, if the PCI ID is not available.</span>
    <span class="s1">device_string: str</span>

    <span class="s0">#: String description of the GPU driver vendor.</span>
    <span class="s1">driver_vendor: str</span>

    <span class="s0">#: String description of the GPU driver version.</span>
    <span class="s1">driver_version: str</span>

    <span class="s0">#: Sub sys ID of the GPU, only available on Windows.</span>
    <span class="s1">sub_sys_id: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s0">#: Revision of the GPU, only available on Windows.</span>
    <span class="s1">revision: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'vendorId'</span><span class="s1">] = self.vendor_id</span>
        <span class="s1">json[</span><span class="s4">'deviceId'</span><span class="s1">] = self.device_id</span>
        <span class="s1">json[</span><span class="s4">'vendorString'</span><span class="s1">] = self.vendor_string</span>
        <span class="s1">json[</span><span class="s4">'deviceString'</span><span class="s1">] = self.device_string</span>
        <span class="s1">json[</span><span class="s4">'driverVendor'</span><span class="s1">] = self.driver_vendor</span>
        <span class="s1">json[</span><span class="s4">'driverVersion'</span><span class="s1">] = self.driver_version</span>
        <span class="s2">if </span><span class="s1">self.sub_sys_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'subSysId'</span><span class="s1">] = self.sub_sys_id</span>
        <span class="s2">if </span><span class="s1">self.revision </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'revision'</span><span class="s1">] = self.revision</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">vendor_id=float(json[</span><span class="s4">'vendorId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">device_id=float(json[</span><span class="s4">'deviceId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">vendor_string=str(json[</span><span class="s4">'vendorString'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">device_string=str(json[</span><span class="s4">'deviceString'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">driver_vendor=str(json[</span><span class="s4">'driverVendor'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">driver_version=str(json[</span><span class="s4">'driverVersion'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">sub_sys_id=float(json[</span><span class="s4">'subSysId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'subSysId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">revision=float(json[</span><span class="s4">'revision'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'revision' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Size:</span>
    <span class="s3">''' 
    Describes the width and height dimensions of an entity. 
    '''</span>
    <span class="s0">#: Width in pixels.</span>
    <span class="s1">width: int</span>

    <span class="s0">#: Height in pixels.</span>
    <span class="s1">height: int</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'width'</span><span class="s1">] = self.width</span>
        <span class="s1">json[</span><span class="s4">'height'</span><span class="s1">] = self.height</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">width=int(json[</span><span class="s4">'width'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">height=int(json[</span><span class="s4">'height'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">VideoDecodeAcceleratorCapability:</span>
    <span class="s3">''' 
    Describes a supported video decoding profile with its associated minimum and 
    maximum resolutions. 
    '''</span>
    <span class="s0">#: Video codec profile that is supported, e.g. VP9 Profile 2.</span>
    <span class="s1">profile: str</span>

    <span class="s0">#: Maximum video dimensions in pixels supported for this ``profile``.</span>
    <span class="s1">max_resolution: Size</span>

    <span class="s0">#: Minimum video dimensions in pixels supported for this ``profile``.</span>
    <span class="s1">min_resolution: Size</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'profile'</span><span class="s1">] = self.profile</span>
        <span class="s1">json[</span><span class="s4">'maxResolution'</span><span class="s1">] = self.max_resolution.to_json()</span>
        <span class="s1">json[</span><span class="s4">'minResolution'</span><span class="s1">] = self.min_resolution.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">profile=str(json[</span><span class="s4">'profile'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">max_resolution=Size.from_json(json[</span><span class="s4">'maxResolution'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">min_resolution=Size.from_json(json[</span><span class="s4">'minResolution'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">VideoEncodeAcceleratorCapability:</span>
    <span class="s3">''' 
    Describes a supported video encoding profile with its associated maximum 
    resolution and maximum framerate. 
    '''</span>
    <span class="s0">#: Video codec profile that is supported, e.g H264 Main.</span>
    <span class="s1">profile: str</span>

    <span class="s0">#: Maximum video dimensions in pixels supported for this ``profile``.</span>
    <span class="s1">max_resolution: Size</span>

    <span class="s0">#: Maximum encoding framerate in frames per second supported for this</span>
    <span class="s0">#: ``profile``, as fraction's numerator and denominator, e.g. 24/1 fps,</span>
    <span class="s0">#: 24000/1001 fps, etc.</span>
    <span class="s1">max_framerate_numerator: int</span>

    <span class="s1">max_framerate_denominator: int</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'profile'</span><span class="s1">] = self.profile</span>
        <span class="s1">json[</span><span class="s4">'maxResolution'</span><span class="s1">] = self.max_resolution.to_json()</span>
        <span class="s1">json[</span><span class="s4">'maxFramerateNumerator'</span><span class="s1">] = self.max_framerate_numerator</span>
        <span class="s1">json[</span><span class="s4">'maxFramerateDenominator'</span><span class="s1">] = self.max_framerate_denominator</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">profile=str(json[</span><span class="s4">'profile'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">max_resolution=Size.from_json(json[</span><span class="s4">'maxResolution'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">max_framerate_numerator=int(json[</span><span class="s4">'maxFramerateNumerator'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">max_framerate_denominator=int(json[</span><span class="s4">'maxFramerateDenominator'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">SubsamplingFormat(enum.Enum):</span>
    <span class="s3">''' 
    YUV subsampling type of the pixels of a given image. 
    '''</span>
    <span class="s1">YUV420 = </span><span class="s4">&quot;yuv420&quot;</span>
    <span class="s1">YUV422 = </span><span class="s4">&quot;yuv422&quot;</span>
    <span class="s1">YUV444 = </span><span class="s4">&quot;yuv444&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">ImageType(enum.Enum):</span>
    <span class="s3">''' 
    Image format of a given image. 
    '''</span>
    <span class="s1">JPEG = </span><span class="s4">&quot;jpeg&quot;</span>
    <span class="s1">WEBP = </span><span class="s4">&quot;webp&quot;</span>
    <span class="s1">UNKNOWN = </span><span class="s4">&quot;unknown&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ImageDecodeAcceleratorCapability:</span>
    <span class="s3">''' 
    Describes a supported image decoding profile with its associated minimum and 
    maximum resolutions and subsampling. 
    '''</span>
    <span class="s0">#: Image coded, e.g. Jpeg.</span>
    <span class="s1">image_type: ImageType</span>

    <span class="s0">#: Maximum supported dimensions of the image in pixels.</span>
    <span class="s1">max_dimensions: Size</span>

    <span class="s0">#: Minimum supported dimensions of the image in pixels.</span>
    <span class="s1">min_dimensions: Size</span>

    <span class="s0">#: Optional array of supported subsampling formats, e.g. 4:2:0, if known.</span>
    <span class="s1">subsamplings: typing.List[SubsamplingFormat]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'imageType'</span><span class="s1">] = self.image_type.to_json()</span>
        <span class="s1">json[</span><span class="s4">'maxDimensions'</span><span class="s1">] = self.max_dimensions.to_json()</span>
        <span class="s1">json[</span><span class="s4">'minDimensions'</span><span class="s1">] = self.min_dimensions.to_json()</span>
        <span class="s1">json[</span><span class="s4">'subsamplings'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.subsamplings]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">image_type=ImageType.from_json(json[</span><span class="s4">'imageType'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">max_dimensions=Size.from_json(json[</span><span class="s4">'maxDimensions'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">min_dimensions=Size.from_json(json[</span><span class="s4">'minDimensions'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">subsamplings=[SubsamplingFormat.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'subsamplings'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">GPUInfo:</span>
    <span class="s3">''' 
    Provides information about the GPU(s) on the system. 
    '''</span>
    <span class="s0">#: The graphics devices on the system. Element 0 is the primary GPU.</span>
    <span class="s1">devices: typing.List[GPUDevice]</span>

    <span class="s0">#: An optional array of GPU driver bug workarounds.</span>
    <span class="s1">driver_bug_workarounds: typing.List[str]</span>

    <span class="s0">#: Supported accelerated video decoding capabilities.</span>
    <span class="s1">video_decoding: typing.List[VideoDecodeAcceleratorCapability]</span>

    <span class="s0">#: Supported accelerated video encoding capabilities.</span>
    <span class="s1">video_encoding: typing.List[VideoEncodeAcceleratorCapability]</span>

    <span class="s0">#: Supported accelerated image decoding capabilities.</span>
    <span class="s1">image_decoding: typing.List[ImageDecodeAcceleratorCapability]</span>

    <span class="s0">#: An optional dictionary of additional GPU related attributes.</span>
    <span class="s1">aux_attributes: typing.Optional[dict] = </span><span class="s2">None</span>

    <span class="s0">#: An optional dictionary of graphics features and their status.</span>
    <span class="s1">feature_status: typing.Optional[dict] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'devices'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.devices]</span>
        <span class="s1">json[</span><span class="s4">'driverBugWorkarounds'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.driver_bug_workarounds]</span>
        <span class="s1">json[</span><span class="s4">'videoDecoding'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.video_decoding]</span>
        <span class="s1">json[</span><span class="s4">'videoEncoding'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.video_encoding]</span>
        <span class="s1">json[</span><span class="s4">'imageDecoding'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.image_decoding]</span>
        <span class="s2">if </span><span class="s1">self.aux_attributes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'auxAttributes'</span><span class="s1">] = self.aux_attributes</span>
        <span class="s2">if </span><span class="s1">self.feature_status </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'featureStatus'</span><span class="s1">] = self.feature_status</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">devices=[GPUDevice.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'devices'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">driver_bug_workarounds=[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'driverBugWorkarounds'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">video_decoding=[VideoDecodeAcceleratorCapability.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'videoDecoding'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">video_encoding=[VideoEncodeAcceleratorCapability.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'videoEncoding'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">image_decoding=[ImageDecodeAcceleratorCapability.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'imageDecoding'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">aux_attributes=dict(json[</span><span class="s4">'auxAttributes'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'auxAttributes' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">feature_status=dict(json[</span><span class="s4">'featureStatus'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'featureStatus' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ProcessInfo:</span>
    <span class="s3">''' 
    Represents process info. 
    '''</span>
    <span class="s0">#: Specifies process type.</span>
    <span class="s1">type_: str</span>

    <span class="s0">#: Specifies process id.</span>
    <span class="s1">id_: int</span>

    <span class="s0">#: Specifies cumulative CPU usage in seconds across all threads of the</span>
    <span class="s0">#: process since the process start.</span>
    <span class="s1">cpu_time: float</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s1">json[</span><span class="s4">'id'</span><span class="s1">] = self.id_</span>
        <span class="s1">json[</span><span class="s4">'cpuTime'</span><span class="s1">] = self.cpu_time</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">id_=int(json[</span><span class="s4">'id'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">cpu_time=float(json[</span><span class="s4">'cpuTime'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_info() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[GPUInfo</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str</span><span class="s2">, </span><span class="s1">str]]:</span>
    <span class="s3">''' 
    Returns information about the system. 
 
    :returns: A tuple with the following items: 
 
        0. **gpu** - Information about the GPUs on the system. 
        1. **modelName** - A platform-dependent description of the model of the machine. On Mac OS, this is, for example, 'MacBookPro'. Will be the empty string if not supported. 
        2. **modelVersion** - A platform-dependent description of the version of the machine. On Mac OS, this is, for example, '10.1'. Will be the empty string if not supported. 
        3. **commandLine** - The command line string used to launch the browser. Will be the empty string if not supported. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'SystemInfo.getInfo'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">GPUInfo.from_json(json[</span><span class="s4">'gpu'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">str(json[</span><span class="s4">'modelName'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">str(json[</span><span class="s4">'modelVersion'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">str(json[</span><span class="s4">'commandLine'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_process_info() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[ProcessInfo]]:</span>
    <span class="s3">''' 
    Returns information about all running processes. 
 
    :returns: An array of process info blocks. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'SystemInfo.getProcessInfo'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[ProcessInfo.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'processInfo'</span><span class="s1">]]</span>
</pre>
</body>
</html>