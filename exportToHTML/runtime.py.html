<html>
<head>
<title>runtime.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
runtime.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: Runtime</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>

<span class="s2">class </span><span class="s1">ScriptId(str):</span>
    <span class="s3">''' 
    Unique script identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; ScriptId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'ScriptId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">RemoteObjectId(str):</span>
    <span class="s3">''' 
    Unique object identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; RemoteObjectId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'RemoteObjectId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">UnserializableValue(str):</span>
    <span class="s3">''' 
    Primitive value which cannot be JSON-stringified. Includes values ``-0``, ``NaN``, ``Infinity``, 
    ``-Infinity``, and bigint literals. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; UnserializableValue:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'UnserializableValue({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RemoteObject:</span>
    <span class="s3">''' 
    Mirror object referencing original JavaScript object. 
    '''</span>
    <span class="s0">#: Object type.</span>
    <span class="s1">type_: str</span>

    <span class="s0">#: Object subtype hint. Specified for ``object`` type values only.</span>
    <span class="s0">#: NOTE: If you change anything here, make sure to also update</span>
    <span class="s0">#: ``subtype`` in ``ObjectPreview`` and ``PropertyPreview`` below.</span>
    <span class="s1">subtype: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Object class (constructor) name. Specified for ``object`` type values only.</span>
    <span class="s1">class_name: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Remote object value in case of primitive values or JSON values (if it was requested).</span>
    <span class="s1">value: typing.Optional[typing.Any] = </span><span class="s2">None</span>

    <span class="s0">#: Primitive value which can not be JSON-stringified does not have ``value``, but gets this</span>
    <span class="s0">#: property.</span>
    <span class="s1">unserializable_value: typing.Optional[UnserializableValue] = </span><span class="s2">None</span>

    <span class="s0">#: String representation of the object.</span>
    <span class="s1">description: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Unique object identifier (for non-primitive values).</span>
    <span class="s1">object_id: typing.Optional[RemoteObjectId] = </span><span class="s2">None</span>

    <span class="s0">#: Preview containing abbreviated property values. Specified for ``object`` type values only.</span>
    <span class="s1">preview: typing.Optional[ObjectPreview] = </span><span class="s2">None</span>

    <span class="s1">custom_preview: typing.Optional[CustomPreview] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s2">if </span><span class="s1">self.subtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'subtype'</span><span class="s1">] = self.subtype</span>
        <span class="s2">if </span><span class="s1">self.class_name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'className'</span><span class="s1">] = self.class_name</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s2">if </span><span class="s1">self.unserializable_value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'unserializableValue'</span><span class="s1">] = self.unserializable_value.to_json()</span>
        <span class="s2">if </span><span class="s1">self.description </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'description'</span><span class="s1">] = self.description</span>
        <span class="s2">if </span><span class="s1">self.object_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'objectId'</span><span class="s1">] = self.object_id.to_json()</span>
        <span class="s2">if </span><span class="s1">self.preview </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'preview'</span><span class="s1">] = self.preview.to_json()</span>
        <span class="s2">if </span><span class="s1">self.custom_preview </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'customPreview'</span><span class="s1">] = self.custom_preview.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">subtype=str(json[</span><span class="s4">'subtype'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'subtype' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">class_name=str(json[</span><span class="s4">'className'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'className' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">value=json[</span><span class="s4">'value'</span><span class="s1">] </span><span class="s2">if </span><span class="s4">'value' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">unserializable_value=UnserializableValue.from_json(json[</span><span class="s4">'unserializableValue'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'unserializableValue' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">description=str(json[</span><span class="s4">'description'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'description' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">object_id=RemoteObjectId.from_json(json[</span><span class="s4">'objectId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'objectId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">preview=ObjectPreview.from_json(json[</span><span class="s4">'preview'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'preview' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">custom_preview=CustomPreview.from_json(json[</span><span class="s4">'customPreview'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'customPreview' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CustomPreview:</span>
    <span class="s0">#: The JSON-stringified result of formatter.header(object, config) call.</span>
    <span class="s0">#: It contains json ML array that represents RemoteObject.</span>
    <span class="s1">header: str</span>

    <span class="s0">#: If formatter returns true as a result of formatter.hasBody call then bodyGetterId will</span>
    <span class="s0">#: contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.</span>
    <span class="s0">#: The result value is json ML array.</span>
    <span class="s1">body_getter_id: typing.Optional[RemoteObjectId] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'header'</span><span class="s1">] = self.header</span>
        <span class="s2">if </span><span class="s1">self.body_getter_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'bodyGetterId'</span><span class="s1">] = self.body_getter_id.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">header=str(json[</span><span class="s4">'header'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">body_getter_id=RemoteObjectId.from_json(json[</span><span class="s4">'bodyGetterId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'bodyGetterId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ObjectPreview:</span>
    <span class="s3">''' 
    Object containing abbreviated remote object value. 
    '''</span>
    <span class="s0">#: Object type.</span>
    <span class="s1">type_: str</span>

    <span class="s0">#: True iff some of the properties or entries of the original object did not fit.</span>
    <span class="s1">overflow: bool</span>

    <span class="s0">#: List of the properties.</span>
    <span class="s1">properties: typing.List[PropertyPreview]</span>

    <span class="s0">#: Object subtype hint. Specified for ``object`` type values only.</span>
    <span class="s1">subtype: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: String representation of the object.</span>
    <span class="s1">description: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: List of the entries. Specified for ``map`` and ``set`` subtype values only.</span>
    <span class="s1">entries: typing.Optional[typing.List[EntryPreview]] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s1">json[</span><span class="s4">'overflow'</span><span class="s1">] = self.overflow</span>
        <span class="s1">json[</span><span class="s4">'properties'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.properties]</span>
        <span class="s2">if </span><span class="s1">self.subtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'subtype'</span><span class="s1">] = self.subtype</span>
        <span class="s2">if </span><span class="s1">self.description </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'description'</span><span class="s1">] = self.description</span>
        <span class="s2">if </span><span class="s1">self.entries </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'entries'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.entries]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">overflow=bool(json[</span><span class="s4">'overflow'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">properties=[PropertyPreview.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'properties'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">subtype=str(json[</span><span class="s4">'subtype'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'subtype' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">description=str(json[</span><span class="s4">'description'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'description' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">entries=[EntryPreview.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'entries'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'entries' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PropertyPreview:</span>
    <span class="s0">#: Property name.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: Object type. Accessor means that the property itself is an accessor property.</span>
    <span class="s1">type_: str</span>

    <span class="s0">#: User-friendly property value string.</span>
    <span class="s1">value: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Nested value preview.</span>
    <span class="s1">value_preview: typing.Optional[ObjectPreview] = </span><span class="s2">None</span>

    <span class="s0">#: Object subtype hint. Specified for ``object`` type values only.</span>
    <span class="s1">subtype: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s2">if </span><span class="s1">self.value_preview </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'valuePreview'</span><span class="s1">] = self.value_preview.to_json()</span>
        <span class="s2">if </span><span class="s1">self.subtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'subtype'</span><span class="s1">] = self.subtype</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=str(json[</span><span class="s4">'value'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'value' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">value_preview=ObjectPreview.from_json(json[</span><span class="s4">'valuePreview'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'valuePreview' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">subtype=str(json[</span><span class="s4">'subtype'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'subtype' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">EntryPreview:</span>
    <span class="s0">#: Preview of the value.</span>
    <span class="s1">value: ObjectPreview</span>

    <span class="s0">#: Preview of the key. Specified for map-like collection entries.</span>
    <span class="s1">key: typing.Optional[ObjectPreview] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value.to_json()</span>
        <span class="s2">if </span><span class="s1">self.key </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'key'</span><span class="s1">] = self.key.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">value=ObjectPreview.from_json(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">key=ObjectPreview.from_json(json[</span><span class="s4">'key'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'key' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PropertyDescriptor:</span>
    <span class="s3">''' 
    Object property descriptor. 
    '''</span>
    <span class="s0">#: Property name or symbol description.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: True if the type of this property descriptor may be changed and if the property may be</span>
    <span class="s0">#: deleted from the corresponding object.</span>
    <span class="s1">configurable: bool</span>

    <span class="s0">#: True if this property shows up during enumeration of the properties on the corresponding</span>
    <span class="s0">#: object.</span>
    <span class="s1">enumerable: bool</span>

    <span class="s0">#: The value associated with the property.</span>
    <span class="s1">value: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s0">#: True if the value associated with the property may be changed (data descriptors only).</span>
    <span class="s1">writable: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: A function which serves as a getter for the property, or ``undefined`` if there is no getter</span>
    <span class="s0">#: (accessor descriptors only).</span>
    <span class="s1">get: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s0">#: A function which serves as a setter for the property, or ``undefined`` if there is no setter</span>
    <span class="s0">#: (accessor descriptors only).</span>
    <span class="s1">set_: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s0">#: True if the result was thrown during the evaluation.</span>
    <span class="s1">was_thrown: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: True if the property is owned for the object.</span>
    <span class="s1">is_own: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Property symbol object, if the property is of the ``symbol`` type.</span>
    <span class="s1">symbol: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'configurable'</span><span class="s1">] = self.configurable</span>
        <span class="s1">json[</span><span class="s4">'enumerable'</span><span class="s1">] = self.enumerable</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value.to_json()</span>
        <span class="s2">if </span><span class="s1">self.writable </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'writable'</span><span class="s1">] = self.writable</span>
        <span class="s2">if </span><span class="s1">self.get </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'get'</span><span class="s1">] = self.get.to_json()</span>
        <span class="s2">if </span><span class="s1">self.set_ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'set'</span><span class="s1">] = self.set_.to_json()</span>
        <span class="s2">if </span><span class="s1">self.was_thrown </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'wasThrown'</span><span class="s1">] = self.was_thrown</span>
        <span class="s2">if </span><span class="s1">self.is_own </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'isOwn'</span><span class="s1">] = self.is_own</span>
        <span class="s2">if </span><span class="s1">self.symbol </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'symbol'</span><span class="s1">] = self.symbol.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">configurable=bool(json[</span><span class="s4">'configurable'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">enumerable=bool(json[</span><span class="s4">'enumerable'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=RemoteObject.from_json(json[</span><span class="s4">'value'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'value' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">writable=bool(json[</span><span class="s4">'writable'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'writable' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">get=RemoteObject.from_json(json[</span><span class="s4">'get'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'get' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">set_=RemoteObject.from_json(json[</span><span class="s4">'set'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'set' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">was_thrown=bool(json[</span><span class="s4">'wasThrown'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'wasThrown' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">is_own=bool(json[</span><span class="s4">'isOwn'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'isOwn' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">symbol=RemoteObject.from_json(json[</span><span class="s4">'symbol'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'symbol' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">InternalPropertyDescriptor:</span>
    <span class="s3">''' 
    Object internal property descriptor. This property isn't normally visible in JavaScript code. 
    '''</span>
    <span class="s0">#: Conventional property name.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: The value associated with the property.</span>
    <span class="s1">value: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=RemoteObject.from_json(json[</span><span class="s4">'value'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'value' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PrivatePropertyDescriptor:</span>
    <span class="s3">''' 
    Object private field descriptor. 
    '''</span>
    <span class="s0">#: Private property name.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: The value associated with the private property.</span>
    <span class="s1">value: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s0">#: A function which serves as a getter for the private property,</span>
    <span class="s0">#: or ``undefined`` if there is no getter (accessor descriptors only).</span>
    <span class="s1">get: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s0">#: A function which serves as a setter for the private property,</span>
    <span class="s0">#: or ``undefined`` if there is no setter (accessor descriptors only).</span>
    <span class="s1">set_: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value.to_json()</span>
        <span class="s2">if </span><span class="s1">self.get </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'get'</span><span class="s1">] = self.get.to_json()</span>
        <span class="s2">if </span><span class="s1">self.set_ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'set'</span><span class="s1">] = self.set_.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=RemoteObject.from_json(json[</span><span class="s4">'value'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'value' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">get=RemoteObject.from_json(json[</span><span class="s4">'get'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'get' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">set_=RemoteObject.from_json(json[</span><span class="s4">'set'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'set' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CallArgument:</span>
    <span class="s3">''' 
    Represents function call argument. Either remote object id ``objectId``, primitive ``value``, 
    unserializable primitive value or neither of (for undefined) them should be specified. 
    '''</span>
    <span class="s0">#: Primitive value or serializable javascript object.</span>
    <span class="s1">value: typing.Optional[typing.Any] = </span><span class="s2">None</span>

    <span class="s0">#: Primitive value which can not be JSON-stringified.</span>
    <span class="s1">unserializable_value: typing.Optional[UnserializableValue] = </span><span class="s2">None</span>

    <span class="s0">#: Remote object handle.</span>
    <span class="s1">object_id: typing.Optional[RemoteObjectId] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s2">if </span><span class="s1">self.unserializable_value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'unserializableValue'</span><span class="s1">] = self.unserializable_value.to_json()</span>
        <span class="s2">if </span><span class="s1">self.object_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'objectId'</span><span class="s1">] = self.object_id.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">value=json[</span><span class="s4">'value'</span><span class="s1">] </span><span class="s2">if </span><span class="s4">'value' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">unserializable_value=UnserializableValue.from_json(json[</span><span class="s4">'unserializableValue'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'unserializableValue' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">object_id=RemoteObjectId.from_json(json[</span><span class="s4">'objectId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'objectId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">ExecutionContextId(int):</span>
    <span class="s3">''' 
    Id of an execution context. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: int) -&gt; ExecutionContextId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'ExecutionContextId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ExecutionContextDescription:</span>
    <span class="s3">''' 
    Description of an isolated world. 
    '''</span>
    <span class="s0">#: Unique id of the execution context. It can be used to specify in which execution context</span>
    <span class="s0">#: script evaluation should be performed.</span>
    <span class="s1">id_: ExecutionContextId</span>

    <span class="s0">#: Execution context origin.</span>
    <span class="s1">origin: str</span>

    <span class="s0">#: Human readable name describing given context.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: A system-unique execution context identifier. Unlike the id, this is unique accross</span>
    <span class="s0">#: multiple processes, so can be reliably used to identify specific context while backend</span>
    <span class="s0">#: performs a cross-process navigation.</span>
    <span class="s1">unique_id: str</span>

    <span class="s0">#: Embedder-specific auxiliary data.</span>
    <span class="s1">aux_data: typing.Optional[dict] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'id'</span><span class="s1">] = self.id_.to_json()</span>
        <span class="s1">json[</span><span class="s4">'origin'</span><span class="s1">] = self.origin</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'uniqueId'</span><span class="s1">] = self.unique_id</span>
        <span class="s2">if </span><span class="s1">self.aux_data </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'auxData'</span><span class="s1">] = self.aux_data</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">id_=ExecutionContextId.from_json(json[</span><span class="s4">'id'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">origin=str(json[</span><span class="s4">'origin'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">unique_id=str(json[</span><span class="s4">'uniqueId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">aux_data=dict(json[</span><span class="s4">'auxData'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'auxData' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ExceptionDetails:</span>
    <span class="s3">''' 
    Detailed information about exception (or error) that was thrown during script compilation or 
    execution. 
    '''</span>
    <span class="s0">#: Exception id.</span>
    <span class="s1">exception_id: int</span>

    <span class="s0">#: Exception text, which should be used together with exception object when available.</span>
    <span class="s1">text: str</span>

    <span class="s0">#: Line number of the exception location (0-based).</span>
    <span class="s1">line_number: int</span>

    <span class="s0">#: Column number of the exception location (0-based).</span>
    <span class="s1">column_number: int</span>

    <span class="s0">#: Script ID of the exception location.</span>
    <span class="s1">script_id: typing.Optional[ScriptId] = </span><span class="s2">None</span>

    <span class="s0">#: URL of the exception location, to be used when the script was not reported.</span>
    <span class="s1">url: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: JavaScript stack trace if available.</span>
    <span class="s1">stack_trace: typing.Optional[StackTrace] = </span><span class="s2">None</span>

    <span class="s0">#: Exception object if available.</span>
    <span class="s1">exception: typing.Optional[RemoteObject] = </span><span class="s2">None</span>

    <span class="s0">#: Identifier of the context where exception happened.</span>
    <span class="s1">execution_context_id: typing.Optional[ExecutionContextId] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'exceptionId'</span><span class="s1">] = self.exception_id</span>
        <span class="s1">json[</span><span class="s4">'text'</span><span class="s1">] = self.text</span>
        <span class="s1">json[</span><span class="s4">'lineNumber'</span><span class="s1">] = self.line_number</span>
        <span class="s1">json[</span><span class="s4">'columnNumber'</span><span class="s1">] = self.column_number</span>
        <span class="s2">if </span><span class="s1">self.script_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'scriptId'</span><span class="s1">] = self.script_id.to_json()</span>
        <span class="s2">if </span><span class="s1">self.url </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s2">if </span><span class="s1">self.stack_trace </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'stackTrace'</span><span class="s1">] = self.stack_trace.to_json()</span>
        <span class="s2">if </span><span class="s1">self.exception </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'exception'</span><span class="s1">] = self.exception.to_json()</span>
        <span class="s2">if </span><span class="s1">self.execution_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'executionContextId'</span><span class="s1">] = self.execution_context_id.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">exception_id=int(json[</span><span class="s4">'exceptionId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">text=str(json[</span><span class="s4">'text'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">line_number=int(json[</span><span class="s4">'lineNumber'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">column_number=int(json[</span><span class="s4">'columnNumber'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">script_id=ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'scriptId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'url' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">stack_trace=StackTrace.from_json(json[</span><span class="s4">'stackTrace'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'stackTrace' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">exception=RemoteObject.from_json(json[</span><span class="s4">'exception'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exception' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">execution_context_id=ExecutionContextId.from_json(json[</span><span class="s4">'executionContextId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'executionContextId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Timestamp(float):</span>
    <span class="s3">''' 
    Number of milliseconds since epoch. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; float:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: float) -&gt; Timestamp:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'Timestamp({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">TimeDelta(float):</span>
    <span class="s3">''' 
    Number of milliseconds. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; float:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: float) -&gt; TimeDelta:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'TimeDelta({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CallFrame:</span>
    <span class="s3">''' 
    Stack entry for runtime errors and assertions. 
    '''</span>
    <span class="s0">#: JavaScript function name.</span>
    <span class="s1">function_name: str</span>

    <span class="s0">#: JavaScript script id.</span>
    <span class="s1">script_id: ScriptId</span>

    <span class="s0">#: JavaScript script name or url.</span>
    <span class="s1">url: str</span>

    <span class="s0">#: JavaScript script line number (0-based).</span>
    <span class="s1">line_number: int</span>

    <span class="s0">#: JavaScript script column number (0-based).</span>
    <span class="s1">column_number: int</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'functionName'</span><span class="s1">] = self.function_name</span>
        <span class="s1">json[</span><span class="s4">'scriptId'</span><span class="s1">] = self.script_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s1">json[</span><span class="s4">'lineNumber'</span><span class="s1">] = self.line_number</span>
        <span class="s1">json[</span><span class="s4">'columnNumber'</span><span class="s1">] = self.column_number</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">function_name=str(json[</span><span class="s4">'functionName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">script_id=ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">line_number=int(json[</span><span class="s4">'lineNumber'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">column_number=int(json[</span><span class="s4">'columnNumber'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">StackTrace:</span>
    <span class="s3">''' 
    Call frames for assertions or error messages. 
    '''</span>
    <span class="s0">#: JavaScript function name.</span>
    <span class="s1">call_frames: typing.List[CallFrame]</span>

    <span class="s0">#: String label of this stack trace. For async traces this may be a name of the function that</span>
    <span class="s0">#: initiated the async call.</span>
    <span class="s1">description: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Asynchronous JavaScript stack trace that preceded this stack, if available.</span>
    <span class="s1">parent: typing.Optional[StackTrace] = </span><span class="s2">None</span>

    <span class="s0">#: Asynchronous JavaScript stack trace that preceded this stack, if available.</span>
    <span class="s1">parent_id: typing.Optional[StackTraceId] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'callFrames'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.call_frames]</span>
        <span class="s2">if </span><span class="s1">self.description </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'description'</span><span class="s1">] = self.description</span>
        <span class="s2">if </span><span class="s1">self.parent </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'parent'</span><span class="s1">] = self.parent.to_json()</span>
        <span class="s2">if </span><span class="s1">self.parent_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'parentId'</span><span class="s1">] = self.parent_id.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">call_frames=[CallFrame.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'callFrames'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">description=str(json[</span><span class="s4">'description'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'description' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">parent=StackTrace.from_json(json[</span><span class="s4">'parent'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'parent' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">parent_id=StackTraceId.from_json(json[</span><span class="s4">'parentId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'parentId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">UniqueDebuggerId(str):</span>
    <span class="s3">''' 
    Unique identifier of current debugger. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; UniqueDebuggerId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'UniqueDebuggerId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">StackTraceId:</span>
    <span class="s3">''' 
    If ``debuggerId`` is set stack trace comes from another debugger and can be resolved there. This 
    allows to track cross-debugger calls. See ``Runtime.StackTrace`` and ``Debugger.paused`` for usages. 
    '''</span>
    <span class="s1">id_: str</span>

    <span class="s1">debugger_id: typing.Optional[UniqueDebuggerId] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'id'</span><span class="s1">] = self.id_</span>
        <span class="s2">if </span><span class="s1">self.debugger_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'debuggerId'</span><span class="s1">] = self.debugger_id.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">id_=str(json[</span><span class="s4">'id'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">debugger_id=UniqueDebuggerId.from_json(json[</span><span class="s4">'debuggerId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'debuggerId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">await_promise(</span>
        <span class="s1">promise_object_id: RemoteObjectId</span><span class="s2">,</span>
        <span class="s1">return_by_value: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">generate_preview: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[RemoteObject</span><span class="s2">, </span><span class="s1">typing.Optional[ExceptionDetails]]]:</span>
    <span class="s3">''' 
    Add handler to promise with given promise object id. 
 
    :param promise_object_id: Identifier of the promise. 
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value. 
    :param generate_preview: *(Optional)* Whether preview should be generated for the result. 
    :returns: A tuple with the following items: 
 
        0. **result** - Promise result. Will contain rejected value if promise was rejected. 
        1. **exceptionDetails** - *(Optional)* Exception details if stack strace is available. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'promiseObjectId'</span><span class="s1">] = promise_object_id.to_json()</span>
    <span class="s2">if </span><span class="s1">return_by_value </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'returnByValue'</span><span class="s1">] = return_by_value</span>
    <span class="s2">if </span><span class="s1">generate_preview </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'generatePreview'</span><span class="s1">] = generate_preview</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.awaitPromise'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">RemoteObject.from_json(json[</span><span class="s4">'result'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exceptionDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">call_function_on(</span>
        <span class="s1">function_declaration: str</span><span class="s2">,</span>
        <span class="s1">object_id: typing.Optional[RemoteObjectId] = </span><span class="s2">None,</span>
        <span class="s1">arguments: typing.Optional[typing.List[CallArgument]] = </span><span class="s2">None,</span>
        <span class="s1">silent: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">return_by_value: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">generate_preview: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">user_gesture: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">await_promise: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">execution_context_id: typing.Optional[ExecutionContextId] = </span><span class="s2">None,</span>
        <span class="s1">object_group: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[RemoteObject</span><span class="s2">, </span><span class="s1">typing.Optional[ExceptionDetails]]]:</span>
    <span class="s3">''' 
    Calls function with given declaration on the given object. Object group of the result is 
    inherited from the target object. 
 
    :param function_declaration: Declaration of the function to call. 
    :param object_id: *(Optional)* Identifier of the object to call function on. Either objectId or executionContextId should be specified. 
    :param arguments: *(Optional)* Call arguments. All call arguments must belong to the same JavaScript world as the target object. 
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state. 
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. 
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result. 
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI. 
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved. 
    :param execution_context_id: *(Optional)* Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified. 
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object. 
    :returns: A tuple with the following items: 
 
        0. **result** - Call result. 
        1. **exceptionDetails** - *(Optional)* Exception details. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'functionDeclaration'</span><span class="s1">] = function_declaration</span>
    <span class="s2">if </span><span class="s1">object_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s2">if </span><span class="s1">arguments </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'arguments'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">arguments]</span>
    <span class="s2">if </span><span class="s1">silent </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'silent'</span><span class="s1">] = silent</span>
    <span class="s2">if </span><span class="s1">return_by_value </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'returnByValue'</span><span class="s1">] = return_by_value</span>
    <span class="s2">if </span><span class="s1">generate_preview </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'generatePreview'</span><span class="s1">] = generate_preview</span>
    <span class="s2">if </span><span class="s1">user_gesture </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'userGesture'</span><span class="s1">] = user_gesture</span>
    <span class="s2">if </span><span class="s1">await_promise </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'awaitPromise'</span><span class="s1">] = await_promise</span>
    <span class="s2">if </span><span class="s1">execution_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'executionContextId'</span><span class="s1">] = execution_context_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_group </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectGroup'</span><span class="s1">] = object_group</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.callFunctionOn'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">RemoteObject.from_json(json[</span><span class="s4">'result'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exceptionDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">compile_script(</span>
        <span class="s1">expression: str</span><span class="s2">,</span>
        <span class="s1">source_url: str</span><span class="s2">,</span>
        <span class="s1">persist_script: bool</span><span class="s2">,</span>
        <span class="s1">execution_context_id: typing.Optional[ExecutionContextId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[typing.Optional[ScriptId]</span><span class="s2">, </span><span class="s1">typing.Optional[ExceptionDetails]]]:</span>
    <span class="s3">''' 
    Compiles expression. 
 
    :param expression: Expression to compile. 
    :param source_url: Source url to be set for the script. 
    :param persist_script: Specifies whether the compiled script should be persisted. 
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page. 
    :returns: A tuple with the following items: 
 
        0. **scriptId** - *(Optional)* Id of the script. 
        1. **exceptionDetails** - *(Optional)* Exception details. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'expression'</span><span class="s1">] = expression</span>
    <span class="s1">params[</span><span class="s4">'sourceURL'</span><span class="s1">] = source_url</span>
    <span class="s1">params[</span><span class="s4">'persistScript'</span><span class="s1">] = persist_script</span>
    <span class="s2">if </span><span class="s1">execution_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'executionContextId'</span><span class="s1">] = execution_context_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.compileScript'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'scriptId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exceptionDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">disable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disables reporting of execution contexts creation. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.disable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">discard_console_entries() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Discards collected exceptions and console API calls. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.discardConsoleEntries'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">enable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables reporting of execution contexts creation by means of ``executionContextCreated`` event. 
    When the reporting gets enabled the event will be sent immediately for each existing execution 
    context. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.enable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">evaluate(</span>
        <span class="s1">expression: str</span><span class="s2">,</span>
        <span class="s1">object_group: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">include_command_line_api: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">silent: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">context_id: typing.Optional[ExecutionContextId] = </span><span class="s2">None,</span>
        <span class="s1">return_by_value: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">generate_preview: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">user_gesture: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">await_promise: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">throw_on_side_effect: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">timeout: typing.Optional[TimeDelta] = </span><span class="s2">None,</span>
        <span class="s1">disable_breaks: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">repl_mode: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">allow_unsafe_eval_blocked_by_csp: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">unique_context_id: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[RemoteObject</span><span class="s2">, </span><span class="s1">typing.Optional[ExceptionDetails]]]:</span>
    <span class="s3">''' 
    Evaluates expression on global object. 
 
    :param expression: Expression to evaluate. 
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. 
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation. 
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state. 
    :param context_id: *(Optional)* Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page. This is mutually exclusive with ````uniqueContextId````, which offers an alternative way to identify the execution context that is more reliable in a multi-process environment. 
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value. 
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result. 
    :param user_gesture: *(Optional)* Whether execution should be treated as initiated by user in the UI. 
    :param await_promise: *(Optional)* Whether execution should ````await```` for resulting value and return once awaited promise is resolved. 
    :param throw_on_side_effect: **(EXPERIMENTAL)** *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. This implies ````disableBreaks```` below. 
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds). 
    :param disable_breaks: **(EXPERIMENTAL)** *(Optional)* Disable breakpoints during execution. 
    :param repl_mode: **(EXPERIMENTAL)** *(Optional)* Setting this flag to true enables ````let```` re-declaration and top-level ````await````. Note that ````let```` variables can only be re-declared if they originate from ````replMode```` themselves. 
    :param allow_unsafe_eval_blocked_by_csp: **(EXPERIMENTAL)** *(Optional)* The Content Security Policy (CSP) for the target might block 'unsafe-eval' which includes eval(), Function(), setTimeout() and setInterval() when called with non-callable arguments. This flag bypasses CSP for this evaluation and allows unsafe-eval. Defaults to true. 
    :param unique_context_id: **(EXPERIMENTAL)** *(Optional)* An alternative way to specify the execution context to evaluate in. Compared to contextId that may be reused accross processes, this is guaranteed to be system-unique, so it can be used to prevent accidental evaluation of the expression in context different than intended (e.g. as a result of navigation accross process boundaries). This is mutually exclusive with ````contextId```. 
    :returns: A tuple with the following items: 
 
        0. **result** - Evaluation result. 
        1. **exceptionDetails** - *(Optional)* Exception details. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'expression'</span><span class="s1">] = expression</span>
    <span class="s2">if </span><span class="s1">object_group </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectGroup'</span><span class="s1">] = object_group</span>
    <span class="s2">if </span><span class="s1">include_command_line_api </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'includeCommandLineAPI'</span><span class="s1">] = include_command_line_api</span>
    <span class="s2">if </span><span class="s1">silent </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'silent'</span><span class="s1">] = silent</span>
    <span class="s2">if </span><span class="s1">context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'contextId'</span><span class="s1">] = context_id.to_json()</span>
    <span class="s2">if </span><span class="s1">return_by_value </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'returnByValue'</span><span class="s1">] = return_by_value</span>
    <span class="s2">if </span><span class="s1">generate_preview </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'generatePreview'</span><span class="s1">] = generate_preview</span>
    <span class="s2">if </span><span class="s1">user_gesture </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'userGesture'</span><span class="s1">] = user_gesture</span>
    <span class="s2">if </span><span class="s1">await_promise </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'awaitPromise'</span><span class="s1">] = await_promise</span>
    <span class="s2">if </span><span class="s1">throw_on_side_effect </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'throwOnSideEffect'</span><span class="s1">] = throw_on_side_effect</span>
    <span class="s2">if </span><span class="s1">timeout </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'timeout'</span><span class="s1">] = timeout.to_json()</span>
    <span class="s2">if </span><span class="s1">disable_breaks </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'disableBreaks'</span><span class="s1">] = disable_breaks</span>
    <span class="s2">if </span><span class="s1">repl_mode </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'replMode'</span><span class="s1">] = repl_mode</span>
    <span class="s2">if </span><span class="s1">allow_unsafe_eval_blocked_by_csp </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'allowUnsafeEvalBlockedByCSP'</span><span class="s1">] = allow_unsafe_eval_blocked_by_csp</span>
    <span class="s2">if </span><span class="s1">unique_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'uniqueContextId'</span><span class="s1">] = unique_context_id</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.evaluate'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">RemoteObject.from_json(json[</span><span class="s4">'result'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exceptionDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_isolate_id() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">str]:</span>
    <span class="s3">''' 
    Returns the isolate id. 
 
    **EXPERIMENTAL** 
 
    :returns: The isolate id. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.getIsolateId'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">str(json[</span><span class="s4">'id'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_heap_usage() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[float</span><span class="s2">, </span><span class="s1">float]]:</span>
    <span class="s3">''' 
    Returns the JavaScript heap usage. 
    It is the total usage of the corresponding isolate not scoped to a particular Runtime. 
 
    **EXPERIMENTAL** 
 
    :returns: A tuple with the following items: 
 
        0. **usedSize** - Used heap size in bytes. 
        1. **totalSize** - Allocated heap size in bytes. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.getHeapUsage'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">float(json[</span><span class="s4">'usedSize'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">float(json[</span><span class="s4">'totalSize'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_properties(</span>
        <span class="s1">object_id: RemoteObjectId</span><span class="s2">,</span>
        <span class="s1">own_properties: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">accessor_properties_only: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">generate_preview: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[typing.List[PropertyDescriptor]</span><span class="s2">, </span><span class="s1">typing.Optional[typing.List[InternalPropertyDescriptor]]</span><span class="s2">, </span><span class="s1">typing.Optional[typing.List[PrivatePropertyDescriptor]]</span><span class="s2">, </span><span class="s1">typing.Optional[ExceptionDetails]]]:</span>
    <span class="s3">''' 
    Returns properties of a given object. Object group of the result is inherited from the target 
    object. 
 
    :param object_id: Identifier of the object to return properties for. 
    :param own_properties: *(Optional)* If true, returns properties belonging only to the element itself, not to its prototype chain. 
    :param accessor_properties_only: **(EXPERIMENTAL)** *(Optional)* If true, returns accessor properties (with getter/setter) only; internal properties are not returned either. 
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the results. 
    :returns: A tuple with the following items: 
 
        0. **result** - Object properties. 
        1. **internalProperties** - *(Optional)* Internal object properties (only of the element itself). 
        2. **privateProperties** - *(Optional)* Object private properties. 
        3. **exceptionDetails** - *(Optional)* Exception details. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s2">if </span><span class="s1">own_properties </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'ownProperties'</span><span class="s1">] = own_properties</span>
    <span class="s2">if </span><span class="s1">accessor_properties_only </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'accessorPropertiesOnly'</span><span class="s1">] = accessor_properties_only</span>
    <span class="s2">if </span><span class="s1">generate_preview </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'generatePreview'</span><span class="s1">] = generate_preview</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.getProperties'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">[PropertyDescriptor.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[InternalPropertyDescriptor.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'internalProperties'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'internalProperties' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">[PrivatePropertyDescriptor.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'privateProperties'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'privateProperties' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exceptionDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">global_lexical_scope_names(</span>
        <span class="s1">execution_context_id: typing.Optional[ExecutionContextId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[str]]:</span>
    <span class="s3">''' 
    Returns all let, const and class variables from global scope. 
 
    :param execution_context_id: *(Optional)* Specifies in which execution context to lookup global scope variables. 
    :returns:  
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">execution_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'executionContextId'</span><span class="s1">] = execution_context_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.globalLexicalScopeNames'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'names'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">query_objects(</span>
        <span class="s1">prototype_object_id: RemoteObjectId</span><span class="s2">,</span>
        <span class="s1">object_group: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">RemoteObject]:</span>
    <span class="s3">''' 
    :param prototype_object_id: Identifier of the prototype to return objects for. 
    :param object_group: *(Optional)* Symbolic group name that can be used to release the results. 
    :returns: Array with objects. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'prototypeObjectId'</span><span class="s1">] = prototype_object_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_group </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectGroup'</span><span class="s1">] = object_group</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.queryObjects'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">RemoteObject.from_json(json[</span><span class="s4">'objects'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">release_object(</span>
        <span class="s1">object_id: RemoteObjectId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Releases remote object with given id. 
 
    :param object_id: Identifier of the object to release. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.releaseObject'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">release_object_group(</span>
        <span class="s1">object_group: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Releases all remote objects that belong to a given group. 
 
    :param object_group: Symbolic object group name. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'objectGroup'</span><span class="s1">] = object_group</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.releaseObjectGroup'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">run_if_waiting_for_debugger() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Tells inspected instance to run if it was waiting for debugger to attach. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.runIfWaitingForDebugger'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">run_script(</span>
        <span class="s1">script_id: ScriptId</span><span class="s2">,</span>
        <span class="s1">execution_context_id: typing.Optional[ExecutionContextId] = </span><span class="s2">None,</span>
        <span class="s1">object_group: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">silent: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">include_command_line_api: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">return_by_value: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">generate_preview: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">await_promise: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[RemoteObject</span><span class="s2">, </span><span class="s1">typing.Optional[ExceptionDetails]]]:</span>
    <span class="s3">''' 
    Runs script with given id in a given context. 
 
    :param script_id: Id of the script to run. 
    :param execution_context_id: *(Optional)* Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page. 
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. 
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ```setPauseOnException```` state. 
    :param include_command_line_api: *(Optional)* Determines whether Command Line API should be available during the evaluation. 
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object which should be sent by value. 
    :param generate_preview: *(Optional)* Whether preview should be generated for the result. 
    :param await_promise: *(Optional)* Whether execution should ````await``` for resulting value and return once awaited promise is resolved. 
    :returns: A tuple with the following items: 
 
        0. **result** - Run result. 
        1. **exceptionDetails** - *(Optional)* Exception details. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'scriptId'</span><span class="s1">] = script_id.to_json()</span>
    <span class="s2">if </span><span class="s1">execution_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'executionContextId'</span><span class="s1">] = execution_context_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_group </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectGroup'</span><span class="s1">] = object_group</span>
    <span class="s2">if </span><span class="s1">silent </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'silent'</span><span class="s1">] = silent</span>
    <span class="s2">if </span><span class="s1">include_command_line_api </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'includeCommandLineAPI'</span><span class="s1">] = include_command_line_api</span>
    <span class="s2">if </span><span class="s1">return_by_value </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'returnByValue'</span><span class="s1">] = return_by_value</span>
    <span class="s2">if </span><span class="s1">generate_preview </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'generatePreview'</span><span class="s1">] = generate_preview</span>
    <span class="s2">if </span><span class="s1">await_promise </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'awaitPromise'</span><span class="s1">] = await_promise</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.runScript'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">RemoteObject.from_json(json[</span><span class="s4">'result'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exceptionDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">set_async_call_stack_depth(</span>
        <span class="s1">max_depth: int</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables or disables async call stacks tracking. 
 
    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default). 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'maxDepth'</span><span class="s1">] = max_depth</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.setAsyncCallStackDepth'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_custom_object_formatter_enabled(</span>
        <span class="s1">enabled: bool</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
 
 
    **EXPERIMENTAL** 
 
    :param enabled: 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'enabled'</span><span class="s1">] = enabled</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.setCustomObjectFormatterEnabled'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_max_call_stack_size_to_capture(</span>
        <span class="s1">size: int</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
 
 
    **EXPERIMENTAL** 
 
    :param size: 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'size'</span><span class="s1">] = size</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.setMaxCallStackSizeToCapture'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">terminate_execution() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Terminate current or next JavaScript execution. 
    Will cancel the termination when the outer-most script execution ends. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.terminateExecution'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">add_binding(</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">execution_context_id: typing.Optional[ExecutionContextId] = </span><span class="s2">None,</span>
        <span class="s1">execution_context_name: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    If executionContextId is empty, adds binding with the given name on the 
    global objects of all inspected contexts, including those created later, 
    bindings survive reloads. 
    Binding function takes exactly one argument, this argument should be string, 
    in case of any other input, function throws an exception. 
    Each binding function call produces Runtime.bindingCalled notification. 
 
    **EXPERIMENTAL** 
 
    :param name: 
    :param execution_context_id: *(Optional)* If specified, the binding would only be exposed to the specified execution context. If omitted and ```executionContextName```` is not set, the binding is exposed to all execution contexts of the target. This parameter is mutually exclusive with ````executionContextName````. 
    :param execution_context_name: **(EXPERIMENTAL)** *(Optional)* If specified, the binding is exposed to the executionContext with matching name, even for contexts created after the binding is added. See also ````ExecutionContext.name```` and ````worldName```` parameter to ````Page.addScriptToEvaluateOnNewDocument````. This parameter is mutually exclusive with ````executionContextId```. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'name'</span><span class="s1">] = name</span>
    <span class="s2">if </span><span class="s1">execution_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'executionContextId'</span><span class="s1">] = execution_context_id.to_json()</span>
    <span class="s2">if </span><span class="s1">execution_context_name </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'executionContextName'</span><span class="s1">] = execution_context_name</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.addBinding'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">remove_binding(</span>
        <span class="s1">name: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    This method does not remove binding function from global object but 
    unsubscribes current runtime agent from Runtime.bindingCalled notifications. 
 
    **EXPERIMENTAL** 
 
    :param name: 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'name'</span><span class="s1">] = name</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Runtime.removeBinding'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s1">@event_class(</span><span class="s4">'Runtime.bindingCalled'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">BindingCalled:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Notification is issued every time when binding is called. 
    '''</span>
    <span class="s1">name: str</span>
    <span class="s1">payload: str</span>
    <span class="s0">#: Identifier of the context where the call was made.</span>
    <span class="s1">execution_context_id: ExecutionContextId</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; BindingCalled:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">payload=str(json[</span><span class="s4">'payload'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">execution_context_id=ExecutionContextId.from_json(json[</span><span class="s4">'executionContextId'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Runtime.consoleAPICalled'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ConsoleAPICalled:</span>
    <span class="s3">''' 
    Issued when console API was called. 
    '''</span>
    <span class="s0">#: Type of the call.</span>
    <span class="s1">type_: str</span>
    <span class="s0">#: Call arguments.</span>
    <span class="s1">args: typing.List[RemoteObject]</span>
    <span class="s0">#: Identifier of the context where the call was made.</span>
    <span class="s1">execution_context_id: ExecutionContextId</span>
    <span class="s0">#: Call timestamp.</span>
    <span class="s1">timestamp: Timestamp</span>
    <span class="s0">#: Stack trace captured when the call was made. The async stack chain is automatically reported for</span>
    <span class="s0">#: the following call types: ``assert``, ``error``, ``trace``, ``warning``. For other types the async call</span>
    <span class="s0">#: chain can be retrieved using ``Debugger.getStackTrace`` and ``stackTrace.parentId`` field.</span>
    <span class="s1">stack_trace: typing.Optional[StackTrace]</span>
    <span class="s0">#: Console context descriptor for calls on non-default console context (not console.*):</span>
    <span class="s0">#: 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call</span>
    <span class="s0">#: on named context.</span>
    <span class="s1">context: typing.Optional[str]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ConsoleAPICalled:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">args=[RemoteObject.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'args'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">execution_context_id=ExecutionContextId.from_json(json[</span><span class="s4">'executionContextId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=Timestamp.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">stack_trace=StackTrace.from_json(json[</span><span class="s4">'stackTrace'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'stackTrace' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">context=str(json[</span><span class="s4">'context'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'context' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Runtime.exceptionRevoked'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ExceptionRevoked:</span>
    <span class="s3">''' 
    Issued when unhandled exception was revoked. 
    '''</span>
    <span class="s0">#: Reason describing why exception was revoked.</span>
    <span class="s1">reason: str</span>
    <span class="s0">#: The id of revoked exception, as reported in ``exceptionThrown``.</span>
    <span class="s1">exception_id: int</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ExceptionRevoked:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">reason=str(json[</span><span class="s4">'reason'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">exception_id=int(json[</span><span class="s4">'exceptionId'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Runtime.exceptionThrown'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ExceptionThrown:</span>
    <span class="s3">''' 
    Issued when exception was thrown and unhandled. 
    '''</span>
    <span class="s0">#: Timestamp of the exception.</span>
    <span class="s1">timestamp: Timestamp</span>
    <span class="s1">exception_details: ExceptionDetails</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ExceptionThrown:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">timestamp=Timestamp.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">exception_details=ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Runtime.executionContextCreated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ExecutionContextCreated:</span>
    <span class="s3">''' 
    Issued when new execution context is created. 
    '''</span>
    <span class="s0">#: A newly created execution context.</span>
    <span class="s1">context: ExecutionContextDescription</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ExecutionContextCreated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">context=ExecutionContextDescription.from_json(json[</span><span class="s4">'context'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Runtime.executionContextDestroyed'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ExecutionContextDestroyed:</span>
    <span class="s3">''' 
    Issued when execution context is destroyed. 
    '''</span>
    <span class="s0">#: Id of the destroyed context</span>
    <span class="s1">execution_context_id: ExecutionContextId</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ExecutionContextDestroyed:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">execution_context_id=ExecutionContextId.from_json(json[</span><span class="s4">'executionContextId'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Runtime.executionContextsCleared'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ExecutionContextsCleared:</span>
    <span class="s3">''' 
    Issued when all executionContexts were cleared in browser 
    '''</span>


    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ExecutionContextsCleared:</span>
        <span class="s2">return </span><span class="s1">cls(</span>

        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Runtime.inspectRequested'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">InspectRequested:</span>
    <span class="s3">''' 
    Issued when object should be inspected (for example, as a result of inspect() command line API 
    call). 
    '''</span>
    <span class="s1">object_: RemoteObject</span>
    <span class="s1">hints: dict</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; InspectRequested:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">object_=RemoteObject.from_json(json[</span><span class="s4">'object'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">hints=dict(json[</span><span class="s4">'hints'</span><span class="s1">])</span>
        <span class="s1">)</span>
</pre>
</body>
</html>