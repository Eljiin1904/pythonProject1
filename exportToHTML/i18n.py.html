<html>
<head>
<title>i18n.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
i18n.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">decimal </span><span class="s0">import </span><span class="s1">Decimal</span>

<span class="s0">from </span><span class="s1">django.conf </span><span class="s0">import </span><span class="s1">settings</span>
<span class="s0">from </span><span class="s1">django.template </span><span class="s0">import </span><span class="s1">Library</span><span class="s0">, </span><span class="s1">Node</span><span class="s0">, </span><span class="s1">TemplateSyntaxError</span><span class="s0">, </span><span class="s1">Variable</span>
<span class="s0">from </span><span class="s1">django.template.base </span><span class="s0">import </span><span class="s1">TokenType</span><span class="s0">, </span><span class="s1">render_value_in_context</span>
<span class="s0">from </span><span class="s1">django.template.defaulttags </span><span class="s0">import </span><span class="s1">token_kwargs</span>
<span class="s0">from </span><span class="s1">django.utils </span><span class="s0">import </span><span class="s1">translation</span>
<span class="s0">from </span><span class="s1">django.utils.safestring </span><span class="s0">import </span><span class="s1">SafeData</span><span class="s0">, </span><span class="s1">mark_safe</span>

<span class="s1">register = Library()</span>


<span class="s0">class </span><span class="s1">GetAvailableLanguagesNode(Node):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">variable):</span>
        <span class="s1">self.variable = variable</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">context):</span>
        <span class="s1">context[self.variable] = [(k</span><span class="s0">, </span><span class="s1">translation.gettext(v)) </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">settings.LANGUAGES]</span>
        <span class="s0">return </span><span class="s2">''</span>


<span class="s0">class </span><span class="s1">GetLanguageInfoNode(Node):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">lang_code</span><span class="s0">, </span><span class="s1">variable):</span>
        <span class="s1">self.lang_code = lang_code</span>
        <span class="s1">self.variable = variable</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">context):</span>
        <span class="s1">lang_code = self.lang_code.resolve(context)</span>
        <span class="s1">context[self.variable] = translation.get_language_info(lang_code)</span>
        <span class="s0">return </span><span class="s2">''</span>


<span class="s0">class </span><span class="s1">GetLanguageInfoListNode(Node):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">languages</span><span class="s0">, </span><span class="s1">variable):</span>
        <span class="s1">self.languages = languages</span>
        <span class="s1">self.variable = variable</span>

    <span class="s0">def </span><span class="s1">get_language_info(self</span><span class="s0">, </span><span class="s1">language):</span>
        <span class="s3"># ``language`` is either a language code string or a sequence</span>
        <span class="s3"># with the language code as its first item</span>
        <span class="s0">if </span><span class="s1">len(language[</span><span class="s4">0</span><span class="s1">]) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">translation.get_language_info(language[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">translation.get_language_info(str(language))</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">context):</span>
        <span class="s1">langs = self.languages.resolve(context)</span>
        <span class="s1">context[self.variable] = [self.get_language_info(lang) </span><span class="s0">for </span><span class="s1">lang </span><span class="s0">in </span><span class="s1">langs]</span>
        <span class="s0">return </span><span class="s2">''</span>


<span class="s0">class </span><span class="s1">GetCurrentLanguageNode(Node):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">variable):</span>
        <span class="s1">self.variable = variable</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">context):</span>
        <span class="s1">context[self.variable] = translation.get_language()</span>
        <span class="s0">return </span><span class="s2">''</span>


<span class="s0">class </span><span class="s1">GetCurrentLanguageBidiNode(Node):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">variable):</span>
        <span class="s1">self.variable = variable</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">context):</span>
        <span class="s1">context[self.variable] = translation.get_language_bidi()</span>
        <span class="s0">return </span><span class="s2">''</span>


<span class="s0">class </span><span class="s1">TranslateNode(Node):</span>
    <span class="s1">child_nodelists = ()</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">filter_expression</span><span class="s0">, </span><span class="s1">noop</span><span class="s0">, </span><span class="s1">asvar=</span><span class="s0">None,</span>
                 <span class="s1">message_context=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.noop = noop</span>
        <span class="s1">self.asvar = asvar</span>
        <span class="s1">self.message_context = message_context</span>
        <span class="s1">self.filter_expression = filter_expression</span>
        <span class="s0">if </span><span class="s1">isinstance(self.filter_expression.var</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">self.filter_expression.var = Variable(</span><span class="s2">&quot;'%s'&quot; </span><span class="s1">%</span>
                                                  <span class="s1">self.filter_expression.var)</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">context):</span>
        <span class="s1">self.filter_expression.var.translate = </span><span class="s0">not </span><span class="s1">self.noop</span>
        <span class="s0">if </span><span class="s1">self.message_context:</span>
            <span class="s1">self.filter_expression.var.message_context = (</span>
                <span class="s1">self.message_context.resolve(context))</span>
        <span class="s1">output = self.filter_expression.resolve(context)</span>
        <span class="s1">value = render_value_in_context(output</span><span class="s0">, </span><span class="s1">context)</span>
        <span class="s3"># Restore percent signs. Percent signs in template text are doubled</span>
        <span class="s3"># so they are not interpreted as string format flags.</span>
        <span class="s1">is_safe = isinstance(value</span><span class="s0">, </span><span class="s1">SafeData)</span>
        <span class="s1">value = value.replace(</span><span class="s2">'%%'</span><span class="s0">, </span><span class="s2">'%'</span><span class="s1">)</span>
        <span class="s1">value = mark_safe(value) </span><span class="s0">if </span><span class="s1">is_safe </span><span class="s0">else </span><span class="s1">value</span>
        <span class="s0">if </span><span class="s1">self.asvar:</span>
            <span class="s1">context[self.asvar] = value</span>
            <span class="s0">return </span><span class="s2">''</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">value</span>


<span class="s0">class </span><span class="s1">BlockTranslateNode(Node):</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">extra_context</span><span class="s0">, </span><span class="s1">singular</span><span class="s0">, </span><span class="s1">plural=</span><span class="s0">None, </span><span class="s1">countervar=</span><span class="s0">None,</span>
                 <span class="s1">counter=</span><span class="s0">None, </span><span class="s1">message_context=</span><span class="s0">None, </span><span class="s1">trimmed=</span><span class="s0">False, </span><span class="s1">asvar=</span><span class="s0">None,</span>
                 <span class="s1">tag_name=</span><span class="s2">'blocktranslate'</span><span class="s1">):</span>
        <span class="s1">self.extra_context = extra_context</span>
        <span class="s1">self.singular = singular</span>
        <span class="s1">self.plural = plural</span>
        <span class="s1">self.countervar = countervar</span>
        <span class="s1">self.counter = counter</span>
        <span class="s1">self.message_context = message_context</span>
        <span class="s1">self.trimmed = trimmed</span>
        <span class="s1">self.asvar = asvar</span>
        <span class="s1">self.tag_name = tag_name</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s2">f'&lt;</span><span class="s0">{</span><span class="s1">self.__class__.__qualname__</span><span class="s0">}</span><span class="s2">: '</span>
            <span class="s2">f'extra_context=</span><span class="s0">{</span><span class="s1">self.extra_context</span><span class="s0">!r} </span><span class="s2">'</span>
            <span class="s2">f'singular=</span><span class="s0">{</span><span class="s1">self.singular</span><span class="s0">!r} </span><span class="s2">plural=</span><span class="s0">{</span><span class="s1">self.plural</span><span class="s0">!r}</span><span class="s2">&gt;'</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">render_token_list(self</span><span class="s0">, </span><span class="s1">tokens):</span>
        <span class="s1">result = []</span>
        <span class="s1">vars = []</span>
        <span class="s0">for </span><span class="s1">token </span><span class="s0">in </span><span class="s1">tokens:</span>
            <span class="s0">if </span><span class="s1">token.token_type == TokenType.TEXT:</span>
                <span class="s1">result.append(token.contents.replace(</span><span class="s2">'%'</span><span class="s0">, </span><span class="s2">'%%'</span><span class="s1">))</span>
            <span class="s0">elif </span><span class="s1">token.token_type == TokenType.VAR:</span>
                <span class="s1">result.append(</span><span class="s2">'%%(%s)s' </span><span class="s1">% token.contents)</span>
                <span class="s1">vars.append(token.contents)</span>
        <span class="s1">msg = </span><span class="s2">''</span><span class="s1">.join(result)</span>
        <span class="s0">if </span><span class="s1">self.trimmed:</span>
            <span class="s1">msg = translation.trim_whitespace(msg)</span>
        <span class="s0">return </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">vars</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">context</span><span class="s0">, </span><span class="s1">nested=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">self.message_context:</span>
            <span class="s1">message_context = self.message_context.resolve(context)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">message_context = </span><span class="s0">None</span>
        <span class="s3"># Update() works like a push(), so corresponding context.pop() is at</span>
        <span class="s3"># the end of function</span>
        <span class="s1">context.update({var: val.resolve(context) </span><span class="s0">for </span><span class="s1">var</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">self.extra_context.items()})</span>
        <span class="s1">singular</span><span class="s0">, </span><span class="s1">vars = self.render_token_list(self.singular)</span>
        <span class="s0">if </span><span class="s1">self.plural </span><span class="s0">and </span><span class="s1">self.countervar </span><span class="s0">and </span><span class="s1">self.counter:</span>
            <span class="s1">count = self.counter.resolve(context)</span>
            <span class="s0">if not </span><span class="s1">isinstance(count</span><span class="s0">, </span><span class="s1">(Decimal</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">int)):</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                    <span class="s2">&quot;%r argument to %r tag must be a number.&quot;</span>
                    <span class="s1">% (self.countervar</span><span class="s0">, </span><span class="s1">self.tag_name)</span>
                <span class="s1">)</span>
            <span class="s1">context[self.countervar] = count</span>
            <span class="s1">plural</span><span class="s0">, </span><span class="s1">plural_vars = self.render_token_list(self.plural)</span>
            <span class="s0">if </span><span class="s1">message_context:</span>
                <span class="s1">result = translation.npgettext(message_context</span><span class="s0">, </span><span class="s1">singular</span><span class="s0">,</span>
                                               <span class="s1">plural</span><span class="s0">, </span><span class="s1">count)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = translation.ngettext(singular</span><span class="s0">, </span><span class="s1">plural</span><span class="s0">, </span><span class="s1">count)</span>
            <span class="s1">vars.extend(plural_vars)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">message_context:</span>
                <span class="s1">result = translation.pgettext(message_context</span><span class="s0">, </span><span class="s1">singular)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = translation.gettext(singular)</span>
        <span class="s1">default_value = context.template.engine.string_if_invalid</span>

        <span class="s0">def </span><span class="s1">render_value(key):</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">context:</span>
                <span class="s1">val = context[key]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">val = default_value % key </span><span class="s0">if </span><span class="s2">'%s' </span><span class="s0">in </span><span class="s1">default_value </span><span class="s0">else </span><span class="s1">default_value</span>
            <span class="s0">return </span><span class="s1">render_value_in_context(val</span><span class="s0">, </span><span class="s1">context)</span>

        <span class="s1">data = {v: render_value(v) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">vars}</span>
        <span class="s1">context.pop()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">result = result % data</span>
        <span class="s0">except </span><span class="s1">(KeyError</span><span class="s0">, </span><span class="s1">ValueError):</span>
            <span class="s0">if </span><span class="s1">nested:</span>
                <span class="s3"># Either string is malformed, or it's a bug</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                    <span class="s2">'%r is unable to format string returned by gettext: %r '</span>
                    <span class="s2">'using %r' </span><span class="s1">% (self.tag_name</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">data)</span>
                <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">translation.override(</span><span class="s0">None</span><span class="s1">):</span>
                <span class="s1">result = self.render(context</span><span class="s0">, </span><span class="s1">nested=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self.asvar:</span>
            <span class="s1">context[self.asvar] = result</span>
            <span class="s0">return </span><span class="s2">''</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">LanguageNode(Node):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">nodelist</span><span class="s0">, </span><span class="s1">language):</span>
        <span class="s1">self.nodelist = nodelist</span>
        <span class="s1">self.language = language</span>

    <span class="s0">def </span><span class="s1">render(self</span><span class="s0">, </span><span class="s1">context):</span>
        <span class="s0">with </span><span class="s1">translation.override(self.language.resolve(context)):</span>
            <span class="s1">output = self.nodelist.render(context)</span>
        <span class="s0">return </span><span class="s1">output</span>


<span class="s1">@register.tag(</span><span class="s2">&quot;get_available_languages&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">do_get_available_languages(parser</span><span class="s0">, </span><span class="s1">token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Store a list of available languages in the context. 
 
    Usage:: 
 
        {% get_available_languages as languages %} 
        {% for language in languages %} 
        ... 
        {% endfor %} 
 
    This puts settings.LANGUAGES into the named variable. 
    &quot;&quot;&quot;</span>
    <span class="s3"># token.split_contents() isn't useful here because this tag doesn't accept variable as arguments</span>
    <span class="s1">args = token.contents.split()</span>
    <span class="s0">if </span><span class="s1">len(args) != </span><span class="s4">3 </span><span class="s0">or </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">] != </span><span class="s2">'as'</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;'get_available_languages' requires 'as variable' (got %r)&quot; </span><span class="s1">% args)</span>
    <span class="s0">return </span><span class="s1">GetAvailableLanguagesNode(args[</span><span class="s4">2</span><span class="s1">])</span>


<span class="s1">@register.tag(</span><span class="s2">&quot;get_language_info&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">do_get_language_info(parser</span><span class="s0">, </span><span class="s1">token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Store the language information dictionary for the given language code in a 
    context variable. 
 
    Usage:: 
 
        {% get_language_info for LANGUAGE_CODE as l %} 
        {{ l.code }} 
        {{ l.name }} 
        {{ l.name_translated }} 
        {{ l.name_local }} 
        {{ l.bidi|yesno:&quot;bi-directional,uni-directional&quot; }} 
    &quot;&quot;&quot;</span>
    <span class="s1">args = token.split_contents()</span>
    <span class="s0">if </span><span class="s1">len(args) != </span><span class="s4">5 </span><span class="s0">or </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">] != </span><span class="s2">'for' </span><span class="s0">or </span><span class="s1">args[</span><span class="s4">3</span><span class="s1">] != </span><span class="s2">'as'</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;'%s' requires 'for string as variable' (got %r)&quot; </span><span class="s1">% (args[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">:]))</span>
    <span class="s0">return </span><span class="s1">GetLanguageInfoNode(parser.compile_filter(args[</span><span class="s4">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">args[</span><span class="s4">4</span><span class="s1">])</span>


<span class="s1">@register.tag(</span><span class="s2">&quot;get_language_info_list&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">do_get_language_info_list(parser</span><span class="s0">, </span><span class="s1">token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Store a list of language information dictionaries for the given language 
    codes in a context variable. The language codes can be specified either as 
    a list of strings or a settings.LANGUAGES style list (or any sequence of 
    sequences whose first items are language codes). 
 
    Usage:: 
 
        {% get_language_info_list for LANGUAGES as langs %} 
        {% for l in langs %} 
          {{ l.code }} 
          {{ l.name }} 
          {{ l.name_translated }} 
          {{ l.name_local }} 
          {{ l.bidi|yesno:&quot;bi-directional,uni-directional&quot; }} 
        {% endfor %} 
    &quot;&quot;&quot;</span>
    <span class="s1">args = token.split_contents()</span>
    <span class="s0">if </span><span class="s1">len(args) != </span><span class="s4">5 </span><span class="s0">or </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">] != </span><span class="s2">'for' </span><span class="s0">or </span><span class="s1">args[</span><span class="s4">3</span><span class="s1">] != </span><span class="s2">'as'</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;'%s' requires 'for sequence as variable' (got %r)&quot; </span><span class="s1">% (args[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">:]))</span>
    <span class="s0">return </span><span class="s1">GetLanguageInfoListNode(parser.compile_filter(args[</span><span class="s4">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">args[</span><span class="s4">4</span><span class="s1">])</span>


<span class="s1">@register.filter</span>
<span class="s0">def </span><span class="s1">language_name(lang_code):</span>
    <span class="s0">return </span><span class="s1">translation.get_language_info(lang_code)[</span><span class="s2">'name'</span><span class="s1">]</span>


<span class="s1">@register.filter</span>
<span class="s0">def </span><span class="s1">language_name_translated(lang_code):</span>
    <span class="s1">english_name = translation.get_language_info(lang_code)[</span><span class="s2">'name'</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">translation.gettext(english_name)</span>


<span class="s1">@register.filter</span>
<span class="s0">def </span><span class="s1">language_name_local(lang_code):</span>
    <span class="s0">return </span><span class="s1">translation.get_language_info(lang_code)[</span><span class="s2">'name_local'</span><span class="s1">]</span>


<span class="s1">@register.filter</span>
<span class="s0">def </span><span class="s1">language_bidi(lang_code):</span>
    <span class="s0">return </span><span class="s1">translation.get_language_info(lang_code)[</span><span class="s2">'bidi'</span><span class="s1">]</span>


<span class="s1">@register.tag(</span><span class="s2">&quot;get_current_language&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">do_get_current_language(parser</span><span class="s0">, </span><span class="s1">token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Store the current language in the context. 
 
    Usage:: 
 
        {% get_current_language as language %} 
 
    This fetches the currently active language and puts its value into the 
    ``language`` context variable. 
    &quot;&quot;&quot;</span>
    <span class="s3"># token.split_contents() isn't useful here because this tag doesn't accept variable as arguments</span>
    <span class="s1">args = token.contents.split()</span>
    <span class="s0">if </span><span class="s1">len(args) != </span><span class="s4">3 </span><span class="s0">or </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">] != </span><span class="s2">'as'</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;'get_current_language' requires 'as variable' (got %r)&quot; </span><span class="s1">% args)</span>
    <span class="s0">return </span><span class="s1">GetCurrentLanguageNode(args[</span><span class="s4">2</span><span class="s1">])</span>


<span class="s1">@register.tag(</span><span class="s2">&quot;get_current_language_bidi&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">do_get_current_language_bidi(parser</span><span class="s0">, </span><span class="s1">token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Store the current language layout in the context. 
 
    Usage:: 
 
        {% get_current_language_bidi as bidi %} 
 
    This fetches the currently active language's layout and puts its value into 
    the ``bidi`` context variable. True indicates right-to-left layout, 
    otherwise left-to-right. 
    &quot;&quot;&quot;</span>
    <span class="s3"># token.split_contents() isn't useful here because this tag doesn't accept variable as arguments</span>
    <span class="s1">args = token.contents.split()</span>
    <span class="s0">if </span><span class="s1">len(args) != </span><span class="s4">3 </span><span class="s0">or </span><span class="s1">args[</span><span class="s4">1</span><span class="s1">] != </span><span class="s2">'as'</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;'get_current_language_bidi' requires 'as variable' (got %r)&quot; </span><span class="s1">% args)</span>
    <span class="s0">return </span><span class="s1">GetCurrentLanguageBidiNode(args[</span><span class="s4">2</span><span class="s1">])</span>


<span class="s1">@register.tag(</span><span class="s2">&quot;translate&quot;</span><span class="s1">)</span>
<span class="s1">@register.tag(</span><span class="s2">&quot;trans&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">do_translate(parser</span><span class="s0">, </span><span class="s1">token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Mark a string for translation and translate the string for the current 
    language. 
 
    Usage:: 
 
        {% translate &quot;this is a test&quot; %} 
 
    This marks the string for translation so it will be pulled out by 
    makemessages into the .po files and runs the string through the translation 
    engine. 
 
    There is a second form:: 
 
        {% translate &quot;this is a test&quot; noop %} 
 
    This marks the string for translation, but returns the string unchanged. 
    Use it when you need to store values into forms that should be translated 
    later on. 
 
    You can use variables instead of constant strings 
    to translate stuff you marked somewhere else:: 
 
        {% translate variable %} 
 
    This tries to translate the contents of the variable ``variable``. Make 
    sure that the string in there is something that is in the .po file. 
 
    It is possible to store the translated string into a variable:: 
 
        {% translate &quot;this is a test&quot; as var %} 
        {{ var }} 
 
    Contextual translations are also supported:: 
 
        {% translate &quot;this is a test&quot; context &quot;greeting&quot; %} 
 
    This is equivalent to calling pgettext instead of (u)gettext. 
    &quot;&quot;&quot;</span>
    <span class="s1">bits = token.split_contents()</span>
    <span class="s0">if </span><span class="s1">len(bits) &lt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;'%s' takes at least one argument&quot; </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">message_string = parser.compile_filter(bits[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">remaining = bits[</span><span class="s4">2</span><span class="s1">:]</span>

    <span class="s1">noop = </span><span class="s0">False</span>
    <span class="s1">asvar = </span><span class="s0">None</span>
    <span class="s1">message_context = </span><span class="s0">None</span>
    <span class="s1">seen = set()</span>
    <span class="s1">invalid_context = {</span><span class="s2">'as'</span><span class="s0">, </span><span class="s2">'noop'</span><span class="s1">}</span>

    <span class="s0">while </span><span class="s1">remaining:</span>
        <span class="s1">option = remaining.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">option </span><span class="s0">in </span><span class="s1">seen:</span>
            <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                <span class="s2">&quot;The '%s' option was specified more than once.&quot; </span><span class="s1">% option</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">option == </span><span class="s2">'noop'</span><span class="s1">:</span>
            <span class="s1">noop = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">option == </span><span class="s2">'context'</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">value = remaining.pop(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">IndexError:</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                    <span class="s2">&quot;No argument provided to the '%s' tag for the context option.&quot; </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">value </span><span class="s0">in </span><span class="s1">invalid_context:</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                    <span class="s2">&quot;Invalid argument '%s' provided to the '%s' tag for the context option&quot; </span><span class="s1">% (value</span><span class="s0">, </span><span class="s1">bits[</span><span class="s4">0</span><span class="s1">])</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">message_context = parser.compile_filter(value)</span>
        <span class="s0">elif </span><span class="s1">option == </span><span class="s2">'as'</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">value = remaining.pop(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">IndexError:</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                    <span class="s2">&quot;No argument provided to the '%s' tag for the as option.&quot; </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">)</span>
            <span class="s1">asvar = value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                <span class="s2">&quot;Unknown argument for '%s' tag: '%s'. The only options &quot;</span>
                <span class="s2">&quot;available are 'noop', 'context' </span><span class="s0">\&quot;</span><span class="s2">xxx</span><span class="s0">\&quot;</span><span class="s2">, and 'as VAR'.&quot; </span><span class="s1">% (</span>
                    <span class="s1">bits[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">option</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">seen.add(option)</span>

    <span class="s0">return </span><span class="s1">TranslateNode(message_string</span><span class="s0">, </span><span class="s1">noop</span><span class="s0">, </span><span class="s1">asvar</span><span class="s0">, </span><span class="s1">message_context)</span>


<span class="s1">@register.tag(</span><span class="s2">&quot;blocktranslate&quot;</span><span class="s1">)</span>
<span class="s1">@register.tag(</span><span class="s2">&quot;blocktrans&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">do_block_translate(parser</span><span class="s0">, </span><span class="s1">token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Translate a block of text with parameters. 
 
    Usage:: 
 
        {% blocktranslate with bar=foo|filter boo=baz|filter %} 
        This is {{ bar }} and {{ boo }}. 
        {% endblocktranslate %} 
 
    Additionally, this supports pluralization:: 
 
        {% blocktranslate count count=var|length %} 
        There is {{ count }} object. 
        {% plural %} 
        There are {{ count }} objects. 
        {% endblocktranslate %} 
 
    This is much like ngettext, only in template syntax. 
 
    The &quot;var as value&quot; legacy format is still supported:: 
 
        {% blocktranslate with foo|filter as bar and baz|filter as boo %} 
        {% blocktranslate count var|length as count %} 
 
    The translated string can be stored in a variable using `asvar`:: 
 
        {% blocktranslate with bar=foo|filter boo=baz|filter asvar var %} 
        This is {{ bar }} and {{ boo }}. 
        {% endblocktranslate %} 
        {{ var }} 
 
    Contextual translations are supported:: 
 
        {% blocktranslate with bar=foo|filter context &quot;greeting&quot; %} 
            This is {{ bar }}. 
        {% endblocktranslate %} 
 
    This is equivalent to calling pgettext/npgettext instead of 
    (u)gettext/(u)ngettext. 
    &quot;&quot;&quot;</span>
    <span class="s1">bits = token.split_contents()</span>

    <span class="s1">options = {}</span>
    <span class="s1">remaining_bits = bits[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s1">asvar = </span><span class="s0">None</span>
    <span class="s0">while </span><span class="s1">remaining_bits:</span>
        <span class="s1">option = remaining_bits.pop(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">option </span><span class="s0">in </span><span class="s1">options:</span>
            <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">'The %r option was specified more '</span>
                                      <span class="s2">'than once.' </span><span class="s1">% option)</span>
        <span class="s0">if </span><span class="s1">option == </span><span class="s2">'with'</span><span class="s1">:</span>
            <span class="s1">value = token_kwargs(remaining_bits</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">support_legacy=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">value:</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">'&quot;with&quot; in %r tag needs at least '</span>
                                          <span class="s2">'one keyword argument.' </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">elif </span><span class="s1">option == </span><span class="s2">'count'</span><span class="s1">:</span>
            <span class="s1">value = token_kwargs(remaining_bits</span><span class="s0">, </span><span class="s1">parser</span><span class="s0">, </span><span class="s1">support_legacy=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(value) != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">'&quot;count&quot; in %r tag expected exactly '</span>
                                          <span class="s2">'one keyword argument.' </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">elif </span><span class="s1">option == </span><span class="s2">&quot;context&quot;</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">value = remaining_bits.pop(</span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">value = parser.compile_filter(value)</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                    <span class="s2">'&quot;context&quot; in %r tag expected exactly one argument.' </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">option == </span><span class="s2">&quot;trimmed&quot;</span><span class="s1">:</span>
            <span class="s1">value = </span><span class="s0">True</span>
        <span class="s0">elif </span><span class="s1">option == </span><span class="s2">&quot;asvar&quot;</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">value = remaining_bits.pop(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">IndexError:</span>
                <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span>
                    <span class="s2">&quot;No argument provided to the '%s' tag for the asvar option.&quot; </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">)</span>
            <span class="s1">asvar = value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">'Unknown argument for %r tag: %r.' </span><span class="s1">%</span>
                                      <span class="s1">(bits[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">option))</span>
        <span class="s1">options[option] = value</span>

    <span class="s0">if </span><span class="s2">'count' </span><span class="s0">in </span><span class="s1">options:</span>
        <span class="s1">countervar</span><span class="s0">, </span><span class="s1">counter = next(iter(options[</span><span class="s2">'count'</span><span class="s1">].items()))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">countervar</span><span class="s0">, </span><span class="s1">counter = </span><span class="s0">None, None</span>
    <span class="s0">if </span><span class="s2">'context' </span><span class="s0">in </span><span class="s1">options:</span>
        <span class="s1">message_context = options[</span><span class="s2">'context'</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">message_context = </span><span class="s0">None</span>
    <span class="s1">extra_context = options.get(</span><span class="s2">'with'</span><span class="s0">, </span><span class="s1">{})</span>

    <span class="s1">trimmed = options.get(</span><span class="s2">&quot;trimmed&quot;</span><span class="s0">, False</span><span class="s1">)</span>

    <span class="s1">singular = []</span>
    <span class="s1">plural = []</span>
    <span class="s0">while </span><span class="s1">parser.tokens:</span>
        <span class="s1">token = parser.next_token()</span>
        <span class="s0">if </span><span class="s1">token.token_type </span><span class="s0">in </span><span class="s1">(TokenType.VAR</span><span class="s0">, </span><span class="s1">TokenType.TEXT):</span>
            <span class="s1">singular.append(token)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">break</span>
    <span class="s0">if </span><span class="s1">countervar </span><span class="s0">and </span><span class="s1">counter:</span>
        <span class="s0">if </span><span class="s1">token.contents.strip() != </span><span class="s2">'plural'</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;%r doesn't allow other block tags inside it&quot; </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">while </span><span class="s1">parser.tokens:</span>
            <span class="s1">token = parser.next_token()</span>
            <span class="s0">if </span><span class="s1">token.token_type </span><span class="s0">in </span><span class="s1">(TokenType.VAR</span><span class="s0">, </span><span class="s1">TokenType.TEXT):</span>
                <span class="s1">plural.append(token)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">break</span>
    <span class="s1">end_tag_name = </span><span class="s2">'end%s' </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">token.contents.strip() != end_tag_name:</span>
        <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;%r doesn't allow other block tags (seen %r) inside it&quot; </span><span class="s1">% (bits[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">token.contents))</span>

    <span class="s0">return </span><span class="s1">BlockTranslateNode(extra_context</span><span class="s0">, </span><span class="s1">singular</span><span class="s0">, </span><span class="s1">plural</span><span class="s0">, </span><span class="s1">countervar</span><span class="s0">,</span>
                              <span class="s1">counter</span><span class="s0">, </span><span class="s1">message_context</span><span class="s0">, </span><span class="s1">trimmed=trimmed</span><span class="s0">,</span>
                              <span class="s1">asvar=asvar</span><span class="s0">, </span><span class="s1">tag_name=bits[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s1">@register.tag</span>
<span class="s0">def </span><span class="s1">language(parser</span><span class="s0">, </span><span class="s1">token):</span>
    <span class="s5">&quot;&quot;&quot; 
    Enable the given language just for this block. 
 
    Usage:: 
 
        {% language &quot;de&quot; %} 
            This is {{ bar }} and {{ boo }}. 
        {% endlanguage %} 
    &quot;&quot;&quot;</span>
    <span class="s1">bits = token.split_contents()</span>
    <span class="s0">if </span><span class="s1">len(bits) != </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TemplateSyntaxError(</span><span class="s2">&quot;'%s' takes one argument (language)&quot; </span><span class="s1">% bits[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">language = parser.compile_filter(bits[</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">nodelist = parser.parse((</span><span class="s2">'endlanguage'</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">parser.delete_first_token()</span>
    <span class="s0">return </span><span class="s1">LanguageNode(nodelist</span><span class="s0">, </span><span class="s1">language)</span>
</pre>
</body>
</html>