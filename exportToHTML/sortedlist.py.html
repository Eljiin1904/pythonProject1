<html>
<head>
<title>sortedlist.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sortedlist.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Sorted List 
============== 
 
:doc:`Sorted Containers&lt;index&gt;` is an Apache2 licensed Python sorted 
collections library, written in pure-Python, and fast as C-extensions. The 
:doc:`introduction&lt;introduction&gt;` is the best way to get started. 
 
Sorted list implementations: 
 
.. currentmodule:: sortedcontainers 
 
* :class:`SortedList` 
* :class:`SortedKeyList` 
 
&quot;&quot;&quot;</span>
<span class="s2"># pylint: disable=too-many-lines</span>
<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">print_function</span>

<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">traceback</span>

<span class="s3">from </span><span class="s1">bisect </span><span class="s3">import </span><span class="s1">bisect_left</span><span class="s3">, </span><span class="s1">bisect_right</span><span class="s3">, </span><span class="s1">insort</span>
<span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">chain</span><span class="s3">, </span><span class="s1">repeat</span><span class="s3">, </span><span class="s1">starmap</span>
<span class="s3">from </span><span class="s1">math </span><span class="s3">import </span><span class="s1">log</span>
<span class="s3">from </span><span class="s1">operator </span><span class="s3">import </span><span class="s1">add</span><span class="s3">, </span><span class="s1">eq</span><span class="s3">, </span><span class="s1">ne</span><span class="s3">, </span><span class="s1">gt</span><span class="s3">, </span><span class="s1">ge</span><span class="s3">, </span><span class="s1">lt</span><span class="s3">, </span><span class="s1">le</span><span class="s3">, </span><span class="s1">iadd</span>
<span class="s3">from </span><span class="s1">textwrap </span><span class="s3">import </span><span class="s1">dedent</span>

<span class="s2">###############################################################################</span>
<span class="s2"># BEGIN Python 2/3 Shims</span>
<span class="s2">###############################################################################</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">MutableSequence</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Sequence</span><span class="s3">, </span><span class="s1">MutableSequence</span>

<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">wraps</span>
<span class="s3">from </span><span class="s1">sys </span><span class="s3">import </span><span class="s1">hexversion</span>

<span class="s3">if </span><span class="s1">hexversion &lt; </span><span class="s4">0x03000000</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">imap </span><span class="s3">as </span><span class="s1">map  </span><span class="s2"># pylint: disable=redefined-builtin</span>
    <span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">izip </span><span class="s3">as </span><span class="s1">zip  </span><span class="s2"># pylint: disable=redefined-builtin</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">from </span><span class="s1">thread </span><span class="s3">import </span><span class="s1">get_ident</span>
    <span class="s3">except </span><span class="s1">ImportError:</span>
        <span class="s3">from </span><span class="s1">dummy_thread </span><span class="s3">import </span><span class="s1">get_ident</span>
<span class="s3">else</span><span class="s1">:</span>
    <span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">reduce</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">from </span><span class="s1">_thread </span><span class="s3">import </span><span class="s1">get_ident</span>
    <span class="s3">except </span><span class="s1">ImportError:</span>
        <span class="s3">from </span><span class="s1">_dummy_thread </span><span class="s3">import </span><span class="s1">get_ident</span>


<span class="s3">def </span><span class="s1">recursive_repr(fillvalue=</span><span class="s5">'...'</span><span class="s1">):</span>
    <span class="s0">&quot;Decorator to make a repr function return fillvalue for a recursive call.&quot;</span>
    <span class="s2"># pylint: disable=missing-docstring</span>
    <span class="s2"># Copied from reprlib in Python 3</span>
    <span class="s2"># https://hg.python.org/cpython/file/3.6/Lib/reprlib.py</span>

    <span class="s3">def </span><span class="s1">decorating_function(user_function):</span>
        <span class="s1">repr_running = set()</span>

        <span class="s1">@wraps(user_function)</span>
        <span class="s3">def </span><span class="s1">wrapper(self):</span>
            <span class="s1">key = id(self)</span><span class="s3">, </span><span class="s1">get_ident()</span>
            <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">repr_running:</span>
                <span class="s3">return </span><span class="s1">fillvalue</span>
            <span class="s1">repr_running.add(key)</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">result = user_function(self)</span>
            <span class="s3">finally</span><span class="s1">:</span>
                <span class="s1">repr_running.discard(key)</span>
            <span class="s3">return </span><span class="s1">result</span>

        <span class="s3">return </span><span class="s1">wrapper</span>

    <span class="s3">return </span><span class="s1">decorating_function</span>

<span class="s2">###############################################################################</span>
<span class="s2"># END Python 2/3 Shims</span>
<span class="s2">###############################################################################</span>


<span class="s3">class </span><span class="s1">SortedList(MutableSequence):</span>
    <span class="s0">&quot;&quot;&quot;Sorted list is a sorted mutable sequence. 
 
    Sorted list values are maintained in sorted order. 
 
    Sorted list values must be comparable. The total ordering of values must 
    not change while they are stored in the sorted list. 
 
    Methods for adding values: 
 
    * :func:`SortedList.add` 
    * :func:`SortedList.update` 
    * :func:`SortedList.__add__` 
    * :func:`SortedList.__iadd__` 
    * :func:`SortedList.__mul__` 
    * :func:`SortedList.__imul__` 
 
    Methods for removing values: 
 
    * :func:`SortedList.clear` 
    * :func:`SortedList.discard` 
    * :func:`SortedList.remove` 
    * :func:`SortedList.pop` 
    * :func:`SortedList.__delitem__` 
 
    Methods for looking up values: 
 
    * :func:`SortedList.bisect_left` 
    * :func:`SortedList.bisect_right` 
    * :func:`SortedList.count` 
    * :func:`SortedList.index` 
    * :func:`SortedList.__contains__` 
    * :func:`SortedList.__getitem__` 
 
    Methods for iterating values: 
 
    * :func:`SortedList.irange` 
    * :func:`SortedList.islice` 
    * :func:`SortedList.__iter__` 
    * :func:`SortedList.__reversed__` 
 
    Methods for miscellany: 
 
    * :func:`SortedList.copy` 
    * :func:`SortedList.__len__` 
    * :func:`SortedList.__repr__` 
    * :func:`SortedList._check` 
    * :func:`SortedList._reset` 
 
    Sorted lists use lexicographical ordering semantics when compared to other 
    sequences. 
 
    Some methods of mutable sequences are not supported and will raise 
    not-implemented error. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">DEFAULT_LOAD_FACTOR = </span><span class="s4">1000</span>


    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">iterable=</span><span class="s3">None, </span><span class="s1">key=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize sorted list instance. 
 
        Optional `iterable` argument provides an initial iterable of values to 
        initialize the sorted list. 
 
        Runtime complexity: `O(n*log(n))` 
 
        &gt;&gt;&gt; sl = SortedList() 
        &gt;&gt;&gt; sl 
        SortedList([]) 
        &gt;&gt;&gt; sl = SortedList([3, 1, 2, 5, 4]) 
        &gt;&gt;&gt; sl 
        SortedList([1, 2, 3, 4, 5]) 
 
        :param iterable: initial values (optional) 
 
        &quot;&quot;&quot;</span>
        <span class="s3">assert </span><span class="s1">key </span><span class="s3">is None</span>
        <span class="s1">self._len = </span><span class="s4">0</span>
        <span class="s1">self._load = self.DEFAULT_LOAD_FACTOR</span>
        <span class="s1">self._lists = []</span>
        <span class="s1">self._maxes = []</span>
        <span class="s1">self._index = []</span>
        <span class="s1">self._offset = </span><span class="s4">0</span>

        <span class="s3">if </span><span class="s1">iterable </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._update(iterable)</span>


    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">iterable=</span><span class="s3">None, </span><span class="s1">key=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create new sorted list or sorted-key list instance. 
 
        Optional `key`-function argument will return an instance of subtype 
        :class:`SortedKeyList`. 
 
        &gt;&gt;&gt; sl = SortedList() 
        &gt;&gt;&gt; isinstance(sl, SortedList) 
        True 
        &gt;&gt;&gt; sl = SortedList(key=lambda x: -x) 
        &gt;&gt;&gt; isinstance(sl, SortedList) 
        True 
        &gt;&gt;&gt; isinstance(sl, SortedKeyList) 
        True 
 
        :param iterable: initial values (optional) 
        :param key: function used to extract comparison key (optional) 
        :return: sorted list or sorted-key list instance 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># pylint: disable=unused-argument</span>
        <span class="s3">if </span><span class="s1">key </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">object.__new__(cls)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">cls </span><span class="s3">is </span><span class="s1">SortedList:</span>
                <span class="s3">return </span><span class="s1">object.__new__(SortedKeyList)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s5">'inherit SortedKeyList for key argument'</span><span class="s1">)</span>


    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">key(self):  </span><span class="s2"># pylint: disable=useless-return</span>
        <span class="s0">&quot;&quot;&quot;Function used to extract comparison key from values. 
 
        Sorted list compares values directly so the key function is none. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return None</span>


    <span class="s3">def </span><span class="s1">_reset(self</span><span class="s3">, </span><span class="s1">load):</span>
        <span class="s0">&quot;&quot;&quot;Reset sorted list load factor. 
 
        The `load` specifies the load-factor of the list. The default load 
        factor of 1000 works well for lists from tens to tens-of-millions of 
        values. Good practice is to use a value that is the cube root of the 
        list size. With billions of elements, the best load factor depends on 
        your usage. It's best to leave the load factor at the default until you 
        start benchmarking. 
 
        See :doc:`implementation` and :doc:`performance-scale` for more 
        information. 
 
        Runtime complexity: `O(n)` 
 
        :param int load: load-factor for sorted list sublists 
 
        &quot;&quot;&quot;</span>
        <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s1">self._clear()</span>
        <span class="s1">self._load = load</span>
        <span class="s1">self._update(values)</span>


    <span class="s3">def </span><span class="s1">clear(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove all values from sorted list. 
 
        Runtime complexity: `O(n)` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._len = </span><span class="s4">0</span>
        <span class="s3">del </span><span class="s1">self._lists[:]</span>
        <span class="s3">del </span><span class="s1">self._maxes[:]</span>
        <span class="s3">del </span><span class="s1">self._index[:]</span>
        <span class="s1">self._offset = </span><span class="s4">0</span>

    <span class="s1">_clear = clear</span>


    <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Add `value` to sorted list. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList() 
        &gt;&gt;&gt; sl.add(3) 
        &gt;&gt;&gt; sl.add(1) 
        &gt;&gt;&gt; sl.add(2) 
        &gt;&gt;&gt; sl 
        SortedList([1, 2, 3]) 
 
        :param value: value to add to sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if </span><span class="s1">_maxes:</span>
            <span class="s1">pos = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

            <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
                <span class="s1">pos -= </span><span class="s4">1</span>
                <span class="s1">_lists[pos].append(value)</span>
                <span class="s1">_maxes[pos] = value</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">insort(_lists[pos]</span><span class="s3">, </span><span class="s1">value)</span>

            <span class="s1">self._expand(pos)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_lists.append([value])</span>
            <span class="s1">_maxes.append(value)</span>

        <span class="s1">self._len += </span><span class="s4">1</span>


    <span class="s3">def </span><span class="s1">_expand(self</span><span class="s3">, </span><span class="s1">pos):</span>
        <span class="s0">&quot;&quot;&quot;Split sublists with length greater than double the load-factor. 
 
        Updates the index when the sublist length is less than double the load 
        level. This requires incrementing the nodes in a traversal from the 
        leaf node to the root. For an example traversal see 
        ``SortedList._loc``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_load = self._load</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_index = self._index</span>

        <span class="s3">if </span><span class="s1">len(_lists[pos]) &gt; (_load &lt;&lt; </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">_maxes = self._maxes</span>

            <span class="s1">_lists_pos = _lists[pos]</span>
            <span class="s1">half = _lists_pos[_load:]</span>
            <span class="s3">del </span><span class="s1">_lists_pos[_load:]</span>
            <span class="s1">_maxes[pos] = _lists_pos[-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s1">_lists.insert(pos + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">half)</span>
            <span class="s1">_maxes.insert(pos + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">half[-</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s3">del </span><span class="s1">_index[:]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">_index:</span>
                <span class="s1">child = self._offset + pos</span>
                <span class="s3">while </span><span class="s1">child:</span>
                    <span class="s1">_index[child] += </span><span class="s4">1</span>
                    <span class="s1">child = (child - </span><span class="s4">1</span><span class="s1">) &gt;&gt; </span><span class="s4">1</span>
                <span class="s1">_index[</span><span class="s4">0</span><span class="s1">] += </span><span class="s4">1</span>


    <span class="s3">def </span><span class="s1">update(self</span><span class="s3">, </span><span class="s1">iterable):</span>
        <span class="s0">&quot;&quot;&quot;Update sorted list by adding all values from `iterable`. 
 
        Runtime complexity: `O(k*log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList() 
        &gt;&gt;&gt; sl.update([3, 1, 2]) 
        &gt;&gt;&gt; sl 
        SortedList([1, 2, 3]) 
 
        :param iterable: iterable of values to add 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_maxes = self._maxes</span>
        <span class="s1">values = sorted(iterable)</span>

        <span class="s3">if </span><span class="s1">_maxes:</span>
            <span class="s3">if </span><span class="s1">len(values) * </span><span class="s4">4 </span><span class="s1">&gt;= self._len:</span>
                <span class="s1">_lists.append(values)</span>
                <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">_lists</span><span class="s3">, </span><span class="s1">[])</span>
                <span class="s1">values.sort()</span>
                <span class="s1">self._clear()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">_add = self.add</span>
                <span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">values:</span>
                    <span class="s1">_add(val)</span>
                <span class="s3">return</span>

        <span class="s1">_load = self._load</span>
        <span class="s1">_lists.extend(values[pos:(pos + _load)]</span>
                      <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">len(values)</span><span class="s3">, </span><span class="s1">_load))</span>
        <span class="s1">_maxes.extend(sublist[-</span><span class="s4">1</span><span class="s1">] </span><span class="s3">for </span><span class="s1">sublist </span><span class="s3">in </span><span class="s1">_lists)</span>
        <span class="s1">self._len = len(values)</span>
        <span class="s3">del </span><span class="s1">self._index[:]</span>

    <span class="s1">_update = update</span>


    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Return true if `value` is an element of the sorted list. 
 
        ``sl.__contains__(value)`` &lt;==&gt; ``value in sl`` 
 
        Runtime complexity: `O(log(n))` 
 
        &gt;&gt;&gt; sl = SortedList([1, 2, 3, 4, 5]) 
        &gt;&gt;&gt; 3 in sl 
        True 
 
        :param value: search for value in sorted list 
        :return: true if `value` in sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return False</span>

        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return False</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">idx = bisect_left(_lists[pos]</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">return </span><span class="s1">_lists[pos][idx] == value</span>


    <span class="s3">def </span><span class="s1">discard(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Remove `value` from sorted list if it is a member. 
 
        If `value` is not a member, do nothing. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList([1, 2, 3, 4, 5]) 
        &gt;&gt;&gt; sl.discard(5) 
        &gt;&gt;&gt; sl.discard(0) 
        &gt;&gt;&gt; sl == [1, 2, 3, 4] 
        True 
 
        :param value: `value` to discard from sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return</span>

        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">idx = bisect_left(_lists[pos]</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">_lists[pos][idx] == value:</span>
            <span class="s1">self._delete(pos</span><span class="s3">, </span><span class="s1">idx)</span>


    <span class="s3">def </span><span class="s1">remove(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Remove `value` from sorted list; `value` must be a member. 
 
        If `value` is not a member, raise ValueError. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList([1, 2, 3, 4, 5]) 
        &gt;&gt;&gt; sl.remove(5) 
        &gt;&gt;&gt; sl == [1, 2, 3, 4] 
        True 
        &gt;&gt;&gt; sl.remove(0) 
        Traceback (most recent call last): 
          ... 
        ValueError: 0 not in list 
 
        :param value: `value` to remove from sorted list 
        :raises ValueError: if `value` is not in sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">idx = bisect_left(_lists[pos]</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">_lists[pos][idx] == value:</span>
            <span class="s1">self._delete(pos</span><span class="s3">, </span><span class="s1">idx)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} not in list'</span><span class="s1">.format(value))</span>


    <span class="s3">def </span><span class="s1">_delete(self</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">idx):</span>
        <span class="s0">&quot;&quot;&quot;Delete value at the given `(pos, idx)`. 
 
        Combines lists that are less than half the load level. 
 
        Updates the index when the sublist length is more than half the load 
        level. This requires decrementing the nodes in a traversal from the 
        leaf node to the root. For an example traversal see 
        ``SortedList._loc``. 
 
        :param int pos: lists index 
        :param int idx: sublist index 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_maxes = self._maxes</span>
        <span class="s1">_index = self._index</span>

        <span class="s1">_lists_pos = _lists[pos]</span>

        <span class="s3">del </span><span class="s1">_lists_pos[idx]</span>
        <span class="s1">self._len -= </span><span class="s4">1</span>

        <span class="s1">len_lists_pos = len(_lists_pos)</span>

        <span class="s3">if </span><span class="s1">len_lists_pos &gt; (self._load &gt;&gt; </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">_maxes[pos] = _lists_pos[-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s3">if </span><span class="s1">_index:</span>
                <span class="s1">child = self._offset + pos</span>
                <span class="s3">while </span><span class="s1">child &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">_index[child] -= </span><span class="s4">1</span>
                    <span class="s1">child = (child - </span><span class="s4">1</span><span class="s1">) &gt;&gt; </span><span class="s4">1</span>
                <span class="s1">_index[</span><span class="s4">0</span><span class="s1">] -= </span><span class="s4">1</span>
        <span class="s3">elif </span><span class="s1">len(_lists) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">pos:</span>
                <span class="s1">pos += </span><span class="s4">1</span>

            <span class="s1">prev = pos - </span><span class="s4">1</span>
            <span class="s1">_lists[prev].extend(_lists[pos])</span>
            <span class="s1">_maxes[prev] = _lists[prev][-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s3">del </span><span class="s1">_lists[pos]</span>
            <span class="s3">del </span><span class="s1">_maxes[pos]</span>
            <span class="s3">del </span><span class="s1">_index[:]</span>

            <span class="s1">self._expand(prev)</span>
        <span class="s3">elif </span><span class="s1">len_lists_pos:</span>
            <span class="s1">_maxes[pos] = _lists_pos[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">del </span><span class="s1">_lists[pos]</span>
            <span class="s3">del </span><span class="s1">_maxes[pos]</span>
            <span class="s3">del </span><span class="s1">_index[:]</span>


    <span class="s3">def </span><span class="s1">_loc(self</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">idx):</span>
        <span class="s0">&quot;&quot;&quot;Convert an index pair (lists index, sublist index) into a single 
        index number that corresponds to the position of the value in the 
        sorted list. 
 
        Many queries require the index be built. Details of the index are 
        described in ``SortedList._build_index``. 
 
        Indexing requires traversing the tree from a leaf node to the root. The 
        parent of each node is easily computable at ``(pos - 1) // 2``. 
 
        Left-child nodes are always at odd indices and right-child nodes are 
        always at even indices. 
 
        When traversing up from a right-child node, increment the total by the 
        left-child node. 
 
        The final index is the sum from traversal and the index in the sublist. 
 
        For example, using the index from ``SortedList._build_index``:: 
 
            _index = 14 5 9 3 2 4 5 
            _offset = 3 
 
        Tree:: 
 
                 14 
              5      9 
            3   2  4   5 
 
        Converting an index pair (2, 3) into a single index involves iterating 
        like so: 
 
        1. Starting at the leaf node: offset + alpha = 3 + 2 = 5. We identify 
           the node as a left-child node. At such nodes, we simply traverse to 
           the parent. 
 
        2. At node 9, position 2, we recognize the node as a right-child node 
           and accumulate the left-child in our total. Total is now 5 and we 
           traverse to the parent at position 0. 
 
        3. Iteration ends at the root. 
 
        The index is then the sum of the total and sublist index: 5 + 3 = 8. 
 
        :param int pos: lists index 
        :param int idx: sublist index 
        :return: index in sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">pos:</span>
            <span class="s3">return </span><span class="s1">idx</span>

        <span class="s1">_index = self._index</span>

        <span class="s3">if not </span><span class="s1">_index:</span>
            <span class="s1">self._build_index()</span>

        <span class="s1">total = </span><span class="s4">0</span>

        <span class="s2"># Increment pos to point in the index to len(self._lists[pos]).</span>

        <span class="s1">pos += self._offset</span>

        <span class="s2"># Iterate until reaching the root of the index tree at pos = 0.</span>

        <span class="s3">while </span><span class="s1">pos:</span>

            <span class="s2"># Right-child nodes are at odd indices. At such indices</span>
            <span class="s2"># account the total below the left child node.</span>

            <span class="s3">if not </span><span class="s1">pos &amp; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">total += _index[pos - </span><span class="s4">1</span><span class="s1">]</span>

            <span class="s2"># Advance pos to the parent node.</span>

            <span class="s1">pos = (pos - </span><span class="s4">1</span><span class="s1">) &gt;&gt; </span><span class="s4">1</span>

        <span class="s3">return </span><span class="s1">total + idx</span>


    <span class="s3">def </span><span class="s1">_pos(self</span><span class="s3">, </span><span class="s1">idx):</span>
        <span class="s0">&quot;&quot;&quot;Convert an index into an index pair (lists index, sublist index) 
        that can be used to access the corresponding lists position. 
 
        Many queries require the index be built. Details of the index are 
        described in ``SortedList._build_index``. 
 
        Indexing requires traversing the tree to a leaf node. Each node has two 
        children which are easily computable. Given an index, pos, the 
        left-child is at ``pos * 2 + 1`` and the right-child is at ``pos * 2 + 
        2``. 
 
        When the index is less than the left-child, traversal moves to the 
        left sub-tree. Otherwise, the index is decremented by the left-child 
        and traversal moves to the right sub-tree. 
 
        At a child node, the indexing pair is computed from the relative 
        position of the child node as compared with the offset and the remaining 
        index. 
 
        For example, using the index from ``SortedList._build_index``:: 
 
            _index = 14 5 9 3 2 4 5 
            _offset = 3 
 
        Tree:: 
 
                 14 
              5      9 
            3   2  4   5 
 
        Indexing position 8 involves iterating like so: 
 
        1. Starting at the root, position 0, 8 is compared with the left-child 
           node (5) which it is greater than. When greater the index is 
           decremented and the position is updated to the right child node. 
 
        2. At node 9 with index 3, we again compare the index to the left-child 
           node with value 4. Because the index is the less than the left-child 
           node, we simply traverse to the left. 
 
        3. At node 4 with index 3, we recognize that we are at a leaf node and 
           stop iterating. 
 
        4. To compute the sublist index, we subtract the offset from the index 
           of the leaf node: 5 - 3 = 2. To compute the index in the sublist, we 
           simply use the index remaining from iteration. In this case, 3. 
 
        The final index pair from our example is (2, 3) which corresponds to 
        index 8 in the sorted list. 
 
        :param int idx: index in sorted list 
        :return: (lists index, sublist index) pair 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">idx &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">last_len = len(self._lists[-</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s3">if </span><span class="s1">(-idx) &lt;= last_len:</span>
                <span class="s3">return </span><span class="s1">len(self._lists) - </span><span class="s4">1</span><span class="s3">, </span><span class="s1">last_len + idx</span>

            <span class="s1">idx += self._len</span>

            <span class="s3">if </span><span class="s1">idx &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s5">'list index out of range'</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">idx &gt;= self._len:</span>
            <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s5">'list index out of range'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">idx &lt; len(self._lists[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s3">return </span><span class="s4">0</span><span class="s3">, </span><span class="s1">idx</span>

        <span class="s1">_index = self._index</span>

        <span class="s3">if not </span><span class="s1">_index:</span>
            <span class="s1">self._build_index()</span>

        <span class="s1">pos = </span><span class="s4">0</span>
        <span class="s1">child = </span><span class="s4">1</span>
        <span class="s1">len_index = len(_index)</span>

        <span class="s3">while </span><span class="s1">child &lt; len_index:</span>
            <span class="s1">index_child = _index[child]</span>

            <span class="s3">if </span><span class="s1">idx &lt; index_child:</span>
                <span class="s1">pos = child</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">idx -= index_child</span>
                <span class="s1">pos = child + </span><span class="s4">1</span>

            <span class="s1">child = (pos &lt;&lt; </span><span class="s4">1</span><span class="s1">) + </span><span class="s4">1</span>

        <span class="s3">return </span><span class="s1">(pos - self._offset</span><span class="s3">, </span><span class="s1">idx)</span>


    <span class="s3">def </span><span class="s1">_build_index(self):</span>
        <span class="s0">&quot;&quot;&quot;Build a positional index for indexing the sorted list. 
 
        Indexes are represented as binary trees in a dense array notation 
        similar to a binary heap. 
 
        For example, given a lists representation storing integers:: 
 
            0: [1, 2, 3] 
            1: [4, 5] 
            2: [6, 7, 8, 9] 
            3: [10, 11, 12, 13, 14] 
 
        The first transformation maps the sub-lists by their length. The 
        first row of the index is the length of the sub-lists:: 
 
            0: [3, 2, 4, 5] 
 
        Each row after that is the sum of consecutive pairs of the previous 
        row:: 
 
            1: [5, 9] 
            2: [14] 
 
        Finally, the index is built by concatenating these lists together:: 
 
            _index = [14, 5, 9, 3, 2, 4, 5] 
 
        An offset storing the start of the first row is also stored:: 
 
            _offset = 3 
 
        When built, the index can be used for efficient indexing into the list. 
        See the comment and notes on ``SortedList._pos`` for details. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">row0 = list(map(len</span><span class="s3">, </span><span class="s1">self._lists))</span>

        <span class="s3">if </span><span class="s1">len(row0) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self._index[:] = row0</span>
            <span class="s1">self._offset = </span><span class="s4">0</span>
            <span class="s3">return</span>

        <span class="s1">head = iter(row0)</span>
        <span class="s1">tail = iter(head)</span>
        <span class="s1">row1 = list(starmap(add</span><span class="s3">, </span><span class="s1">zip(head</span><span class="s3">, </span><span class="s1">tail)))</span>

        <span class="s3">if </span><span class="s1">len(row0) &amp; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">row1.append(row0[-</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s3">if </span><span class="s1">len(row1) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self._index[:] = row1 + row0</span>
            <span class="s1">self._offset = </span><span class="s4">1</span>
            <span class="s3">return</span>

        <span class="s1">size = </span><span class="s4">2 </span><span class="s1">** (int(log(len(row1) - </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)) + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">row1.extend(repeat(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">size - len(row1)))</span>
        <span class="s1">tree = [row0</span><span class="s3">, </span><span class="s1">row1]</span>

        <span class="s3">while </span><span class="s1">len(tree[-</span><span class="s4">1</span><span class="s1">]) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">head = iter(tree[-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">tail = iter(head)</span>
            <span class="s1">row = list(starmap(add</span><span class="s3">, </span><span class="s1">zip(head</span><span class="s3">, </span><span class="s1">tail)))</span>
            <span class="s1">tree.append(row)</span>

        <span class="s1">reduce(iadd</span><span class="s3">, </span><span class="s1">reversed(tree)</span><span class="s3">, </span><span class="s1">self._index)</span>
        <span class="s1">self._offset = size * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span>


    <span class="s3">def </span><span class="s1">__delitem__(self</span><span class="s3">, </span><span class="s1">index):</span>
        <span class="s0">&quot;&quot;&quot;Remove value at `index` from sorted list. 
 
        ``sl.__delitem__(index)`` &lt;==&gt; ``del sl[index]`` 
 
        Supports slicing. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList('abcde') 
        &gt;&gt;&gt; del sl[2] 
        &gt;&gt;&gt; sl 
        SortedList(['a', 'b', 'd', 'e']) 
        &gt;&gt;&gt; del sl[:2] 
        &gt;&gt;&gt; sl 
        SortedList(['d', 'e']) 
 
        :param index: integer or slice for indexing 
        :raises IndexError: if index out of range 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">isinstance(index</span><span class="s3">, </span><span class="s1">slice):</span>
            <span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step = index.indices(self._len)</span>

            <span class="s3">if </span><span class="s1">step == </span><span class="s4">1 </span><span class="s3">and </span><span class="s1">start &lt; stop:</span>
                <span class="s3">if </span><span class="s1">start == </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">stop == self._len:</span>
                    <span class="s3">return </span><span class="s1">self._clear()</span>
                <span class="s3">elif </span><span class="s1">self._len &lt;= </span><span class="s4">8 </span><span class="s1">* (stop - start):</span>
                    <span class="s1">values = self._getitem(slice(</span><span class="s3">None, </span><span class="s1">start))</span>
                    <span class="s3">if </span><span class="s1">stop &lt; self._len:</span>
                        <span class="s1">values += self._getitem(slice(stop</span><span class="s3">, None</span><span class="s1">))</span>
                    <span class="s1">self._clear()</span>
                    <span class="s3">return </span><span class="s1">self._update(values)</span>

            <span class="s1">indices = range(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step)</span>

            <span class="s2"># Delete items from greatest index to least so</span>
            <span class="s2"># that the indices remain valid throughout iteration.</span>

            <span class="s3">if </span><span class="s1">step &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">indices = reversed(indices)</span>

            <span class="s1">_pos</span><span class="s3">, </span><span class="s1">_delete = self._pos</span><span class="s3">, </span><span class="s1">self._delete</span>

            <span class="s3">for </span><span class="s1">index </span><span class="s3">in </span><span class="s1">indices:</span>
                <span class="s1">pos</span><span class="s3">, </span><span class="s1">idx = _pos(index)</span>
                <span class="s1">_delete(pos</span><span class="s3">, </span><span class="s1">idx)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pos</span><span class="s3">, </span><span class="s1">idx = self._pos(index)</span>
            <span class="s1">self._delete(pos</span><span class="s3">, </span><span class="s1">idx)</span>


    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">index):</span>
        <span class="s0">&quot;&quot;&quot;Lookup value at `index` in sorted list. 
 
        ``sl.__getitem__(index)`` &lt;==&gt; ``sl[index]`` 
 
        Supports slicing. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList('abcde') 
        &gt;&gt;&gt; sl[1] 
        'b' 
        &gt;&gt;&gt; sl[-1] 
        'e' 
        &gt;&gt;&gt; sl[2:5] 
        ['c', 'd', 'e'] 
 
        :param index: integer or slice for indexing 
        :return: value or list of values 
        :raises IndexError: if index out of range 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>

        <span class="s3">if </span><span class="s1">isinstance(index</span><span class="s3">, </span><span class="s1">slice):</span>
            <span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step = index.indices(self._len)</span>

            <span class="s3">if </span><span class="s1">step == </span><span class="s4">1 </span><span class="s3">and </span><span class="s1">start &lt; stop:</span>
                <span class="s2"># Whole slice optimization: start to stop slices the whole</span>
                <span class="s2"># sorted list.</span>

                <span class="s3">if </span><span class="s1">start == </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">stop == self._len:</span>
                    <span class="s3">return </span><span class="s1">reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[])</span>

                <span class="s1">start_pos</span><span class="s3">, </span><span class="s1">start_idx = self._pos(start)</span>
                <span class="s1">start_list = _lists[start_pos]</span>
                <span class="s1">stop_idx = start_idx + stop - start</span>

                <span class="s2"># Small slice optimization: start index and stop index are</span>
                <span class="s2"># within the start list.</span>

                <span class="s3">if </span><span class="s1">len(start_list) &gt;= stop_idx:</span>
                    <span class="s3">return </span><span class="s1">start_list[start_idx:stop_idx]</span>

                <span class="s3">if </span><span class="s1">stop == self._len:</span>
                    <span class="s1">stop_pos = len(_lists) - </span><span class="s4">1</span>
                    <span class="s1">stop_idx = len(_lists[stop_pos])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">stop_pos</span><span class="s3">, </span><span class="s1">stop_idx = self._pos(stop)</span>

                <span class="s1">prefix = _lists[start_pos][start_idx:]</span>
                <span class="s1">middle = _lists[(start_pos + </span><span class="s4">1</span><span class="s1">):stop_pos]</span>
                <span class="s1">result = reduce(iadd</span><span class="s3">, </span><span class="s1">middle</span><span class="s3">, </span><span class="s1">prefix)</span>
                <span class="s1">result += _lists[stop_pos][:stop_idx]</span>

                <span class="s3">return </span><span class="s1">result</span>

            <span class="s3">if </span><span class="s1">step == -</span><span class="s4">1 </span><span class="s3">and </span><span class="s1">start &gt; stop:</span>
                <span class="s1">result = self._getitem(slice(stop + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">start + </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">result.reverse()</span>
                <span class="s3">return </span><span class="s1">result</span>

            <span class="s2"># Return a list because a negative step could</span>
            <span class="s2"># reverse the order of the items and this could</span>
            <span class="s2"># be the desired behavior.</span>

            <span class="s1">indices = range(start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step)</span>
            <span class="s3">return </span><span class="s1">list(self._getitem(index) </span><span class="s3">for </span><span class="s1">index </span><span class="s3">in </span><span class="s1">indices)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self._len:</span>
                <span class="s3">if </span><span class="s1">index == </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">_lists[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s3">elif </span><span class="s1">index == -</span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s3">return </span><span class="s1">_lists[-</span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s5">'list index out of range'</span><span class="s1">)</span>

            <span class="s3">if </span><span class="s4">0 </span><span class="s1">&lt;= index &lt; len(_lists[</span><span class="s4">0</span><span class="s1">]):</span>
                <span class="s3">return </span><span class="s1">_lists[</span><span class="s4">0</span><span class="s1">][index]</span>

            <span class="s1">len_last = len(_lists[-</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s3">if </span><span class="s1">-len_last &lt; index &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">_lists[-</span><span class="s4">1</span><span class="s1">][len_last + index]</span>

            <span class="s1">pos</span><span class="s3">, </span><span class="s1">idx = self._pos(index)</span>
            <span class="s3">return </span><span class="s1">_lists[pos][idx]</span>

    <span class="s1">_getitem = __getitem__</span>


    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Raise not-implemented error. 
 
        ``sl.__setitem__(index, value)`` &lt;==&gt; ``sl[index] = value`` 
 
        :raises NotImplementedError: use ``del sl[index]`` and 
            ``sl.add(value)`` instead 
 
        &quot;&quot;&quot;</span>
        <span class="s1">message = </span><span class="s5">'use ``del sl[index]`` and ``sl.add(value)`` instead'</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(message)</span>


    <span class="s3">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return an iterator over the sorted list. 
 
        ``sl.__iter__()`` &lt;==&gt; ``iter(sl)`` 
 
        Iterating the sorted list while adding or deleting values may raise a 
        :exc:`RuntimeError` or fail to iterate over all values. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">chain.from_iterable(self._lists)</span>


    <span class="s3">def </span><span class="s1">__reversed__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a reverse iterator over the sorted list. 
 
        ``sl.__reversed__()`` &lt;==&gt; ``reversed(sl)`` 
 
        Iterating the sorted list while adding or deleting values may raise a 
        :exc:`RuntimeError` or fail to iterate over all values. 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">chain.from_iterable(map(reversed</span><span class="s3">, </span><span class="s1">reversed(self._lists)))</span>


    <span class="s3">def </span><span class="s1">reverse(self):</span>
        <span class="s0">&quot;&quot;&quot;Raise not-implemented error. 
 
        Sorted list maintains values in ascending sort order. Values may not be 
        reversed in-place. 
 
        Use ``reversed(sl)`` for an iterator over values in descending sort 
        order. 
 
        Implemented to override `MutableSequence.reverse` which provides an 
        erroneous default implementation. 
 
        :raises NotImplementedError: use ``reversed(sl)`` instead 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'use ``reversed(sl)`` instead'</span><span class="s1">)</span>


    <span class="s3">def </span><span class="s1">islice(self</span><span class="s3">, </span><span class="s1">start=</span><span class="s3">None, </span><span class="s1">stop=</span><span class="s3">None, </span><span class="s1">reverse=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return an iterator that slices sorted list from `start` to `stop`. 
 
        The `start` and `stop` index are treated inclusive and exclusive, 
        respectively. 
 
        Both `start` and `stop` default to `None` which is automatically 
        inclusive of the beginning and end of the sorted list. 
 
        When `reverse` is `True` the values are yielded from the iterator in 
        reverse order; `reverse` defaults to `False`. 
 
        &gt;&gt;&gt; sl = SortedList('abcdefghij') 
        &gt;&gt;&gt; it = sl.islice(2, 6) 
        &gt;&gt;&gt; list(it) 
        ['c', 'd', 'e', 'f'] 
 
        :param int start: start index (inclusive) 
        :param int stop: stop index (exclusive) 
        :param bool reverse: yield values in reverse order 
        :return: iterator 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_len = self._len</span>

        <span class="s3">if not </span><span class="s1">_len:</span>
            <span class="s3">return </span><span class="s1">iter(())</span>

        <span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">_ = slice(start</span><span class="s3">, </span><span class="s1">stop).indices(self._len)</span>

        <span class="s3">if </span><span class="s1">start &gt;= stop:</span>
            <span class="s3">return </span><span class="s1">iter(())</span>

        <span class="s1">_pos = self._pos</span>

        <span class="s1">min_pos</span><span class="s3">, </span><span class="s1">min_idx = _pos(start)</span>

        <span class="s3">if </span><span class="s1">stop == _len:</span>
            <span class="s1">max_pos = len(self._lists) - </span><span class="s4">1</span>
            <span class="s1">max_idx = len(self._lists[-</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">max_pos</span><span class="s3">, </span><span class="s1">max_idx = _pos(stop)</span>

        <span class="s3">return </span><span class="s1">self._islice(min_pos</span><span class="s3">, </span><span class="s1">min_idx</span><span class="s3">, </span><span class="s1">max_pos</span><span class="s3">, </span><span class="s1">max_idx</span><span class="s3">, </span><span class="s1">reverse)</span>


    <span class="s3">def </span><span class="s1">_islice(self</span><span class="s3">, </span><span class="s1">min_pos</span><span class="s3">, </span><span class="s1">min_idx</span><span class="s3">, </span><span class="s1">max_pos</span><span class="s3">, </span><span class="s1">max_idx</span><span class="s3">, </span><span class="s1">reverse):</span>
        <span class="s0">&quot;&quot;&quot;Return an iterator that slices sorted list using two index pairs. 
 
        The index pairs are (min_pos, min_idx) and (max_pos, max_idx), the 
        first inclusive and the latter exclusive. See `_pos` for details on how 
        an index is converted to an index pair. 
 
        When `reverse` is `True`, values are yielded from the iterator in 
        reverse order. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>

        <span class="s3">if </span><span class="s1">min_pos &gt; max_pos:</span>
            <span class="s3">return </span><span class="s1">iter(())</span>

        <span class="s3">if </span><span class="s1">min_pos == max_pos:</span>
            <span class="s3">if </span><span class="s1">reverse:</span>
                <span class="s1">indices = reversed(range(min_idx</span><span class="s3">, </span><span class="s1">max_idx))</span>
                <span class="s3">return </span><span class="s1">map(_lists[min_pos].__getitem__</span><span class="s3">, </span><span class="s1">indices)</span>

            <span class="s1">indices = range(min_idx</span><span class="s3">, </span><span class="s1">max_idx)</span>
            <span class="s3">return </span><span class="s1">map(_lists[min_pos].__getitem__</span><span class="s3">, </span><span class="s1">indices)</span>

        <span class="s1">next_pos = min_pos + </span><span class="s4">1</span>

        <span class="s3">if </span><span class="s1">next_pos == max_pos:</span>
            <span class="s3">if </span><span class="s1">reverse:</span>
                <span class="s1">min_indices = range(min_idx</span><span class="s3">, </span><span class="s1">len(_lists[min_pos]))</span>
                <span class="s1">max_indices = range(max_idx)</span>
                <span class="s3">return </span><span class="s1">chain(</span>
                    <span class="s1">map(_lists[max_pos].__getitem__</span><span class="s3">, </span><span class="s1">reversed(max_indices))</span><span class="s3">,</span>
                    <span class="s1">map(_lists[min_pos].__getitem__</span><span class="s3">, </span><span class="s1">reversed(min_indices))</span><span class="s3">,</span>
                <span class="s1">)</span>

            <span class="s1">min_indices = range(min_idx</span><span class="s3">, </span><span class="s1">len(_lists[min_pos]))</span>
            <span class="s1">max_indices = range(max_idx)</span>
            <span class="s3">return </span><span class="s1">chain(</span>
                <span class="s1">map(_lists[min_pos].__getitem__</span><span class="s3">, </span><span class="s1">min_indices)</span><span class="s3">,</span>
                <span class="s1">map(_lists[max_pos].__getitem__</span><span class="s3">, </span><span class="s1">max_indices)</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">reverse:</span>
            <span class="s1">min_indices = range(min_idx</span><span class="s3">, </span><span class="s1">len(_lists[min_pos]))</span>
            <span class="s1">sublist_indices = range(next_pos</span><span class="s3">, </span><span class="s1">max_pos)</span>
            <span class="s1">sublists = map(_lists.__getitem__</span><span class="s3">, </span><span class="s1">reversed(sublist_indices))</span>
            <span class="s1">max_indices = range(max_idx)</span>
            <span class="s3">return </span><span class="s1">chain(</span>
                <span class="s1">map(_lists[max_pos].__getitem__</span><span class="s3">, </span><span class="s1">reversed(max_indices))</span><span class="s3">,</span>
                <span class="s1">chain.from_iterable(map(reversed</span><span class="s3">, </span><span class="s1">sublists))</span><span class="s3">,</span>
                <span class="s1">map(_lists[min_pos].__getitem__</span><span class="s3">, </span><span class="s1">reversed(min_indices))</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s1">min_indices = range(min_idx</span><span class="s3">, </span><span class="s1">len(_lists[min_pos]))</span>
        <span class="s1">sublist_indices = range(next_pos</span><span class="s3">, </span><span class="s1">max_pos)</span>
        <span class="s1">sublists = map(_lists.__getitem__</span><span class="s3">, </span><span class="s1">sublist_indices)</span>
        <span class="s1">max_indices = range(max_idx)</span>
        <span class="s3">return </span><span class="s1">chain(</span>
            <span class="s1">map(_lists[min_pos].__getitem__</span><span class="s3">, </span><span class="s1">min_indices)</span><span class="s3">,</span>
            <span class="s1">chain.from_iterable(sublists)</span><span class="s3">,</span>
            <span class="s1">map(_lists[max_pos].__getitem__</span><span class="s3">, </span><span class="s1">max_indices)</span><span class="s3">,</span>
        <span class="s1">)</span>


    <span class="s3">def </span><span class="s1">irange(self</span><span class="s3">, </span><span class="s1">minimum=</span><span class="s3">None, </span><span class="s1">maximum=</span><span class="s3">None, </span><span class="s1">inclusive=(</span><span class="s3">True, True</span><span class="s1">)</span><span class="s3">,</span>
               <span class="s1">reverse=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create an iterator of values between `minimum` and `maximum`. 
 
        Both `minimum` and `maximum` default to `None` which is automatically 
        inclusive of the beginning and end of the sorted list. 
 
        The argument `inclusive` is a pair of booleans that indicates whether 
        the minimum and maximum ought to be included in the range, 
        respectively. The default is ``(True, True)`` such that the range is 
        inclusive of both minimum and maximum. 
 
        When `reverse` is `True` the values are yielded from the iterator in 
        reverse order; `reverse` defaults to `False`. 
 
        &gt;&gt;&gt; sl = SortedList('abcdefghij') 
        &gt;&gt;&gt; it = sl.irange('c', 'f') 
        &gt;&gt;&gt; list(it) 
        ['c', 'd', 'e', 'f'] 
 
        :param minimum: minimum value to start iterating 
        :param maximum: maximum value to stop iterating 
        :param inclusive: pair of booleans 
        :param bool reverse: yield values in reverse order 
        :return: iterator 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return </span><span class="s1">iter(())</span>

        <span class="s1">_lists = self._lists</span>

        <span class="s2"># Calculate the minimum (pos, idx) pair. By default this location</span>
        <span class="s2"># will be inclusive in our calculation.</span>

        <span class="s3">if </span><span class="s1">minimum </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">min_pos = </span><span class="s4">0</span>
            <span class="s1">min_idx = </span><span class="s4">0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">inclusive[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s1">min_pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">minimum)</span>

                <span class="s3">if </span><span class="s1">min_pos == len(_maxes):</span>
                    <span class="s3">return </span><span class="s1">iter(())</span>

                <span class="s1">min_idx = bisect_left(_lists[min_pos]</span><span class="s3">, </span><span class="s1">minimum)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">min_pos = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">minimum)</span>

                <span class="s3">if </span><span class="s1">min_pos == len(_maxes):</span>
                    <span class="s3">return </span><span class="s1">iter(())</span>

                <span class="s1">min_idx = bisect_right(_lists[min_pos]</span><span class="s3">, </span><span class="s1">minimum)</span>

        <span class="s2"># Calculate the maximum (pos, idx) pair. By default this location</span>
        <span class="s2"># will be exclusive in our calculation.</span>

        <span class="s3">if </span><span class="s1">maximum </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">max_pos = len(_maxes) - </span><span class="s4">1</span>
            <span class="s1">max_idx = len(_lists[max_pos])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">inclusive[</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">max_pos = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">maximum)</span>

                <span class="s3">if </span><span class="s1">max_pos == len(_maxes):</span>
                    <span class="s1">max_pos -= </span><span class="s4">1</span>
                    <span class="s1">max_idx = len(_lists[max_pos])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">max_idx = bisect_right(_lists[max_pos]</span><span class="s3">, </span><span class="s1">maximum)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">max_pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">maximum)</span>

                <span class="s3">if </span><span class="s1">max_pos == len(_maxes):</span>
                    <span class="s1">max_pos -= </span><span class="s4">1</span>
                    <span class="s1">max_idx = len(_lists[max_pos])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">max_idx = bisect_left(_lists[max_pos]</span><span class="s3">, </span><span class="s1">maximum)</span>

        <span class="s3">return </span><span class="s1">self._islice(min_pos</span><span class="s3">, </span><span class="s1">min_idx</span><span class="s3">, </span><span class="s1">max_pos</span><span class="s3">, </span><span class="s1">max_idx</span><span class="s3">, </span><span class="s1">reverse)</span>


    <span class="s3">def </span><span class="s1">__len__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the size of the sorted list. 
 
        ``sl.__len__()`` &lt;==&gt; ``len(sl)`` 
 
        :return: size of sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._len</span>


    <span class="s3">def </span><span class="s1">bisect_left(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Return an index to insert `value` in the sorted list. 
 
        If the `value` is already present, the insertion point will be before 
        (to the left of) any existing values. 
 
        Similar to the `bisect` module in the standard library. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList([10, 11, 12, 13, 14]) 
        &gt;&gt;&gt; sl.bisect_left(12) 
        2 
 
        :param value: insertion index of value in sorted list 
        :return: index 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return </span><span class="s4">0</span>

        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return </span><span class="s1">self._len</span>

        <span class="s1">idx = bisect_left(self._lists[pos]</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">return </span><span class="s1">self._loc(pos</span><span class="s3">, </span><span class="s1">idx)</span>


    <span class="s3">def </span><span class="s1">bisect_right(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Return an index to insert `value` in the sorted list. 
 
        Similar to `bisect_left`, but if `value` is already present, the 
        insertion point will be after (to the right of) any existing values. 
 
        Similar to the `bisect` module in the standard library. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList([10, 11, 12, 13, 14]) 
        &gt;&gt;&gt; sl.bisect_right(12) 
        3 
 
        :param value: insertion index of value in sorted list 
        :return: index 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return </span><span class="s4">0</span>

        <span class="s1">pos = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return </span><span class="s1">self._len</span>

        <span class="s1">idx = bisect_right(self._lists[pos]</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s3">return </span><span class="s1">self._loc(pos</span><span class="s3">, </span><span class="s1">idx)</span>

    <span class="s1">bisect = bisect_right</span>
    <span class="s1">_bisect_right = bisect_right</span>


    <span class="s3">def </span><span class="s1">count(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Return number of occurrences of `value` in the sorted list. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]) 
        &gt;&gt;&gt; sl.count(3) 
        3 
 
        :param value: value to count in sorted list 
        :return: count 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return </span><span class="s4">0</span>

        <span class="s1">pos_left = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos_left == len(_maxes):</span>
            <span class="s3">return </span><span class="s4">0</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">idx_left = bisect_left(_lists[pos_left]</span><span class="s3">, </span><span class="s1">value)</span>
        <span class="s1">pos_right = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos_right == len(_maxes):</span>
            <span class="s3">return </span><span class="s1">self._len - self._loc(pos_left</span><span class="s3">, </span><span class="s1">idx_left)</span>

        <span class="s1">idx_right = bisect_right(_lists[pos_right]</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos_left == pos_right:</span>
            <span class="s3">return </span><span class="s1">idx_right - idx_left</span>

        <span class="s1">right = self._loc(pos_right</span><span class="s3">, </span><span class="s1">idx_right)</span>
        <span class="s1">left = self._loc(pos_left</span><span class="s3">, </span><span class="s1">idx_left)</span>
        <span class="s3">return </span><span class="s1">right - left</span>


    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a shallow copy of the sorted list. 
 
        Runtime complexity: `O(n)` 
 
        :return: new sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.__class__(self)</span>

    <span class="s1">__copy__ = copy</span>


    <span class="s3">def </span><span class="s1">append(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Raise not-implemented error. 
 
        Implemented to override `MutableSequence.append` which provides an 
        erroneous default implementation. 
 
        :raises NotImplementedError: use ``sl.add(value)`` instead 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'use ``sl.add(value)`` instead'</span><span class="s1">)</span>


    <span class="s3">def </span><span class="s1">extend(self</span><span class="s3">, </span><span class="s1">values):</span>
        <span class="s0">&quot;&quot;&quot;Raise not-implemented error. 
 
        Implemented to override `MutableSequence.extend` which provides an 
        erroneous default implementation. 
 
        :raises NotImplementedError: use ``sl.update(values)`` instead 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'use ``sl.update(values)`` instead'</span><span class="s1">)</span>


    <span class="s3">def </span><span class="s1">insert(self</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Raise not-implemented error. 
 
        :raises NotImplementedError: use ``sl.add(value)`` instead 
 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'use ``sl.add(value)`` instead'</span><span class="s1">)</span>


    <span class="s3">def </span><span class="s1">pop(self</span><span class="s3">, </span><span class="s1">index=-</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Remove and return value at `index` in sorted list. 
 
        Raise :exc:`IndexError` if the sorted list is empty or index is out of 
        range. 
 
        Negative indices are supported. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList('abcde') 
        &gt;&gt;&gt; sl.pop() 
        'e' 
        &gt;&gt;&gt; sl.pop(2) 
        'c' 
        &gt;&gt;&gt; sl 
        SortedList(['a', 'b', 'd']) 
 
        :param int index: index of value (default -1) 
        :return: value 
        :raises IndexError: if index is out of range 
 
        &quot;&quot;&quot;</span>
        <span class="s3">if not </span><span class="s1">self._len:</span>
            <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s5">'pop index out of range'</span><span class="s1">)</span>

        <span class="s1">_lists = self._lists</span>

        <span class="s3">if </span><span class="s1">index == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">val = _lists[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">self._delete(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">val</span>

        <span class="s3">if </span><span class="s1">index == -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">pos = len(_lists) - </span><span class="s4">1</span>
            <span class="s1">loc = len(_lists[pos]) - </span><span class="s4">1</span>
            <span class="s1">val = _lists[pos][loc]</span>
            <span class="s1">self._delete(pos</span><span class="s3">, </span><span class="s1">loc)</span>
            <span class="s3">return </span><span class="s1">val</span>

        <span class="s3">if </span><span class="s4">0 </span><span class="s1">&lt;= index &lt; len(_lists[</span><span class="s4">0</span><span class="s1">]):</span>
            <span class="s1">val = _lists[</span><span class="s4">0</span><span class="s1">][index]</span>
            <span class="s1">self._delete(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">index)</span>
            <span class="s3">return </span><span class="s1">val</span>

        <span class="s1">len_last = len(_lists[-</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s3">if </span><span class="s1">-len_last &lt; index &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">pos = len(_lists) - </span><span class="s4">1</span>
            <span class="s1">loc = len_last + index</span>
            <span class="s1">val = _lists[pos][loc]</span>
            <span class="s1">self._delete(pos</span><span class="s3">, </span><span class="s1">loc)</span>
            <span class="s3">return </span><span class="s1">val</span>

        <span class="s1">pos</span><span class="s3">, </span><span class="s1">idx = self._pos(index)</span>
        <span class="s1">val = _lists[pos][idx]</span>
        <span class="s1">self._delete(pos</span><span class="s3">, </span><span class="s1">idx)</span>
        <span class="s3">return </span><span class="s1">val</span>


    <span class="s3">def </span><span class="s1">index(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">start=</span><span class="s3">None, </span><span class="s1">stop=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return first index of value in sorted list. 
 
        Raise ValueError if `value` is not present. 
 
        Index must be between `start` and `stop` for the `value` to be 
        considered present. The default value, None, for `start` and `stop` 
        indicate the beginning and end of the sorted list. 
 
        Negative indices are supported. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList('abcde') 
        &gt;&gt;&gt; sl.index('d') 
        3 
        &gt;&gt;&gt; sl.index('z') 
        Traceback (most recent call last): 
          ... 
        ValueError: 'z' is not in list 
 
        :param value: value in sorted list 
        :param int start: start index (default None, start of sorted list) 
        :param int stop: stop index (default None, end of sorted list) 
        :return: index of value 
        :raises ValueError: if value is not present 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_len = self._len</span>

        <span class="s3">if not </span><span class="s1">_len:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>

        <span class="s3">if </span><span class="s1">start </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">start = </span><span class="s4">0</span>
        <span class="s3">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start += _len</span>
        <span class="s3">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start = </span><span class="s4">0</span>

        <span class="s3">if </span><span class="s1">stop </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">stop = _len</span>
        <span class="s3">if </span><span class="s1">stop &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">stop += _len</span>
        <span class="s3">if </span><span class="s1">stop &gt; _len:</span>
            <span class="s1">stop = _len</span>

        <span class="s3">if </span><span class="s1">stop &lt;= start:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">_maxes = self._maxes</span>
        <span class="s1">pos_left = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">pos_left == len(_maxes):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">idx_left = bisect_left(_lists[pos_left]</span><span class="s3">, </span><span class="s1">value)</span>

        <span class="s3">if </span><span class="s1">_lists[pos_left][idx_left] != value:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">stop -= </span><span class="s4">1</span>
        <span class="s1">left = self._loc(pos_left</span><span class="s3">, </span><span class="s1">idx_left)</span>

        <span class="s3">if </span><span class="s1">start &lt;= left:</span>
            <span class="s3">if </span><span class="s1">left &lt;= stop:</span>
                <span class="s3">return </span><span class="s1">left</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">right = self._bisect_right(value) - </span><span class="s4">1</span>

            <span class="s3">if </span><span class="s1">start &lt;= right:</span>
                <span class="s3">return </span><span class="s1">start</span>

        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>


    <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Return new sorted list containing all values in both sequences. 
 
        ``sl.__add__(other)`` &lt;==&gt; ``sl + other`` 
 
        Values in `other` do not need to be in sorted order. 
 
        Runtime complexity: `O(n*log(n))` 
 
        &gt;&gt;&gt; sl1 = SortedList('bat') 
        &gt;&gt;&gt; sl2 = SortedList('cat') 
        &gt;&gt;&gt; sl1 + sl2 
        SortedList(['a', 'a', 'b', 'c', 't', 't']) 
 
        :param other: other iterable 
        :return: new sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s1">values.extend(other)</span>
        <span class="s3">return </span><span class="s1">self.__class__(values)</span>

    <span class="s1">__radd__ = __add__</span>


    <span class="s3">def </span><span class="s1">__iadd__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Update sorted list with values from `other`. 
 
        ``sl.__iadd__(other)`` &lt;==&gt; ``sl += other`` 
 
        Values in `other` do not need to be in sorted order. 
 
        Runtime complexity: `O(k*log(n))` -- approximate. 
 
        &gt;&gt;&gt; sl = SortedList('bat') 
        &gt;&gt;&gt; sl += 'cat' 
        &gt;&gt;&gt; sl 
        SortedList(['a', 'a', 'b', 'c', 't', 't']) 
 
        :param other: other iterable 
        :return: existing sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._update(other)</span>
        <span class="s3">return </span><span class="s1">self</span>


    <span class="s3">def </span><span class="s1">__mul__(self</span><span class="s3">, </span><span class="s1">num):</span>
        <span class="s0">&quot;&quot;&quot;Return new sorted list with `num` shallow copies of values. 
 
        ``sl.__mul__(num)`` &lt;==&gt; ``sl * num`` 
 
        Runtime complexity: `O(n*log(n))` 
 
        &gt;&gt;&gt; sl = SortedList('abc') 
        &gt;&gt;&gt; sl * 3 
        SortedList(['a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'c']) 
 
        :param int num: count of shallow copies 
        :return: new sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[]) * num</span>
        <span class="s3">return </span><span class="s1">self.__class__(values)</span>

    <span class="s1">__rmul__ = __mul__</span>


    <span class="s3">def </span><span class="s1">__imul__(self</span><span class="s3">, </span><span class="s1">num):</span>
        <span class="s0">&quot;&quot;&quot;Update the sorted list with `num` shallow copies of values. 
 
        ``sl.__imul__(num)`` &lt;==&gt; ``sl *= num`` 
 
        Runtime complexity: `O(n*log(n))` 
 
        &gt;&gt;&gt; sl = SortedList('abc') 
        &gt;&gt;&gt; sl *= 3 
        &gt;&gt;&gt; sl 
        SortedList(['a', 'a', 'a', 'b', 'b', 'b', 'c', 'c', 'c']) 
 
        :param int num: count of shallow copies 
        :return: existing sorted list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[]) * num</span>
        <span class="s1">self._clear()</span>
        <span class="s1">self._update(values)</span>
        <span class="s3">return </span><span class="s1">self</span>


    <span class="s3">def </span><span class="s1">__make_cmp(seq_op</span><span class="s3">, </span><span class="s1">symbol</span><span class="s3">, </span><span class="s1">doc):</span>
        <span class="s0">&quot;Make comparator method.&quot;</span>
        <span class="s3">def </span><span class="s1">comparer(self</span><span class="s3">, </span><span class="s1">other):</span>
            <span class="s0">&quot;Compare method for sorted list and sequence.&quot;</span>
            <span class="s3">if not </span><span class="s1">isinstance(other</span><span class="s3">, </span><span class="s1">Sequence):</span>
                <span class="s3">return </span><span class="s1">NotImplemented</span>

            <span class="s1">self_len = self._len</span>
            <span class="s1">len_other = len(other)</span>

            <span class="s3">if </span><span class="s1">self_len != len_other:</span>
                <span class="s3">if </span><span class="s1">seq_op </span><span class="s3">is </span><span class="s1">eq:</span>
                    <span class="s3">return False</span>
                <span class="s3">if </span><span class="s1">seq_op </span><span class="s3">is </span><span class="s1">ne:</span>
                    <span class="s3">return True</span>

            <span class="s3">for </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta </span><span class="s3">in </span><span class="s1">zip(self</span><span class="s3">, </span><span class="s1">other):</span>
                <span class="s3">if </span><span class="s1">alpha != beta:</span>
                    <span class="s3">return </span><span class="s1">seq_op(alpha</span><span class="s3">, </span><span class="s1">beta)</span>

            <span class="s3">return </span><span class="s1">seq_op(self_len</span><span class="s3">, </span><span class="s1">len_other)</span>

        <span class="s1">seq_op_name = seq_op.__name__</span>
        <span class="s1">comparer.__name__ = </span><span class="s5">'__{0}__'</span><span class="s1">.format(seq_op_name)</span>
        <span class="s1">doc_str = </span><span class="s5">&quot;&quot;&quot;Return true if and only if sorted list is {0} `other`. 
 
        ``sl.__{1}__(other)`` &lt;==&gt; ``sl {2} other`` 
 
        Comparisons use lexicographical order as with sequences. 
 
        Runtime complexity: `O(n)` 
 
        :param other: `other` sequence 
        :return: true if sorted list is {0} `other` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">comparer.__doc__ = dedent(doc_str.format(doc</span><span class="s3">, </span><span class="s1">seq_op_name</span><span class="s3">, </span><span class="s1">symbol))</span>
        <span class="s3">return </span><span class="s1">comparer</span>


    <span class="s1">__eq__ = __make_cmp(eq</span><span class="s3">, </span><span class="s5">'=='</span><span class="s3">, </span><span class="s5">'equal to'</span><span class="s1">)</span>
    <span class="s1">__ne__ = __make_cmp(ne</span><span class="s3">, </span><span class="s5">'!='</span><span class="s3">, </span><span class="s5">'not equal to'</span><span class="s1">)</span>
    <span class="s1">__lt__ = __make_cmp(lt</span><span class="s3">, </span><span class="s5">'&lt;'</span><span class="s3">, </span><span class="s5">'less than'</span><span class="s1">)</span>
    <span class="s1">__gt__ = __make_cmp(gt</span><span class="s3">, </span><span class="s5">'&gt;'</span><span class="s3">, </span><span class="s5">'greater than'</span><span class="s1">)</span>
    <span class="s1">__le__ = __make_cmp(le</span><span class="s3">, </span><span class="s5">'&lt;='</span><span class="s3">, </span><span class="s5">'less than or equal to'</span><span class="s1">)</span>
    <span class="s1">__ge__ = __make_cmp(ge</span><span class="s3">, </span><span class="s5">'&gt;='</span><span class="s3">, </span><span class="s5">'greater than or equal to'</span><span class="s1">)</span>
    <span class="s1">__make_cmp = staticmethod(__make_cmp)</span>


    <span class="s3">def </span><span class="s1">__reduce__(self):</span>
        <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">return </span><span class="s1">(type(self)</span><span class="s3">, </span><span class="s1">(values</span><span class="s3">,</span><span class="s1">))</span>


    <span class="s1">@recursive_repr()</span>
    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return string representation of sorted list. 
 
        ``sl.__repr__()`` &lt;==&gt; ``repr(sl)`` 
 
        :return: string representation 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s5">'{0}({1!r})'</span><span class="s1">.format(type(self).__name__</span><span class="s3">, </span><span class="s1">list(self))</span>


    <span class="s3">def </span><span class="s1">_check(self):</span>
        <span class="s0">&quot;&quot;&quot;Check invariants of sorted list. 
 
        Runtime complexity: `O(n)` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">self._load &gt;= </span><span class="s4">4</span>
            <span class="s3">assert </span><span class="s1">len(self._maxes) == len(self._lists)</span>
            <span class="s3">assert </span><span class="s1">self._len == sum(len(sublist) </span><span class="s3">for </span><span class="s1">sublist </span><span class="s3">in </span><span class="s1">self._lists)</span>

            <span class="s2"># Check all sublists are sorted.</span>

            <span class="s3">for </span><span class="s1">sublist </span><span class="s3">in </span><span class="s1">self._lists:</span>
                <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">len(sublist)):</span>
                    <span class="s3">assert </span><span class="s1">sublist[pos - </span><span class="s4">1</span><span class="s1">] &lt;= sublist[pos]</span>

            <span class="s2"># Check beginning/end of sublists are sorted.</span>

            <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">len(self._lists)):</span>
                <span class="s3">assert </span><span class="s1">self._lists[pos - </span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">] &lt;= self._lists[pos][</span><span class="s4">0</span><span class="s1">]</span>

            <span class="s2"># Check _maxes index is the last value of each sublist.</span>

            <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(len(self._maxes)):</span>
                <span class="s3">assert </span><span class="s1">self._maxes[pos] == self._lists[pos][-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s2"># Check sublist lengths are less than double load-factor.</span>

            <span class="s1">double = self._load &lt;&lt; </span><span class="s4">1</span>
            <span class="s3">assert </span><span class="s1">all(len(sublist) &lt;= double </span><span class="s3">for </span><span class="s1">sublist </span><span class="s3">in </span><span class="s1">self._lists)</span>

            <span class="s2"># Check sublist lengths are greater than half load-factor for all</span>
            <span class="s2"># but the last sublist.</span>

            <span class="s1">half = self._load &gt;&gt; </span><span class="s4">1</span>
            <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">len(self._lists) - </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s3">assert </span><span class="s1">len(self._lists[pos]) &gt;= half</span>

            <span class="s3">if </span><span class="s1">self._index:</span>
                <span class="s3">assert </span><span class="s1">self._len == self._index[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s3">assert </span><span class="s1">len(self._index) == self._offset + len(self._lists)</span>

                <span class="s2"># Check index leaf nodes equal length of sublists.</span>

                <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(len(self._lists)):</span>
                    <span class="s1">leaf = self._index[self._offset + pos]</span>
                    <span class="s3">assert </span><span class="s1">leaf == len(self._lists[pos])</span>

                <span class="s2"># Check index branch nodes are the sum of their children.</span>

                <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(self._offset):</span>
                    <span class="s1">child = (pos &lt;&lt; </span><span class="s4">1</span><span class="s1">) + </span><span class="s4">1</span>
                    <span class="s3">if </span><span class="s1">child &gt;= len(self._index):</span>
                        <span class="s3">assert </span><span class="s1">self._index[pos] == </span><span class="s4">0</span>
                    <span class="s3">elif </span><span class="s1">child + </span><span class="s4">1 </span><span class="s1">== len(self._index):</span>
                        <span class="s3">assert </span><span class="s1">self._index[pos] == self._index[child]</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">child_sum = self._index[child] + self._index[child + </span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s3">assert </span><span class="s1">child_sum == self._index[pos]</span>
        <span class="s3">except</span><span class="s1">:</span>
            <span class="s1">traceback.print_exc(file=sys.stdout)</span>
            <span class="s1">print(</span><span class="s5">'len'</span><span class="s3">, </span><span class="s1">self._len)</span>
            <span class="s1">print(</span><span class="s5">'load'</span><span class="s3">, </span><span class="s1">self._load)</span>
            <span class="s1">print(</span><span class="s5">'offset'</span><span class="s3">, </span><span class="s1">self._offset)</span>
            <span class="s1">print(</span><span class="s5">'len_index'</span><span class="s3">, </span><span class="s1">len(self._index))</span>
            <span class="s1">print(</span><span class="s5">'index'</span><span class="s3">, </span><span class="s1">self._index)</span>
            <span class="s1">print(</span><span class="s5">'len_maxes'</span><span class="s3">, </span><span class="s1">len(self._maxes))</span>
            <span class="s1">print(</span><span class="s5">'maxes'</span><span class="s3">, </span><span class="s1">self._maxes)</span>
            <span class="s1">print(</span><span class="s5">'len_lists'</span><span class="s3">, </span><span class="s1">len(self._lists))</span>
            <span class="s1">print(</span><span class="s5">'lists'</span><span class="s3">, </span><span class="s1">self._lists)</span>
            <span class="s3">raise</span>


<span class="s3">def </span><span class="s1">identity(value):</span>
    <span class="s0">&quot;Identity function.&quot;</span>
    <span class="s3">return </span><span class="s1">value</span>


<span class="s3">class </span><span class="s1">SortedKeyList(SortedList):</span>
    <span class="s0">&quot;&quot;&quot;Sorted-key list is a subtype of sorted list. 
 
    The sorted-key list maintains values in comparison order based on the 
    result of a key function applied to every value. 
 
    All the same methods that are available in :class:`SortedList` are also 
    available in :class:`SortedKeyList`. 
 
    Additional methods provided: 
 
    * :attr:`SortedKeyList.key` 
    * :func:`SortedKeyList.bisect_key_left` 
    * :func:`SortedKeyList.bisect_key_right` 
    * :func:`SortedKeyList.irange_key` 
 
    Some examples below use: 
 
    &gt;&gt;&gt; from operator import neg 
    &gt;&gt;&gt; neg 
    &lt;built-in function neg&gt; 
    &gt;&gt;&gt; neg(1) 
    -1 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">iterable=</span><span class="s3">None, </span><span class="s1">key=identity):</span>
        <span class="s0">&quot;&quot;&quot;Initialize sorted-key list instance. 
 
        Optional `iterable` argument provides an initial iterable of values to 
        initialize the sorted-key list. 
 
        Optional `key` argument defines a callable that, like the `key` 
        argument to Python's `sorted` function, extracts a comparison key from 
        each value. The default is the identity function. 
 
        Runtime complexity: `O(n*log(n))` 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList(key=neg) 
        &gt;&gt;&gt; skl 
        SortedKeyList([], key=&lt;built-in function neg&gt;) 
        &gt;&gt;&gt; skl = SortedKeyList([3, 1, 2], key=neg) 
        &gt;&gt;&gt; skl 
        SortedKeyList([3, 2, 1], key=&lt;built-in function neg&gt;) 
 
        :param iterable: initial values (optional) 
        :param key: function used to extract comparison key (optional) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._key = key</span>
        <span class="s1">self._len = </span><span class="s4">0</span>
        <span class="s1">self._load = self.DEFAULT_LOAD_FACTOR</span>
        <span class="s1">self._lists = []</span>
        <span class="s1">self._keys = []</span>
        <span class="s1">self._maxes = []</span>
        <span class="s1">self._index = []</span>
        <span class="s1">self._offset = </span><span class="s4">0</span>

        <span class="s3">if </span><span class="s1">iterable </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._update(iterable)</span>


    <span class="s3">def </span><span class="s1">__new__(cls</span><span class="s3">, </span><span class="s1">iterable=</span><span class="s3">None, </span><span class="s1">key=identity):</span>
        <span class="s3">return </span><span class="s1">object.__new__(cls)</span>


    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">key(self):</span>
        <span class="s0">&quot;Function used to extract comparison key from values.&quot;</span>
        <span class="s3">return </span><span class="s1">self._key</span>


    <span class="s3">def </span><span class="s1">clear(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove all values from sorted-key list. 
 
        Runtime complexity: `O(n)` 
 
        &quot;&quot;&quot;</span>
        <span class="s1">self._len = </span><span class="s4">0</span>
        <span class="s3">del </span><span class="s1">self._lists[:]</span>
        <span class="s3">del </span><span class="s1">self._keys[:]</span>
        <span class="s3">del </span><span class="s1">self._maxes[:]</span>
        <span class="s3">del </span><span class="s1">self._index[:]</span>

    <span class="s1">_clear = clear</span>


    <span class="s3">def </span><span class="s1">add(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Add `value` to sorted-key list. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList(key=neg) 
        &gt;&gt;&gt; skl.add(3) 
        &gt;&gt;&gt; skl.add(1) 
        &gt;&gt;&gt; skl.add(2) 
        &gt;&gt;&gt; skl 
        SortedKeyList([3, 2, 1], key=&lt;built-in function neg&gt;) 
 
        :param value: value to add to sorted-key list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s1">key = self._key(value)</span>

        <span class="s3">if </span><span class="s1">_maxes:</span>
            <span class="s1">pos = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">key)</span>

            <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
                <span class="s1">pos -= </span><span class="s4">1</span>
                <span class="s1">_lists[pos].append(value)</span>
                <span class="s1">_keys[pos].append(key)</span>
                <span class="s1">_maxes[pos] = key</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">idx = bisect_right(_keys[pos]</span><span class="s3">, </span><span class="s1">key)</span>
                <span class="s1">_lists[pos].insert(idx</span><span class="s3">, </span><span class="s1">value)</span>
                <span class="s1">_keys[pos].insert(idx</span><span class="s3">, </span><span class="s1">key)</span>

            <span class="s1">self._expand(pos)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_lists.append([value])</span>
            <span class="s1">_keys.append([key])</span>
            <span class="s1">_maxes.append(key)</span>

        <span class="s1">self._len += </span><span class="s4">1</span>


    <span class="s3">def </span><span class="s1">_expand(self</span><span class="s3">, </span><span class="s1">pos):</span>
        <span class="s0">&quot;&quot;&quot;Split sublists with length greater than double the load-factor. 
 
        Updates the index when the sublist length is less than double the load 
        level. This requires incrementing the nodes in a traversal from the 
        leaf node to the root. For an example traversal see 
        ``SortedList._loc``. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>
        <span class="s1">_index = self._index</span>

        <span class="s3">if </span><span class="s1">len(_keys[pos]) &gt; (self._load &lt;&lt; </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">_maxes = self._maxes</span>
            <span class="s1">_load = self._load</span>

            <span class="s1">_lists_pos = _lists[pos]</span>
            <span class="s1">_keys_pos = _keys[pos]</span>
            <span class="s1">half = _lists_pos[_load:]</span>
            <span class="s1">half_keys = _keys_pos[_load:]</span>
            <span class="s3">del </span><span class="s1">_lists_pos[_load:]</span>
            <span class="s3">del </span><span class="s1">_keys_pos[_load:]</span>
            <span class="s1">_maxes[pos] = _keys_pos[-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s1">_lists.insert(pos + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">half)</span>
            <span class="s1">_keys.insert(pos + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">half_keys)</span>
            <span class="s1">_maxes.insert(pos + </span><span class="s4">1</span><span class="s3">, </span><span class="s1">half_keys[-</span><span class="s4">1</span><span class="s1">])</span>

            <span class="s3">del </span><span class="s1">_index[:]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">_index:</span>
                <span class="s1">child = self._offset + pos</span>
                <span class="s3">while </span><span class="s1">child:</span>
                    <span class="s1">_index[child] += </span><span class="s4">1</span>
                    <span class="s1">child = (child - </span><span class="s4">1</span><span class="s1">) &gt;&gt; </span><span class="s4">1</span>
                <span class="s1">_index[</span><span class="s4">0</span><span class="s1">] += </span><span class="s4">1</span>


    <span class="s3">def </span><span class="s1">update(self</span><span class="s3">, </span><span class="s1">iterable):</span>
        <span class="s0">&quot;&quot;&quot;Update sorted-key list by adding all values from `iterable`. 
 
        Runtime complexity: `O(k*log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList(key=neg) 
        &gt;&gt;&gt; skl.update([3, 1, 2]) 
        &gt;&gt;&gt; skl 
        SortedKeyList([3, 2, 1], key=&lt;built-in function neg&gt;) 
 
        :param iterable: iterable of values to add 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>
        <span class="s1">_maxes = self._maxes</span>
        <span class="s1">values = sorted(iterable</span><span class="s3">, </span><span class="s1">key=self._key)</span>

        <span class="s3">if </span><span class="s1">_maxes:</span>
            <span class="s3">if </span><span class="s1">len(values) * </span><span class="s4">4 </span><span class="s1">&gt;= self._len:</span>
                <span class="s1">_lists.append(values)</span>
                <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">_lists</span><span class="s3">, </span><span class="s1">[])</span>
                <span class="s1">values.sort(key=self._key)</span>
                <span class="s1">self._clear()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">_add = self.add</span>
                <span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">values:</span>
                    <span class="s1">_add(val)</span>
                <span class="s3">return</span>

        <span class="s1">_load = self._load</span>
        <span class="s1">_lists.extend(values[pos:(pos + _load)]</span>
                      <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">len(values)</span><span class="s3">, </span><span class="s1">_load))</span>
        <span class="s1">_keys.extend(list(map(self._key</span><span class="s3">, </span><span class="s1">_list)) </span><span class="s3">for </span><span class="s1">_list </span><span class="s3">in </span><span class="s1">_lists)</span>
        <span class="s1">_maxes.extend(sublist[-</span><span class="s4">1</span><span class="s1">] </span><span class="s3">for </span><span class="s1">sublist </span><span class="s3">in </span><span class="s1">_keys)</span>
        <span class="s1">self._len = len(values)</span>
        <span class="s3">del </span><span class="s1">self._index[:]</span>

    <span class="s1">_update = update</span>


    <span class="s3">def </span><span class="s1">__contains__(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Return true if `value` is an element of the sorted-key list. 
 
        ``skl.__contains__(value)`` &lt;==&gt; ``value in skl`` 
 
        Runtime complexity: `O(log(n))` 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([1, 2, 3, 4, 5], key=neg) 
        &gt;&gt;&gt; 3 in skl 
        True 
 
        :param value: search for value in sorted-key list 
        :return: true if `value` in sorted-key list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return False</span>

        <span class="s1">key = self._key(value)</span>
        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return False</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>

        <span class="s1">idx = bisect_left(_keys[pos]</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s1">len_keys = len(_keys)</span>
        <span class="s1">len_sublist = len(_keys[pos])</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">_keys[pos][idx] != key:</span>
                <span class="s3">return False</span>
            <span class="s3">if </span><span class="s1">_lists[pos][idx] == value:</span>
                <span class="s3">return True</span>
            <span class="s1">idx += </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">idx == len_sublist:</span>
                <span class="s1">pos += </span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">pos == len_keys:</span>
                    <span class="s3">return False</span>
                <span class="s1">len_sublist = len(_keys[pos])</span>
                <span class="s1">idx = </span><span class="s4">0</span>


    <span class="s3">def </span><span class="s1">discard(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Remove `value` from sorted-key list if it is a member. 
 
        If `value` is not a member, do nothing. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([5, 4, 3, 2, 1], key=neg) 
        &gt;&gt;&gt; skl.discard(1) 
        &gt;&gt;&gt; skl.discard(0) 
        &gt;&gt;&gt; skl == [5, 4, 3, 2] 
        True 
 
        :param value: `value` to discard from sorted-key list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return</span>

        <span class="s1">key = self._key(value)</span>
        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>
        <span class="s1">idx = bisect_left(_keys[pos]</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">len_keys = len(_keys)</span>
        <span class="s1">len_sublist = len(_keys[pos])</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">_keys[pos][idx] != key:</span>
                <span class="s3">return</span>
            <span class="s3">if </span><span class="s1">_lists[pos][idx] == value:</span>
                <span class="s1">self._delete(pos</span><span class="s3">, </span><span class="s1">idx)</span>
                <span class="s3">return</span>
            <span class="s1">idx += </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">idx == len_sublist:</span>
                <span class="s1">pos += </span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">pos == len_keys:</span>
                    <span class="s3">return</span>
                <span class="s1">len_sublist = len(_keys[pos])</span>
                <span class="s1">idx = </span><span class="s4">0</span>


    <span class="s3">def </span><span class="s1">remove(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Remove `value` from sorted-key list; `value` must be a member. 
 
        If `value` is not a member, raise ValueError. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([1, 2, 3, 4, 5], key=neg) 
        &gt;&gt;&gt; skl.remove(5) 
        &gt;&gt;&gt; skl == [4, 3, 2, 1] 
        True 
        &gt;&gt;&gt; skl.remove(0) 
        Traceback (most recent call last): 
          ... 
        ValueError: 0 not in list 
 
        :param value: `value` to remove from sorted-key list 
        :raises ValueError: if `value` is not in sorted-key list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">key = self._key(value)</span>
        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>
        <span class="s1">idx = bisect_left(_keys[pos]</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">len_keys = len(_keys)</span>
        <span class="s1">len_sublist = len(_keys[pos])</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">_keys[pos][idx] != key:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} not in list'</span><span class="s1">.format(value))</span>
            <span class="s3">if </span><span class="s1">_lists[pos][idx] == value:</span>
                <span class="s1">self._delete(pos</span><span class="s3">, </span><span class="s1">idx)</span>
                <span class="s3">return</span>
            <span class="s1">idx += </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">idx == len_sublist:</span>
                <span class="s1">pos += </span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">pos == len_keys:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} not in list'</span><span class="s1">.format(value))</span>
                <span class="s1">len_sublist = len(_keys[pos])</span>
                <span class="s1">idx = </span><span class="s4">0</span>


    <span class="s3">def </span><span class="s1">_delete(self</span><span class="s3">, </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">idx):</span>
        <span class="s0">&quot;&quot;&quot;Delete value at the given `(pos, idx)`. 
 
        Combines lists that are less than half the load level. 
 
        Updates the index when the sublist length is more than half the load 
        level. This requires decrementing the nodes in a traversal from the 
        leaf node to the root. For an example traversal see 
        ``SortedList._loc``. 
 
        :param int pos: lists index 
        :param int idx: sublist index 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>
        <span class="s1">_maxes = self._maxes</span>
        <span class="s1">_index = self._index</span>
        <span class="s1">keys_pos = _keys[pos]</span>
        <span class="s1">lists_pos = _lists[pos]</span>

        <span class="s3">del </span><span class="s1">keys_pos[idx]</span>
        <span class="s3">del </span><span class="s1">lists_pos[idx]</span>
        <span class="s1">self._len -= </span><span class="s4">1</span>

        <span class="s1">len_keys_pos = len(keys_pos)</span>

        <span class="s3">if </span><span class="s1">len_keys_pos &gt; (self._load &gt;&gt; </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">_maxes[pos] = keys_pos[-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s3">if </span><span class="s1">_index:</span>
                <span class="s1">child = self._offset + pos</span>
                <span class="s3">while </span><span class="s1">child &gt; </span><span class="s4">0</span><span class="s1">:</span>
                    <span class="s1">_index[child] -= </span><span class="s4">1</span>
                    <span class="s1">child = (child - </span><span class="s4">1</span><span class="s1">) &gt;&gt; </span><span class="s4">1</span>
                <span class="s1">_index[</span><span class="s4">0</span><span class="s1">] -= </span><span class="s4">1</span>
        <span class="s3">elif </span><span class="s1">len(_keys) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">pos:</span>
                <span class="s1">pos += </span><span class="s4">1</span>

            <span class="s1">prev = pos - </span><span class="s4">1</span>
            <span class="s1">_keys[prev].extend(_keys[pos])</span>
            <span class="s1">_lists[prev].extend(_lists[pos])</span>
            <span class="s1">_maxes[prev] = _keys[prev][-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s3">del </span><span class="s1">_lists[pos]</span>
            <span class="s3">del </span><span class="s1">_keys[pos]</span>
            <span class="s3">del </span><span class="s1">_maxes[pos]</span>
            <span class="s3">del </span><span class="s1">_index[:]</span>

            <span class="s1">self._expand(prev)</span>
        <span class="s3">elif </span><span class="s1">len_keys_pos:</span>
            <span class="s1">_maxes[pos] = keys_pos[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">del </span><span class="s1">_lists[pos]</span>
            <span class="s3">del </span><span class="s1">_keys[pos]</span>
            <span class="s3">del </span><span class="s1">_maxes[pos]</span>
            <span class="s3">del </span><span class="s1">_index[:]</span>


    <span class="s3">def </span><span class="s1">irange(self</span><span class="s3">, </span><span class="s1">minimum=</span><span class="s3">None, </span><span class="s1">maximum=</span><span class="s3">None, </span><span class="s1">inclusive=(</span><span class="s3">True, True</span><span class="s1">)</span><span class="s3">,</span>
               <span class="s1">reverse=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create an iterator of values between `minimum` and `maximum`. 
 
        Both `minimum` and `maximum` default to `None` which is automatically 
        inclusive of the beginning and end of the sorted-key list. 
 
        The argument `inclusive` is a pair of booleans that indicates whether 
        the minimum and maximum ought to be included in the range, 
        respectively. The default is ``(True, True)`` such that the range is 
        inclusive of both minimum and maximum. 
 
        When `reverse` is `True` the values are yielded from the iterator in 
        reverse order; `reverse` defaults to `False`. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([11, 12, 13, 14, 15], key=neg) 
        &gt;&gt;&gt; it = skl.irange(14.5, 11.5) 
        &gt;&gt;&gt; list(it) 
        [14, 13, 12] 
 
        :param minimum: minimum value to start iterating 
        :param maximum: maximum value to stop iterating 
        :param inclusive: pair of booleans 
        :param bool reverse: yield values in reverse order 
        :return: iterator 
 
        &quot;&quot;&quot;</span>
        <span class="s1">min_key = self._key(minimum) </span><span class="s3">if </span><span class="s1">minimum </span><span class="s3">is not None else None</span>
        <span class="s1">max_key = self._key(maximum) </span><span class="s3">if </span><span class="s1">maximum </span><span class="s3">is not None else None</span>
        <span class="s3">return </span><span class="s1">self._irange_key(</span>
            <span class="s1">min_key=min_key</span><span class="s3">, </span><span class="s1">max_key=max_key</span><span class="s3">,</span>
            <span class="s1">inclusive=inclusive</span><span class="s3">, </span><span class="s1">reverse=reverse</span><span class="s3">,</span>
        <span class="s1">)</span>


    <span class="s3">def </span><span class="s1">irange_key(self</span><span class="s3">, </span><span class="s1">min_key=</span><span class="s3">None, </span><span class="s1">max_key=</span><span class="s3">None, </span><span class="s1">inclusive=(</span><span class="s3">True, True</span><span class="s1">)</span><span class="s3">,</span>
                   <span class="s1">reverse=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create an iterator of values between `min_key` and `max_key`. 
 
        Both `min_key` and `max_key` default to `None` which is automatically 
        inclusive of the beginning and end of the sorted-key list. 
 
        The argument `inclusive` is a pair of booleans that indicates whether 
        the minimum and maximum ought to be included in the range, 
        respectively. The default is ``(True, True)`` such that the range is 
        inclusive of both minimum and maximum. 
 
        When `reverse` is `True` the values are yielded from the iterator in 
        reverse order; `reverse` defaults to `False`. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([11, 12, 13, 14, 15], key=neg) 
        &gt;&gt;&gt; it = skl.irange_key(-14, -12) 
        &gt;&gt;&gt; list(it) 
        [14, 13, 12] 
 
        :param min_key: minimum key to start iterating 
        :param max_key: maximum key to stop iterating 
        :param inclusive: pair of booleans 
        :param bool reverse: yield values in reverse order 
        :return: iterator 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return </span><span class="s1">iter(())</span>

        <span class="s1">_keys = self._keys</span>

        <span class="s2"># Calculate the minimum (pos, idx) pair. By default this location</span>
        <span class="s2"># will be inclusive in our calculation.</span>

        <span class="s3">if </span><span class="s1">min_key </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">min_pos = </span><span class="s4">0</span>
            <span class="s1">min_idx = </span><span class="s4">0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">inclusive[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s1">min_pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">min_key)</span>

                <span class="s3">if </span><span class="s1">min_pos == len(_maxes):</span>
                    <span class="s3">return </span><span class="s1">iter(())</span>

                <span class="s1">min_idx = bisect_left(_keys[min_pos]</span><span class="s3">, </span><span class="s1">min_key)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">min_pos = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">min_key)</span>

                <span class="s3">if </span><span class="s1">min_pos == len(_maxes):</span>
                    <span class="s3">return </span><span class="s1">iter(())</span>

                <span class="s1">min_idx = bisect_right(_keys[min_pos]</span><span class="s3">, </span><span class="s1">min_key)</span>

        <span class="s2"># Calculate the maximum (pos, idx) pair. By default this location</span>
        <span class="s2"># will be exclusive in our calculation.</span>

        <span class="s3">if </span><span class="s1">max_key </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">max_pos = len(_maxes) - </span><span class="s4">1</span>
            <span class="s1">max_idx = len(_keys[max_pos])</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">inclusive[</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s1">max_pos = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">max_key)</span>

                <span class="s3">if </span><span class="s1">max_pos == len(_maxes):</span>
                    <span class="s1">max_pos -= </span><span class="s4">1</span>
                    <span class="s1">max_idx = len(_keys[max_pos])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">max_idx = bisect_right(_keys[max_pos]</span><span class="s3">, </span><span class="s1">max_key)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">max_pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">max_key)</span>

                <span class="s3">if </span><span class="s1">max_pos == len(_maxes):</span>
                    <span class="s1">max_pos -= </span><span class="s4">1</span>
                    <span class="s1">max_idx = len(_keys[max_pos])</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">max_idx = bisect_left(_keys[max_pos]</span><span class="s3">, </span><span class="s1">max_key)</span>

        <span class="s3">return </span><span class="s1">self._islice(min_pos</span><span class="s3">, </span><span class="s1">min_idx</span><span class="s3">, </span><span class="s1">max_pos</span><span class="s3">, </span><span class="s1">max_idx</span><span class="s3">, </span><span class="s1">reverse)</span>

    <span class="s1">_irange_key = irange_key</span>


    <span class="s3">def </span><span class="s1">bisect_left(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Return an index to insert `value` in the sorted-key list. 
 
        If the `value` is already present, the insertion point will be before 
        (to the left of) any existing values. 
 
        Similar to the `bisect` module in the standard library. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([5, 4, 3, 2, 1], key=neg) 
        &gt;&gt;&gt; skl.bisect_left(1) 
        4 
 
        :param value: insertion index of value in sorted-key list 
        :return: index 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._bisect_key_left(self._key(value))</span>


    <span class="s3">def </span><span class="s1">bisect_right(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Return an index to insert `value` in the sorted-key list. 
 
        Similar to `bisect_left`, but if `value` is already present, the 
        insertion point will be after (to the right of) any existing values. 
 
        Similar to the `bisect` module in the standard library. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedList([5, 4, 3, 2, 1], key=neg) 
        &gt;&gt;&gt; skl.bisect_right(1) 
        5 
 
        :param value: insertion index of value in sorted-key list 
        :return: index 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._bisect_key_right(self._key(value))</span>

    <span class="s1">bisect = bisect_right</span>


    <span class="s3">def </span><span class="s1">bisect_key_left(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s0">&quot;&quot;&quot;Return an index to insert `key` in the sorted-key list. 
 
        If the `key` is already present, the insertion point will be before (to 
        the left of) any existing keys. 
 
        Similar to the `bisect` module in the standard library. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([5, 4, 3, 2, 1], key=neg) 
        &gt;&gt;&gt; skl.bisect_key_left(-1) 
        4 
 
        :param key: insertion index of key in sorted-key list 
        :return: index 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return </span><span class="s4">0</span>

        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return </span><span class="s1">self._len</span>

        <span class="s1">idx = bisect_left(self._keys[pos]</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">return </span><span class="s1">self._loc(pos</span><span class="s3">, </span><span class="s1">idx)</span>

    <span class="s1">_bisect_key_left = bisect_key_left</span>


    <span class="s3">def </span><span class="s1">bisect_key_right(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s0">&quot;&quot;&quot;Return an index to insert `key` in the sorted-key list. 
 
        Similar to `bisect_key_left`, but if `key` is already present, the 
        insertion point will be after (to the right of) any existing keys. 
 
        Similar to the `bisect` module in the standard library. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedList([5, 4, 3, 2, 1], key=neg) 
        &gt;&gt;&gt; skl.bisect_key_right(-1) 
        5 
 
        :param key: insertion index of key in sorted-key list 
        :return: index 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return </span><span class="s4">0</span>

        <span class="s1">pos = bisect_right(_maxes</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return </span><span class="s1">self._len</span>

        <span class="s1">idx = bisect_right(self._keys[pos]</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">return </span><span class="s1">self._loc(pos</span><span class="s3">, </span><span class="s1">idx)</span>

    <span class="s1">bisect_key = bisect_key_right</span>
    <span class="s1">_bisect_key_right = bisect_key_right</span>


    <span class="s3">def </span><span class="s1">count(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s0">&quot;&quot;&quot;Return number of occurrences of `value` in the sorted-key list. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([4, 4, 4, 4, 3, 3, 3, 2, 2, 1], key=neg) 
        &gt;&gt;&gt; skl.count(2) 
        2 
 
        :param value: value to count in sorted-key list 
        :return: count 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_maxes = self._maxes</span>

        <span class="s3">if not </span><span class="s1">_maxes:</span>
            <span class="s3">return </span><span class="s4">0</span>

        <span class="s1">key = self._key(value)</span>
        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">return </span><span class="s4">0</span>

        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>
        <span class="s1">idx = bisect_left(_keys[pos]</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">total = </span><span class="s4">0</span>
        <span class="s1">len_keys = len(_keys)</span>
        <span class="s1">len_sublist = len(_keys[pos])</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">_keys[pos][idx] != key:</span>
                <span class="s3">return </span><span class="s1">total</span>
            <span class="s3">if </span><span class="s1">_lists[pos][idx] == value:</span>
                <span class="s1">total += </span><span class="s4">1</span>
            <span class="s1">idx += </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">idx == len_sublist:</span>
                <span class="s1">pos += </span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">pos == len_keys:</span>
                    <span class="s3">return </span><span class="s1">total</span>
                <span class="s1">len_sublist = len(_keys[pos])</span>
                <span class="s1">idx = </span><span class="s4">0</span>


    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s0">&quot;&quot;&quot;Return a shallow copy of the sorted-key list. 
 
        Runtime complexity: `O(n)` 
 
        :return: new sorted-key list 
 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.__class__(self</span><span class="s3">, </span><span class="s1">key=self._key)</span>

    <span class="s1">__copy__ = copy</span>


    <span class="s3">def </span><span class="s1">index(self</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">start=</span><span class="s3">None, </span><span class="s1">stop=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Return first index of value in sorted-key list. 
 
        Raise ValueError if `value` is not present. 
 
        Index must be between `start` and `stop` for the `value` to be 
        considered present. The default value, None, for `start` and `stop` 
        indicate the beginning and end of the sorted-key list. 
 
        Negative indices are supported. 
 
        Runtime complexity: `O(log(n))` -- approximate. 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([5, 4, 3, 2, 1], key=neg) 
        &gt;&gt;&gt; skl.index(2) 
        3 
        &gt;&gt;&gt; skl.index(0) 
        Traceback (most recent call last): 
          ... 
        ValueError: 0 is not in list 
 
        :param value: value in sorted-key list 
        :param int start: start index (default None, start of sorted-key list) 
        :param int stop: stop index (default None, end of sorted-key list) 
        :return: index of value 
        :raises ValueError: if value is not present 
 
        &quot;&quot;&quot;</span>
        <span class="s1">_len = self._len</span>

        <span class="s3">if not </span><span class="s1">_len:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>

        <span class="s3">if </span><span class="s1">start </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">start = </span><span class="s4">0</span>
        <span class="s3">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start += _len</span>
        <span class="s3">if </span><span class="s1">start &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">start = </span><span class="s4">0</span>

        <span class="s3">if </span><span class="s1">stop </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">stop = _len</span>
        <span class="s3">if </span><span class="s1">stop &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">stop += _len</span>
        <span class="s3">if </span><span class="s1">stop &gt; _len:</span>
            <span class="s1">stop = _len</span>

        <span class="s3">if </span><span class="s1">stop &lt;= start:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">_maxes = self._maxes</span>
        <span class="s1">key = self._key(value)</span>
        <span class="s1">pos = bisect_left(_maxes</span><span class="s3">, </span><span class="s1">key)</span>

        <span class="s3">if </span><span class="s1">pos == len(_maxes):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>

        <span class="s1">stop -= </span><span class="s4">1</span>
        <span class="s1">_lists = self._lists</span>
        <span class="s1">_keys = self._keys</span>
        <span class="s1">idx = bisect_left(_keys[pos]</span><span class="s3">, </span><span class="s1">key)</span>
        <span class="s1">len_keys = len(_keys)</span>
        <span class="s1">len_sublist = len(_keys[pos])</span>

        <span class="s3">while True</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">_keys[pos][idx] != key:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>
            <span class="s3">if </span><span class="s1">_lists[pos][idx] == value:</span>
                <span class="s1">loc = self._loc(pos</span><span class="s3">, </span><span class="s1">idx)</span>
                <span class="s3">if </span><span class="s1">start &lt;= loc &lt;= stop:</span>
                    <span class="s3">return </span><span class="s1">loc</span>
                <span class="s3">elif </span><span class="s1">loc &gt; stop:</span>
                    <span class="s3">break</span>
            <span class="s1">idx += </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">idx == len_sublist:</span>
                <span class="s1">pos += </span><span class="s4">1</span>
                <span class="s3">if </span><span class="s1">pos == len_keys:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>
                <span class="s1">len_sublist = len(_keys[pos])</span>
                <span class="s1">idx = </span><span class="s4">0</span>

        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'{0!r} is not in list'</span><span class="s1">.format(value))</span>


    <span class="s3">def </span><span class="s1">__add__(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Return new sorted-key list containing all values in both sequences. 
 
        ``skl.__add__(other)`` &lt;==&gt; ``skl + other`` 
 
        Values in `other` do not need to be in sorted-key order. 
 
        Runtime complexity: `O(n*log(n))` 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl1 = SortedKeyList([5, 4, 3], key=neg) 
        &gt;&gt;&gt; skl2 = SortedKeyList([2, 1, 0], key=neg) 
        &gt;&gt;&gt; skl1 + skl2 
        SortedKeyList([5, 4, 3, 2, 1, 0], key=&lt;built-in function neg&gt;) 
 
        :param other: other iterable 
        :return: new sorted-key list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s1">values.extend(other)</span>
        <span class="s3">return </span><span class="s1">self.__class__(values</span><span class="s3">, </span><span class="s1">key=self._key)</span>

    <span class="s1">__radd__ = __add__</span>


    <span class="s3">def </span><span class="s1">__mul__(self</span><span class="s3">, </span><span class="s1">num):</span>
        <span class="s0">&quot;&quot;&quot;Return new sorted-key list with `num` shallow copies of values. 
 
        ``skl.__mul__(num)`` &lt;==&gt; ``skl * num`` 
 
        Runtime complexity: `O(n*log(n))` 
 
        &gt;&gt;&gt; from operator import neg 
        &gt;&gt;&gt; skl = SortedKeyList([3, 2, 1], key=neg) 
        &gt;&gt;&gt; skl * 2 
        SortedKeyList([3, 3, 2, 2, 1, 1], key=&lt;built-in function neg&gt;) 
 
        :param int num: count of shallow copies 
        :return: new sorted-key list 
 
        &quot;&quot;&quot;</span>
        <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[]) * num</span>
        <span class="s3">return </span><span class="s1">self.__class__(values</span><span class="s3">, </span><span class="s1">key=self._key)</span>


    <span class="s3">def </span><span class="s1">__reduce__(self):</span>
        <span class="s1">values = reduce(iadd</span><span class="s3">, </span><span class="s1">self._lists</span><span class="s3">, </span><span class="s1">[])</span>
        <span class="s3">return </span><span class="s1">(type(self)</span><span class="s3">, </span><span class="s1">(values</span><span class="s3">, </span><span class="s1">self.key))</span>


    <span class="s1">@recursive_repr()</span>
    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return string representation of sorted-key list. 
 
        ``skl.__repr__()`` &lt;==&gt; ``repr(skl)`` 
 
        :return: string representation 
 
        &quot;&quot;&quot;</span>
        <span class="s1">type_name = type(self).__name__</span>
        <span class="s3">return </span><span class="s5">'{0}({1!r}, key={2!r})'</span><span class="s1">.format(type_name</span><span class="s3">, </span><span class="s1">list(self)</span><span class="s3">, </span><span class="s1">self._key)</span>


    <span class="s3">def </span><span class="s1">_check(self):</span>
        <span class="s0">&quot;&quot;&quot;Check invariants of sorted-key list. 
 
        Runtime complexity: `O(n)` 
 
        &quot;&quot;&quot;</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">self._load &gt;= </span><span class="s4">4</span>
            <span class="s3">assert </span><span class="s1">len(self._maxes) == len(self._lists) == len(self._keys)</span>
            <span class="s3">assert </span><span class="s1">self._len == sum(len(sublist) </span><span class="s3">for </span><span class="s1">sublist </span><span class="s3">in </span><span class="s1">self._lists)</span>

            <span class="s2"># Check all sublists are sorted.</span>

            <span class="s3">for </span><span class="s1">sublist </span><span class="s3">in </span><span class="s1">self._keys:</span>
                <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">len(sublist)):</span>
                    <span class="s3">assert </span><span class="s1">sublist[pos - </span><span class="s4">1</span><span class="s1">] &lt;= sublist[pos]</span>

            <span class="s2"># Check beginning/end of sublists are sorted.</span>

            <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">, </span><span class="s1">len(self._keys)):</span>
                <span class="s3">assert </span><span class="s1">self._keys[pos - </span><span class="s4">1</span><span class="s1">][-</span><span class="s4">1</span><span class="s1">] &lt;= self._keys[pos][</span><span class="s4">0</span><span class="s1">]</span>

            <span class="s2"># Check _keys matches _key mapped to _lists.</span>

            <span class="s3">for </span><span class="s1">val_sublist</span><span class="s3">, </span><span class="s1">key_sublist </span><span class="s3">in </span><span class="s1">zip(self._lists</span><span class="s3">, </span><span class="s1">self._keys):</span>
                <span class="s3">assert </span><span class="s1">len(val_sublist) == len(key_sublist)</span>
                <span class="s3">for </span><span class="s1">val</span><span class="s3">, </span><span class="s1">key </span><span class="s3">in </span><span class="s1">zip(val_sublist</span><span class="s3">, </span><span class="s1">key_sublist):</span>
                    <span class="s3">assert </span><span class="s1">self._key(val) == key</span>

            <span class="s2"># Check _maxes index is the last value of each sublist.</span>

            <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(len(self._maxes)):</span>
                <span class="s3">assert </span><span class="s1">self._maxes[pos] == self._keys[pos][-</span><span class="s4">1</span><span class="s1">]</span>

            <span class="s2"># Check sublist lengths are less than double load-factor.</span>

            <span class="s1">double = self._load &lt;&lt; </span><span class="s4">1</span>
            <span class="s3">assert </span><span class="s1">all(len(sublist) &lt;= double </span><span class="s3">for </span><span class="s1">sublist </span><span class="s3">in </span><span class="s1">self._lists)</span>

            <span class="s2"># Check sublist lengths are greater than half load-factor for all</span>
            <span class="s2"># but the last sublist.</span>

            <span class="s1">half = self._load &gt;&gt; </span><span class="s4">1</span>
            <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">len(self._lists) - </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s3">assert </span><span class="s1">len(self._lists[pos]) &gt;= half</span>

            <span class="s3">if </span><span class="s1">self._index:</span>
                <span class="s3">assert </span><span class="s1">self._len == self._index[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s3">assert </span><span class="s1">len(self._index) == self._offset + len(self._lists)</span>

                <span class="s2"># Check index leaf nodes equal length of sublists.</span>

                <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(len(self._lists)):</span>
                    <span class="s1">leaf = self._index[self._offset + pos]</span>
                    <span class="s3">assert </span><span class="s1">leaf == len(self._lists[pos])</span>

                <span class="s2"># Check index branch nodes are the sum of their children.</span>

                <span class="s3">for </span><span class="s1">pos </span><span class="s3">in </span><span class="s1">range(self._offset):</span>
                    <span class="s1">child = (pos &lt;&lt; </span><span class="s4">1</span><span class="s1">) + </span><span class="s4">1</span>
                    <span class="s3">if </span><span class="s1">child &gt;= len(self._index):</span>
                        <span class="s3">assert </span><span class="s1">self._index[pos] == </span><span class="s4">0</span>
                    <span class="s3">elif </span><span class="s1">child + </span><span class="s4">1 </span><span class="s1">== len(self._index):</span>
                        <span class="s3">assert </span><span class="s1">self._index[pos] == self._index[child]</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">child_sum = self._index[child] + self._index[child + </span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s3">assert </span><span class="s1">child_sum == self._index[pos]</span>
        <span class="s3">except</span><span class="s1">:</span>
            <span class="s1">traceback.print_exc(file=sys.stdout)</span>
            <span class="s1">print(</span><span class="s5">'len'</span><span class="s3">, </span><span class="s1">self._len)</span>
            <span class="s1">print(</span><span class="s5">'load'</span><span class="s3">, </span><span class="s1">self._load)</span>
            <span class="s1">print(</span><span class="s5">'offset'</span><span class="s3">, </span><span class="s1">self._offset)</span>
            <span class="s1">print(</span><span class="s5">'len_index'</span><span class="s3">, </span><span class="s1">len(self._index))</span>
            <span class="s1">print(</span><span class="s5">'index'</span><span class="s3">, </span><span class="s1">self._index)</span>
            <span class="s1">print(</span><span class="s5">'len_maxes'</span><span class="s3">, </span><span class="s1">len(self._maxes))</span>
            <span class="s1">print(</span><span class="s5">'maxes'</span><span class="s3">, </span><span class="s1">self._maxes)</span>
            <span class="s1">print(</span><span class="s5">'len_keys'</span><span class="s3">, </span><span class="s1">len(self._keys))</span>
            <span class="s1">print(</span><span class="s5">'keys'</span><span class="s3">, </span><span class="s1">self._keys)</span>
            <span class="s1">print(</span><span class="s5">'len_lists'</span><span class="s3">, </span><span class="s1">len(self._lists))</span>
            <span class="s1">print(</span><span class="s5">'lists'</span><span class="s3">, </span><span class="s1">self._lists)</span>
            <span class="s3">raise</span>


<span class="s1">SortedListWithKey = SortedKeyList</span>
</pre>
</body>
</html>