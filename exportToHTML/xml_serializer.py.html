<html>
<head>
<title>xml_serializer.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
xml_serializer.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
XML serializer. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">from </span><span class="s1">xml.dom </span><span class="s2">import </span><span class="s1">pulldom</span>
<span class="s2">from </span><span class="s1">xml.sax </span><span class="s2">import </span><span class="s1">handler</span>
<span class="s2">from </span><span class="s1">xml.sax.expatreader </span><span class="s2">import </span><span class="s1">ExpatParser </span><span class="s2">as </span><span class="s1">_ExpatParser</span>

<span class="s2">from </span><span class="s1">django.apps </span><span class="s2">import </span><span class="s1">apps</span>
<span class="s2">from </span><span class="s1">django.conf </span><span class="s2">import </span><span class="s1">settings</span>
<span class="s2">from </span><span class="s1">django.core.exceptions </span><span class="s2">import </span><span class="s1">ObjectDoesNotExist</span>
<span class="s2">from </span><span class="s1">django.core.serializers </span><span class="s2">import </span><span class="s1">base</span>
<span class="s2">from </span><span class="s1">django.db </span><span class="s2">import </span><span class="s1">DEFAULT_DB_ALIAS</span><span class="s2">, </span><span class="s1">models</span>
<span class="s2">from </span><span class="s1">django.utils.xmlutils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">SimplerXMLGenerator</span><span class="s2">, </span><span class="s1">UnserializableContentError</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">class </span><span class="s1">Serializer(base.Serializer):</span>
    <span class="s0">&quot;&quot;&quot;Serialize a QuerySet to XML.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">indent(self</span><span class="s2">, </span><span class="s1">level):</span>
        <span class="s2">if </span><span class="s1">self.options.get(</span><span class="s3">'indent'</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.xml.ignorableWhitespace(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s3">' ' </span><span class="s1">* self.options.get(</span><span class="s3">'indent'</span><span class="s1">) * level)</span>

    <span class="s2">def </span><span class="s1">start_serialization(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Start serialization -- open the XML document and the root element. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.xml = SimplerXMLGenerator(self.stream</span><span class="s2">, </span><span class="s1">self.options.get(</span><span class="s3">&quot;encoding&quot;</span><span class="s2">, </span><span class="s1">settings.DEFAULT_CHARSET))</span>
        <span class="s1">self.xml.startDocument()</span>
        <span class="s1">self.xml.startElement(</span><span class="s3">&quot;django-objects&quot;</span><span class="s2">, </span><span class="s1">{</span><span class="s3">&quot;version&quot;</span><span class="s1">: </span><span class="s3">&quot;1.0&quot;</span><span class="s1">})</span>

    <span class="s2">def </span><span class="s1">end_serialization(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        End serialization -- end the document. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.indent(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">self.xml.endElement(</span><span class="s3">&quot;django-objects&quot;</span><span class="s1">)</span>
        <span class="s1">self.xml.endDocument()</span>

    <span class="s2">def </span><span class="s1">start_object(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s0">&quot;&quot;&quot; 
        Called as each object is handled. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">&quot;_meta&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">base.SerializationError(</span><span class="s3">&quot;Non-model object (%s) encountered during serialization&quot; </span><span class="s1">% type(obj))</span>

        <span class="s1">self.indent(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">attrs = {</span><span class="s3">'model'</span><span class="s1">: str(obj._meta)}</span>
        <span class="s2">if not </span><span class="s1">self.use_natural_primary_keys </span><span class="s2">or not </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">'natural_key'</span><span class="s1">):</span>
            <span class="s1">obj_pk = obj.pk</span>
            <span class="s2">if </span><span class="s1">obj_pk </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">attrs[</span><span class="s3">'pk'</span><span class="s1">] = str(obj_pk)</span>

        <span class="s1">self.xml.startElement(</span><span class="s3">&quot;object&quot;</span><span class="s2">, </span><span class="s1">attrs)</span>

    <span class="s2">def </span><span class="s1">end_object(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s0">&quot;&quot;&quot; 
        Called after handling all fields for an object. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.indent(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.xml.endElement(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">handle_field(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">field):</span>
        <span class="s0">&quot;&quot;&quot; 
        Handle each field on an object (except for ForeignKeys and 
        ManyToManyFields). 
        &quot;&quot;&quot;</span>
        <span class="s1">self.indent(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.xml.startElement(</span><span class="s3">'field'</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s3">'name'</span><span class="s1">: field.name</span><span class="s2">,</span>
            <span class="s3">'type'</span><span class="s1">: field.get_internal_type()</span><span class="s2">,</span>
        <span class="s1">})</span>

        <span class="s5"># Get a &quot;string version&quot; of the object's data.</span>
        <span class="s2">if </span><span class="s1">getattr(obj</span><span class="s2">, </span><span class="s1">field.name) </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">value = field.value_to_string(obj)</span>
            <span class="s2">if </span><span class="s1">field.get_internal_type() == </span><span class="s3">'JSONField'</span><span class="s1">:</span>
                <span class="s5"># Dump value since JSONField.value_to_string() doesn't output</span>
                <span class="s5"># strings.</span>
                <span class="s1">value = json.dumps(value</span><span class="s2">, </span><span class="s1">cls=field.encoder)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">self.xml.characters(value)</span>
            <span class="s2">except </span><span class="s1">UnserializableContentError:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;%s.%s (pk:%s) contains unserializable characters&quot; </span><span class="s1">% (</span>
                    <span class="s1">obj.__class__.__name__</span><span class="s2">, </span><span class="s1">field.name</span><span class="s2">, </span><span class="s1">obj.pk))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.xml.addQuickElement(</span><span class="s3">&quot;None&quot;</span><span class="s1">)</span>

        <span class="s1">self.xml.endElement(</span><span class="s3">&quot;field&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">handle_fk_field(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">field):</span>
        <span class="s0">&quot;&quot;&quot; 
        Handle a ForeignKey (they need to be treated slightly 
        differently from regular fields). 
        &quot;&quot;&quot;</span>
        <span class="s1">self._start_relational_field(field)</span>
        <span class="s1">related_att = getattr(obj</span><span class="s2">, </span><span class="s1">field.get_attname())</span>
        <span class="s2">if </span><span class="s1">related_att </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.use_natural_foreign_keys </span><span class="s2">and </span><span class="s1">hasattr(field.remote_field.model</span><span class="s2">, </span><span class="s3">'natural_key'</span><span class="s1">):</span>
                <span class="s1">related = getattr(obj</span><span class="s2">, </span><span class="s1">field.name)</span>
                <span class="s5"># If related object has a natural key, use it</span>
                <span class="s1">related = related.natural_key()</span>
                <span class="s5"># Iterable natural keys are rolled out as subelements</span>
                <span class="s2">for </span><span class="s1">key_value </span><span class="s2">in </span><span class="s1">related:</span>
                    <span class="s1">self.xml.startElement(</span><span class="s3">&quot;natural&quot;</span><span class="s2">, </span><span class="s1">{})</span>
                    <span class="s1">self.xml.characters(str(key_value))</span>
                    <span class="s1">self.xml.endElement(</span><span class="s3">&quot;natural&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.xml.characters(str(related_att))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.xml.addQuickElement(</span><span class="s3">&quot;None&quot;</span><span class="s1">)</span>
        <span class="s1">self.xml.endElement(</span><span class="s3">&quot;field&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">handle_m2m_field(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">field):</span>
        <span class="s0">&quot;&quot;&quot; 
        Handle a ManyToManyField. Related objects are only serialized as 
        references to the object's PK (i.e. the related *data* is not dumped, 
        just the relation). 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">field.remote_field.through._meta.auto_created:</span>
            <span class="s1">self._start_relational_field(field)</span>
            <span class="s2">if </span><span class="s1">self.use_natural_foreign_keys </span><span class="s2">and </span><span class="s1">hasattr(field.remote_field.model</span><span class="s2">, </span><span class="s3">'natural_key'</span><span class="s1">):</span>
                <span class="s5"># If the objects in the m2m have a natural key, use it</span>
                <span class="s2">def </span><span class="s1">handle_m2m(value):</span>
                    <span class="s1">natural = value.natural_key()</span>
                    <span class="s5"># Iterable natural keys are rolled out as subelements</span>
                    <span class="s1">self.xml.startElement(</span><span class="s3">&quot;object&quot;</span><span class="s2">, </span><span class="s1">{})</span>
                    <span class="s2">for </span><span class="s1">key_value </span><span class="s2">in </span><span class="s1">natural:</span>
                        <span class="s1">self.xml.startElement(</span><span class="s3">&quot;natural&quot;</span><span class="s2">, </span><span class="s1">{})</span>
                        <span class="s1">self.xml.characters(str(key_value))</span>
                        <span class="s1">self.xml.endElement(</span><span class="s3">&quot;natural&quot;</span><span class="s1">)</span>
                    <span class="s1">self.xml.endElement(</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">def </span><span class="s1">handle_m2m(value):</span>
                    <span class="s1">self.xml.addQuickElement(</span><span class="s3">&quot;object&quot;</span><span class="s2">, </span><span class="s1">attrs={</span>
                        <span class="s3">'pk'</span><span class="s1">: str(value.pk)</span>
                    <span class="s1">})</span>
            <span class="s1">m2m_iter = getattr(obj</span><span class="s2">, </span><span class="s3">'_prefetched_objects_cache'</span><span class="s2">, </span><span class="s1">{}).get(</span>
                <span class="s1">field.name</span><span class="s2">,</span>
                <span class="s1">getattr(obj</span><span class="s2">, </span><span class="s1">field.name).iterator()</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">relobj </span><span class="s2">in </span><span class="s1">m2m_iter:</span>
                <span class="s1">handle_m2m(relobj)</span>

            <span class="s1">self.xml.endElement(</span><span class="s3">&quot;field&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_start_relational_field(self</span><span class="s2">, </span><span class="s1">field):</span>
        <span class="s0">&quot;&quot;&quot;Output the &lt;field&gt; element for relational fields.&quot;&quot;&quot;</span>
        <span class="s1">self.indent(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">self.xml.startElement(</span><span class="s3">'field'</span><span class="s2">, </span><span class="s1">{</span>
            <span class="s3">'name'</span><span class="s1">: field.name</span><span class="s2">,</span>
            <span class="s3">'rel'</span><span class="s1">: field.remote_field.__class__.__name__</span><span class="s2">,</span>
            <span class="s3">'to'</span><span class="s1">: str(field.remote_field.model._meta)</span><span class="s2">,</span>
        <span class="s1">})</span>


<span class="s2">class </span><span class="s1">Deserializer(base.Deserializer):</span>
    <span class="s0">&quot;&quot;&quot;Deserialize XML.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">stream_or_string</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">using=DEFAULT_DB_ALIAS</span><span class="s2">, </span><span class="s1">ignorenonexistent=</span><span class="s2">False, </span><span class="s1">**options):</span>
        <span class="s1">super().__init__(stream_or_string</span><span class="s2">, </span><span class="s1">**options)</span>
        <span class="s1">self.handle_forward_references = options.pop(</span><span class="s3">'handle_forward_references'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.event_stream = pulldom.parse(self.stream</span><span class="s2">, </span><span class="s1">self._make_parser())</span>
        <span class="s1">self.db = using</span>
        <span class="s1">self.ignore = ignorenonexistent</span>

    <span class="s2">def </span><span class="s1">_make_parser(self):</span>
        <span class="s0">&quot;&quot;&quot;Create a hardened XML parser (no custom/external entities).&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">DefusedExpatParser()</span>

    <span class="s2">def </span><span class="s1">__next__(self):</span>
        <span class="s2">for </span><span class="s1">event</span><span class="s2">, </span><span class="s1">node </span><span class="s2">in </span><span class="s1">self.event_stream:</span>
            <span class="s2">if </span><span class="s1">event == </span><span class="s3">&quot;START_ELEMENT&quot; </span><span class="s2">and </span><span class="s1">node.nodeName == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
                <span class="s1">self.event_stream.expandNode(node)</span>
                <span class="s2">return </span><span class="s1">self._handle_object(node)</span>
        <span class="s2">raise </span><span class="s1">StopIteration</span>

    <span class="s2">def </span><span class="s1">_handle_object(self</span><span class="s2">, </span><span class="s1">node):</span>
        <span class="s0">&quot;&quot;&quot;Convert an &lt;object&gt; node to a DeserializedObject.&quot;&quot;&quot;</span>
        <span class="s5"># Look up the model using the model loading mechanism. If this fails,</span>
        <span class="s5"># bail.</span>
        <span class="s1">Model = self._get_model_from_node(node</span><span class="s2">, </span><span class="s3">&quot;model&quot;</span><span class="s1">)</span>

        <span class="s5"># Start building a data dictionary from the object.</span>
        <span class="s1">data = {}</span>
        <span class="s2">if </span><span class="s1">node.hasAttribute(</span><span class="s3">'pk'</span><span class="s1">):</span>
            <span class="s1">data[Model._meta.pk.attname] = Model._meta.pk.to_python(</span>
                <span class="s1">node.getAttribute(</span><span class="s3">'pk'</span><span class="s1">))</span>

        <span class="s5"># Also start building a dict of m2m data (this is saved as</span>
        <span class="s5"># {m2m_accessor_attribute : [list_of_related_objects]})</span>
        <span class="s1">m2m_data = {}</span>
        <span class="s1">deferred_fields = {}</span>

        <span class="s1">field_names = {f.name </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">Model._meta.get_fields()}</span>
        <span class="s5"># Deserialize each field.</span>
        <span class="s2">for </span><span class="s1">field_node </span><span class="s2">in </span><span class="s1">node.getElementsByTagName(</span><span class="s3">&quot;field&quot;</span><span class="s1">):</span>
            <span class="s5"># If the field is missing the name attribute, bail (are you</span>
            <span class="s5"># sensing a pattern here?)</span>
            <span class="s1">field_name = field_node.getAttribute(</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">field_name:</span>
                <span class="s2">raise </span><span class="s1">base.DeserializationError(</span><span class="s3">&quot;&lt;field&gt; node is missing the 'name' attribute&quot;</span><span class="s1">)</span>

            <span class="s5"># Get the field from the Model. This will raise a</span>
            <span class="s5"># FieldDoesNotExist if, well, the field doesn't exist, which will</span>
            <span class="s5"># be propagated correctly unless ignorenonexistent=True is used.</span>
            <span class="s2">if </span><span class="s1">self.ignore </span><span class="s2">and </span><span class="s1">field_name </span><span class="s2">not in </span><span class="s1">field_names:</span>
                <span class="s2">continue</span>
            <span class="s1">field = Model._meta.get_field(field_name)</span>

            <span class="s5"># As is usually the case, relation fields get the special treatment.</span>
            <span class="s2">if </span><span class="s1">field.remote_field </span><span class="s2">and </span><span class="s1">isinstance(field.remote_field</span><span class="s2">, </span><span class="s1">models.ManyToManyRel):</span>
                <span class="s1">value = self._handle_m2m_field_node(field_node</span><span class="s2">, </span><span class="s1">field)</span>
                <span class="s2">if </span><span class="s1">value == base.DEFER_FIELD:</span>
                    <span class="s1">deferred_fields[field] = [</span>
                        <span class="s1">[</span>
                            <span class="s1">getInnerText(nat_node).strip()</span>
                            <span class="s2">for </span><span class="s1">nat_node </span><span class="s2">in </span><span class="s1">obj_node.getElementsByTagName(</span><span class="s3">'natural'</span><span class="s1">)</span>
                        <span class="s1">]</span>
                        <span class="s2">for </span><span class="s1">obj_node </span><span class="s2">in </span><span class="s1">field_node.getElementsByTagName(</span><span class="s3">'object'</span><span class="s1">)</span>
                    <span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">m2m_data[field.name] = value</span>
            <span class="s2">elif </span><span class="s1">field.remote_field </span><span class="s2">and </span><span class="s1">isinstance(field.remote_field</span><span class="s2">, </span><span class="s1">models.ManyToOneRel):</span>
                <span class="s1">value = self._handle_fk_field_node(field_node</span><span class="s2">, </span><span class="s1">field)</span>
                <span class="s2">if </span><span class="s1">value == base.DEFER_FIELD:</span>
                    <span class="s1">deferred_fields[field] = [</span>
                        <span class="s1">getInnerText(k).strip()</span>
                        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">field_node.getElementsByTagName(</span><span class="s3">'natural'</span><span class="s1">)</span>
                    <span class="s1">]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">data[field.attname] = value</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">field_node.getElementsByTagName(</span><span class="s3">'None'</span><span class="s1">):</span>
                    <span class="s1">value = </span><span class="s2">None</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">value = field.to_python(getInnerText(field_node).strip())</span>
                    <span class="s5"># Load value since JSONField.to_python() outputs strings.</span>
                    <span class="s2">if </span><span class="s1">field.get_internal_type() == </span><span class="s3">'JSONField'</span><span class="s1">:</span>
                        <span class="s1">value = json.loads(value</span><span class="s2">, </span><span class="s1">cls=field.decoder)</span>
                <span class="s1">data[field.name] = value</span>

        <span class="s1">obj = base.build_instance(Model</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">self.db)</span>

        <span class="s5"># Return a DeserializedObject so that the m2m data has a place to live.</span>
        <span class="s2">return </span><span class="s1">base.DeserializedObject(obj</span><span class="s2">, </span><span class="s1">m2m_data</span><span class="s2">, </span><span class="s1">deferred_fields)</span>

    <span class="s2">def </span><span class="s1">_handle_fk_field_node(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">field):</span>
        <span class="s0">&quot;&quot;&quot; 
        Handle a &lt;field&gt; node for a ForeignKey 
        &quot;&quot;&quot;</span>
        <span class="s5"># Check if there is a child node named 'None', returning None if so.</span>
        <span class="s2">if </span><span class="s1">node.getElementsByTagName(</span><span class="s3">'None'</span><span class="s1">):</span>
            <span class="s2">return None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">model = field.remote_field.model</span>
            <span class="s2">if </span><span class="s1">hasattr(model._default_manager</span><span class="s2">, </span><span class="s3">'get_by_natural_key'</span><span class="s1">):</span>
                <span class="s1">keys = node.getElementsByTagName(</span><span class="s3">'natural'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">keys:</span>
                    <span class="s5"># If there are 'natural' subelements, it must be a natural key</span>
                    <span class="s1">field_value = [getInnerText(k).strip() </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">keys]</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s1">obj = model._default_manager.db_manager(self.db).get_by_natural_key(*field_value)</span>
                    <span class="s2">except </span><span class="s1">ObjectDoesNotExist:</span>
                        <span class="s2">if </span><span class="s1">self.handle_forward_references:</span>
                            <span class="s2">return </span><span class="s1">base.DEFER_FIELD</span>
                        <span class="s2">else</span><span class="s1">:</span>
                            <span class="s2">raise</span>
                    <span class="s1">obj_pk = getattr(obj</span><span class="s2">, </span><span class="s1">field.remote_field.field_name)</span>
                    <span class="s5"># If this is a natural foreign key to an object that</span>
                    <span class="s5"># has a FK/O2O as the foreign key, use the FK value</span>
                    <span class="s2">if </span><span class="s1">field.remote_field.model._meta.pk.remote_field:</span>
                        <span class="s1">obj_pk = obj_pk.pk</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s5"># Otherwise, treat like a normal PK</span>
                    <span class="s1">field_value = getInnerText(node).strip()</span>
                    <span class="s1">obj_pk = model._meta.get_field(field.remote_field.field_name).to_python(field_value)</span>
                <span class="s2">return </span><span class="s1">obj_pk</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">field_value = getInnerText(node).strip()</span>
                <span class="s2">return </span><span class="s1">model._meta.get_field(field.remote_field.field_name).to_python(field_value)</span>

    <span class="s2">def </span><span class="s1">_handle_m2m_field_node(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">field):</span>
        <span class="s0">&quot;&quot;&quot; 
        Handle a &lt;field&gt; node for a ManyToManyField. 
        &quot;&quot;&quot;</span>
        <span class="s1">model = field.remote_field.model</span>
        <span class="s1">default_manager = model._default_manager</span>
        <span class="s2">if </span><span class="s1">hasattr(default_manager</span><span class="s2">, </span><span class="s3">'get_by_natural_key'</span><span class="s1">):</span>
            <span class="s2">def </span><span class="s1">m2m_convert(n):</span>
                <span class="s1">keys = n.getElementsByTagName(</span><span class="s3">'natural'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">keys:</span>
                    <span class="s5"># If there are 'natural' subelements, it must be a natural key</span>
                    <span class="s1">field_value = [getInnerText(k).strip() </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">keys]</span>
                    <span class="s1">obj_pk = default_manager.db_manager(self.db).get_by_natural_key(*field_value).pk</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s5"># Otherwise, treat like a normal PK value.</span>
                    <span class="s1">obj_pk = model._meta.pk.to_python(n.getAttribute(</span><span class="s3">'pk'</span><span class="s1">))</span>
                <span class="s2">return </span><span class="s1">obj_pk</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">m2m_convert(n):</span>
                <span class="s2">return </span><span class="s1">model._meta.pk.to_python(n.getAttribute(</span><span class="s3">'pk'</span><span class="s1">))</span>
        <span class="s1">values = []</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">node.getElementsByTagName(</span><span class="s3">'object'</span><span class="s1">):</span>
                <span class="s1">values.append(m2m_convert(c))</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">isinstance(e</span><span class="s2">, </span><span class="s1">ObjectDoesNotExist) </span><span class="s2">and </span><span class="s1">self.handle_forward_references:</span>
                <span class="s2">return </span><span class="s1">base.DEFER_FIELD</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">base.M2MDeserializationError(e</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">values</span>

    <span class="s2">def </span><span class="s1">_get_model_from_node(self</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">attr):</span>
        <span class="s0">&quot;&quot;&quot; 
        Look up a model from a &lt;object model=...&gt; or a &lt;field rel=... to=...&gt; 
        node. 
        &quot;&quot;&quot;</span>
        <span class="s1">model_identifier = node.getAttribute(attr)</span>
        <span class="s2">if not </span><span class="s1">model_identifier:</span>
            <span class="s2">raise </span><span class="s1">base.DeserializationError(</span>
                <span class="s3">&quot;&lt;%s&gt; node is missing the required '%s' attribute&quot;</span>
                <span class="s1">% (node.nodeName</span><span class="s2">, </span><span class="s1">attr))</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">apps.get_model(model_identifier)</span>
        <span class="s2">except </span><span class="s1">(LookupError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s2">raise </span><span class="s1">base.DeserializationError(</span>
                <span class="s3">&quot;&lt;%s&gt; node has invalid model identifier: '%s'&quot;</span>
                <span class="s1">% (node.nodeName</span><span class="s2">, </span><span class="s1">model_identifier))</span>


<span class="s2">def </span><span class="s1">getInnerText(node):</span>
    <span class="s0">&quot;&quot;&quot;Get all the inner text of a DOM node (recursively).&quot;&quot;&quot;</span>
    <span class="s5"># inspired by https://mail.python.org/pipermail/xml-sig/2005-March/011022.html</span>
    <span class="s1">inner_text = []</span>
    <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">node.childNodes:</span>
        <span class="s2">if </span><span class="s1">child.nodeType == child.TEXT_NODE </span><span class="s2">or </span><span class="s1">child.nodeType == child.CDATA_SECTION_NODE:</span>
            <span class="s1">inner_text.append(child.data)</span>
        <span class="s2">elif </span><span class="s1">child.nodeType == child.ELEMENT_NODE:</span>
            <span class="s1">inner_text.extend(getInnerText(child))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">pass</span>
    <span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">.join(inner_text)</span>


<span class="s5"># Below code based on Christian Heimes' defusedxml</span>


<span class="s2">class </span><span class="s1">DefusedExpatParser(_ExpatParser):</span>
    <span class="s0">&quot;&quot;&quot; 
    An expat parser hardened against XML bomb attacks. 
 
    Forbid DTDs, external entity references 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.setFeature(handler.feature_external_ges</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self.setFeature(handler.feature_external_pes</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">start_doctype_decl(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid</span><span class="s2">, </span><span class="s1">has_internal_subset):</span>
        <span class="s2">raise </span><span class="s1">DTDForbidden(name</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid)</span>

    <span class="s2">def </span><span class="s1">entity_decl(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">is_parameter_entity</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">base</span><span class="s2">,</span>
                    <span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid</span><span class="s2">, </span><span class="s1">notation_name):</span>
        <span class="s2">raise </span><span class="s1">EntitiesForbidden(name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid</span><span class="s2">, </span><span class="s1">notation_name)</span>

    <span class="s2">def </span><span class="s1">unparsed_entity_decl(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid</span><span class="s2">, </span><span class="s1">notation_name):</span>
        <span class="s5"># expat 1.2</span>
        <span class="s2">raise </span><span class="s1">EntitiesForbidden(name</span><span class="s2">, None, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid</span><span class="s2">, </span><span class="s1">notation_name)</span>

    <span class="s2">def </span><span class="s1">external_entity_ref_handler(self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid):</span>
        <span class="s2">raise </span><span class="s1">ExternalReferenceForbidden(context</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid)</span>

    <span class="s2">def </span><span class="s1">reset(self):</span>
        <span class="s1">_ExpatParser.reset(self)</span>
        <span class="s1">parser = self._parser</span>
        <span class="s1">parser.StartDoctypeDeclHandler = self.start_doctype_decl</span>
        <span class="s1">parser.EntityDeclHandler = self.entity_decl</span>
        <span class="s1">parser.UnparsedEntityDeclHandler = self.unparsed_entity_decl</span>
        <span class="s1">parser.ExternalEntityRefHandler = self.external_entity_ref_handler</span>


<span class="s2">class </span><span class="s1">DefusedXmlException(ValueError):</span>
    <span class="s0">&quot;&quot;&quot;Base exception.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">str(self)</span>


<span class="s2">class </span><span class="s1">DTDForbidden(DefusedXmlException):</span>
    <span class="s0">&quot;&quot;&quot;Document type definition is forbidden.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.sysid = sysid</span>
        <span class="s1">self.pubid = pubid</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">tpl = </span><span class="s3">&quot;DTDForbidden(name='{}', system_id={!r}, public_id={!r})&quot;</span>
        <span class="s2">return </span><span class="s1">tpl.format(self.name</span><span class="s2">, </span><span class="s1">self.sysid</span><span class="s2">, </span><span class="s1">self.pubid)</span>


<span class="s2">class </span><span class="s1">EntitiesForbidden(DefusedXmlException):</span>
    <span class="s0">&quot;&quot;&quot;Entity definition is forbidden.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid</span><span class="s2">, </span><span class="s1">notation_name):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.value = value</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self.sysid = sysid</span>
        <span class="s1">self.pubid = pubid</span>
        <span class="s1">self.notation_name = notation_name</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">tpl = </span><span class="s3">&quot;EntitiesForbidden(name='{}', system_id={!r}, public_id={!r})&quot;</span>
        <span class="s2">return </span><span class="s1">tpl.format(self.name</span><span class="s2">, </span><span class="s1">self.sysid</span><span class="s2">, </span><span class="s1">self.pubid)</span>


<span class="s2">class </span><span class="s1">ExternalReferenceForbidden(DefusedXmlException):</span>
    <span class="s0">&quot;&quot;&quot;Resolving an external reference is forbidden.&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">context</span><span class="s2">, </span><span class="s1">base</span><span class="s2">, </span><span class="s1">sysid</span><span class="s2">, </span><span class="s1">pubid):</span>
        <span class="s1">super().__init__()</span>
        <span class="s1">self.context = context</span>
        <span class="s1">self.base = base</span>
        <span class="s1">self.sysid = sysid</span>
        <span class="s1">self.pubid = pubid</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">tpl = </span><span class="s3">&quot;ExternalReferenceForbidden(system_id='{}', public_id={})&quot;</span>
        <span class="s2">return </span><span class="s1">tpl.format(self.sysid</span><span class="s2">, </span><span class="s1">self.pubid)</span>
</pre>
</body>
</html>