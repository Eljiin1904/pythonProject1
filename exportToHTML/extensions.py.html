<html>
<head>
<title>extensions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extensions.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is dual licensed under the terms of the Apache License, Version</span>
<span class="s0"># 2.0, and the BSD License. See the LICENSE file in the root of this repository</span>
<span class="s0"># for complete details.</span>


<span class="s2">import </span><span class="s1">abc</span>
<span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">import </span><span class="s1">hashlib</span>
<span class="s2">import </span><span class="s1">ipaddress</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">enum </span><span class="s2">import </span><span class="s1">Enum</span>

<span class="s2">from </span><span class="s1">cryptography </span><span class="s2">import </span><span class="s1">utils</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat._der </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BIT_STRING</span><span class="s2">,</span>
    <span class="s1">DERReader</span><span class="s2">,</span>
    <span class="s1">OBJECT_IDENTIFIER</span><span class="s2">,</span>
    <span class="s1">SEQUENCE</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat._types </span><span class="s2">import </span><span class="s1">_PUBLIC_KEY_TYPES</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives </span><span class="s2">import </span><span class="s1">constant_time</span><span class="s2">, </span><span class="s1">serialization</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.asymmetric.ec </span><span class="s2">import </span><span class="s1">EllipticCurvePublicKey</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.asymmetric.rsa </span><span class="s2">import </span><span class="s1">RSAPublicKey</span>
<span class="s2">from </span><span class="s1">cryptography.x509.certificate_transparency </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">SignedCertificateTimestamp</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.x509.general_name </span><span class="s2">import </span><span class="s1">GeneralName</span><span class="s2">, </span><span class="s1">IPAddress</span><span class="s2">, </span><span class="s1">OtherName</span>
<span class="s2">from </span><span class="s1">cryptography.x509.name </span><span class="s2">import </span><span class="s1">RelativeDistinguishedName</span>
<span class="s2">from </span><span class="s1">cryptography.x509.oid </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CRLEntryExtensionOID</span><span class="s2">,</span>
    <span class="s1">ExtensionOID</span><span class="s2">,</span>
    <span class="s1">OCSPExtensionOID</span><span class="s2">,</span>
    <span class="s1">ObjectIdentifier</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">_key_identifier_from_public_key(public_key: _PUBLIC_KEY_TYPES) -&gt; bytes:</span>
    <span class="s2">if </span><span class="s1">isinstance(public_key</span><span class="s2">, </span><span class="s1">RSAPublicKey):</span>
        <span class="s1">data = public_key.public_bytes(</span>
            <span class="s1">serialization.Encoding.DER</span><span class="s2">,</span>
            <span class="s1">serialization.PublicFormat.PKCS1</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">isinstance(public_key</span><span class="s2">, </span><span class="s1">EllipticCurvePublicKey):</span>
        <span class="s1">data = public_key.public_bytes(</span>
            <span class="s1">serialization.Encoding.X962</span><span class="s2">,</span>
            <span class="s1">serialization.PublicFormat.UncompressedPoint</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># This is a very slow way to do this.</span>
        <span class="s1">serialized = public_key.public_bytes(</span>
            <span class="s1">serialization.Encoding.DER</span><span class="s2">,</span>
            <span class="s1">serialization.PublicFormat.SubjectPublicKeyInfo</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">reader = DERReader(serialized)</span>
        <span class="s2">with </span><span class="s1">reader.read_single_element(SEQUENCE) </span><span class="s2">as </span><span class="s1">public_key_info:</span>
            <span class="s1">algorithm = public_key_info.read_element(SEQUENCE)</span>
            <span class="s1">public_key_data = public_key_info.read_element(BIT_STRING)</span>

        <span class="s0"># Double-check the algorithm structure.</span>
        <span class="s2">with </span><span class="s1">algorithm:</span>
            <span class="s1">algorithm.read_element(OBJECT_IDENTIFIER)</span>
            <span class="s2">if not </span><span class="s1">algorithm.is_empty():</span>
                <span class="s0"># Skip the optional parameters field.</span>
                <span class="s1">algorithm.read_any_element()</span>

        <span class="s0"># BIT STRING contents begin with the number of padding bytes added. It</span>
        <span class="s0"># must be zero for SubjectPublicKeyInfo structures.</span>
        <span class="s2">if </span><span class="s1">public_key_data.read_byte() != </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid public key encoding&quot;</span><span class="s1">)</span>

        <span class="s1">data = public_key_data.data</span>

    <span class="s2">return </span><span class="s1">hashlib.sha1(data).digest()</span>


<span class="s2">def </span><span class="s1">_make_sequence_methods(field_name):</span>
    <span class="s2">def </span><span class="s1">len_method(self):</span>
        <span class="s2">return </span><span class="s1">len(getattr(self</span><span class="s2">, </span><span class="s1">field_name))</span>

    <span class="s2">def </span><span class="s1">iter_method(self):</span>
        <span class="s2">return </span><span class="s1">iter(getattr(self</span><span class="s2">, </span><span class="s1">field_name))</span>

    <span class="s2">def </span><span class="s1">getitem_method(self</span><span class="s2">, </span><span class="s1">idx):</span>
        <span class="s2">return </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s1">field_name)[idx]</span>

    <span class="s2">return </span><span class="s1">len_method</span><span class="s2">, </span><span class="s1">iter_method</span><span class="s2">, </span><span class="s1">getitem_method</span>


<span class="s2">class </span><span class="s1">DuplicateExtension(Exception):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">msg: str</span><span class="s2">, </span><span class="s1">oid: ObjectIdentifier):</span>
        <span class="s1">super(DuplicateExtension</span><span class="s2">, </span><span class="s1">self).__init__(msg)</span>
        <span class="s1">self.oid = oid</span>


<span class="s2">class </span><span class="s1">ExtensionNotFound(Exception):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">msg: str</span><span class="s2">, </span><span class="s1">oid: ObjectIdentifier):</span>
        <span class="s1">super(ExtensionNotFound</span><span class="s2">, </span><span class="s1">self).__init__(msg)</span>
        <span class="s1">self.oid = oid</span>


<span class="s2">class </span><span class="s1">ExtensionType(metaclass=abc.ABCMeta):</span>
    <span class="s1">@abc.abstractproperty</span>
    <span class="s2">def </span><span class="s1">oid(self) -&gt; ObjectIdentifier:</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the oid associated with the given extension type. 
        &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Extensions(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">extensions: typing.List[</span><span class="s4">&quot;Extension&quot;</span><span class="s1">]):</span>
        <span class="s1">self._extensions = extensions</span>

    <span class="s2">def </span><span class="s1">get_extension_for_oid(self</span><span class="s2">, </span><span class="s1">oid: ObjectIdentifier) -&gt; </span><span class="s4">&quot;Extension&quot;</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">ext.oid == oid:</span>
                <span class="s2">return </span><span class="s1">ext</span>

        <span class="s2">raise </span><span class="s1">ExtensionNotFound(</span><span class="s4">&quot;No {} extension was found&quot;</span><span class="s1">.format(oid)</span><span class="s2">, </span><span class="s1">oid)</span>

    <span class="s2">def </span><span class="s1">get_extension_for_class(self</span><span class="s2">, </span><span class="s1">extclass) -&gt; </span><span class="s4">&quot;Extension&quot;</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">extclass </span><span class="s2">is </span><span class="s1">UnrecognizedExtension:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;UnrecognizedExtension can't be used with &quot;</span>
                <span class="s4">&quot;get_extension_for_class because more than one instance of the&quot;</span>
                <span class="s4">&quot; class may be present.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">for </span><span class="s1">ext </span><span class="s2">in </span><span class="s1">self:</span>
            <span class="s2">if </span><span class="s1">isinstance(ext.value</span><span class="s2">, </span><span class="s1">extclass):</span>
                <span class="s2">return </span><span class="s1">ext</span>

        <span class="s2">raise </span><span class="s1">ExtensionNotFound(</span>
            <span class="s4">&quot;No {} extension was found&quot;</span><span class="s1">.format(extclass)</span><span class="s2">, </span><span class="s1">extclass.oid</span>
        <span class="s1">)</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_extensions&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;Extensions({})&gt;&quot;</span><span class="s1">.format(self._extensions)</span>


<span class="s2">class </span><span class="s1">CRLNumber(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.CRL_NUMBER</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">crl_number: int):</span>
        <span class="s2">if not </span><span class="s1">isinstance(crl_number</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;crl_number must be an integer&quot;</span><span class="s1">)</span>

        <span class="s1">self._crl_number = crl_number</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">CRLNumber):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self.crl_number == other.crl_number</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self.crl_number)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;CRLNumber({})&gt;&quot;</span><span class="s1">.format(self.crl_number)</span>

    <span class="s1">crl_number = utils.read_only_property(</span><span class="s4">&quot;_crl_number&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">AuthorityKeyIdentifier(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.AUTHORITY_KEY_IDENTIFIER</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">key_identifier: typing.Optional[bytes]</span><span class="s2">,</span>
        <span class="s1">authority_cert_issuer: typing.Optional[typing.Iterable[GeneralName]]</span><span class="s2">,</span>
        <span class="s1">authority_cert_serial_number: typing.Optional[int]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(authority_cert_issuer </span><span class="s2">is None</span><span class="s1">) != (</span>
            <span class="s1">authority_cert_serial_number </span><span class="s2">is None</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;authority_cert_issuer and authority_cert_serial_number &quot;</span>
                <span class="s4">&quot;must both be present or both None&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">authority_cert_issuer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">authority_cert_issuer = list(authority_cert_issuer)</span>
            <span class="s2">if not </span><span class="s1">all(</span>
                <span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">GeneralName) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">authority_cert_issuer</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;authority_cert_issuer must be a list of GeneralName &quot;</span>
                    <span class="s4">&quot;objects&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">authority_cert_serial_number </span><span class="s2">is not None and not </span><span class="s1">isinstance(</span>
            <span class="s1">authority_cert_serial_number</span><span class="s2">, </span><span class="s1">int</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;authority_cert_serial_number must be an integer&quot;</span><span class="s1">)</span>

        <span class="s1">self._key_identifier = key_identifier</span>
        <span class="s1">self._authority_cert_issuer = authority_cert_issuer</span>
        <span class="s1">self._authority_cert_serial_number = authority_cert_serial_number</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_issuer_public_key(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">public_key: _PUBLIC_KEY_TYPES</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;AuthorityKeyIdentifier&quot;</span><span class="s1">:</span>
        <span class="s1">digest = _key_identifier_from_public_key(public_key)</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">key_identifier=digest</span><span class="s2">,</span>
            <span class="s1">authority_cert_issuer=</span><span class="s2">None,</span>
            <span class="s1">authority_cert_serial_number=</span><span class="s2">None,</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_issuer_subject_key_identifier(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">ski: </span><span class="s4">&quot;SubjectKeyIdentifier&quot;</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;AuthorityKeyIdentifier&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">key_identifier=ski.digest</span><span class="s2">,</span>
            <span class="s1">authority_cert_issuer=</span><span class="s2">None,</span>
            <span class="s1">authority_cert_serial_number=</span><span class="s2">None,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;AuthorityKeyIdentifier(key_identifier={0.key_identifier!r}, &quot;</span>
            <span class="s4">&quot;authority_cert_issuer={0.authority_cert_issuer}, &quot;</span>
            <span class="s4">&quot;authority_cert_serial_number={0.authority_cert_serial_number}&quot;</span>
            <span class="s4">&quot;)&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">AuthorityKeyIdentifier):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.key_identifier == other.key_identifier</span>
            <span class="s2">and </span><span class="s1">self.authority_cert_issuer == other.authority_cert_issuer</span>
            <span class="s2">and </span><span class="s1">self.authority_cert_serial_number</span>
            <span class="s1">== other.authority_cert_serial_number</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">if </span><span class="s1">self.authority_cert_issuer </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">aci = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">aci = tuple(self.authority_cert_issuer)</span>
        <span class="s2">return </span><span class="s1">hash(</span>
            <span class="s1">(self.key_identifier</span><span class="s2">, </span><span class="s1">aci</span><span class="s2">, </span><span class="s1">self.authority_cert_serial_number)</span>
        <span class="s1">)</span>

    <span class="s1">key_identifier = utils.read_only_property(</span><span class="s4">&quot;_key_identifier&quot;</span><span class="s1">)</span>
    <span class="s1">authority_cert_issuer = utils.read_only_property(</span><span class="s4">&quot;_authority_cert_issuer&quot;</span><span class="s1">)</span>
    <span class="s1">authority_cert_serial_number = utils.read_only_property(</span>
        <span class="s4">&quot;_authority_cert_serial_number&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">SubjectKeyIdentifier(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.SUBJECT_KEY_IDENTIFIER</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">digest: bytes):</span>
        <span class="s1">self._digest = digest</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_public_key(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">public_key: _PUBLIC_KEY_TYPES</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;SubjectKeyIdentifier&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">cls(_key_identifier_from_public_key(public_key))</span>

    <span class="s1">digest = utils.read_only_property(</span><span class="s4">&quot;_digest&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;SubjectKeyIdentifier(digest={0!r})&gt;&quot;</span><span class="s1">.format(self.digest)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SubjectKeyIdentifier):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">constant_time.bytes_eq(self.digest</span><span class="s2">, </span><span class="s1">other.digest)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self.digest)</span>


<span class="s2">class </span><span class="s1">AuthorityInformationAccess(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.AUTHORITY_INFORMATION_ACCESS</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">descriptions: typing.Iterable[</span><span class="s4">&quot;AccessDescription&quot;</span><span class="s1">]):</span>
        <span class="s1">descriptions = list(descriptions)</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">AccessDescription) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">descriptions):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Every item in the descriptions list must be an &quot;</span>
                <span class="s4">&quot;AccessDescription&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._descriptions = descriptions</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_descriptions&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;AuthorityInformationAccess({})&gt;&quot;</span><span class="s1">.format(self._descriptions)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">AuthorityInformationAccess):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._descriptions == other._descriptions</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._descriptions))</span>


<span class="s2">class </span><span class="s1">SubjectInformationAccess(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.SUBJECT_INFORMATION_ACCESS</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">descriptions: typing.Iterable[</span><span class="s4">&quot;AccessDescription&quot;</span><span class="s1">]):</span>
        <span class="s1">descriptions = list(descriptions)</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">AccessDescription) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">descriptions):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Every item in the descriptions list must be an &quot;</span>
                <span class="s4">&quot;AccessDescription&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._descriptions = descriptions</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_descriptions&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;SubjectInformationAccess({})&gt;&quot;</span><span class="s1">.format(self._descriptions)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SubjectInformationAccess):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._descriptions == other._descriptions</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._descriptions))</span>


<span class="s2">class </span><span class="s1">AccessDescription(object):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">access_method: ObjectIdentifier</span><span class="s2">, </span><span class="s1">access_location: GeneralName</span>
    <span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">isinstance(access_method</span><span class="s2">, </span><span class="s1">ObjectIdentifier):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;access_method must be an ObjectIdentifier&quot;</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">isinstance(access_location</span><span class="s2">, </span><span class="s1">GeneralName):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;access_location must be a GeneralName&quot;</span><span class="s1">)</span>

        <span class="s1">self._access_method = access_method</span>
        <span class="s1">self._access_location = access_location</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;AccessDescription(access_method={0.access_method}, access_locati&quot;</span>
            <span class="s4">&quot;on={0.access_location})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">AccessDescription):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.access_method == other.access_method</span>
            <span class="s2">and </span><span class="s1">self.access_location == other.access_location</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((self.access_method</span><span class="s2">, </span><span class="s1">self.access_location))</span>

    <span class="s1">access_method = utils.read_only_property(</span><span class="s4">&quot;_access_method&quot;</span><span class="s1">)</span>
    <span class="s1">access_location = utils.read_only_property(</span><span class="s4">&quot;_access_location&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">BasicConstraints(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.BASIC_CONSTRAINTS</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ca: bool</span><span class="s2">, </span><span class="s1">path_length: typing.Optional[int]):</span>
        <span class="s2">if not </span><span class="s1">isinstance(ca</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;ca must be a boolean value&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">path_length </span><span class="s2">is not None and not </span><span class="s1">ca:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;path_length must be None when ca is False&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">path_length </span><span class="s2">is not None and </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">isinstance(path_length</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">or </span><span class="s1">path_length &lt; </span><span class="s3">0</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;path_length must be a non-negative integer or None&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._ca = ca</span>
        <span class="s1">self._path_length = path_length</span>

    <span class="s1">ca = utils.read_only_property(</span><span class="s4">&quot;_ca&quot;</span><span class="s1">)</span>
    <span class="s1">path_length = utils.read_only_property(</span><span class="s4">&quot;_path_length&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;BasicConstraints(ca={0.ca}, &quot; &quot;path_length={0.path_length})&gt;&quot;</span>
        <span class="s1">).format(self)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">BasicConstraints):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self.ca == other.ca </span><span class="s2">and </span><span class="s1">self.path_length == other.path_length</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((self.ca</span><span class="s2">, </span><span class="s1">self.path_length))</span>


<span class="s2">class </span><span class="s1">DeltaCRLIndicator(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.DELTA_CRL_INDICATOR</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">crl_number: int):</span>
        <span class="s2">if not </span><span class="s1">isinstance(crl_number</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;crl_number must be an integer&quot;</span><span class="s1">)</span>

        <span class="s1">self._crl_number = crl_number</span>

    <span class="s1">crl_number = utils.read_only_property(</span><span class="s4">&quot;_crl_number&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">DeltaCRLIndicator):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self.crl_number == other.crl_number</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self.crl_number)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;DeltaCRLIndicator(crl_number={0.crl_number})&gt;&quot;</span><span class="s1">.format(self)</span>


<span class="s2">class </span><span class="s1">CRLDistributionPoints(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.CRL_DISTRIBUTION_POINTS</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">distribution_points: typing.Iterable[</span><span class="s4">&quot;DistributionPoint&quot;</span><span class="s1">]</span>
    <span class="s1">):</span>
        <span class="s1">distribution_points = list(distribution_points)</span>
        <span class="s2">if not </span><span class="s1">all(</span>
            <span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">DistributionPoint) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">distribution_points</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;distribution_points must be a list of DistributionPoint &quot;</span>
                <span class="s4">&quot;objects&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._distribution_points = distribution_points</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span>
        <span class="s4">&quot;_distribution_points&quot;</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;CRLDistributionPoints({})&gt;&quot;</span><span class="s1">.format(self._distribution_points)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">CRLDistributionPoints):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._distribution_points == other._distribution_points</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._distribution_points))</span>


<span class="s2">class </span><span class="s1">FreshestCRL(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.FRESHEST_CRL</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">distribution_points: typing.Iterable[</span><span class="s4">&quot;DistributionPoint&quot;</span><span class="s1">]</span>
    <span class="s1">):</span>
        <span class="s1">distribution_points = list(distribution_points)</span>
        <span class="s2">if not </span><span class="s1">all(</span>
            <span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">DistributionPoint) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">distribution_points</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;distribution_points must be a list of DistributionPoint &quot;</span>
                <span class="s4">&quot;objects&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._distribution_points = distribution_points</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span>
        <span class="s4">&quot;_distribution_points&quot;</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;FreshestCRL({})&gt;&quot;</span><span class="s1">.format(self._distribution_points)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">FreshestCRL):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._distribution_points == other._distribution_points</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._distribution_points))</span>


<span class="s2">class </span><span class="s1">DistributionPoint(object):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">full_name: typing.Optional[typing.Iterable[GeneralName]]</span><span class="s2">,</span>
        <span class="s1">relative_name: typing.Optional[RelativeDistinguishedName]</span><span class="s2">,</span>
        <span class="s1">reasons: typing.Optional[typing.FrozenSet[</span><span class="s4">&quot;ReasonFlags&quot;</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">crl_issuer: typing.Optional[typing.Iterable[GeneralName]]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">full_name </span><span class="s2">and </span><span class="s1">relative_name:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;You cannot provide both full_name and relative_name, at &quot;</span>
                <span class="s4">&quot;least one must be None.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">full_name:</span>
            <span class="s1">full_name = list(full_name)</span>
            <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">GeneralName) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">full_name):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;full_name must be a list of GeneralName objects&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">relative_name:</span>
            <span class="s2">if not </span><span class="s1">isinstance(relative_name</span><span class="s2">, </span><span class="s1">RelativeDistinguishedName):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;relative_name must be a RelativeDistinguishedName&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">crl_issuer:</span>
            <span class="s1">crl_issuer = list(crl_issuer)</span>
            <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">GeneralName) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">crl_issuer):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;crl_issuer must be None or a list of general names&quot;</span>
                <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">reasons </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">isinstance(reasons</span><span class="s2">, </span><span class="s1">frozenset)</span>
            <span class="s2">or not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">ReasonFlags) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">reasons)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;reasons must be None or frozenset of ReasonFlags&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">reasons </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">ReasonFlags.unspecified </span><span class="s2">in </span><span class="s1">reasons</span>
            <span class="s2">or </span><span class="s1">ReasonFlags.remove_from_crl </span><span class="s2">in </span><span class="s1">reasons</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;unspecified and remove_from_crl are not valid reasons in a &quot;</span>
                <span class="s4">&quot;DistributionPoint&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">reasons </span><span class="s2">and not </span><span class="s1">crl_issuer </span><span class="s2">and not </span><span class="s1">(full_name </span><span class="s2">or </span><span class="s1">relative_name):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;You must supply crl_issuer, full_name, or relative_name when &quot;</span>
                <span class="s4">&quot;reasons is not None&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._full_name = full_name</span>
        <span class="s1">self._relative_name = relative_name</span>
        <span class="s1">self._reasons = reasons</span>
        <span class="s1">self._crl_issuer = crl_issuer</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;DistributionPoint(full_name={0.full_name}, relative_name={0.rela&quot;</span>
            <span class="s4">&quot;tive_name}, reasons={0.reasons}, &quot;</span>
            <span class="s4">&quot;crl_issuer={0.crl_issuer})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">DistributionPoint):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.full_name == other.full_name</span>
            <span class="s2">and </span><span class="s1">self.relative_name == other.relative_name</span>
            <span class="s2">and </span><span class="s1">self.reasons == other.reasons</span>
            <span class="s2">and </span><span class="s1">self.crl_issuer == other.crl_issuer</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">if </span><span class="s1">self.full_name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">fn: typing.Optional[tuple] = tuple(self.full_name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fn = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.crl_issuer </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">crl_issuer: typing.Optional[tuple] = tuple(self.crl_issuer)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">crl_issuer = </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">hash((fn</span><span class="s2">, </span><span class="s1">self.relative_name</span><span class="s2">, </span><span class="s1">self.reasons</span><span class="s2">, </span><span class="s1">crl_issuer))</span>

    <span class="s1">full_name = utils.read_only_property(</span><span class="s4">&quot;_full_name&quot;</span><span class="s1">)</span>
    <span class="s1">relative_name = utils.read_only_property(</span><span class="s4">&quot;_relative_name&quot;</span><span class="s1">)</span>
    <span class="s1">reasons = utils.read_only_property(</span><span class="s4">&quot;_reasons&quot;</span><span class="s1">)</span>
    <span class="s1">crl_issuer = utils.read_only_property(</span><span class="s4">&quot;_crl_issuer&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">ReasonFlags(Enum):</span>
    <span class="s1">unspecified = </span><span class="s4">&quot;unspecified&quot;</span>
    <span class="s1">key_compromise = </span><span class="s4">&quot;keyCompromise&quot;</span>
    <span class="s1">ca_compromise = </span><span class="s4">&quot;cACompromise&quot;</span>
    <span class="s1">affiliation_changed = </span><span class="s4">&quot;affiliationChanged&quot;</span>
    <span class="s1">superseded = </span><span class="s4">&quot;superseded&quot;</span>
    <span class="s1">cessation_of_operation = </span><span class="s4">&quot;cessationOfOperation&quot;</span>
    <span class="s1">certificate_hold = </span><span class="s4">&quot;certificateHold&quot;</span>
    <span class="s1">privilege_withdrawn = </span><span class="s4">&quot;privilegeWithdrawn&quot;</span>
    <span class="s1">aa_compromise = </span><span class="s4">&quot;aACompromise&quot;</span>
    <span class="s1">remove_from_crl = </span><span class="s4">&quot;removeFromCRL&quot;</span>


<span class="s2">class </span><span class="s1">PolicyConstraints(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.POLICY_CONSTRAINTS</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">require_explicit_policy: typing.Optional[int]</span><span class="s2">,</span>
        <span class="s1">inhibit_policy_mapping: typing.Optional[int]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">require_explicit_policy </span><span class="s2">is not None and not </span><span class="s1">isinstance(</span>
            <span class="s1">require_explicit_policy</span><span class="s2">, </span><span class="s1">int</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;require_explicit_policy must be a non-negative integer or &quot;</span>
                <span class="s4">&quot;None&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">inhibit_policy_mapping </span><span class="s2">is not None and not </span><span class="s1">isinstance(</span>
            <span class="s1">inhibit_policy_mapping</span><span class="s2">, </span><span class="s1">int</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;inhibit_policy_mapping must be a non-negative integer or None&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">inhibit_policy_mapping </span><span class="s2">is None and </span><span class="s1">require_explicit_policy </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;At least one of require_explicit_policy and &quot;</span>
                <span class="s4">&quot;inhibit_policy_mapping must not be None&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._require_explicit_policy = require_explicit_policy</span>
        <span class="s1">self._inhibit_policy_mapping = inhibit_policy_mapping</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;PolicyConstraints(require_explicit_policy={0.require_explicit&quot;</span>
            <span class="s4">&quot;_policy}, inhibit_policy_mapping={0.inhibit_policy_&quot;</span>
            <span class="s4">&quot;mapping})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">PolicyConstraints):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.require_explicit_policy == other.require_explicit_policy</span>
            <span class="s2">and </span><span class="s1">self.inhibit_policy_mapping == other.inhibit_policy_mapping</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(</span>
            <span class="s1">(self.require_explicit_policy</span><span class="s2">, </span><span class="s1">self.inhibit_policy_mapping)</span>
        <span class="s1">)</span>

    <span class="s1">require_explicit_policy = utils.read_only_property(</span>
        <span class="s4">&quot;_require_explicit_policy&quot;</span>
    <span class="s1">)</span>
    <span class="s1">inhibit_policy_mapping = utils.read_only_property(</span>
        <span class="s4">&quot;_inhibit_policy_mapping&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">CertificatePolicies(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.CERTIFICATE_POLICIES</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">policies: typing.Iterable[</span><span class="s4">&quot;PolicyInformation&quot;</span><span class="s1">]):</span>
        <span class="s1">policies = list(policies)</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">PolicyInformation) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">policies):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Every item in the policies list must be a &quot;</span>
                <span class="s4">&quot;PolicyInformation&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._policies = policies</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_policies&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;CertificatePolicies({})&gt;&quot;</span><span class="s1">.format(self._policies)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">CertificatePolicies):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._policies == other._policies</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._policies))</span>


<span class="s2">class </span><span class="s1">PolicyInformation(object):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">policy_identifier: ObjectIdentifier</span><span class="s2">,</span>
        <span class="s1">policy_qualifiers: typing.Optional[</span>
            <span class="s1">typing.Iterable[typing.Union[str</span><span class="s2">, </span><span class="s4">&quot;UserNotice&quot;</span><span class="s1">]]</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">isinstance(policy_identifier</span><span class="s2">, </span><span class="s1">ObjectIdentifier):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;policy_identifier must be an ObjectIdentifier&quot;</span><span class="s1">)</span>

        <span class="s1">self._policy_identifier = policy_identifier</span>

        <span class="s2">if </span><span class="s1">policy_qualifiers:</span>
            <span class="s1">policy_qualifiers = list(policy_qualifiers)</span>
            <span class="s2">if not </span><span class="s1">all(</span>
                <span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">UserNotice)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">policy_qualifiers</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;policy_qualifiers must be a list of strings and/or &quot;</span>
                    <span class="s4">&quot;UserNotice objects or None&quot;</span>
                <span class="s1">)</span>

        <span class="s1">self._policy_qualifiers = policy_qualifiers</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;PolicyInformation(policy_identifier={0.policy_identifier}, polic&quot;</span>
            <span class="s4">&quot;y_qualifiers={0.policy_qualifiers})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">PolicyInformation):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.policy_identifier == other.policy_identifier</span>
            <span class="s2">and </span><span class="s1">self.policy_qualifiers == other.policy_qualifiers</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">if </span><span class="s1">self.policy_qualifiers </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">pq: typing.Optional[tuple] = tuple(self.policy_qualifiers)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pq = </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">hash((self.policy_identifier</span><span class="s2">, </span><span class="s1">pq))</span>

    <span class="s1">policy_identifier = utils.read_only_property(</span><span class="s4">&quot;_policy_identifier&quot;</span><span class="s1">)</span>
    <span class="s1">policy_qualifiers = utils.read_only_property(</span><span class="s4">&quot;_policy_qualifiers&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">UserNotice(object):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">notice_reference: typing.Optional[</span><span class="s4">&quot;NoticeReference&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">explicit_text: typing.Optional[str]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">notice_reference </span><span class="s2">and not </span><span class="s1">isinstance(</span>
            <span class="s1">notice_reference</span><span class="s2">, </span><span class="s1">NoticeReference</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;notice_reference must be None or a NoticeReference&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._notice_reference = notice_reference</span>
        <span class="s1">self._explicit_text = explicit_text</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;UserNotice(notice_reference={0.notice_reference}, explicit_text=&quot;</span>
            <span class="s4">&quot;{0.explicit_text!r})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">UserNotice):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.notice_reference == other.notice_reference</span>
            <span class="s2">and </span><span class="s1">self.explicit_text == other.explicit_text</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((self.notice_reference</span><span class="s2">, </span><span class="s1">self.explicit_text))</span>

    <span class="s1">notice_reference = utils.read_only_property(</span><span class="s4">&quot;_notice_reference&quot;</span><span class="s1">)</span>
    <span class="s1">explicit_text = utils.read_only_property(</span><span class="s4">&quot;_explicit_text&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">NoticeReference(object):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">organization: typing.Optional[str]</span><span class="s2">,</span>
        <span class="s1">notice_numbers: typing.Iterable[int]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">self._organization = organization</span>
        <span class="s1">notice_numbers = list(notice_numbers)</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">notice_numbers):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;notice_numbers must be a list of integers&quot;</span><span class="s1">)</span>

        <span class="s1">self._notice_numbers = notice_numbers</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;NoticeReference(organization={0.organization!r}, notice_numbers=&quot;</span>
            <span class="s4">&quot;{0.notice_numbers})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">NoticeReference):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.organization == other.organization</span>
            <span class="s2">and </span><span class="s1">self.notice_numbers == other.notice_numbers</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((self.organization</span><span class="s2">, </span><span class="s1">tuple(self.notice_numbers)))</span>

    <span class="s1">organization = utils.read_only_property(</span><span class="s4">&quot;_organization&quot;</span><span class="s1">)</span>
    <span class="s1">notice_numbers = utils.read_only_property(</span><span class="s4">&quot;_notice_numbers&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">ExtendedKeyUsage(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.EXTENDED_KEY_USAGE</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">usages: typing.Iterable[ObjectIdentifier]):</span>
        <span class="s1">usages = list(usages)</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">ObjectIdentifier) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">usages):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Every item in the usages list must be an ObjectIdentifier&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._usages = usages</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_usages&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;ExtendedKeyUsage({})&gt;&quot;</span><span class="s1">.format(self._usages)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">ExtendedKeyUsage):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._usages == other._usages</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._usages))</span>


<span class="s2">class </span><span class="s1">OCSPNoCheck(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.OCSP_NO_CHECK</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">OCSPNoCheck):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(OCSPNoCheck)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;OCSPNoCheck()&gt;&quot;</span>


<span class="s2">class </span><span class="s1">PrecertPoison(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.PRECERT_POISON</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">PrecertPoison):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(PrecertPoison)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;PrecertPoison()&gt;&quot;</span>


<span class="s2">class </span><span class="s1">TLSFeature(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.TLS_FEATURE</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">features: typing.Iterable[</span><span class="s4">&quot;TLSFeatureType&quot;</span><span class="s1">]):</span>
        <span class="s1">features = list(features)</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">TLSFeatureType) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">features)</span>
            <span class="s2">or </span><span class="s1">len(features) == </span><span class="s3">0</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;features must be a list of elements from the TLSFeatureType &quot;</span>
                <span class="s4">&quot;enum&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._features = features</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_features&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;TLSFeature(features={0._features})&gt;&quot;</span><span class="s1">.format(self)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">TLSFeature):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._features == other._features</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._features))</span>


<span class="s2">class </span><span class="s1">TLSFeatureType(Enum):</span>
    <span class="s0"># status_request is defined in RFC 6066 and is used for what is commonly</span>
    <span class="s0"># called OCSP Must-Staple when present in the TLS Feature extension in an</span>
    <span class="s0"># X.509 certificate.</span>
    <span class="s1">status_request = </span><span class="s3">5</span>
    <span class="s0"># status_request_v2 is defined in RFC 6961 and allows multiple OCSP</span>
    <span class="s0"># responses to be provided. It is not currently in use by clients or</span>
    <span class="s0"># servers.</span>
    <span class="s1">status_request_v2 = </span><span class="s3">17</span>


<span class="s1">_TLS_FEATURE_TYPE_TO_ENUM = {x.value: x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">TLSFeatureType}</span>


<span class="s2">class </span><span class="s1">InhibitAnyPolicy(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.INHIBIT_ANY_POLICY</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">skip_certs: int):</span>
        <span class="s2">if not </span><span class="s1">isinstance(skip_certs</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;skip_certs must be an integer&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">skip_certs &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;skip_certs must be a non-negative integer&quot;</span><span class="s1">)</span>

        <span class="s1">self._skip_certs = skip_certs</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;InhibitAnyPolicy(skip_certs={0.skip_certs})&gt;&quot;</span><span class="s1">.format(self)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">InhibitAnyPolicy):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self.skip_certs == other.skip_certs</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self.skip_certs)</span>

    <span class="s1">skip_certs = utils.read_only_property(</span><span class="s4">&quot;_skip_certs&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">KeyUsage(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.KEY_USAGE</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">digital_signature: bool</span><span class="s2">,</span>
        <span class="s1">content_commitment: bool</span><span class="s2">,</span>
        <span class="s1">key_encipherment: bool</span><span class="s2">,</span>
        <span class="s1">data_encipherment: bool</span><span class="s2">,</span>
        <span class="s1">key_agreement: bool</span><span class="s2">,</span>
        <span class="s1">key_cert_sign: bool</span><span class="s2">,</span>
        <span class="s1">crl_sign: bool</span><span class="s2">,</span>
        <span class="s1">encipher_only: bool</span><span class="s2">,</span>
        <span class="s1">decipher_only: bool</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">key_agreement </span><span class="s2">and </span><span class="s1">(encipher_only </span><span class="s2">or </span><span class="s1">decipher_only):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;encipher_only and decipher_only can only be true when &quot;</span>
                <span class="s4">&quot;key_agreement is true&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._digital_signature = digital_signature</span>
        <span class="s1">self._content_commitment = content_commitment</span>
        <span class="s1">self._key_encipherment = key_encipherment</span>
        <span class="s1">self._data_encipherment = data_encipherment</span>
        <span class="s1">self._key_agreement = key_agreement</span>
        <span class="s1">self._key_cert_sign = key_cert_sign</span>
        <span class="s1">self._crl_sign = crl_sign</span>
        <span class="s1">self._encipher_only = encipher_only</span>
        <span class="s1">self._decipher_only = decipher_only</span>

    <span class="s1">digital_signature = utils.read_only_property(</span><span class="s4">&quot;_digital_signature&quot;</span><span class="s1">)</span>
    <span class="s1">content_commitment = utils.read_only_property(</span><span class="s4">&quot;_content_commitment&quot;</span><span class="s1">)</span>
    <span class="s1">key_encipherment = utils.read_only_property(</span><span class="s4">&quot;_key_encipherment&quot;</span><span class="s1">)</span>
    <span class="s1">data_encipherment = utils.read_only_property(</span><span class="s4">&quot;_data_encipherment&quot;</span><span class="s1">)</span>
    <span class="s1">key_agreement = utils.read_only_property(</span><span class="s4">&quot;_key_agreement&quot;</span><span class="s1">)</span>
    <span class="s1">key_cert_sign = utils.read_only_property(</span><span class="s4">&quot;_key_cert_sign&quot;</span><span class="s1">)</span>
    <span class="s1">crl_sign = utils.read_only_property(</span><span class="s4">&quot;_crl_sign&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">encipher_only(self):</span>
        <span class="s2">if not </span><span class="s1">self.key_agreement:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;encipher_only is undefined unless key_agreement is true&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._encipher_only</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">decipher_only(self):</span>
        <span class="s2">if not </span><span class="s1">self.key_agreement:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;decipher_only is undefined unless key_agreement is true&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._decipher_only</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">encipher_only = self.encipher_only</span>
            <span class="s1">decipher_only = self.decipher_only</span>
        <span class="s2">except </span><span class="s1">ValueError:</span>
            <span class="s0"># Users found None confusing because even though encipher/decipher</span>
            <span class="s0"># have no meaning unless key_agreement is true, to construct an</span>
            <span class="s0"># instance of the class you still need to pass False.</span>
            <span class="s1">encipher_only = </span><span class="s2">False</span>
            <span class="s1">decipher_only = </span><span class="s2">False</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;KeyUsage(digital_signature={0.digital_signature}, &quot;</span>
            <span class="s4">&quot;content_commitment={0.content_commitment}, &quot;</span>
            <span class="s4">&quot;key_encipherment={0.key_encipherment}, &quot;</span>
            <span class="s4">&quot;data_encipherment={0.data_encipherment}, &quot;</span>
            <span class="s4">&quot;key_agreement={0.key_agreement}, &quot;</span>
            <span class="s4">&quot;key_cert_sign={0.key_cert_sign}, crl_sign={0.crl_sign}, &quot;</span>
            <span class="s4">&quot;encipher_only={1}, decipher_only={2})&gt;&quot;</span>
        <span class="s1">).format(self</span><span class="s2">, </span><span class="s1">encipher_only</span><span class="s2">, </span><span class="s1">decipher_only)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">KeyUsage):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.digital_signature == other.digital_signature</span>
            <span class="s2">and </span><span class="s1">self.content_commitment == other.content_commitment</span>
            <span class="s2">and </span><span class="s1">self.key_encipherment == other.key_encipherment</span>
            <span class="s2">and </span><span class="s1">self.data_encipherment == other.data_encipherment</span>
            <span class="s2">and </span><span class="s1">self.key_agreement == other.key_agreement</span>
            <span class="s2">and </span><span class="s1">self.key_cert_sign == other.key_cert_sign</span>
            <span class="s2">and </span><span class="s1">self.crl_sign == other.crl_sign</span>
            <span class="s2">and </span><span class="s1">self._encipher_only == other._encipher_only</span>
            <span class="s2">and </span><span class="s1">self._decipher_only == other._decipher_only</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(</span>
            <span class="s1">(</span>
                <span class="s1">self.digital_signature</span><span class="s2">,</span>
                <span class="s1">self.content_commitment</span><span class="s2">,</span>
                <span class="s1">self.key_encipherment</span><span class="s2">,</span>
                <span class="s1">self.data_encipherment</span><span class="s2">,</span>
                <span class="s1">self.key_agreement</span><span class="s2">,</span>
                <span class="s1">self.key_cert_sign</span><span class="s2">,</span>
                <span class="s1">self.crl_sign</span><span class="s2">,</span>
                <span class="s1">self._encipher_only</span><span class="s2">,</span>
                <span class="s1">self._decipher_only</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">NameConstraints(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.NAME_CONSTRAINTS</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">permitted_subtrees: typing.Optional[typing.Iterable[GeneralName]]</span><span class="s2">,</span>
        <span class="s1">excluded_subtrees: typing.Optional[typing.Iterable[GeneralName]]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">permitted_subtrees </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">permitted_subtrees = list(permitted_subtrees)</span>
            <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">GeneralName) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">permitted_subtrees):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;permitted_subtrees must be a list of GeneralName objects &quot;</span>
                    <span class="s4">&quot;or None&quot;</span>
                <span class="s1">)</span>

            <span class="s1">self._validate_ip_name(permitted_subtrees)</span>

        <span class="s2">if </span><span class="s1">excluded_subtrees </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">excluded_subtrees = list(excluded_subtrees)</span>
            <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">GeneralName) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">excluded_subtrees):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;excluded_subtrees must be a list of GeneralName objects &quot;</span>
                    <span class="s4">&quot;or None&quot;</span>
                <span class="s1">)</span>

            <span class="s1">self._validate_ip_name(excluded_subtrees)</span>

        <span class="s2">if </span><span class="s1">permitted_subtrees </span><span class="s2">is None and </span><span class="s1">excluded_subtrees </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;At least one of permitted_subtrees and excluded_subtrees &quot;</span>
                <span class="s4">&quot;must not be None&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._permitted_subtrees = permitted_subtrees</span>
        <span class="s1">self._excluded_subtrees = excluded_subtrees</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">NameConstraints):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.excluded_subtrees == other.excluded_subtrees</span>
            <span class="s2">and </span><span class="s1">self.permitted_subtrees == other.permitted_subtrees</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">_validate_ip_name(self</span><span class="s2">, </span><span class="s1">tree):</span>
        <span class="s2">if </span><span class="s1">any(</span>
            <span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">IPAddress)</span>
            <span class="s2">and not </span><span class="s1">isinstance(</span>
                <span class="s1">name.value</span><span class="s2">, </span><span class="s1">(ipaddress.IPv4Network</span><span class="s2">, </span><span class="s1">ipaddress.IPv6Network)</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">tree</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;IPAddress name constraints must be an IPv4Network or&quot;</span>
                <span class="s4">&quot; IPv6Network object&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;NameConstraints(permitted_subtrees={0.permitted_subtrees}, &quot;</span>
            <span class="s4">&quot;excluded_subtrees={0.excluded_subtrees})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">if </span><span class="s1">self.permitted_subtrees </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">ps: typing.Optional[tuple] = tuple(self.permitted_subtrees)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ps = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.excluded_subtrees </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">es: typing.Optional[tuple] = tuple(self.excluded_subtrees)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">es = </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">hash((ps</span><span class="s2">, </span><span class="s1">es))</span>

    <span class="s1">permitted_subtrees = utils.read_only_property(</span><span class="s4">&quot;_permitted_subtrees&quot;</span><span class="s1">)</span>
    <span class="s1">excluded_subtrees = utils.read_only_property(</span><span class="s4">&quot;_excluded_subtrees&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">Extension(object):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">oid: ObjectIdentifier</span><span class="s2">, </span><span class="s1">critical: bool</span><span class="s2">, </span><span class="s1">value: ExtensionType</span>
    <span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">isinstance(oid</span><span class="s2">, </span><span class="s1">ObjectIdentifier):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;oid argument must be an ObjectIdentifier instance.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">isinstance(critical</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;critical must be a boolean value&quot;</span><span class="s1">)</span>

        <span class="s1">self._oid = oid</span>
        <span class="s1">self._critical = critical</span>
        <span class="s1">self._value = value</span>

    <span class="s1">oid = utils.read_only_property(</span><span class="s4">&quot;_oid&quot;</span><span class="s1">)</span>
    <span class="s1">critical = utils.read_only_property(</span><span class="s4">&quot;_critical&quot;</span><span class="s1">)</span>
    <span class="s1">value = utils.read_only_property(</span><span class="s4">&quot;_value&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;Extension(oid={0.oid}, critical={0.critical}, &quot;</span>
            <span class="s4">&quot;value={0.value})&gt;&quot;</span>
        <span class="s1">).format(self)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Extension):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.oid == other.oid</span>
            <span class="s2">and </span><span class="s1">self.critical == other.critical</span>
            <span class="s2">and </span><span class="s1">self.value == other.value</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((self.oid</span><span class="s2">, </span><span class="s1">self.critical</span><span class="s2">, </span><span class="s1">self.value))</span>


<span class="s2">class </span><span class="s1">GeneralNames(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">general_names: typing.Iterable[GeneralName]):</span>
        <span class="s1">general_names = list(general_names)</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">GeneralName) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">general_names):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Every item in the general_names list must be an &quot;</span>
                <span class="s4">&quot;object conforming to the GeneralName interface&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._general_names = general_names</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_general_names&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_values_for_type(self</span><span class="s2">, </span><span class="s1">type: typing.Type[GeneralName]):</span>
        <span class="s0"># Return the value of each GeneralName, except for OtherName instances</span>
        <span class="s0"># which we return directly because it has two important properties not</span>
        <span class="s0"># just one value.</span>
        <span class="s1">objs = (i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self </span><span class="s2">if </span><span class="s1">isinstance(i</span><span class="s2">, </span><span class="s1">type))</span>
        <span class="s2">if </span><span class="s1">type != OtherName:</span>
            <span class="s1">objs = (i.value </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">objs)</span>
        <span class="s2">return </span><span class="s1">list(objs)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;GeneralNames({})&gt;&quot;</span><span class="s1">.format(self._general_names)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">GeneralNames):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._general_names == other._general_names</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._general_names))</span>


<span class="s2">class </span><span class="s1">SubjectAlternativeName(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.SUBJECT_ALTERNATIVE_NAME</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">general_names: typing.Iterable[GeneralName]):</span>
        <span class="s1">self._general_names = GeneralNames(general_names)</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_general_names&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_values_for_type(self</span><span class="s2">, </span><span class="s1">type):</span>
        <span class="s2">return </span><span class="s1">self._general_names.get_values_for_type(type)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;SubjectAlternativeName({})&gt;&quot;</span><span class="s1">.format(self._general_names)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SubjectAlternativeName):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._general_names == other._general_names</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self._general_names)</span>


<span class="s2">class </span><span class="s1">IssuerAlternativeName(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.ISSUER_ALTERNATIVE_NAME</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">general_names: typing.Iterable[GeneralName]):</span>
        <span class="s1">self._general_names = GeneralNames(general_names)</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_general_names&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_values_for_type(self</span><span class="s2">, </span><span class="s1">type):</span>
        <span class="s2">return </span><span class="s1">self._general_names.get_values_for_type(type)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;IssuerAlternativeName({})&gt;&quot;</span><span class="s1">.format(self._general_names)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">IssuerAlternativeName):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._general_names == other._general_names</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self._general_names)</span>


<span class="s2">class </span><span class="s1">CertificateIssuer(ExtensionType):</span>
    <span class="s1">oid = CRLEntryExtensionOID.CERTIFICATE_ISSUER</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">general_names: typing.Iterable[GeneralName]):</span>
        <span class="s1">self._general_names = GeneralNames(general_names)</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span><span class="s4">&quot;_general_names&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_values_for_type(self</span><span class="s2">, </span><span class="s1">type):</span>
        <span class="s2">return </span><span class="s1">self._general_names.get_values_for_type(type)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;CertificateIssuer({})&gt;&quot;</span><span class="s1">.format(self._general_names)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">CertificateIssuer):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self._general_names == other._general_names</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self._general_names)</span>


<span class="s2">class </span><span class="s1">CRLReason(ExtensionType):</span>
    <span class="s1">oid = CRLEntryExtensionOID.CRL_REASON</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">reason: ReasonFlags):</span>
        <span class="s2">if not </span><span class="s1">isinstance(reason</span><span class="s2">, </span><span class="s1">ReasonFlags):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;reason must be an element from ReasonFlags&quot;</span><span class="s1">)</span>

        <span class="s1">self._reason = reason</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;CRLReason(reason={})&gt;&quot;</span><span class="s1">.format(self._reason)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">CRLReason):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self.reason == other.reason</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self.reason)</span>

    <span class="s1">reason = utils.read_only_property(</span><span class="s4">&quot;_reason&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">InvalidityDate(ExtensionType):</span>
    <span class="s1">oid = CRLEntryExtensionOID.INVALIDITY_DATE</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">invalidity_date: datetime.datetime):</span>
        <span class="s2">if not </span><span class="s1">isinstance(invalidity_date</span><span class="s2">, </span><span class="s1">datetime.datetime):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;invalidity_date must be a datetime.datetime&quot;</span><span class="s1">)</span>

        <span class="s1">self._invalidity_date = invalidity_date</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;InvalidityDate(invalidity_date={})&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">self._invalidity_date</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">InvalidityDate):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self.invalidity_date == other.invalidity_date</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self.invalidity_date)</span>

    <span class="s1">invalidity_date = utils.read_only_property(</span><span class="s4">&quot;_invalidity_date&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">PrecertificateSignedCertificateTimestamps(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">signed_certificate_timestamps: typing.Iterable[</span>
            <span class="s1">SignedCertificateTimestamp</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">signed_certificate_timestamps = list(signed_certificate_timestamps)</span>
        <span class="s2">if not </span><span class="s1">all(</span>
            <span class="s1">isinstance(sct</span><span class="s2">, </span><span class="s1">SignedCertificateTimestamp)</span>
            <span class="s2">for </span><span class="s1">sct </span><span class="s2">in </span><span class="s1">signed_certificate_timestamps</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Every item in the signed_certificate_timestamps list must be &quot;</span>
                <span class="s4">&quot;a SignedCertificateTimestamp&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self._signed_certificate_timestamps = signed_certificate_timestamps</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span>
        <span class="s4">&quot;_signed_certificate_timestamps&quot;</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;PrecertificateSignedCertificateTimestamps({})&gt;&quot;</span><span class="s1">.format(</span>
            <span class="s1">list(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._signed_certificate_timestamps))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">PrecertificateSignedCertificateTimestamps):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self._signed_certificate_timestamps</span>
            <span class="s1">== other._signed_certificate_timestamps</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>


<span class="s2">class </span><span class="s1">SignedCertificateTimestamps(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.SIGNED_CERTIFICATE_TIMESTAMPS</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">signed_certificate_timestamps: typing.Iterable[</span>
            <span class="s1">SignedCertificateTimestamp</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">signed_certificate_timestamps = list(signed_certificate_timestamps)</span>
        <span class="s2">if not </span><span class="s1">all(</span>
            <span class="s1">isinstance(sct</span><span class="s2">, </span><span class="s1">SignedCertificateTimestamp)</span>
            <span class="s2">for </span><span class="s1">sct </span><span class="s2">in </span><span class="s1">signed_certificate_timestamps</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Every item in the signed_certificate_timestamps list must be &quot;</span>
                <span class="s4">&quot;a SignedCertificateTimestamp&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self._signed_certificate_timestamps = signed_certificate_timestamps</span>

    <span class="s1">__len__</span><span class="s2">, </span><span class="s1">__iter__</span><span class="s2">, </span><span class="s1">__getitem__ = _make_sequence_methods(</span>
        <span class="s4">&quot;_signed_certificate_timestamps&quot;</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;SignedCertificateTimestamps({})&gt;&quot;</span><span class="s1">.format(list(self))</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(tuple(self._signed_certificate_timestamps))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">SignedCertificateTimestamps):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self._signed_certificate_timestamps</span>
            <span class="s1">== other._signed_certificate_timestamps</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>


<span class="s2">class </span><span class="s1">OCSPNonce(ExtensionType):</span>
    <span class="s1">oid = OCSPExtensionOID.NONCE</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">nonce: bytes):</span>
        <span class="s2">if not </span><span class="s1">isinstance(nonce</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;nonce must be bytes&quot;</span><span class="s1">)</span>

        <span class="s1">self._nonce = nonce</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">OCSPNonce):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self.nonce == other.nonce</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self.nonce)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;OCSPNonce(nonce={0.nonce!r})&gt;&quot;</span><span class="s1">.format(self)</span>

    <span class="s1">nonce = utils.read_only_property(</span><span class="s4">&quot;_nonce&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">IssuingDistributionPoint(ExtensionType):</span>
    <span class="s1">oid = ExtensionOID.ISSUING_DISTRIBUTION_POINT</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">full_name</span><span class="s2">,</span>
        <span class="s1">relative_name</span><span class="s2">,</span>
        <span class="s1">only_contains_user_certs</span><span class="s2">,</span>
        <span class="s1">only_contains_ca_certs</span><span class="s2">,</span>
        <span class="s1">only_some_reasons</span><span class="s2">,</span>
        <span class="s1">indirect_crl</span><span class="s2">,</span>
        <span class="s1">only_contains_attribute_certs</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">only_some_reasons </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s2">not </span><span class="s1">isinstance(only_some_reasons</span><span class="s2">, </span><span class="s1">frozenset)</span>
            <span class="s2">or not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">ReasonFlags) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">only_some_reasons)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;only_some_reasons must be None or frozenset of ReasonFlags&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">only_some_reasons </span><span class="s2">and </span><span class="s1">(</span>
            <span class="s1">ReasonFlags.unspecified </span><span class="s2">in </span><span class="s1">only_some_reasons</span>
            <span class="s2">or </span><span class="s1">ReasonFlags.remove_from_crl </span><span class="s2">in </span><span class="s1">only_some_reasons</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;unspecified and remove_from_crl are not valid reasons in an &quot;</span>
                <span class="s4">&quot;IssuingDistributionPoint&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">(</span>
            <span class="s1">isinstance(only_contains_user_certs</span><span class="s2">, </span><span class="s1">bool)</span>
            <span class="s2">and </span><span class="s1">isinstance(only_contains_ca_certs</span><span class="s2">, </span><span class="s1">bool)</span>
            <span class="s2">and </span><span class="s1">isinstance(indirect_crl</span><span class="s2">, </span><span class="s1">bool)</span>
            <span class="s2">and </span><span class="s1">isinstance(only_contains_attribute_certs</span><span class="s2">, </span><span class="s1">bool)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;only_contains_user_certs, only_contains_ca_certs, &quot;</span>
                <span class="s4">&quot;indirect_crl and only_contains_attribute_certs &quot;</span>
                <span class="s4">&quot;must all be boolean.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">crl_constraints = [</span>
            <span class="s1">only_contains_user_certs</span><span class="s2">,</span>
            <span class="s1">only_contains_ca_certs</span><span class="s2">,</span>
            <span class="s1">indirect_crl</span><span class="s2">,</span>
            <span class="s1">only_contains_attribute_certs</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len([x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">crl_constraints </span><span class="s2">if </span><span class="s1">x]) &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Only one of the following can be set to True: &quot;</span>
                <span class="s4">&quot;only_contains_user_certs, only_contains_ca_certs, &quot;</span>
                <span class="s4">&quot;indirect_crl, only_contains_attribute_certs&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">any(</span>
            <span class="s1">[</span>
                <span class="s1">only_contains_user_certs</span><span class="s2">,</span>
                <span class="s1">only_contains_ca_certs</span><span class="s2">,</span>
                <span class="s1">indirect_crl</span><span class="s2">,</span>
                <span class="s1">only_contains_attribute_certs</span><span class="s2">,</span>
                <span class="s1">full_name</span><span class="s2">,</span>
                <span class="s1">relative_name</span><span class="s2">,</span>
                <span class="s1">only_some_reasons</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Cannot create empty extension: &quot;</span>
                <span class="s4">&quot;if only_contains_user_certs, only_contains_ca_certs, &quot;</span>
                <span class="s4">&quot;indirect_crl, and only_contains_attribute_certs are all False&quot;</span>
                <span class="s4">&quot;, then either full_name, relative_name, or only_some_reasons &quot;</span>
                <span class="s4">&quot;must have a value.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">self._only_contains_user_certs = only_contains_user_certs</span>
        <span class="s1">self._only_contains_ca_certs = only_contains_ca_certs</span>
        <span class="s1">self._indirect_crl = indirect_crl</span>
        <span class="s1">self._only_contains_attribute_certs = only_contains_attribute_certs</span>
        <span class="s1">self._only_some_reasons = only_some_reasons</span>
        <span class="s1">self._full_name = full_name</span>
        <span class="s1">self._relative_name = relative_name</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;IssuingDistributionPoint(full_name={0.full_name}, &quot;</span>
            <span class="s4">&quot;relative_name={0.relative_name}, &quot;</span>
            <span class="s4">&quot;only_contains_user_certs={0.only_contains_user_certs}, &quot;</span>
            <span class="s4">&quot;only_contains_ca_certs={0.only_contains_ca_certs}, &quot;</span>
            <span class="s4">&quot;only_some_reasons={0.only_some_reasons}, &quot;</span>
            <span class="s4">&quot;indirect_crl={0.indirect_crl}, &quot;</span>
            <span class="s4">&quot;only_contains_attribute_certs=&quot;</span>
            <span class="s4">&quot;{0.only_contains_attribute_certs})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">IssuingDistributionPoint):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">self.full_name == other.full_name</span>
            <span class="s2">and </span><span class="s1">self.relative_name == other.relative_name</span>
            <span class="s2">and </span><span class="s1">self.only_contains_user_certs == other.only_contains_user_certs</span>
            <span class="s2">and </span><span class="s1">self.only_contains_ca_certs == other.only_contains_ca_certs</span>
            <span class="s2">and </span><span class="s1">self.only_some_reasons == other.only_some_reasons</span>
            <span class="s2">and </span><span class="s1">self.indirect_crl == other.indirect_crl</span>
            <span class="s2">and </span><span class="s1">self.only_contains_attribute_certs</span>
            <span class="s1">== other.only_contains_attribute_certs</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(</span>
            <span class="s1">(</span>
                <span class="s1">self.full_name</span><span class="s2">,</span>
                <span class="s1">self.relative_name</span><span class="s2">,</span>
                <span class="s1">self.only_contains_user_certs</span><span class="s2">,</span>
                <span class="s1">self.only_contains_ca_certs</span><span class="s2">,</span>
                <span class="s1">self.only_some_reasons</span><span class="s2">,</span>
                <span class="s1">self.indirect_crl</span><span class="s2">,</span>
                <span class="s1">self.only_contains_attribute_certs</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s1">full_name = utils.read_only_property(</span><span class="s4">&quot;_full_name&quot;</span><span class="s1">)</span>
    <span class="s1">relative_name = utils.read_only_property(</span><span class="s4">&quot;_relative_name&quot;</span><span class="s1">)</span>
    <span class="s1">only_contains_user_certs = utils.read_only_property(</span>
        <span class="s4">&quot;_only_contains_user_certs&quot;</span>
    <span class="s1">)</span>
    <span class="s1">only_contains_ca_certs = utils.read_only_property(</span>
        <span class="s4">&quot;_only_contains_ca_certs&quot;</span>
    <span class="s1">)</span>
    <span class="s1">only_some_reasons = utils.read_only_property(</span><span class="s4">&quot;_only_some_reasons&quot;</span><span class="s1">)</span>
    <span class="s1">indirect_crl = utils.read_only_property(</span><span class="s4">&quot;_indirect_crl&quot;</span><span class="s1">)</span>
    <span class="s1">only_contains_attribute_certs = utils.read_only_property(</span>
        <span class="s4">&quot;_only_contains_attribute_certs&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">UnrecognizedExtension(ExtensionType):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">oid: ObjectIdentifier</span><span class="s2">, </span><span class="s1">value: bytes):</span>
        <span class="s2">if not </span><span class="s1">isinstance(oid</span><span class="s2">, </span><span class="s1">ObjectIdentifier):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;oid must be an ObjectIdentifier&quot;</span><span class="s1">)</span>
        <span class="s1">self._oid = oid</span>
        <span class="s1">self._value = value</span>

    <span class="s1">oid = utils.read_only_property(</span><span class="s4">&quot;_oid&quot;</span><span class="s1">)</span>
    <span class="s1">value = utils.read_only_property(</span><span class="s4">&quot;_value&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">&quot;&lt;UnrecognizedExtension(oid={0.oid}, &quot;</span>
            <span class="s4">&quot;value={0.value!r})&gt;&quot;</span><span class="s1">.format(self)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">UnrecognizedExtension):</span>
            <span class="s2">return </span><span class="s1">NotImplemented</span>

        <span class="s2">return </span><span class="s1">self.oid == other.oid </span><span class="s2">and </span><span class="s1">self.value == other.value</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return not </span><span class="s1">self == other</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((self.oid</span><span class="s2">, </span><span class="s1">self.value))</span>
</pre>
</body>
</html>