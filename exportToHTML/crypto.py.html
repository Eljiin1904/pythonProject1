<html>
<head>
<title>crypto.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
crypto.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">calendar</span>
<span class="s0">import </span><span class="s1">datetime</span>

<span class="s0">from </span><span class="s1">base64 </span><span class="s0">import </span><span class="s1">b16encode</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">operator </span><span class="s0">import </span><span class="s1">__eq__</span><span class="s0">, </span><span class="s1">__ne__</span><span class="s0">, </span><span class="s1">__lt__</span><span class="s0">, </span><span class="s1">__le__</span><span class="s0">, </span><span class="s1">__gt__</span><span class="s0">, </span><span class="s1">__ge__</span>

<span class="s0">from </span><span class="s1">six </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">integer_types </span><span class="s0">as </span><span class="s1">_integer_types</span><span class="s0">,</span>
    <span class="s1">text_type </span><span class="s0">as </span><span class="s1">_text_type</span><span class="s0">,</span>
    <span class="s1">PY2 </span><span class="s0">as </span><span class="s1">_PY2</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">cryptography </span><span class="s0">import </span><span class="s1">utils</span><span class="s0">, </span><span class="s1">x509</span>
<span class="s0">from </span><span class="s1">cryptography.hazmat.primitives.asymmetric </span><span class="s0">import </span><span class="s1">dsa</span><span class="s0">, </span><span class="s1">rsa</span>

<span class="s0">from </span><span class="s1">OpenSSL._util </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ffi </span><span class="s0">as </span><span class="s1">_ffi</span><span class="s0">,</span>
    <span class="s1">lib </span><span class="s0">as </span><span class="s1">_lib</span><span class="s0">,</span>
    <span class="s1">exception_from_error_queue </span><span class="s0">as </span><span class="s1">_exception_from_error_queue</span><span class="s0">,</span>
    <span class="s1">byte_string </span><span class="s0">as </span><span class="s1">_byte_string</span><span class="s0">,</span>
    <span class="s1">native </span><span class="s0">as </span><span class="s1">_native</span><span class="s0">,</span>
    <span class="s1">path_string </span><span class="s0">as </span><span class="s1">_path_string</span><span class="s0">,</span>
    <span class="s1">UNSPECIFIED </span><span class="s0">as </span><span class="s1">_UNSPECIFIED</span><span class="s0">,</span>
    <span class="s1">text_to_bytes_and_warn </span><span class="s0">as </span><span class="s1">_text_to_bytes_and_warn</span><span class="s0">,</span>
    <span class="s1">make_assert </span><span class="s0">as </span><span class="s1">_make_assert</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s1">__all__ = [</span>
    <span class="s2">&quot;FILETYPE_PEM&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FILETYPE_ASN1&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;FILETYPE_TEXT&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TYPE_RSA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;TYPE_DSA&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Error&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PKey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;get_elliptic_curves&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;get_elliptic_curve&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;X509Name&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;X509Extension&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;X509Req&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;X509&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;X509StoreFlags&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;X509Store&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;X509StoreContextError&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;X509StoreContext&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;load_certificate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dump_certificate&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dump_publickey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dump_privatekey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;Revoked&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;CRL&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PKCS7&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;PKCS12&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;NetscapeSPKI&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;load_publickey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;load_privatekey&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dump_certificate_request&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;load_certificate_request&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;sign&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;verify&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;dump_crl&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;load_crl&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;load_pkcs7_data&quot;</span><span class="s0">,</span>
    <span class="s2">&quot;load_pkcs12&quot;</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s1">FILETYPE_PEM = _lib.SSL_FILETYPE_PEM</span>
<span class="s1">FILETYPE_ASN1 = _lib.SSL_FILETYPE_ASN1</span>

<span class="s3"># TODO This was an API mistake.  OpenSSL has no such constant.</span>
<span class="s1">FILETYPE_TEXT = </span><span class="s4">2 </span><span class="s1">** </span><span class="s4">16 </span><span class="s1">- </span><span class="s4">1</span>

<span class="s1">TYPE_RSA = _lib.EVP_PKEY_RSA</span>
<span class="s1">TYPE_DSA = _lib.EVP_PKEY_DSA</span>
<span class="s1">TYPE_DH = _lib.EVP_PKEY_DH</span>
<span class="s1">TYPE_EC = _lib.EVP_PKEY_EC</span>


<span class="s0">class </span><span class="s1">Error(Exception):</span>
    <span class="s5">&quot;&quot;&quot; 
    An error occurred in an `OpenSSL.crypto` API. 
    &quot;&quot;&quot;</span>


<span class="s1">_raise_current_error = partial(_exception_from_error_queue</span><span class="s0">, </span><span class="s1">Error)</span>
<span class="s1">_openssl_assert = _make_assert(Error)</span>


<span class="s0">def </span><span class="s1">_get_backend():</span>
    <span class="s5">&quot;&quot;&quot; 
    Importing the backend from cryptography has the side effect of activating 
    the osrandom engine. This mutates the global state of OpenSSL in the 
    process and causes issues for various programs that use subinterpreters or 
    embed Python. By putting the import in this function we can avoid 
    triggering this side effect unless _get_backend is called. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">cryptography.hazmat.backends.openssl.backend </span><span class="s0">import </span><span class="s1">backend</span>

    <span class="s0">return </span><span class="s1">backend</span>


<span class="s0">def </span><span class="s1">_untested_error(where):</span>
    <span class="s5">&quot;&quot;&quot; 
    An OpenSSL API failed somehow.  Additionally, the failure which was 
    encountered isn't one that's exercised by the test suite so future behavior 
    of pyOpenSSL is now somewhat less predictable. 
    &quot;&quot;&quot;</span>
    <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s2">&quot;Unknown %s failure&quot; </span><span class="s1">% (where</span><span class="s0">,</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">_new_mem_buf(buffer=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Allocate a new OpenSSL memory BIO. 
 
    Arrange for the garbage collector to clean it up automatically. 
 
    :param buffer: None or some bytes to use to put into the BIO so that they 
        can be read out. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">buffer </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">bio = _lib.BIO_new(_lib.BIO_s_mem())</span>
        <span class="s1">free = _lib.BIO_free</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">data = _ffi.new(</span><span class="s2">&quot;char[]&quot;</span><span class="s0">, </span><span class="s1">buffer)</span>
        <span class="s1">bio = _lib.BIO_new_mem_buf(data</span><span class="s0">, </span><span class="s1">len(buffer))</span>

        <span class="s3"># Keep the memory alive as long as the bio is alive!</span>
        <span class="s0">def </span><span class="s1">free(bio</span><span class="s0">, </span><span class="s1">ref=data):</span>
            <span class="s0">return </span><span class="s1">_lib.BIO_free(bio)</span>

    <span class="s1">_openssl_assert(bio != _ffi.NULL)</span>

    <span class="s1">bio = _ffi.gc(bio</span><span class="s0">, </span><span class="s1">free)</span>
    <span class="s0">return </span><span class="s1">bio</span>


<span class="s0">def </span><span class="s1">_bio_to_string(bio):</span>
    <span class="s5">&quot;&quot;&quot; 
    Copy the contents of an OpenSSL BIO object into a Python byte string. 
    &quot;&quot;&quot;</span>
    <span class="s1">result_buffer = _ffi.new(</span><span class="s2">&quot;char**&quot;</span><span class="s1">)</span>
    <span class="s1">buffer_length = _lib.BIO_get_mem_data(bio</span><span class="s0">, </span><span class="s1">result_buffer)</span>
    <span class="s0">return </span><span class="s1">_ffi.buffer(result_buffer[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">buffer_length)[:]</span>


<span class="s0">def </span><span class="s1">_set_asn1_time(boundary</span><span class="s0">, </span><span class="s1">when):</span>
    <span class="s5">&quot;&quot;&quot; 
    The the time value of an ASN1 time object. 
 
    @param boundary: An ASN1_TIME pointer (or an object safely 
        castable to that type) which will have its value set. 
    @param when: A string representation of the desired time value. 
 
    @raise TypeError: If C{when} is not a L{bytes} string. 
    @raise ValueError: If C{when} does not represent a time in the required 
        format. 
    @raise RuntimeError: If the time value cannot be set for some other 
        (unspecified) reason. 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance(when</span><span class="s0">, </span><span class="s1">bytes):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;when must be a byte string&quot;</span><span class="s1">)</span>

    <span class="s1">set_result = _lib.ASN1_TIME_set_string(boundary</span><span class="s0">, </span><span class="s1">when)</span>
    <span class="s0">if </span><span class="s1">set_result == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid string&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_get_asn1_time(timestamp):</span>
    <span class="s5">&quot;&quot;&quot; 
    Retrieve the time value of an ASN1 time object. 
 
    @param timestamp: An ASN1_GENERALIZEDTIME* (or an object safely castable to 
        that type) from which the time value will be retrieved. 
 
    @return: The time value from C{timestamp} as a L{bytes} string in a certain 
        format.  Or C{None} if the object contains no time value. 
    &quot;&quot;&quot;</span>
    <span class="s1">string_timestamp = _ffi.cast(</span><span class="s2">&quot;ASN1_STRING*&quot;</span><span class="s0">, </span><span class="s1">timestamp)</span>
    <span class="s0">if </span><span class="s1">_lib.ASN1_STRING_length(string_timestamp) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return None</span>
    <span class="s0">elif </span><span class="s1">(</span>
        <span class="s1">_lib.ASN1_STRING_type(string_timestamp) == _lib.V_ASN1_GENERALIZEDTIME</span>
    <span class="s1">):</span>
        <span class="s0">return </span><span class="s1">_ffi.string(_lib.ASN1_STRING_data(string_timestamp))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">generalized_timestamp = _ffi.new(</span><span class="s2">&quot;ASN1_GENERALIZEDTIME**&quot;</span><span class="s1">)</span>
        <span class="s1">_lib.ASN1_TIME_to_generalizedtime(timestamp</span><span class="s0">, </span><span class="s1">generalized_timestamp)</span>
        <span class="s0">if </span><span class="s1">generalized_timestamp[</span><span class="s4">0</span><span class="s1">] == _ffi.NULL:</span>
            <span class="s3"># This may happen:</span>
            <span class="s3">#   - if timestamp was not an ASN1_TIME</span>
            <span class="s3">#   - if allocating memory for the ASN1_GENERALIZEDTIME failed</span>
            <span class="s3">#   - if a copy of the time data from timestamp cannot be made for</span>
            <span class="s3">#     the newly allocated ASN1_GENERALIZEDTIME</span>
            <span class="s3">#</span>
            <span class="s3"># These are difficult to test.  cffi enforces the ASN1_TIME type.</span>
            <span class="s3"># Memory allocation failures are a pain to trigger</span>
            <span class="s3"># deterministically.</span>
            <span class="s1">_untested_error(</span><span class="s2">&quot;ASN1_TIME_to_generalizedtime&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">string_timestamp = _ffi.cast(</span>
                <span class="s2">&quot;ASN1_STRING*&quot;</span><span class="s0">, </span><span class="s1">generalized_timestamp[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">)</span>
            <span class="s1">string_data = _lib.ASN1_STRING_data(string_timestamp)</span>
            <span class="s1">string_result = _ffi.string(string_data)</span>
            <span class="s1">_lib.ASN1_GENERALIZEDTIME_free(generalized_timestamp[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s0">return </span><span class="s1">string_result</span>


<span class="s0">class </span><span class="s1">_X509NameInvalidator(object):</span>
    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._names = []</span>

    <span class="s0">def </span><span class="s1">add(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s1">self._names.append(name)</span>

    <span class="s0">def </span><span class="s1">clear(self):</span>
        <span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self._names:</span>
            <span class="s3"># Breaks the object, but also prevents UAF!</span>
            <span class="s0">del </span><span class="s1">name._name</span>


<span class="s0">class </span><span class="s1">PKey(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    A class representing an DSA or RSA public key or key pair. 
    &quot;&quot;&quot;</span>

    <span class="s1">_only_public = </span><span class="s0">False</span>
    <span class="s1">_initialized = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">pkey = _lib.EVP_PKEY_new()</span>
        <span class="s1">self._pkey = _ffi.gc(pkey</span><span class="s0">, </span><span class="s1">_lib.EVP_PKEY_free)</span>
        <span class="s1">self._initialized = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">to_cryptography_key(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Export as a ``cryptography`` key. 
 
        :rtype: One of ``cryptography``'s `key interfaces`_. 
 
        .. _key interfaces: https://cryptography.io/en/latest/hazmat/\ 
            primitives/asymmetric/rsa/#key-interfaces 
 
        .. versionadded:: 16.1.0 
        &quot;&quot;&quot;</span>
        <span class="s1">backend = _get_backend()</span>
        <span class="s0">if </span><span class="s1">self._only_public:</span>
            <span class="s0">return </span><span class="s1">backend._evp_pkey_to_public_key(self._pkey)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">backend._evp_pkey_to_private_key(self._pkey)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_cryptography_key(cls</span><span class="s0">, </span><span class="s1">crypto_key):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct based on a ``cryptography`` *crypto_key*. 
 
        :param crypto_key: A ``cryptography`` key. 
        :type crypto_key: One of ``cryptography``'s `key interfaces`_. 
 
        :rtype: PKey 
 
        .. versionadded:: 16.1.0 
        &quot;&quot;&quot;</span>
        <span class="s1">pkey = cls()</span>
        <span class="s0">if not </span><span class="s1">isinstance(</span>
            <span class="s1">crypto_key</span><span class="s0">,</span>
            <span class="s1">(</span>
                <span class="s1">rsa.RSAPublicKey</span><span class="s0">,</span>
                <span class="s1">rsa.RSAPrivateKey</span><span class="s0">,</span>
                <span class="s1">dsa.DSAPublicKey</span><span class="s0">,</span>
                <span class="s1">dsa.DSAPrivateKey</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Unsupported key type&quot;</span><span class="s1">)</span>

        <span class="s1">pkey._pkey = crypto_key._evp_pkey</span>
        <span class="s0">if </span><span class="s1">isinstance(crypto_key</span><span class="s0">, </span><span class="s1">(rsa.RSAPublicKey</span><span class="s0">, </span><span class="s1">dsa.DSAPublicKey)):</span>
            <span class="s1">pkey._only_public = </span><span class="s0">True</span>
        <span class="s1">pkey._initialized = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">pkey</span>

    <span class="s0">def </span><span class="s1">generate_key(self</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">bits):</span>
        <span class="s5">&quot;&quot;&quot; 
        Generate a key pair of the given type, with the given number of bits. 
 
        This generates a key &quot;into&quot; the this object. 
 
        :param type: The key type. 
        :type type: :py:data:`TYPE_RSA` or :py:data:`TYPE_DSA` 
        :param bits: The number of bits. 
        :type bits: :py:data:`int` ``&gt;= 0`` 
        :raises TypeError: If :py:data:`type` or :py:data:`bits` isn't 
            of the appropriate type. 
        :raises ValueError: If the number of bits isn't an integer of 
            the appropriate size. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(type</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;type must be an integer&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">isinstance(bits</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;bits must be an integer&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">type == TYPE_RSA:</span>
            <span class="s0">if </span><span class="s1">bits &lt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid number of bits&quot;</span><span class="s1">)</span>

            <span class="s3"># TODO Check error return</span>
            <span class="s1">exponent = _lib.BN_new()</span>
            <span class="s1">exponent = _ffi.gc(exponent</span><span class="s0">, </span><span class="s1">_lib.BN_free)</span>
            <span class="s1">_lib.BN_set_word(exponent</span><span class="s0">, </span><span class="s1">_lib.RSA_F4)</span>

            <span class="s1">rsa = _lib.RSA_new()</span>

            <span class="s1">result = _lib.RSA_generate_key_ex(rsa</span><span class="s0">, </span><span class="s1">bits</span><span class="s0">, </span><span class="s1">exponent</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
            <span class="s1">_openssl_assert(result == </span><span class="s4">1</span><span class="s1">)</span>

            <span class="s1">result = _lib.EVP_PKEY_assign_RSA(self._pkey</span><span class="s0">, </span><span class="s1">rsa)</span>
            <span class="s1">_openssl_assert(result == </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0">elif </span><span class="s1">type == TYPE_DSA:</span>
            <span class="s1">dsa = _lib.DSA_new()</span>
            <span class="s1">_openssl_assert(dsa != _ffi.NULL)</span>

            <span class="s1">dsa = _ffi.gc(dsa</span><span class="s0">, </span><span class="s1">_lib.DSA_free)</span>
            <span class="s1">res = _lib.DSA_generate_parameters_ex(</span>
                <span class="s1">dsa</span><span class="s0">, </span><span class="s1">bits</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span>
            <span class="s1">)</span>
            <span class="s1">_openssl_assert(res == </span><span class="s4">1</span><span class="s1">)</span>

            <span class="s1">_openssl_assert(_lib.DSA_generate_key(dsa) == </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">_openssl_assert(_lib.EVP_PKEY_set1_DSA(self._pkey</span><span class="s0">, </span><span class="s1">dsa) == </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">Error(</span><span class="s2">&quot;No such key type&quot;</span><span class="s1">)</span>

        <span class="s1">self._initialized = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">check(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Check the consistency of an RSA private key. 
 
        This is the Python equivalent of OpenSSL's ``RSA_check_key``. 
 
        :return: ``True`` if key is consistent. 
 
        :raise OpenSSL.crypto.Error: if the key is inconsistent. 
 
        :raise TypeError: if the key is of a type which cannot be checked. 
            Only RSA keys can currently be checked. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._only_public:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;public key only&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">_lib.EVP_PKEY_type(self.type()) != _lib.EVP_PKEY_RSA:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;key type unsupported&quot;</span><span class="s1">)</span>

        <span class="s1">rsa = _lib.EVP_PKEY_get1_RSA(self._pkey)</span>
        <span class="s1">rsa = _ffi.gc(rsa</span><span class="s0">, </span><span class="s1">_lib.RSA_free)</span>
        <span class="s1">result = _lib.RSA_check_key(rsa)</span>
        <span class="s0">if </span><span class="s1">result == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">return True</span>
        <span class="s1">_raise_current_error()</span>

    <span class="s0">def </span><span class="s1">type(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the type of the key 
 
        :return: The type of the key. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_lib.EVP_PKEY_id(self._pkey)</span>

    <span class="s0">def </span><span class="s1">bits(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the number of bits of the key 
 
        :return: The number of bits of the key. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_lib.EVP_PKEY_bits(self._pkey)</span>


<span class="s0">class </span><span class="s1">_EllipticCurve(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    A representation of a supported elliptic curve. 
 
    @cvar _curves: :py:obj:`None` until an attempt is made to load the curves. 
        Thereafter, a :py:type:`set` containing :py:type:`_EllipticCurve` 
        instances each of which represents one curve supported by the system. 
    @type _curves: :py:type:`NoneType` or :py:type:`set` 
    &quot;&quot;&quot;</span>

    <span class="s1">_curves = </span><span class="s0">None</span>

    <span class="s0">if not </span><span class="s1">_PY2:</span>
        <span class="s3"># This only necessary on Python 3.  Moreover, it is broken on Python 2.</span>
        <span class="s0">def </span><span class="s1">__ne__(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s5">&quot;&quot;&quot; 
            Implement cooperation with the right-hand side argument of ``!=``. 
 
            Python 3 seems to have dropped this cooperation in this very narrow 
            circumstance. 
            &quot;&quot;&quot;</span>
            <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">_EllipticCurve):</span>
                <span class="s0">return </span><span class="s1">super(_EllipticCurve</span><span class="s0">, </span><span class="s1">self).__ne__(other)</span>
            <span class="s0">return </span><span class="s1">NotImplemented</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_load_elliptic_curves(cls</span><span class="s0">, </span><span class="s1">lib):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the curves supported by OpenSSL. 
 
        :param lib: The OpenSSL library binding object. 
 
        :return: A :py:type:`set` of ``cls`` instances giving the names of the 
            elliptic curves the underlying library supports. 
        &quot;&quot;&quot;</span>
        <span class="s1">num_curves = lib.EC_get_builtin_curves(_ffi.NULL</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">builtin_curves = _ffi.new(</span><span class="s2">&quot;EC_builtin_curve[]&quot;</span><span class="s0">, </span><span class="s1">num_curves)</span>
        <span class="s3"># The return value on this call should be num_curves again.  We</span>
        <span class="s3"># could check it to make sure but if it *isn't* then.. what could</span>
        <span class="s3"># we do? Abort the whole process, I suppose...?  -exarkun</span>
        <span class="s1">lib.EC_get_builtin_curves(builtin_curves</span><span class="s0">, </span><span class="s1">num_curves)</span>
        <span class="s0">return </span><span class="s1">set(cls.from_nid(lib</span><span class="s0">, </span><span class="s1">c.nid) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">builtin_curves)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_get_elliptic_curves(cls</span><span class="s0">, </span><span class="s1">lib):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get, cache, and return the curves supported by OpenSSL. 
 
        :param lib: The OpenSSL library binding object. 
 
        :return: A :py:type:`set` of ``cls`` instances giving the names of the 
            elliptic curves the underlying library supports. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">cls._curves </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">cls._curves = cls._load_elliptic_curves(lib)</span>
        <span class="s0">return </span><span class="s1">cls._curves</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_nid(cls</span><span class="s0">, </span><span class="s1">lib</span><span class="s0">, </span><span class="s1">nid):</span>
        <span class="s5">&quot;&quot;&quot; 
        Instantiate a new :py:class:`_EllipticCurve` associated with the given 
        OpenSSL NID. 
 
        :param lib: The OpenSSL library binding object. 
 
        :param nid: The OpenSSL NID the resulting curve object will represent. 
            This must be a curve NID (and not, for example, a hash NID) or 
            subsequent operations will fail in unpredictable ways. 
        :type nid: :py:class:`int` 
 
        :return: The curve object. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">cls(lib</span><span class="s0">, </span><span class="s1">nid</span><span class="s0">, </span><span class="s1">_ffi.string(lib.OBJ_nid2sn(nid)).decode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">lib</span><span class="s0">, </span><span class="s1">nid</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s5">&quot;&quot;&quot; 
        :param _lib: The :py:mod:`cryptography` binding instance used to 
            interface with OpenSSL. 
 
        :param _nid: The OpenSSL NID identifying the curve this object 
            represents. 
        :type _nid: :py:class:`int` 
 
        :param name: The OpenSSL short name identifying the curve this object 
            represents. 
        :type name: :py:class:`unicode` 
        &quot;&quot;&quot;</span>
        <span class="s1">self._lib = lib</span>
        <span class="s1">self._nid = nid</span>
        <span class="s1">self.name = name</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s2">&quot;&lt;Curve %r&gt;&quot; </span><span class="s1">% (self.name</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_to_EC_KEY(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Create a new OpenSSL EC_KEY structure initialized to use this curve. 
 
        The structure is automatically garbage collected when the Python object 
        is garbage collected. 
        &quot;&quot;&quot;</span>
        <span class="s1">key = self._lib.EC_KEY_new_by_curve_name(self._nid)</span>
        <span class="s0">return </span><span class="s1">_ffi.gc(key</span><span class="s0">, </span><span class="s1">_lib.EC_KEY_free)</span>


<span class="s0">def </span><span class="s1">get_elliptic_curves():</span>
    <span class="s5">&quot;&quot;&quot; 
    Return a set of objects representing the elliptic curves supported in the 
    OpenSSL build in use. 
 
    The curve objects have a :py:class:`unicode` ``name`` attribute by which 
    they identify themselves. 
 
    The curve objects are useful as values for the argument accepted by 
    :py:meth:`Context.set_tmp_ecdh` to specify which elliptical curve should be 
    used for ECDHE key exchange. 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">_EllipticCurve._get_elliptic_curves(_lib)</span>


<span class="s0">def </span><span class="s1">get_elliptic_curve(name):</span>
    <span class="s5">&quot;&quot;&quot; 
    Return a single curve object selected by name. 
 
    See :py:func:`get_elliptic_curves` for information about curve objects. 
 
    :param name: The OpenSSL short name identifying the curve object to 
        retrieve. 
    :type name: :py:class:`unicode` 
 
    If the named curve is not supported then :py:class:`ValueError` is raised. 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">curve </span><span class="s0">in </span><span class="s1">get_elliptic_curves():</span>
        <span class="s0">if </span><span class="s1">curve.name == name:</span>
            <span class="s0">return </span><span class="s1">curve</span>
    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;unknown curve name&quot;</span><span class="s0">, </span><span class="s1">name)</span>


<span class="s0">class </span><span class="s1">X509Name(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    An X.509 Distinguished Name. 
 
    :ivar countryName: The country of the entity. 
    :ivar C: Alias for  :py:attr:`countryName`. 
 
    :ivar stateOrProvinceName: The state or province of the entity. 
    :ivar ST: Alias for :py:attr:`stateOrProvinceName`. 
 
    :ivar localityName: The locality of the entity. 
    :ivar L: Alias for :py:attr:`localityName`. 
 
    :ivar organizationName: The organization name of the entity. 
    :ivar O: Alias for :py:attr:`organizationName`. 
 
    :ivar organizationalUnitName: The organizational unit of the entity. 
    :ivar OU: Alias for :py:attr:`organizationalUnitName` 
 
    :ivar commonName: The common name of the entity. 
    :ivar CN: Alias for :py:attr:`commonName`. 
 
    :ivar emailAddress: The e-mail address of the entity. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s5">&quot;&quot;&quot; 
        Create a new X509Name, copying the given X509Name instance. 
 
        :param name: The name to copy. 
        :type name: :py:class:`X509Name` 
        &quot;&quot;&quot;</span>
        <span class="s1">name = _lib.X509_NAME_dup(name._name)</span>
        <span class="s1">self._name = _ffi.gc(name</span><span class="s0">, </span><span class="s1">_lib.X509_NAME_free)</span>

    <span class="s0">def </span><span class="s1">__setattr__(self</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">if </span><span class="s1">name.startswith(</span><span class="s2">&quot;_&quot;</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">super(X509Name</span><span class="s0">, </span><span class="s1">self).__setattr__(name</span><span class="s0">, </span><span class="s1">value)</span>

        <span class="s3"># Note: we really do not want str subclasses here, so we do not use</span>
        <span class="s3"># isinstance.</span>
        <span class="s0">if </span><span class="s1">type(name) </span><span class="s0">is not </span><span class="s1">str:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;attribute name must be string, not '%.200s'&quot;</span>
                <span class="s1">% (type(value).__name__</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">nid = _lib.OBJ_txt2nid(_byte_string(name))</span>
        <span class="s0">if </span><span class="s1">nid == _lib.NID_undef:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">_raise_current_error()</span>
            <span class="s0">except </span><span class="s1">Error:</span>
                <span class="s0">pass</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">&quot;No such attribute&quot;</span><span class="s1">)</span>

        <span class="s3"># If there's an old entry for this NID, remove it</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.X509_NAME_entry_count(self._name)):</span>
            <span class="s1">ent = _lib.X509_NAME_get_entry(self._name</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">ent_obj = _lib.X509_NAME_ENTRY_get_object(ent)</span>
            <span class="s1">ent_nid = _lib.OBJ_obj2nid(ent_obj)</span>
            <span class="s0">if </span><span class="s1">nid == ent_nid:</span>
                <span class="s1">ent = _lib.X509_NAME_delete_entry(self._name</span><span class="s0">, </span><span class="s1">i)</span>
                <span class="s1">_lib.X509_NAME_ENTRY_free(ent)</span>
                <span class="s0">break</span>

        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">_text_type):</span>
            <span class="s1">value = value.encode(</span><span class="s2">&quot;utf-8&quot;</span><span class="s1">)</span>

        <span class="s1">add_result = _lib.X509_NAME_add_entry_by_NID(</span>
            <span class="s1">self._name</span><span class="s0">, </span><span class="s1">nid</span><span class="s0">, </span><span class="s1">_lib.MBSTRING_UTF8</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span>
        <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">add_result:</span>
            <span class="s1">_raise_current_error()</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s5">&quot;&quot;&quot; 
        Find attribute. An X509Name object has the following attributes: 
        countryName (alias C), stateOrProvince (alias ST), locality (alias L), 
        organization (alias O), organizationalUnit (alias OU), commonName 
        (alias CN) and more... 
        &quot;&quot;&quot;</span>
        <span class="s1">nid = _lib.OBJ_txt2nid(_byte_string(name))</span>
        <span class="s0">if </span><span class="s1">nid == _lib.NID_undef:</span>
            <span class="s3"># This is a bit weird.  OBJ_txt2nid indicated failure, but it seems</span>
            <span class="s3"># a lower level function, a2d_ASN1_OBJECT, also feels the need to</span>
            <span class="s3"># push something onto the error queue.  If we don't clean that up</span>
            <span class="s3"># now, someone else will bump into it later and be quite confused.</span>
            <span class="s3"># See lp#314814.</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">_raise_current_error()</span>
            <span class="s0">except </span><span class="s1">Error:</span>
                <span class="s0">pass</span>
            <span class="s0">return </span><span class="s1">super(X509Name</span><span class="s0">, </span><span class="s1">self).__getattr__(name)</span>

        <span class="s1">entry_index = _lib.X509_NAME_get_index_by_NID(self._name</span><span class="s0">, </span><span class="s1">nid</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">entry_index == -</span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">return None</span>

        <span class="s1">entry = _lib.X509_NAME_get_entry(self._name</span><span class="s0">, </span><span class="s1">entry_index)</span>
        <span class="s1">data = _lib.X509_NAME_ENTRY_get_data(entry)</span>

        <span class="s1">result_buffer = _ffi.new(</span><span class="s2">&quot;unsigned char**&quot;</span><span class="s1">)</span>
        <span class="s1">data_length = _lib.ASN1_STRING_to_UTF8(result_buffer</span><span class="s0">, </span><span class="s1">data)</span>
        <span class="s1">_openssl_assert(data_length &gt;= </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">result = _ffi.buffer(result_buffer[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">data_length)[:].decode(</span>
                <span class="s2">&quot;utf-8&quot;</span>
            <span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s3"># XXX untested</span>
            <span class="s1">_lib.OPENSSL_free(result_buffer[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_cmp(op):</span>
        <span class="s0">def </span><span class="s1">f(self</span><span class="s0">, </span><span class="s1">other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">X509Name):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>
            <span class="s1">result = _lib.X509_NAME_cmp(self._name</span><span class="s0">, </span><span class="s1">other._name)</span>
            <span class="s0">return </span><span class="s1">op(result</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">f</span>

    <span class="s1">__eq__ = _cmp(__eq__)</span>
    <span class="s1">__ne__ = _cmp(__ne__)</span>

    <span class="s1">__lt__ = _cmp(__lt__)</span>
    <span class="s1">__le__ = _cmp(__le__)</span>

    <span class="s1">__gt__ = _cmp(__gt__)</span>
    <span class="s1">__ge__ = _cmp(__ge__)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        String representation of an X509Name 
        &quot;&quot;&quot;</span>
        <span class="s1">result_buffer = _ffi.new(</span><span class="s2">&quot;char[]&quot;</span><span class="s0">, </span><span class="s4">512</span><span class="s1">)</span>
        <span class="s1">format_result = _lib.X509_NAME_oneline(</span>
            <span class="s1">self._name</span><span class="s0">, </span><span class="s1">result_buffer</span><span class="s0">, </span><span class="s1">len(result_buffer)</span>
        <span class="s1">)</span>
        <span class="s1">_openssl_assert(format_result != _ffi.NULL)</span>

        <span class="s0">return </span><span class="s2">&quot;&lt;X509Name object '%s'&gt;&quot; </span><span class="s1">% (</span>
            <span class="s1">_native(_ffi.string(result_buffer))</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">hash(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return an integer representation of the first four bytes of the 
        MD5 digest of the DER representation of the name. 
 
        This is the Python equivalent of OpenSSL's ``X509_NAME_hash``. 
 
        :return: The (integer) hash of this name. 
        :rtype: :py:class:`int` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_lib.X509_NAME_hash(self._name)</span>

    <span class="s0">def </span><span class="s1">der(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the DER encoding of this name. 
 
        :return: The DER encoded form of this name. 
        :rtype: :py:class:`bytes` 
        &quot;&quot;&quot;</span>
        <span class="s1">result_buffer = _ffi.new(</span><span class="s2">&quot;unsigned char**&quot;</span><span class="s1">)</span>
        <span class="s1">encode_result = _lib.i2d_X509_NAME(self._name</span><span class="s0">, </span><span class="s1">result_buffer)</span>
        <span class="s1">_openssl_assert(encode_result &gt;= </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">string_result = _ffi.buffer(result_buffer[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">encode_result)[:]</span>
        <span class="s1">_lib.OPENSSL_free(result_buffer[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s0">return </span><span class="s1">string_result</span>

    <span class="s0">def </span><span class="s1">get_components(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the components of this name, as a sequence of 2-tuples. 
 
        :return: The components of this name. 
        :rtype: :py:class:`list` of ``name, value`` tuples. 
        &quot;&quot;&quot;</span>
        <span class="s1">result = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.X509_NAME_entry_count(self._name)):</span>
            <span class="s1">ent = _lib.X509_NAME_get_entry(self._name</span><span class="s0">, </span><span class="s1">i)</span>

            <span class="s1">fname = _lib.X509_NAME_ENTRY_get_object(ent)</span>
            <span class="s1">fval = _lib.X509_NAME_ENTRY_get_data(ent)</span>

            <span class="s1">nid = _lib.OBJ_obj2nid(fname)</span>
            <span class="s1">name = _lib.OBJ_nid2sn(nid)</span>

            <span class="s3"># ffi.string does not handle strings containing NULL bytes</span>
            <span class="s3"># (which may have been generated by old, broken software)</span>
            <span class="s1">value = _ffi.buffer(</span>
                <span class="s1">_lib.ASN1_STRING_data(fval)</span><span class="s0">, </span><span class="s1">_lib.ASN1_STRING_length(fval)</span>
            <span class="s1">)[:]</span>
            <span class="s1">result.append((_ffi.string(name)</span><span class="s0">, </span><span class="s1">value))</span>

        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">X509Extension(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    An X.509 v3 certificate extension. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">type_name</span><span class="s0">, </span><span class="s1">critical</span><span class="s0">, </span><span class="s1">value</span><span class="s0">, </span><span class="s1">subject=</span><span class="s0">None, </span><span class="s1">issuer=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Initializes an X509 extension. 
 
        :param type_name: The name of the type of extension_ to create. 
        :type type_name: :py:data:`bytes` 
 
        :param bool critical: A flag indicating whether this is a critical 
            extension. 
 
        :param value: The value of the extension. 
        :type value: :py:data:`bytes` 
 
        :param subject: Optional X509 certificate to use as subject. 
        :type subject: :py:class:`X509` 
 
        :param issuer: Optional X509 certificate to use as issuer. 
        :type issuer: :py:class:`X509` 
 
        .. _extension: https://www.openssl.org/docs/manmaster/man5/ 
            x509v3_config.html#STANDARD-EXTENSIONS 
        &quot;&quot;&quot;</span>
        <span class="s1">ctx = _ffi.new(</span><span class="s2">&quot;X509V3_CTX*&quot;</span><span class="s1">)</span>

        <span class="s3"># A context is necessary for any extension which uses the r2i</span>
        <span class="s3"># conversion method.  That is, X509V3_EXT_nconf may segfault if passed</span>
        <span class="s3"># a NULL ctx. Start off by initializing most of the fields to NULL.</span>
        <span class="s1">_lib.X509V3_set_ctx(ctx</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s3"># We have no configuration database - but perhaps we should (some</span>
        <span class="s3"># extensions may require it).</span>
        <span class="s1">_lib.X509V3_set_ctx_nodb(ctx)</span>

        <span class="s3"># Initialize the subject and issuer, if appropriate.  ctx is a local,</span>
        <span class="s3"># and as far as I can tell none of the X509V3_* APIs invoked here steal</span>
        <span class="s3"># any references, so no need to mess with reference counts or</span>
        <span class="s3"># duplicates.</span>
        <span class="s0">if </span><span class="s1">issuer </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(issuer</span><span class="s0">, </span><span class="s1">X509):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;issuer must be an X509 instance&quot;</span><span class="s1">)</span>
            <span class="s1">ctx.issuer_cert = issuer._x509</span>
        <span class="s0">if </span><span class="s1">subject </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(subject</span><span class="s0">, </span><span class="s1">X509):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;subject must be an X509 instance&quot;</span><span class="s1">)</span>
            <span class="s1">ctx.subject_cert = subject._x509</span>

        <span class="s0">if </span><span class="s1">critical:</span>
            <span class="s3"># There are other OpenSSL APIs which would let us pass in critical</span>
            <span class="s3"># separately, but they're harder to use, and since value is already</span>
            <span class="s3"># a pile of crappy junk smuggling a ton of utterly important</span>
            <span class="s3"># structured data, what's the point of trying to avoid nasty stuff</span>
            <span class="s3"># with strings? (However, X509V3_EXT_i2d in particular seems like</span>
            <span class="s3"># it would be a better API to invoke.  I do not know where to get</span>
            <span class="s3"># the ext_struc it desires for its last parameter, though.)</span>
            <span class="s1">value = </span><span class="s6">b&quot;critical,&quot; </span><span class="s1">+ value</span>

        <span class="s1">extension = _lib.X509V3_EXT_nconf(_ffi.NULL</span><span class="s0">, </span><span class="s1">ctx</span><span class="s0">, </span><span class="s1">type_name</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">if </span><span class="s1">extension == _ffi.NULL:</span>
            <span class="s1">_raise_current_error()</span>
        <span class="s1">self._extension = _ffi.gc(extension</span><span class="s0">, </span><span class="s1">_lib.X509_EXTENSION_free)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_nid(self):</span>
        <span class="s0">return </span><span class="s1">_lib.OBJ_obj2nid(</span>
            <span class="s1">_lib.X509_EXTENSION_get_object(self._extension)</span>
        <span class="s1">)</span>

    <span class="s1">_prefixes = {</span>
        <span class="s1">_lib.GEN_EMAIL: </span><span class="s2">&quot;email&quot;</span><span class="s0">,</span>
        <span class="s1">_lib.GEN_DNS: </span><span class="s2">&quot;DNS&quot;</span><span class="s0">,</span>
        <span class="s1">_lib.GEN_URI: </span><span class="s2">&quot;URI&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">_subjectAltNameString(self):</span>
        <span class="s1">names = _ffi.cast(</span>
            <span class="s2">&quot;GENERAL_NAMES*&quot;</span><span class="s0">, </span><span class="s1">_lib.X509V3_EXT_d2i(self._extension)</span>
        <span class="s1">)</span>

        <span class="s1">names = _ffi.gc(names</span><span class="s0">, </span><span class="s1">_lib.GENERAL_NAMES_free)</span>
        <span class="s1">parts = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.sk_GENERAL_NAME_num(names)):</span>
            <span class="s1">name = _lib.sk_GENERAL_NAME_value(names</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">label = self._prefixes[name.type]</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s1">bio = _new_mem_buf()</span>
                <span class="s1">_lib.GENERAL_NAME_print(bio</span><span class="s0">, </span><span class="s1">name)</span>
                <span class="s1">parts.append(_native(_bio_to_string(bio)))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value = _native(</span>
                    <span class="s1">_ffi.buffer(name.d.ia5.data</span><span class="s0">, </span><span class="s1">name.d.ia5.length)[:]</span>
                <span class="s1">)</span>
                <span class="s1">parts.append(label + </span><span class="s2">&quot;:&quot; </span><span class="s1">+ value)</span>
        <span class="s0">return </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(parts)</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        :return: a nice text representation of the extension 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">_lib.NID_subject_alt_name == self._nid:</span>
            <span class="s0">return </span><span class="s1">self._subjectAltNameString()</span>

        <span class="s1">bio = _new_mem_buf()</span>
        <span class="s1">print_result = _lib.X509V3_EXT_print(bio</span><span class="s0">, </span><span class="s1">self._extension</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">_openssl_assert(print_result != </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">_native(_bio_to_string(bio))</span>

    <span class="s0">def </span><span class="s1">get_critical(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the critical field of this X.509 extension. 
 
        :return: The critical field. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_lib.X509_EXTENSION_get_critical(self._extension)</span>

    <span class="s0">def </span><span class="s1">get_short_name(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the short type name of this X.509 extension. 
 
        The result is a byte string such as :py:const:`b&quot;basicConstraints&quot;`. 
 
        :return: The short type name. 
        :rtype: :py:data:`bytes` 
 
        .. versionadded:: 0.12 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = _lib.X509_EXTENSION_get_object(self._extension)</span>
        <span class="s1">nid = _lib.OBJ_obj2nid(obj)</span>
        <span class="s0">return </span><span class="s1">_ffi.string(_lib.OBJ_nid2sn(nid))</span>

    <span class="s0">def </span><span class="s1">get_data(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the data of the X509 extension, encoded as ASN.1. 
 
        :return: The ASN.1 encoded data of this X509 extension. 
        :rtype: :py:data:`bytes` 
 
        .. versionadded:: 0.12 
        &quot;&quot;&quot;</span>
        <span class="s1">octet_result = _lib.X509_EXTENSION_get_data(self._extension)</span>
        <span class="s1">string_result = _ffi.cast(</span><span class="s2">&quot;ASN1_STRING*&quot;</span><span class="s0">, </span><span class="s1">octet_result)</span>
        <span class="s1">char_result = _lib.ASN1_STRING_data(string_result)</span>
        <span class="s1">result_length = _lib.ASN1_STRING_length(string_result)</span>
        <span class="s0">return </span><span class="s1">_ffi.buffer(char_result</span><span class="s0">, </span><span class="s1">result_length)[:]</span>


<span class="s0">class </span><span class="s1">X509Req(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    An X.509 certificate signing requests. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">req = _lib.X509_REQ_new()</span>
        <span class="s1">self._req = _ffi.gc(req</span><span class="s0">, </span><span class="s1">_lib.X509_REQ_free)</span>
        <span class="s3"># Default to version 0.</span>
        <span class="s1">self.set_version(</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">to_cryptography(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Export as a ``cryptography`` certificate signing request. 
 
        :rtype: ``cryptography.x509.CertificateSigningRequest`` 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">cryptography.hazmat.backends.openssl.x509 </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">_CertificateSigningRequest</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">backend = _get_backend()</span>
        <span class="s0">return </span><span class="s1">_CertificateSigningRequest(backend</span><span class="s0">, </span><span class="s1">self._req)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_cryptography(cls</span><span class="s0">, </span><span class="s1">crypto_req):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct based on a ``cryptography`` *crypto_req*. 
 
        :param crypto_req: A ``cryptography`` X.509 certificate signing request 
        :type crypto_req: ``cryptography.x509.CertificateSigningRequest`` 
 
        :rtype: X509Req 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(crypto_req</span><span class="s0">, </span><span class="s1">x509.CertificateSigningRequest):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Must be a certificate signing request&quot;</span><span class="s1">)</span>

        <span class="s1">req = cls()</span>
        <span class="s1">req._req = crypto_req._x509_req</span>
        <span class="s0">return </span><span class="s1">req</span>

    <span class="s0">def </span><span class="s1">set_pubkey(self</span><span class="s0">, </span><span class="s1">pkey):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the public key of the certificate signing request. 
 
        :param pkey: The public key to use. 
        :type pkey: :py:class:`PKey` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">set_result = _lib.X509_REQ_set_pubkey(self._req</span><span class="s0">, </span><span class="s1">pkey._pkey)</span>
        <span class="s1">_openssl_assert(set_result == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_pubkey(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the public key of the certificate signing request. 
 
        :return: The public key. 
        :rtype: :py:class:`PKey` 
        &quot;&quot;&quot;</span>
        <span class="s1">pkey = PKey.__new__(PKey)</span>
        <span class="s1">pkey._pkey = _lib.X509_REQ_get_pubkey(self._req)</span>
        <span class="s1">_openssl_assert(pkey._pkey != _ffi.NULL)</span>
        <span class="s1">pkey._pkey = _ffi.gc(pkey._pkey</span><span class="s0">, </span><span class="s1">_lib.EVP_PKEY_free)</span>
        <span class="s1">pkey._only_public = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">pkey</span>

    <span class="s0">def </span><span class="s1">set_version(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the version subfield (RFC 2459, section 4.1.2.1) of the certificate 
        request. 
 
        :param int version: The version number. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">set_result = _lib.X509_REQ_set_version(self._req</span><span class="s0">, </span><span class="s1">version)</span>
        <span class="s1">_openssl_assert(set_result == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_version(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the version subfield (RFC 2459, section 4.1.2.1) of the certificate 
        request. 
 
        :return: The value of the version subfield. 
        :rtype: :py:class:`int` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_lib.X509_REQ_get_version(self._req)</span>

    <span class="s0">def </span><span class="s1">get_subject(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the subject of this certificate signing request. 
 
        This creates a new :class:`X509Name` that wraps the underlying subject 
        name field on the certificate signing request. Modifying it will modify 
        the underlying signing request, and will have the effect of modifying 
        any other :class:`X509Name` that refers to this subject. 
 
        :return: The subject of this certificate signing request. 
        :rtype: :class:`X509Name` 
        &quot;&quot;&quot;</span>
        <span class="s1">name = X509Name.__new__(X509Name)</span>
        <span class="s1">name._name = _lib.X509_REQ_get_subject_name(self._req)</span>
        <span class="s1">_openssl_assert(name._name != _ffi.NULL)</span>

        <span class="s3"># The name is owned by the X509Req structure.  As long as the X509Name</span>
        <span class="s3"># Python object is alive, keep the X509Req Python object alive.</span>
        <span class="s1">name._owner = self</span>

        <span class="s0">return </span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">add_extensions(self</span><span class="s0">, </span><span class="s1">extensions):</span>
        <span class="s5">&quot;&quot;&quot; 
        Add extensions to the certificate signing request. 
 
        :param extensions: The X.509 extensions to add. 
        :type extensions: iterable of :py:class:`X509Extension` 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">stack = _lib.sk_X509_EXTENSION_new_null()</span>
        <span class="s1">_openssl_assert(stack != _ffi.NULL)</span>

        <span class="s1">stack = _ffi.gc(stack</span><span class="s0">, </span><span class="s1">_lib.sk_X509_EXTENSION_free)</span>

        <span class="s0">for </span><span class="s1">ext </span><span class="s0">in </span><span class="s1">extensions:</span>
            <span class="s0">if not </span><span class="s1">isinstance(ext</span><span class="s0">, </span><span class="s1">X509Extension):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;One of the elements is not an X509Extension&quot;</span><span class="s1">)</span>

            <span class="s3"># TODO push can fail (here and elsewhere)</span>
            <span class="s1">_lib.sk_X509_EXTENSION_push(stack</span><span class="s0">, </span><span class="s1">ext._extension)</span>

        <span class="s1">add_result = _lib.X509_REQ_add_extensions(self._req</span><span class="s0">, </span><span class="s1">stack)</span>
        <span class="s1">_openssl_assert(add_result == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_extensions(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get X.509 extensions in the certificate signing request. 
 
        :return: The X.509 extensions in this request. 
        :rtype: :py:class:`list` of :py:class:`X509Extension` objects. 
 
        .. versionadded:: 0.15 
        &quot;&quot;&quot;</span>
        <span class="s1">exts = []</span>
        <span class="s1">native_exts_obj = _lib.X509_REQ_get_extensions(self._req)</span>
        <span class="s1">native_exts_obj = _ffi.gc(</span>
            <span class="s1">native_exts_obj</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x: _lib.sk_X509_EXTENSION_pop_free(</span>
                <span class="s1">x</span><span class="s0">,</span>
                <span class="s1">_ffi.addressof(_lib._original_lib</span><span class="s0">, </span><span class="s2">&quot;X509_EXTENSION_free&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.sk_X509_EXTENSION_num(native_exts_obj)):</span>
            <span class="s1">ext = X509Extension.__new__(X509Extension)</span>
            <span class="s1">extension = _lib.X509_EXTENSION_dup(</span>
                <span class="s1">_lib.sk_X509_EXTENSION_value(native_exts_obj</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">)</span>
            <span class="s1">ext._extension = _ffi.gc(extension</span><span class="s0">, </span><span class="s1">_lib.X509_EXTENSION_free)</span>
            <span class="s1">exts.append(ext)</span>
        <span class="s0">return </span><span class="s1">exts</span>

    <span class="s0">def </span><span class="s1">sign(self</span><span class="s0">, </span><span class="s1">pkey</span><span class="s0">, </span><span class="s1">digest):</span>
        <span class="s5">&quot;&quot;&quot; 
        Sign the certificate signing request with this key and digest type. 
 
        :param pkey: The key pair to sign with. 
        :type pkey: :py:class:`PKey` 
        :param digest: The name of the message digest to use for the signature, 
            e.g. :py:data:`b&quot;sha256&quot;`. 
        :type digest: :py:class:`bytes` 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">pkey._only_public:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Key has only public part&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">pkey._initialized:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Key is uninitialized&quot;</span><span class="s1">)</span>

        <span class="s1">digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))</span>
        <span class="s0">if </span><span class="s1">digest_obj == _ffi.NULL:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No such digest method&quot;</span><span class="s1">)</span>

        <span class="s1">sign_result = _lib.X509_REQ_sign(self._req</span><span class="s0">, </span><span class="s1">pkey._pkey</span><span class="s0">, </span><span class="s1">digest_obj)</span>
        <span class="s1">_openssl_assert(sign_result &gt; </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">pkey):</span>
        <span class="s5">&quot;&quot;&quot; 
        Verifies the signature on this certificate signing request. 
 
        :param PKey key: A public key. 
 
        :return: ``True`` if the signature is correct. 
        :rtype: bool 
 
        :raises OpenSSL.crypto.Error: If the signature is invalid or there is a 
            problem verifying the signature. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(pkey</span><span class="s0">, </span><span class="s1">PKey):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;pkey must be a PKey instance&quot;</span><span class="s1">)</span>

        <span class="s1">result = _lib.X509_REQ_verify(self._req</span><span class="s0">, </span><span class="s1">pkey._pkey)</span>
        <span class="s0">if </span><span class="s1">result &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">_raise_current_error()</span>

        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">class </span><span class="s1">X509(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    An X.509 certificate. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">x509 = _lib.X509_new()</span>
        <span class="s1">_openssl_assert(x509 != _ffi.NULL)</span>
        <span class="s1">self._x509 = _ffi.gc(x509</span><span class="s0">, </span><span class="s1">_lib.X509_free)</span>

        <span class="s1">self._issuer_invalidator = _X509NameInvalidator()</span>
        <span class="s1">self._subject_invalidator = _X509NameInvalidator()</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_from_raw_x509_ptr(cls</span><span class="s0">, </span><span class="s1">x509):</span>
        <span class="s1">cert = cls.__new__(cls)</span>
        <span class="s1">cert._x509 = _ffi.gc(x509</span><span class="s0">, </span><span class="s1">_lib.X509_free)</span>
        <span class="s1">cert._issuer_invalidator = _X509NameInvalidator()</span>
        <span class="s1">cert._subject_invalidator = _X509NameInvalidator()</span>
        <span class="s0">return </span><span class="s1">cert</span>

    <span class="s0">def </span><span class="s1">to_cryptography(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Export as a ``cryptography`` certificate. 
 
        :rtype: ``cryptography.x509.Certificate`` 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">cryptography.hazmat.backends.openssl.x509 </span><span class="s0">import </span><span class="s1">_Certificate</span>

        <span class="s1">backend = _get_backend()</span>
        <span class="s0">return </span><span class="s1">_Certificate(backend</span><span class="s0">, </span><span class="s1">self._x509)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_cryptography(cls</span><span class="s0">, </span><span class="s1">crypto_cert):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct based on a ``cryptography`` *crypto_cert*. 
 
        :param crypto_key: A ``cryptography`` X.509 certificate. 
        :type crypto_key: ``cryptography.x509.Certificate`` 
 
        :rtype: X509 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(crypto_cert</span><span class="s0">, </span><span class="s1">x509.Certificate):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Must be a certificate&quot;</span><span class="s1">)</span>

        <span class="s1">cert = cls()</span>
        <span class="s1">cert._x509 = crypto_cert._x509</span>
        <span class="s0">return </span><span class="s1">cert</span>

    <span class="s0">def </span><span class="s1">set_version(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the version number of the certificate. Note that the 
        version value is zero-based, eg. a value of 0 is V1. 
 
        :param version: The version number of the certificate. 
        :type version: :py:class:`int` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(version</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;version must be an integer&quot;</span><span class="s1">)</span>

        <span class="s1">_lib.X509_set_version(self._x509</span><span class="s0">, </span><span class="s1">version)</span>

    <span class="s0">def </span><span class="s1">get_version(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the version number of the certificate. 
 
        :return: The version number of the certificate. 
        :rtype: :py:class:`int` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_lib.X509_get_version(self._x509)</span>

    <span class="s0">def </span><span class="s1">get_pubkey(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the public key of the certificate. 
 
        :return: The public key. 
        :rtype: :py:class:`PKey` 
        &quot;&quot;&quot;</span>
        <span class="s1">pkey = PKey.__new__(PKey)</span>
        <span class="s1">pkey._pkey = _lib.X509_get_pubkey(self._x509)</span>
        <span class="s0">if </span><span class="s1">pkey._pkey == _ffi.NULL:</span>
            <span class="s1">_raise_current_error()</span>
        <span class="s1">pkey._pkey = _ffi.gc(pkey._pkey</span><span class="s0">, </span><span class="s1">_lib.EVP_PKEY_free)</span>
        <span class="s1">pkey._only_public = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">pkey</span>

    <span class="s0">def </span><span class="s1">set_pubkey(self</span><span class="s0">, </span><span class="s1">pkey):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the public key of the certificate. 
 
        :param pkey: The public key. 
        :type pkey: :py:class:`PKey` 
 
        :return: :py:data:`None` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(pkey</span><span class="s0">, </span><span class="s1">PKey):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;pkey must be a PKey instance&quot;</span><span class="s1">)</span>

        <span class="s1">set_result = _lib.X509_set_pubkey(self._x509</span><span class="s0">, </span><span class="s1">pkey._pkey)</span>
        <span class="s1">_openssl_assert(set_result == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">sign(self</span><span class="s0">, </span><span class="s1">pkey</span><span class="s0">, </span><span class="s1">digest):</span>
        <span class="s5">&quot;&quot;&quot; 
        Sign the certificate with this key and digest type. 
 
        :param pkey: The key to sign with. 
        :type pkey: :py:class:`PKey` 
 
        :param digest: The name of the message digest to use. 
        :type digest: :py:class:`bytes` 
 
        :return: :py:data:`None` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(pkey</span><span class="s0">, </span><span class="s1">PKey):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;pkey must be a PKey instance&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">pkey._only_public:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Key only has public part&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">pkey._initialized:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Key is uninitialized&quot;</span><span class="s1">)</span>

        <span class="s1">evp_md = _lib.EVP_get_digestbyname(_byte_string(digest))</span>
        <span class="s0">if </span><span class="s1">evp_md == _ffi.NULL:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No such digest method&quot;</span><span class="s1">)</span>

        <span class="s1">sign_result = _lib.X509_sign(self._x509</span><span class="s0">, </span><span class="s1">pkey._pkey</span><span class="s0">, </span><span class="s1">evp_md)</span>
        <span class="s1">_openssl_assert(sign_result &gt; </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_signature_algorithm(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the signature algorithm used in the certificate. 
 
        :return: The name of the algorithm. 
        :rtype: :py:class:`bytes` 
 
        :raises ValueError: If the signature algorithm is undefined. 
 
        .. versionadded:: 0.13 
        &quot;&quot;&quot;</span>
        <span class="s1">algor = _lib.X509_get0_tbs_sigalg(self._x509)</span>
        <span class="s1">nid = _lib.OBJ_obj2nid(algor.algorithm)</span>
        <span class="s0">if </span><span class="s1">nid == _lib.NID_undef:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Undefined signature algorithm&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">_ffi.string(_lib.OBJ_nid2ln(nid))</span>

    <span class="s0">def </span><span class="s1">digest(self</span><span class="s0">, </span><span class="s1">digest_name):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the digest of the X509 object. 
 
        :param digest_name: The name of the digest algorithm to use. 
        :type digest_name: :py:class:`bytes` 
 
        :return: The digest of the object, formatted as 
            :py:const:`b&quot;:&quot;`-delimited hex pairs. 
        :rtype: :py:class:`bytes` 
        &quot;&quot;&quot;</span>
        <span class="s1">digest = _lib.EVP_get_digestbyname(_byte_string(digest_name))</span>
        <span class="s0">if </span><span class="s1">digest == _ffi.NULL:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No such digest method&quot;</span><span class="s1">)</span>

        <span class="s1">result_buffer = _ffi.new(</span><span class="s2">&quot;unsigned char[]&quot;</span><span class="s0">, </span><span class="s1">_lib.EVP_MAX_MD_SIZE)</span>
        <span class="s1">result_length = _ffi.new(</span><span class="s2">&quot;unsigned int[]&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">result_length[</span><span class="s4">0</span><span class="s1">] = len(result_buffer)</span>

        <span class="s1">digest_result = _lib.X509_digest(</span>
            <span class="s1">self._x509</span><span class="s0">, </span><span class="s1">digest</span><span class="s0">, </span><span class="s1">result_buffer</span><span class="s0">, </span><span class="s1">result_length</span>
        <span class="s1">)</span>
        <span class="s1">_openssl_assert(digest_result == </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s6">b&quot;:&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s1">b16encode(ch).upper()</span>
                <span class="s0">for </span><span class="s1">ch </span><span class="s0">in </span><span class="s1">_ffi.buffer(result_buffer</span><span class="s0">, </span><span class="s1">result_length[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">subject_name_hash(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the hash of the X509 subject. 
 
        :return: The hash of the subject. 
        :rtype: :py:class:`bytes` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_lib.X509_subject_name_hash(self._x509)</span>

    <span class="s0">def </span><span class="s1">set_serial_number(self</span><span class="s0">, </span><span class="s1">serial):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the serial number of the certificate. 
 
        :param serial: The new serial number. 
        :type serial: :py:class:`int` 
 
        :return: :py:data`None` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(serial</span><span class="s0">, </span><span class="s1">_integer_types):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;serial must be an integer&quot;</span><span class="s1">)</span>

        <span class="s1">hex_serial = hex(serial)[</span><span class="s4">2</span><span class="s1">:]</span>
        <span class="s0">if not </span><span class="s1">isinstance(hex_serial</span><span class="s0">, </span><span class="s1">bytes):</span>
            <span class="s1">hex_serial = hex_serial.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>

        <span class="s1">bignum_serial = _ffi.new(</span><span class="s2">&quot;BIGNUM**&quot;</span><span class="s1">)</span>

        <span class="s3"># BN_hex2bn stores the result in &amp;bignum.  Unless it doesn't feel like</span>
        <span class="s3"># it.  If bignum is still NULL after this call, then the return value</span>
        <span class="s3"># is actually the result.  I hope.  -exarkun</span>
        <span class="s1">small_serial = _lib.BN_hex2bn(bignum_serial</span><span class="s0">, </span><span class="s1">hex_serial)</span>

        <span class="s0">if </span><span class="s1">bignum_serial[</span><span class="s4">0</span><span class="s1">] == _ffi.NULL:</span>
            <span class="s1">set_result = _lib.ASN1_INTEGER_set(</span>
                <span class="s1">_lib.X509_get_serialNumber(self._x509)</span><span class="s0">, </span><span class="s1">small_serial</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">set_result:</span>
                <span class="s3"># TODO Not tested</span>
                <span class="s1">_raise_current_error()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">asn1_serial = _lib.BN_to_ASN1_INTEGER(bignum_serial[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
            <span class="s1">_lib.BN_free(bignum_serial[</span><span class="s4">0</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">asn1_serial == _ffi.NULL:</span>
                <span class="s3"># TODO Not tested</span>
                <span class="s1">_raise_current_error()</span>
            <span class="s1">asn1_serial = _ffi.gc(asn1_serial</span><span class="s0">, </span><span class="s1">_lib.ASN1_INTEGER_free)</span>
            <span class="s1">set_result = _lib.X509_set_serialNumber(self._x509</span><span class="s0">, </span><span class="s1">asn1_serial)</span>
            <span class="s1">_openssl_assert(set_result == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_serial_number(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the serial number of this certificate. 
 
        :return: The serial number. 
        :rtype: int 
        &quot;&quot;&quot;</span>
        <span class="s1">asn1_serial = _lib.X509_get_serialNumber(self._x509)</span>
        <span class="s1">bignum_serial = _lib.ASN1_INTEGER_to_BN(asn1_serial</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">hex_serial = _lib.BN_bn2hex(bignum_serial)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">hexstring_serial = _ffi.string(hex_serial)</span>
                <span class="s1">serial = int(hexstring_serial</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">serial</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">_lib.OPENSSL_free(hex_serial)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">_lib.BN_free(bignum_serial)</span>

    <span class="s0">def </span><span class="s1">gmtime_adj_notAfter(self</span><span class="s0">, </span><span class="s1">amount):</span>
        <span class="s5">&quot;&quot;&quot; 
        Adjust the time stamp on which the certificate stops being valid. 
 
        :param int amount: The number of seconds by which to adjust the 
            timestamp. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(amount</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;amount must be an integer&quot;</span><span class="s1">)</span>

        <span class="s1">notAfter = _lib.X509_getm_notAfter(self._x509)</span>
        <span class="s1">_lib.X509_gmtime_adj(notAfter</span><span class="s0">, </span><span class="s1">amount)</span>

    <span class="s0">def </span><span class="s1">gmtime_adj_notBefore(self</span><span class="s0">, </span><span class="s1">amount):</span>
        <span class="s5">&quot;&quot;&quot; 
        Adjust the timestamp on which the certificate starts being valid. 
 
        :param amount: The number of seconds by which to adjust the timestamp. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(amount</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;amount must be an integer&quot;</span><span class="s1">)</span>

        <span class="s1">notBefore = _lib.X509_getm_notBefore(self._x509)</span>
        <span class="s1">_lib.X509_gmtime_adj(notBefore</span><span class="s0">, </span><span class="s1">amount)</span>

    <span class="s0">def </span><span class="s1">has_expired(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Check whether the certificate has expired. 
 
        :return: ``True`` if the certificate has expired, ``False`` otherwise. 
        :rtype: bool 
        &quot;&quot;&quot;</span>
        <span class="s1">time_string = _native(self.get_notAfter())</span>
        <span class="s1">not_after = datetime.datetime.strptime(time_string</span><span class="s0">, </span><span class="s2">&quot;%Y%m%d%H%M%SZ&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">not_after &lt; datetime.datetime.utcnow()</span>

    <span class="s0">def </span><span class="s1">_get_boundary_time(self</span><span class="s0">, </span><span class="s1">which):</span>
        <span class="s0">return </span><span class="s1">_get_asn1_time(which(self._x509))</span>

    <span class="s0">def </span><span class="s1">get_notBefore(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the timestamp at which the certificate starts being valid. 
 
        The timestamp is formatted as an ASN.1 TIME:: 
 
            YYYYMMDDhhmmssZ 
 
        :return: A timestamp string, or ``None`` if there is none. 
        :rtype: bytes or NoneType 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._get_boundary_time(_lib.X509_getm_notBefore)</span>

    <span class="s0">def </span><span class="s1">_set_boundary_time(self</span><span class="s0">, </span><span class="s1">which</span><span class="s0">, </span><span class="s1">when):</span>
        <span class="s0">return </span><span class="s1">_set_asn1_time(which(self._x509)</span><span class="s0">, </span><span class="s1">when)</span>

    <span class="s0">def </span><span class="s1">set_notBefore(self</span><span class="s0">, </span><span class="s1">when):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the timestamp at which the certificate starts being valid. 
 
        The timestamp is formatted as an ASN.1 TIME:: 
 
            YYYYMMDDhhmmssZ 
 
        :param bytes when: A timestamp string. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._set_boundary_time(_lib.X509_getm_notBefore</span><span class="s0">, </span><span class="s1">when)</span>

    <span class="s0">def </span><span class="s1">get_notAfter(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the timestamp at which the certificate stops being valid. 
 
        The timestamp is formatted as an ASN.1 TIME:: 
 
            YYYYMMDDhhmmssZ 
 
        :return: A timestamp string, or ``None`` if there is none. 
        :rtype: bytes or NoneType 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._get_boundary_time(_lib.X509_getm_notAfter)</span>

    <span class="s0">def </span><span class="s1">set_notAfter(self</span><span class="s0">, </span><span class="s1">when):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the timestamp at which the certificate stops being valid. 
 
        The timestamp is formatted as an ASN.1 TIME:: 
 
            YYYYMMDDhhmmssZ 
 
        :param bytes when: A timestamp string. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._set_boundary_time(_lib.X509_getm_notAfter</span><span class="s0">, </span><span class="s1">when)</span>

    <span class="s0">def </span><span class="s1">_get_name(self</span><span class="s0">, </span><span class="s1">which):</span>
        <span class="s1">name = X509Name.__new__(X509Name)</span>
        <span class="s1">name._name = which(self._x509)</span>
        <span class="s1">_openssl_assert(name._name != _ffi.NULL)</span>

        <span class="s3"># The name is owned by the X509 structure.  As long as the X509Name</span>
        <span class="s3"># Python object is alive, keep the X509 Python object alive.</span>
        <span class="s1">name._owner = self</span>

        <span class="s0">return </span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">_set_name(self</span><span class="s0">, </span><span class="s1">which</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s0">if not </span><span class="s1">isinstance(name</span><span class="s0">, </span><span class="s1">X509Name):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;name must be an X509Name&quot;</span><span class="s1">)</span>
        <span class="s1">set_result = which(self._x509</span><span class="s0">, </span><span class="s1">name._name)</span>
        <span class="s1">_openssl_assert(set_result == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_issuer(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the issuer of this certificate. 
 
        This creates a new :class:`X509Name` that wraps the underlying issuer 
        name field on the certificate. Modifying it will modify the underlying 
        certificate, and will have the effect of modifying any other 
        :class:`X509Name` that refers to this issuer. 
 
        :return: The issuer of this certificate. 
        :rtype: :class:`X509Name` 
        &quot;&quot;&quot;</span>
        <span class="s1">name = self._get_name(_lib.X509_get_issuer_name)</span>
        <span class="s1">self._issuer_invalidator.add(name)</span>
        <span class="s0">return </span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">set_issuer(self</span><span class="s0">, </span><span class="s1">issuer):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the issuer of this certificate. 
 
        :param issuer: The issuer. 
        :type issuer: :py:class:`X509Name` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_name(_lib.X509_set_issuer_name</span><span class="s0">, </span><span class="s1">issuer)</span>
        <span class="s1">self._issuer_invalidator.clear()</span>

    <span class="s0">def </span><span class="s1">get_subject(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the subject of this certificate. 
 
        This creates a new :class:`X509Name` that wraps the underlying subject 
        name field on the certificate. Modifying it will modify the underlying 
        certificate, and will have the effect of modifying any other 
        :class:`X509Name` that refers to this subject. 
 
        :return: The subject of this certificate. 
        :rtype: :class:`X509Name` 
        &quot;&quot;&quot;</span>
        <span class="s1">name = self._get_name(_lib.X509_get_subject_name)</span>
        <span class="s1">self._subject_invalidator.add(name)</span>
        <span class="s0">return </span><span class="s1">name</span>

    <span class="s0">def </span><span class="s1">set_subject(self</span><span class="s0">, </span><span class="s1">subject):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the subject of this certificate. 
 
        :param subject: The subject. 
        :type subject: :py:class:`X509Name` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">self._set_name(_lib.X509_set_subject_name</span><span class="s0">, </span><span class="s1">subject)</span>
        <span class="s1">self._subject_invalidator.clear()</span>

    <span class="s0">def </span><span class="s1">get_extension_count(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the number of extensions on this certificate. 
 
        :return: The number of extensions. 
        :rtype: :py:class:`int` 
 
        .. versionadded:: 0.12 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">_lib.X509_get_ext_count(self._x509)</span>

    <span class="s0">def </span><span class="s1">add_extensions(self</span><span class="s0">, </span><span class="s1">extensions):</span>
        <span class="s5">&quot;&quot;&quot; 
        Add extensions to the certificate. 
 
        :param extensions: The extensions to add. 
        :type extensions: An iterable of :py:class:`X509Extension` objects. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">ext </span><span class="s0">in </span><span class="s1">extensions:</span>
            <span class="s0">if not </span><span class="s1">isinstance(ext</span><span class="s0">, </span><span class="s1">X509Extension):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;One of the elements is not an X509Extension&quot;</span><span class="s1">)</span>

            <span class="s1">add_result = _lib.X509_add_ext(self._x509</span><span class="s0">, </span><span class="s1">ext._extension</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">add_result:</span>
                <span class="s1">_raise_current_error()</span>

    <span class="s0">def </span><span class="s1">get_extension(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get a specific extension of the certificate by index. 
 
        Extensions on a certificate are kept in order. The index 
        parameter selects which extension will be returned. 
 
        :param int index: The index of the extension to retrieve. 
        :return: The extension at the specified index. 
        :rtype: :py:class:`X509Extension` 
        :raises IndexError: If the extension index was out of bounds. 
 
        .. versionadded:: 0.12 
        &quot;&quot;&quot;</span>
        <span class="s1">ext = X509Extension.__new__(X509Extension)</span>
        <span class="s1">ext._extension = _lib.X509_get_ext(self._x509</span><span class="s0">, </span><span class="s1">index)</span>
        <span class="s0">if </span><span class="s1">ext._extension == _ffi.NULL:</span>
            <span class="s0">raise </span><span class="s1">IndexError(</span><span class="s2">&quot;extension index out of bounds&quot;</span><span class="s1">)</span>

        <span class="s1">extension = _lib.X509_EXTENSION_dup(ext._extension)</span>
        <span class="s1">ext._extension = _ffi.gc(extension</span><span class="s0">, </span><span class="s1">_lib.X509_EXTENSION_free)</span>
        <span class="s0">return </span><span class="s1">ext</span>


<span class="s0">class </span><span class="s1">X509StoreFlags(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    Flags for X509 verification, used to change the behavior of 
    :class:`X509Store`. 
 
    See `OpenSSL Verification Flags`_ for details. 
 
    .. _OpenSSL Verification Flags: 
        https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html 
    &quot;&quot;&quot;</span>

    <span class="s1">CRL_CHECK = _lib.X509_V_FLAG_CRL_CHECK</span>
    <span class="s1">CRL_CHECK_ALL = _lib.X509_V_FLAG_CRL_CHECK_ALL</span>
    <span class="s1">IGNORE_CRITICAL = _lib.X509_V_FLAG_IGNORE_CRITICAL</span>
    <span class="s1">X509_STRICT = _lib.X509_V_FLAG_X509_STRICT</span>
    <span class="s1">ALLOW_PROXY_CERTS = _lib.X509_V_FLAG_ALLOW_PROXY_CERTS</span>
    <span class="s1">POLICY_CHECK = _lib.X509_V_FLAG_POLICY_CHECK</span>
    <span class="s1">EXPLICIT_POLICY = _lib.X509_V_FLAG_EXPLICIT_POLICY</span>
    <span class="s1">INHIBIT_MAP = _lib.X509_V_FLAG_INHIBIT_MAP</span>
    <span class="s1">NOTIFY_POLICY = _lib.X509_V_FLAG_NOTIFY_POLICY</span>
    <span class="s1">CHECK_SS_SIGNATURE = _lib.X509_V_FLAG_CHECK_SS_SIGNATURE</span>
    <span class="s1">CB_ISSUER_CHECK = _lib.X509_V_FLAG_CB_ISSUER_CHECK</span>


<span class="s0">class </span><span class="s1">X509Store(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    An X.509 store. 
 
    An X.509 store is used to describe a context in which to verify a 
    certificate. A description of a context may include a set of certificates 
    to trust, a set of certificate revocation lists, verification flags and 
    more. 
 
    An X.509 store, being only a description, cannot be used by itself to 
    verify a certificate. To carry out the actual verification process, see 
    :class:`X509StoreContext`. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">store = _lib.X509_STORE_new()</span>
        <span class="s1">self._store = _ffi.gc(store</span><span class="s0">, </span><span class="s1">_lib.X509_STORE_free)</span>

    <span class="s0">def </span><span class="s1">add_cert(self</span><span class="s0">, </span><span class="s1">cert):</span>
        <span class="s5">&quot;&quot;&quot; 
        Adds a trusted certificate to this store. 
 
        Adding a certificate with this method adds this certificate as a 
        *trusted* certificate. 
 
        :param X509 cert: The certificate to add to this store. 
 
        :raises TypeError: If the certificate is not an :class:`X509`. 
 
        :raises OpenSSL.crypto.Error: If OpenSSL was unhappy with your 
            certificate. 
 
        :return: ``None`` if the certificate was added successfully. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(cert</span><span class="s0">, </span><span class="s1">X509):</span>
            <span class="s0">raise </span><span class="s1">TypeError()</span>

        <span class="s1">res = _lib.X509_STORE_add_cert(self._store</span><span class="s0">, </span><span class="s1">cert._x509)</span>
        <span class="s1">_openssl_assert(res == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_crl(self</span><span class="s0">, </span><span class="s1">crl):</span>
        <span class="s5">&quot;&quot;&quot; 
        Add a certificate revocation list to this store. 
 
        The certificate revocation lists added to a store will only be used if 
        the associated flags are configured to check certificate revocation 
        lists. 
 
        .. versionadded:: 16.1.0 
 
        :param CRL crl: The certificate revocation list to add to this store. 
        :return: ``None`` if the certificate revocation list was added 
            successfully. 
        &quot;&quot;&quot;</span>
        <span class="s1">_openssl_assert(_lib.X509_STORE_add_crl(self._store</span><span class="s0">, </span><span class="s1">crl._crl) != </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set_flags(self</span><span class="s0">, </span><span class="s1">flags):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set verification flags to this store. 
 
        Verification flags can be combined by oring them together. 
 
        .. note:: 
 
          Setting a verification flag sometimes requires clients to add 
          additional information to the store, otherwise a suitable error will 
          be raised. 
 
          For example, in setting flags to enable CRL checking a 
          suitable CRL must be added to the store otherwise an error will be 
          raised. 
 
        .. versionadded:: 16.1.0 
 
        :param int flags: The verification flags to set on this store. 
            See :class:`X509StoreFlags` for available constants. 
        :return: ``None`` if the verification flags were successfully set. 
        &quot;&quot;&quot;</span>
        <span class="s1">_openssl_assert(_lib.X509_STORE_set_flags(self._store</span><span class="s0">, </span><span class="s1">flags) != </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">set_time(self</span><span class="s0">, </span><span class="s1">vfy_time):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the time against which the certificates are verified. 
 
        Normally the current time is used. 
 
        .. note:: 
 
          For example, you can determine if a certificate was valid at a given 
          time. 
 
        .. versionadded:: 17.0.0 
 
        :param datetime vfy_time: The verification time to set on this store. 
        :return: ``None`` if the verification time was successfully set. 
        &quot;&quot;&quot;</span>
        <span class="s1">param = _lib.X509_VERIFY_PARAM_new()</span>
        <span class="s1">param = _ffi.gc(param</span><span class="s0">, </span><span class="s1">_lib.X509_VERIFY_PARAM_free)</span>

        <span class="s1">_lib.X509_VERIFY_PARAM_set_time(</span>
            <span class="s1">param</span><span class="s0">, </span><span class="s1">calendar.timegm(vfy_time.timetuple())</span>
        <span class="s1">)</span>
        <span class="s1">_openssl_assert(_lib.X509_STORE_set1_param(self._store</span><span class="s0">, </span><span class="s1">param) != </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">load_locations(self</span><span class="s0">, </span><span class="s1">cafile</span><span class="s0">, </span><span class="s1">capath=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Let X509Store know where we can find trusted certificates for the 
        certificate chain.  Note that the certificates have to be in PEM 
        format. 
 
        If *capath* is passed, it must be a directory prepared using the 
        ``c_rehash`` tool included with OpenSSL.  Either, but not both, of 
        *cafile* or *capath* may be ``None``. 
 
        .. note:: 
 
          Both *cafile* and *capath* may be set simultaneously. 
 
          Call this method multiple times to add more than one location. 
          For example, CA certificates, and certificate revocation list bundles 
          may be passed in *cafile* in subsequent calls to this method. 
 
        .. versionadded:: 20.0 
 
        :param cafile: In which file we can find the certificates (``bytes`` or 
                       ``unicode``). 
        :param capath: In which directory we can find the certificates 
                       (``bytes`` or ``unicode``). 
 
        :return: ``None`` if the locations were set successfully. 
 
        :raises OpenSSL.crypto.Error: If both *cafile* and *capath* is ``None`` 
            or the locations could not be set for any reason. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">cafile </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">cafile = _ffi.NULL</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">cafile = _path_string(cafile)</span>

        <span class="s0">if </span><span class="s1">capath </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">capath = _ffi.NULL</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">capath = _path_string(capath)</span>

        <span class="s1">load_result = _lib.X509_STORE_load_locations(</span>
            <span class="s1">self._store</span><span class="s0">, </span><span class="s1">cafile</span><span class="s0">, </span><span class="s1">capath</span>
        <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">load_result:</span>
            <span class="s1">_raise_current_error()</span>


<span class="s0">class </span><span class="s1">X509StoreContextError(Exception):</span>
    <span class="s5">&quot;&quot;&quot; 
    An exception raised when an error occurred while verifying a certificate 
    using `OpenSSL.X509StoreContext.verify_certificate`. 
 
    :ivar certificate: The certificate which caused verificate failure. 
    :type certificate: :class:`X509` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">message</span><span class="s0">, </span><span class="s1">certificate):</span>
        <span class="s1">super(X509StoreContextError</span><span class="s0">, </span><span class="s1">self).__init__(message)</span>
        <span class="s1">self.certificate = certificate</span>


<span class="s0">class </span><span class="s1">X509StoreContext(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    An X.509 store context. 
 
    An X.509 store context is used to carry out the actual verification process 
    of a certificate in a described context. For describing such a context, see 
    :class:`X509Store`. 
 
    :ivar _store_ctx: The underlying X509_STORE_CTX structure used by this 
        instance.  It is dynamically allocated and automatically garbage 
        collected. 
    :ivar _store: See the ``store`` ``__init__`` parameter. 
    :ivar _cert: See the ``certificate`` ``__init__`` parameter. 
    :ivar _chain: See the ``chain`` ``__init__`` parameter. 
    :param X509Store store: The certificates which will be trusted for the 
        purposes of any verifications. 
    :param X509 certificate: The certificate to be verified. 
    :param chain: List of untrusted certificates that may be used for building 
        the certificate chain. May be ``None``. 
    :type chain: :class:`list` of :class:`X509` 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">store</span><span class="s0">, </span><span class="s1">certificate</span><span class="s0">, </span><span class="s1">chain=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">store_ctx = _lib.X509_STORE_CTX_new()</span>
        <span class="s1">self._store_ctx = _ffi.gc(store_ctx</span><span class="s0">, </span><span class="s1">_lib.X509_STORE_CTX_free)</span>
        <span class="s1">self._store = store</span>
        <span class="s1">self._cert = certificate</span>
        <span class="s1">self._chain = self._build_certificate_stack(chain)</span>
        <span class="s3"># Make the store context available for use after instantiating this</span>
        <span class="s3"># class by initializing it now. Per testing, subsequent calls to</span>
        <span class="s3"># :meth:`_init` have no adverse affect.</span>
        <span class="s1">self._init()</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_build_certificate_stack(certificates):</span>
        <span class="s0">def </span><span class="s1">cleanup(s):</span>
            <span class="s3"># Equivalent to sk_X509_pop_free, but we don't</span>
            <span class="s3"># currently have a CFFI binding for that available</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.sk_X509_num(s)):</span>
                <span class="s1">x = _lib.sk_X509_value(s</span><span class="s0">, </span><span class="s1">i)</span>
                <span class="s1">_lib.X509_free(x)</span>
            <span class="s1">_lib.sk_X509_free(s)</span>

        <span class="s0">if </span><span class="s1">certificates </span><span class="s0">is None or </span><span class="s1">len(certificates) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">_ffi.NULL</span>

        <span class="s1">stack = _lib.sk_X509_new_null()</span>
        <span class="s1">_openssl_assert(stack != _ffi.NULL)</span>
        <span class="s1">stack = _ffi.gc(stack</span><span class="s0">, </span><span class="s1">cleanup)</span>

        <span class="s0">for </span><span class="s1">cert </span><span class="s0">in </span><span class="s1">certificates:</span>
            <span class="s0">if not </span><span class="s1">isinstance(cert</span><span class="s0">, </span><span class="s1">X509):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;One of the elements is not an X509 instance&quot;</span><span class="s1">)</span>

            <span class="s1">_openssl_assert(_lib.X509_up_ref(cert._x509) &gt; </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">_lib.sk_X509_push(stack</span><span class="s0">, </span><span class="s1">cert._x509) &lt;= </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">_lib.X509_free(cert._x509)</span>
                <span class="s1">_raise_current_error()</span>

        <span class="s0">return </span><span class="s1">stack</span>

    <span class="s0">def </span><span class="s1">_init(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set up the store context for a subsequent verification operation. 
 
        Calling this method more than once without first calling 
        :meth:`_cleanup` will leak memory. 
        &quot;&quot;&quot;</span>
        <span class="s1">ret = _lib.X509_STORE_CTX_init(</span>
            <span class="s1">self._store_ctx</span><span class="s0">, </span><span class="s1">self._store._store</span><span class="s0">, </span><span class="s1">self._cert._x509</span><span class="s0">, </span><span class="s1">self._chain</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">ret &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">_raise_current_error()</span>

    <span class="s0">def </span><span class="s1">_cleanup(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Internally cleans up the store context. 
 
        The store context can then be reused with a new call to :meth:`_init`. 
        &quot;&quot;&quot;</span>
        <span class="s1">_lib.X509_STORE_CTX_cleanup(self._store_ctx)</span>

    <span class="s0">def </span><span class="s1">_exception_from_context(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Convert an OpenSSL native context error failure into a Python 
        exception. 
 
        When a call to native OpenSSL X509_verify_cert fails, additional 
        information about the failure can be obtained from the store context. 
        &quot;&quot;&quot;</span>
        <span class="s1">errors = [</span>
            <span class="s1">_lib.X509_STORE_CTX_get_error(self._store_ctx)</span><span class="s0">,</span>
            <span class="s1">_lib.X509_STORE_CTX_get_error_depth(self._store_ctx)</span><span class="s0">,</span>
            <span class="s1">_native(</span>
                <span class="s1">_ffi.string(</span>
                    <span class="s1">_lib.X509_verify_cert_error_string(</span>
                        <span class="s1">_lib.X509_STORE_CTX_get_error(self._store_ctx)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
        <span class="s3"># A context error should always be associated with a certificate, so we</span>
        <span class="s3"># expect this call to never return :class:`None`.</span>
        <span class="s1">_x509 = _lib.X509_STORE_CTX_get_current_cert(self._store_ctx)</span>
        <span class="s1">_cert = _lib.X509_dup(_x509)</span>
        <span class="s1">pycert = X509._from_raw_x509_ptr(_cert)</span>
        <span class="s0">return </span><span class="s1">X509StoreContextError(errors</span><span class="s0">, </span><span class="s1">pycert)</span>

    <span class="s0">def </span><span class="s1">set_store(self</span><span class="s0">, </span><span class="s1">store):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the context's X.509 store. 
 
        .. versionadded:: 0.15 
 
        :param X509Store store: The store description which will be used for 
            the purposes of any *future* verifications. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._store = store</span>

    <span class="s0">def </span><span class="s1">verify_certificate(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Verify a certificate in a context. 
 
        .. versionadded:: 0.15 
 
        :raises X509StoreContextError: If an error occurred when validating a 
          certificate in the context. Sets ``certificate`` attribute to 
          indicate which certificate caused the error. 
        &quot;&quot;&quot;</span>
        <span class="s3"># Always re-initialize the store context in case</span>
        <span class="s3"># :meth:`verify_certificate` is called multiple times.</span>
        <span class="s3">#</span>
        <span class="s3"># :meth:`_init` is called in :meth:`__init__` so _cleanup is called</span>
        <span class="s3"># before _init to ensure memory is not leaked.</span>
        <span class="s1">self._cleanup()</span>
        <span class="s1">self._init()</span>
        <span class="s1">ret = _lib.X509_verify_cert(self._store_ctx)</span>
        <span class="s1">self._cleanup()</span>
        <span class="s0">if </span><span class="s1">ret &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">self._exception_from_context()</span>

    <span class="s0">def </span><span class="s1">get_verified_chain(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Verify a certificate in a context and return the complete validated 
        chain. 
 
        :raises X509StoreContextError: If an error occurred when validating a 
          certificate in the context. Sets ``certificate`` attribute to 
          indicate which certificate caused the error. 
 
        .. versionadded:: 20.0 
        &quot;&quot;&quot;</span>
        <span class="s3"># Always re-initialize the store context in case</span>
        <span class="s3"># :meth:`verify_certificate` is called multiple times.</span>
        <span class="s3">#</span>
        <span class="s3"># :meth:`_init` is called in :meth:`__init__` so _cleanup is called</span>
        <span class="s3"># before _init to ensure memory is not leaked.</span>
        <span class="s1">self._cleanup()</span>
        <span class="s1">self._init()</span>
        <span class="s1">ret = _lib.X509_verify_cert(self._store_ctx)</span>
        <span class="s0">if </span><span class="s1">ret &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self._cleanup()</span>
            <span class="s0">raise </span><span class="s1">self._exception_from_context()</span>

        <span class="s3"># Note: X509_STORE_CTX_get1_chain returns a deep copy of the chain.</span>
        <span class="s1">cert_stack = _lib.X509_STORE_CTX_get1_chain(self._store_ctx)</span>
        <span class="s1">_openssl_assert(cert_stack != _ffi.NULL)</span>

        <span class="s1">result = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.sk_X509_num(cert_stack)):</span>
            <span class="s1">cert = _lib.sk_X509_value(cert_stack</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">_openssl_assert(cert != _ffi.NULL)</span>
            <span class="s1">pycert = X509._from_raw_x509_ptr(cert)</span>
            <span class="s1">result.append(pycert)</span>

        <span class="s3"># Free the stack but not the members which are freed by the X509 class.</span>
        <span class="s1">_lib.sk_X509_free(cert_stack)</span>
        <span class="s1">self._cleanup()</span>
        <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">load_certificate(type</span><span class="s0">, </span><span class="s1">buffer):</span>
    <span class="s5">&quot;&quot;&quot; 
    Load a certificate (X509) from the string *buffer* encoded with the 
    type *type*. 
 
    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1) 
 
    :param bytes buffer: The buffer the certificate is stored in 
 
    :return: The X509 object 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">_text_type):</span>
        <span class="s1">buffer = buffer.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s1">bio = _new_mem_buf(buffer)</span>

    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">x509 = _lib.PEM_read_bio_X509(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">x509 = _lib.d2i_X509_bio(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">x509 == _ffi.NULL:</span>
        <span class="s1">_raise_current_error()</span>

    <span class="s0">return </span><span class="s1">X509._from_raw_x509_ptr(x509)</span>


<span class="s0">def </span><span class="s1">dump_certificate(type</span><span class="s0">, </span><span class="s1">cert):</span>
    <span class="s5">&quot;&quot;&quot; 
    Dump the certificate *cert* into a buffer string encoded with the type 
    *type*. 
 
    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1, or 
        FILETYPE_TEXT) 
    :param cert: The certificate to dump 
    :return: The buffer with the dumped certificate in 
    &quot;&quot;&quot;</span>
    <span class="s1">bio = _new_mem_buf()</span>

    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">result_code = _lib.PEM_write_bio_X509(bio</span><span class="s0">, </span><span class="s1">cert._x509)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">result_code = _lib.i2d_X509_bio(bio</span><span class="s0">, </span><span class="s1">cert._x509)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_TEXT:</span>
        <span class="s1">result_code = _lib.X509_print_ex(bio</span><span class="s0">, </span><span class="s1">cert._x509</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;type argument must be FILETYPE_PEM, FILETYPE_ASN1, or &quot;</span>
            <span class="s2">&quot;FILETYPE_TEXT&quot;</span>
        <span class="s1">)</span>

    <span class="s1">_openssl_assert(result_code == </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">_bio_to_string(bio)</span>


<span class="s0">def </span><span class="s1">dump_publickey(type</span><span class="s0">, </span><span class="s1">pkey):</span>
    <span class="s5">&quot;&quot;&quot; 
    Dump a public key to a buffer. 
 
    :param type: The file type (one of :data:`FILETYPE_PEM` or 
        :data:`FILETYPE_ASN1`). 
    :param PKey pkey: The public key to dump 
    :return: The buffer with the dumped key in it. 
    :rtype: bytes 
    &quot;&quot;&quot;</span>
    <span class="s1">bio = _new_mem_buf()</span>
    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">write_bio = _lib.PEM_write_bio_PUBKEY</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">write_bio = _lib.i2d_PUBKEY_bio</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;</span><span class="s1">)</span>

    <span class="s1">result_code = write_bio(bio</span><span class="s0">, </span><span class="s1">pkey._pkey)</span>
    <span class="s0">if </span><span class="s1">result_code != </span><span class="s4">1</span><span class="s1">:  </span><span class="s3"># pragma: no cover</span>
        <span class="s1">_raise_current_error()</span>

    <span class="s0">return </span><span class="s1">_bio_to_string(bio)</span>


<span class="s0">def </span><span class="s1">dump_privatekey(type</span><span class="s0">, </span><span class="s1">pkey</span><span class="s0">, </span><span class="s1">cipher=</span><span class="s0">None, </span><span class="s1">passphrase=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Dump the private key *pkey* into a buffer string encoded with the type 
    *type*.  Optionally (if *type* is :const:`FILETYPE_PEM`) encrypting it 
    using *cipher* and *passphrase*. 
 
    :param type: The file type (one of :const:`FILETYPE_PEM`, 
        :const:`FILETYPE_ASN1`, or :const:`FILETYPE_TEXT`) 
    :param PKey pkey: The PKey to dump 
    :param cipher: (optional) if encrypted PEM format, the cipher to use 
    :param passphrase: (optional) if encrypted PEM format, this can be either 
        the passphrase to use, or a callback for providing the passphrase. 
 
    :return: The buffer with the dumped key in 
    :rtype: bytes 
    &quot;&quot;&quot;</span>
    <span class="s1">bio = _new_mem_buf()</span>

    <span class="s0">if not </span><span class="s1">isinstance(pkey</span><span class="s0">, </span><span class="s1">PKey):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;pkey must be a PKey&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">cipher </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">passphrase </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;if a value is given for cipher &quot;</span>
                <span class="s2">&quot;one must also be given for passphrase&quot;</span>
            <span class="s1">)</span>
        <span class="s1">cipher_obj = _lib.EVP_get_cipherbyname(_byte_string(cipher))</span>
        <span class="s0">if </span><span class="s1">cipher_obj == _ffi.NULL:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Invalid cipher name&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">cipher_obj = _ffi.NULL</span>

    <span class="s1">helper = _PassphraseHelper(type</span><span class="s0">, </span><span class="s1">passphrase)</span>
    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">result_code = _lib.PEM_write_bio_PrivateKey(</span>
            <span class="s1">bio</span><span class="s0">,</span>
            <span class="s1">pkey._pkey</span><span class="s0">,</span>
            <span class="s1">cipher_obj</span><span class="s0">,</span>
            <span class="s1">_ffi.NULL</span><span class="s0">,</span>
            <span class="s4">0</span><span class="s0">,</span>
            <span class="s1">helper.callback</span><span class="s0">,</span>
            <span class="s1">helper.callback_args</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">helper.raise_if_problem()</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">result_code = _lib.i2d_PrivateKey_bio(bio</span><span class="s0">, </span><span class="s1">pkey._pkey)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_TEXT:</span>
        <span class="s0">if </span><span class="s1">_lib.EVP_PKEY_id(pkey._pkey) != _lib.EVP_PKEY_RSA:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Only RSA keys are supported for FILETYPE_TEXT&quot;</span><span class="s1">)</span>

        <span class="s1">rsa = _ffi.gc(_lib.EVP_PKEY_get1_RSA(pkey._pkey)</span><span class="s0">, </span><span class="s1">_lib.RSA_free)</span>
        <span class="s1">result_code = _lib.RSA_print(bio</span><span class="s0">, </span><span class="s1">rsa</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;type argument must be FILETYPE_PEM, FILETYPE_ASN1, or &quot;</span>
            <span class="s2">&quot;FILETYPE_TEXT&quot;</span>
        <span class="s1">)</span>

    <span class="s1">_openssl_assert(result_code != </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">_bio_to_string(bio)</span>


<span class="s0">class </span><span class="s1">Revoked(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    A certificate revocation. 
    &quot;&quot;&quot;</span>

    <span class="s3"># https://www.openssl.org/docs/manmaster/man5/x509v3_config.html#CRL-distribution-points</span>
    <span class="s3"># which differs from crl_reasons of crypto/x509v3/v3_enum.c that matches</span>
    <span class="s3"># OCSP_crl_reason_str.  We use the latter, just like the command line</span>
    <span class="s3"># program.</span>
    <span class="s1">_crl_reasons = [</span>
        <span class="s6">b&quot;unspecified&quot;</span><span class="s0">,</span>
        <span class="s6">b&quot;keyCompromise&quot;</span><span class="s0">,</span>
        <span class="s6">b&quot;CACompromise&quot;</span><span class="s0">,</span>
        <span class="s6">b&quot;affiliationChanged&quot;</span><span class="s0">,</span>
        <span class="s6">b&quot;superseded&quot;</span><span class="s0">,</span>
        <span class="s6">b&quot;cessationOfOperation&quot;</span><span class="s0">,</span>
        <span class="s6">b&quot;certificateHold&quot;</span><span class="s0">,</span>
        <span class="s3"># b&quot;removeFromCRL&quot;,</span>
    <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">revoked = _lib.X509_REVOKED_new()</span>
        <span class="s1">self._revoked = _ffi.gc(revoked</span><span class="s0">, </span><span class="s1">_lib.X509_REVOKED_free)</span>

    <span class="s0">def </span><span class="s1">set_serial(self</span><span class="s0">, </span><span class="s1">hex_str):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the serial number. 
 
        The serial number is formatted as a hexadecimal number encoded in 
        ASCII. 
 
        :param bytes hex_str: The new serial number. 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">bignum_serial = _ffi.gc(_lib.BN_new()</span><span class="s0">, </span><span class="s1">_lib.BN_free)</span>
        <span class="s1">bignum_ptr = _ffi.new(</span><span class="s2">&quot;BIGNUM**&quot;</span><span class="s1">)</span>
        <span class="s1">bignum_ptr[</span><span class="s4">0</span><span class="s1">] = bignum_serial</span>
        <span class="s1">bn_result = _lib.BN_hex2bn(bignum_ptr</span><span class="s0">, </span><span class="s1">hex_str)</span>
        <span class="s0">if not </span><span class="s1">bn_result:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;bad hex string&quot;</span><span class="s1">)</span>

        <span class="s1">asn1_serial = _ffi.gc(</span>
            <span class="s1">_lib.BN_to_ASN1_INTEGER(bignum_serial</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span><span class="s0">,</span>
            <span class="s1">_lib.ASN1_INTEGER_free</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">_lib.X509_REVOKED_set_serialNumber(self._revoked</span><span class="s0">, </span><span class="s1">asn1_serial)</span>

    <span class="s0">def </span><span class="s1">get_serial(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the serial number. 
 
        The serial number is formatted as a hexadecimal number encoded in 
        ASCII. 
 
        :return: The serial number. 
        :rtype: bytes 
        &quot;&quot;&quot;</span>
        <span class="s1">bio = _new_mem_buf()</span>

        <span class="s1">asn1_int = _lib.X509_REVOKED_get0_serialNumber(self._revoked)</span>
        <span class="s1">_openssl_assert(asn1_int != _ffi.NULL)</span>
        <span class="s1">result = _lib.i2a_ASN1_INTEGER(bio</span><span class="s0">, </span><span class="s1">asn1_int)</span>
        <span class="s1">_openssl_assert(result &gt;= </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">_bio_to_string(bio)</span>

    <span class="s0">def </span><span class="s1">_delete_reason(self):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.X509_REVOKED_get_ext_count(self._revoked)):</span>
            <span class="s1">ext = _lib.X509_REVOKED_get_ext(self._revoked</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">obj = _lib.X509_EXTENSION_get_object(ext)</span>
            <span class="s0">if </span><span class="s1">_lib.OBJ_obj2nid(obj) == _lib.NID_crl_reason:</span>
                <span class="s1">_lib.X509_EXTENSION_free(ext)</span>
                <span class="s1">_lib.X509_REVOKED_delete_ext(self._revoked</span><span class="s0">, </span><span class="s1">i)</span>
                <span class="s0">break</span>

    <span class="s0">def </span><span class="s1">set_reason(self</span><span class="s0">, </span><span class="s1">reason):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the reason of this revocation. 
 
        If :data:`reason` is ``None``, delete the reason instead. 
 
        :param reason: The reason string. 
        :type reason: :class:`bytes` or :class:`NoneType` 
 
        :return: ``None`` 
 
        .. seealso:: 
 
            :meth:`all_reasons`, which gives you a list of all supported 
            reasons which you might pass to this method. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">reason </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._delete_reason()</span>
        <span class="s0">elif not </span><span class="s1">isinstance(reason</span><span class="s0">, </span><span class="s1">bytes):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;reason must be None or a byte string&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">reason = reason.lower().replace(</span><span class="s6">b&quot; &quot;</span><span class="s0">, </span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">reason_code = [r.lower() </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">self._crl_reasons].index(reason)</span>

            <span class="s1">new_reason_ext = _lib.ASN1_ENUMERATED_new()</span>
            <span class="s1">_openssl_assert(new_reason_ext != _ffi.NULL)</span>
            <span class="s1">new_reason_ext = _ffi.gc(new_reason_ext</span><span class="s0">, </span><span class="s1">_lib.ASN1_ENUMERATED_free)</span>

            <span class="s1">set_result = _lib.ASN1_ENUMERATED_set(new_reason_ext</span><span class="s0">, </span><span class="s1">reason_code)</span>
            <span class="s1">_openssl_assert(set_result != _ffi.NULL)</span>

            <span class="s1">self._delete_reason()</span>
            <span class="s1">add_result = _lib.X509_REVOKED_add1_ext_i2d(</span>
                <span class="s1">self._revoked</span><span class="s0">, </span><span class="s1">_lib.NID_crl_reason</span><span class="s0">, </span><span class="s1">new_reason_ext</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span>
            <span class="s1">)</span>
            <span class="s1">_openssl_assert(add_result == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_reason(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the reason of this revocation. 
 
        :return: The reason, or ``None`` if there is none. 
        :rtype: bytes or NoneType 
 
        .. seealso:: 
 
            :meth:`all_reasons`, which gives you a list of all supported 
            reasons this method might return. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.X509_REVOKED_get_ext_count(self._revoked)):</span>
            <span class="s1">ext = _lib.X509_REVOKED_get_ext(self._revoked</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">obj = _lib.X509_EXTENSION_get_object(ext)</span>
            <span class="s0">if </span><span class="s1">_lib.OBJ_obj2nid(obj) == _lib.NID_crl_reason:</span>
                <span class="s1">bio = _new_mem_buf()</span>

                <span class="s1">print_result = _lib.X509V3_EXT_print(bio</span><span class="s0">, </span><span class="s1">ext</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s0">if not </span><span class="s1">print_result:</span>
                    <span class="s1">print_result = _lib.M_ASN1_OCTET_STRING_print(</span>
                        <span class="s1">bio</span><span class="s0">, </span><span class="s1">_lib.X509_EXTENSION_get_data(ext)</span>
                    <span class="s1">)</span>
                    <span class="s1">_openssl_assert(print_result != </span><span class="s4">0</span><span class="s1">)</span>

                <span class="s0">return </span><span class="s1">_bio_to_string(bio)</span>

    <span class="s0">def </span><span class="s1">all_reasons(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return a list of all the supported reason strings. 
 
        This list is a copy; modifying it does not change the supported reason 
        strings. 
 
        :return: A list of reason strings. 
        :rtype: :class:`list` of :class:`bytes` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._crl_reasons[:]</span>

    <span class="s0">def </span><span class="s1">set_rev_date(self</span><span class="s0">, </span><span class="s1">when):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the revocation timestamp. 
 
        :param bytes when: The timestamp of the revocation, 
            as ASN.1 TIME. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">dt = _lib.X509_REVOKED_get0_revocationDate(self._revoked)</span>
        <span class="s0">return </span><span class="s1">_set_asn1_time(dt</span><span class="s0">, </span><span class="s1">when)</span>

    <span class="s0">def </span><span class="s1">get_rev_date(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the revocation timestamp. 
 
        :return: The timestamp of the revocation, as ASN.1 TIME. 
        :rtype: bytes 
        &quot;&quot;&quot;</span>
        <span class="s1">dt = _lib.X509_REVOKED_get0_revocationDate(self._revoked)</span>
        <span class="s0">return </span><span class="s1">_get_asn1_time(dt)</span>


<span class="s0">class </span><span class="s1">CRL(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    A certificate revocation list. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">crl = _lib.X509_CRL_new()</span>
        <span class="s1">self._crl = _ffi.gc(crl</span><span class="s0">, </span><span class="s1">_lib.X509_CRL_free)</span>

    <span class="s0">def </span><span class="s1">to_cryptography(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Export as a ``cryptography`` CRL. 
 
        :rtype: ``cryptography.x509.CertificateRevocationList`` 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">cryptography.hazmat.backends.openssl.x509 </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">_CertificateRevocationList</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">backend = _get_backend()</span>
        <span class="s0">return </span><span class="s1">_CertificateRevocationList(backend</span><span class="s0">, </span><span class="s1">self._crl)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_cryptography(cls</span><span class="s0">, </span><span class="s1">crypto_crl):</span>
        <span class="s5">&quot;&quot;&quot; 
        Construct based on a ``cryptography`` *crypto_crl*. 
 
        :param crypto_crl: A ``cryptography`` certificate revocation list 
        :type crypto_crl: ``cryptography.x509.CertificateRevocationList`` 
 
        :rtype: CRL 
 
        .. versionadded:: 17.1.0 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(crypto_crl</span><span class="s0">, </span><span class="s1">x509.CertificateRevocationList):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;Must be a certificate revocation list&quot;</span><span class="s1">)</span>

        <span class="s1">crl = cls()</span>
        <span class="s1">crl._crl = crypto_crl._x509_crl</span>
        <span class="s0">return </span><span class="s1">crl</span>

    <span class="s0">def </span><span class="s1">get_revoked(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Return the revocations in this certificate revocation list. 
 
        These revocations will be provided by value, not by reference. 
        That means it's okay to mutate them: it won't affect this CRL. 
 
        :return: The revocations in this CRL. 
        :rtype: :class:`tuple` of :class:`Revocation` 
        &quot;&quot;&quot;</span>
        <span class="s1">results = []</span>
        <span class="s1">revoked_stack = _lib.X509_CRL_get_REVOKED(self._crl)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.sk_X509_REVOKED_num(revoked_stack)):</span>
            <span class="s1">revoked = _lib.sk_X509_REVOKED_value(revoked_stack</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">revoked_copy = _lib.Cryptography_X509_REVOKED_dup(revoked)</span>
            <span class="s1">pyrev = Revoked.__new__(Revoked)</span>
            <span class="s1">pyrev._revoked = _ffi.gc(revoked_copy</span><span class="s0">, </span><span class="s1">_lib.X509_REVOKED_free)</span>
            <span class="s1">results.append(pyrev)</span>
        <span class="s0">if </span><span class="s1">results:</span>
            <span class="s0">return </span><span class="s1">tuple(results)</span>

    <span class="s0">def </span><span class="s1">add_revoked(self</span><span class="s0">, </span><span class="s1">revoked):</span>
        <span class="s5">&quot;&quot;&quot; 
        Add a revoked (by value not reference) to the CRL structure 
 
        This revocation will be added by value, not by reference. That 
        means it's okay to mutate it after adding: it won't affect 
        this CRL. 
 
        :param Revoked revoked: The new revocation. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">copy = _lib.Cryptography_X509_REVOKED_dup(revoked._revoked)</span>
        <span class="s1">_openssl_assert(copy != _ffi.NULL)</span>

        <span class="s1">add_result = _lib.X509_CRL_add0_revoked(self._crl</span><span class="s0">, </span><span class="s1">copy)</span>
        <span class="s1">_openssl_assert(add_result != </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">get_issuer(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the CRL's issuer. 
 
        .. versionadded:: 16.1.0 
 
        :rtype: X509Name 
        &quot;&quot;&quot;</span>
        <span class="s1">_issuer = _lib.X509_NAME_dup(_lib.X509_CRL_get_issuer(self._crl))</span>
        <span class="s1">_openssl_assert(_issuer != _ffi.NULL)</span>
        <span class="s1">_issuer = _ffi.gc(_issuer</span><span class="s0">, </span><span class="s1">_lib.X509_NAME_free)</span>
        <span class="s1">issuer = X509Name.__new__(X509Name)</span>
        <span class="s1">issuer._name = _issuer</span>
        <span class="s0">return </span><span class="s1">issuer</span>

    <span class="s0">def </span><span class="s1">set_version(self</span><span class="s0">, </span><span class="s1">version):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the CRL version. 
 
        .. versionadded:: 16.1.0 
 
        :param int version: The version of the CRL. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">_openssl_assert(_lib.X509_CRL_set_version(self._crl</span><span class="s0">, </span><span class="s1">version) != </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_set_boundary_time(self</span><span class="s0">, </span><span class="s1">which</span><span class="s0">, </span><span class="s1">when):</span>
        <span class="s0">return </span><span class="s1">_set_asn1_time(which(self._crl)</span><span class="s0">, </span><span class="s1">when)</span>

    <span class="s0">def </span><span class="s1">set_lastUpdate(self</span><span class="s0">, </span><span class="s1">when):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set when the CRL was last updated. 
 
        The timestamp is formatted as an ASN.1 TIME:: 
 
            YYYYMMDDhhmmssZ 
 
        .. versionadded:: 16.1.0 
 
        :param bytes when: A timestamp string. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._set_boundary_time(_lib.X509_CRL_get_lastUpdate</span><span class="s0">, </span><span class="s1">when)</span>

    <span class="s0">def </span><span class="s1">set_nextUpdate(self</span><span class="s0">, </span><span class="s1">when):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set when the CRL will next be updated. 
 
        The timestamp is formatted as an ASN.1 TIME:: 
 
            YYYYMMDDhhmmssZ 
 
        .. versionadded:: 16.1.0 
 
        :param bytes when: A timestamp string. 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._set_boundary_time(_lib.X509_CRL_get_nextUpdate</span><span class="s0">, </span><span class="s1">when)</span>

    <span class="s0">def </span><span class="s1">sign(self</span><span class="s0">, </span><span class="s1">issuer_cert</span><span class="s0">, </span><span class="s1">issuer_key</span><span class="s0">, </span><span class="s1">digest):</span>
        <span class="s5">&quot;&quot;&quot; 
        Sign the CRL. 
 
        Signing a CRL enables clients to associate the CRL itself with an 
        issuer. Before a CRL is meaningful to other OpenSSL functions, it must 
        be signed by an issuer. 
 
        This method implicitly sets the issuer's name based on the issuer 
        certificate and private key used to sign the CRL. 
 
        .. versionadded:: 16.1.0 
 
        :param X509 issuer_cert: The issuer's certificate. 
        :param PKey issuer_key: The issuer's private key. 
        :param bytes digest: The digest method to sign the CRL with. 
        &quot;&quot;&quot;</span>
        <span class="s1">digest_obj = _lib.EVP_get_digestbyname(digest)</span>
        <span class="s1">_openssl_assert(digest_obj != _ffi.NULL)</span>
        <span class="s1">_lib.X509_CRL_set_issuer_name(</span>
            <span class="s1">self._crl</span><span class="s0">, </span><span class="s1">_lib.X509_get_subject_name(issuer_cert._x509)</span>
        <span class="s1">)</span>
        <span class="s1">_lib.X509_CRL_sort(self._crl)</span>
        <span class="s1">result = _lib.X509_CRL_sign(self._crl</span><span class="s0">, </span><span class="s1">issuer_key._pkey</span><span class="s0">, </span><span class="s1">digest_obj)</span>
        <span class="s1">_openssl_assert(result != </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">export(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">cert</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">type=FILETYPE_PEM</span><span class="s0">, </span><span class="s1">days=</span><span class="s4">100</span><span class="s0">, </span><span class="s1">digest=_UNSPECIFIED</span>
    <span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Export the CRL as a string. 
 
        :param X509 cert: The certificate used to sign the CRL. 
        :param PKey key: The key used to sign the CRL. 
        :param int type: The export format, either :data:`FILETYPE_PEM`, 
            :data:`FILETYPE_ASN1`, or :data:`FILETYPE_TEXT`. 
        :param int days: The number of days until the next update of this CRL. 
        :param bytes digest: The name of the message digest to use (eg 
            ``b&quot;sha256&quot;``). 
        :rtype: bytes 
        &quot;&quot;&quot;</span>

        <span class="s0">if not </span><span class="s1">isinstance(cert</span><span class="s0">, </span><span class="s1">X509):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;cert must be an X509 instance&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">isinstance(key</span><span class="s0">, </span><span class="s1">PKey):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;key must be a PKey instance&quot;</span><span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">isinstance(type</span><span class="s0">, </span><span class="s1">int):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;type must be an integer&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">digest </span><span class="s0">is </span><span class="s1">_UNSPECIFIED:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;digest must be provided&quot;</span><span class="s1">)</span>

        <span class="s1">digest_obj = _lib.EVP_get_digestbyname(digest)</span>
        <span class="s0">if </span><span class="s1">digest_obj == _ffi.NULL:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No such digest method&quot;</span><span class="s1">)</span>

        <span class="s1">bio = _lib.BIO_new(_lib.BIO_s_mem())</span>
        <span class="s1">_openssl_assert(bio != _ffi.NULL)</span>

        <span class="s3"># A scratch time object to give different values to different CRL</span>
        <span class="s3"># fields</span>
        <span class="s1">sometime = _lib.ASN1_TIME_new()</span>
        <span class="s1">_openssl_assert(sometime != _ffi.NULL)</span>

        <span class="s1">_lib.X509_gmtime_adj(sometime</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">_lib.X509_CRL_set_lastUpdate(self._crl</span><span class="s0">, </span><span class="s1">sometime)</span>

        <span class="s1">_lib.X509_gmtime_adj(sometime</span><span class="s0">, </span><span class="s1">days * </span><span class="s4">24 </span><span class="s1">* </span><span class="s4">60 </span><span class="s1">* </span><span class="s4">60</span><span class="s1">)</span>
        <span class="s1">_lib.X509_CRL_set_nextUpdate(self._crl</span><span class="s0">, </span><span class="s1">sometime)</span>

        <span class="s1">_lib.X509_CRL_set_issuer_name(</span>
            <span class="s1">self._crl</span><span class="s0">, </span><span class="s1">_lib.X509_get_subject_name(cert._x509)</span>
        <span class="s1">)</span>

        <span class="s1">sign_result = _lib.X509_CRL_sign(self._crl</span><span class="s0">, </span><span class="s1">key._pkey</span><span class="s0">, </span><span class="s1">digest_obj)</span>
        <span class="s0">if not </span><span class="s1">sign_result:</span>
            <span class="s1">_raise_current_error()</span>

        <span class="s0">return </span><span class="s1">dump_crl(type</span><span class="s0">, </span><span class="s1">self)</span>


<span class="s0">class </span><span class="s1">PKCS7(object):</span>
    <span class="s0">def </span><span class="s1">type_is_signed(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Check if this NID_pkcs7_signed object 
 
        :return: True if the PKCS7 is of type signed 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">bool(_lib.PKCS7_type_is_signed(self._pkcs7))</span>

    <span class="s0">def </span><span class="s1">type_is_enveloped(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Check if this NID_pkcs7_enveloped object 
 
        :returns: True if the PKCS7 is of type enveloped 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">bool(_lib.PKCS7_type_is_enveloped(self._pkcs7))</span>

    <span class="s0">def </span><span class="s1">type_is_signedAndEnveloped(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Check if this NID_pkcs7_signedAndEnveloped object 
 
        :returns: True if the PKCS7 is of type signedAndEnveloped 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">bool(_lib.PKCS7_type_is_signedAndEnveloped(self._pkcs7))</span>

    <span class="s0">def </span><span class="s1">type_is_data(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Check if this NID_pkcs7_data object 
 
        :return: True if the PKCS7 is of type data 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">bool(_lib.PKCS7_type_is_data(self._pkcs7))</span>

    <span class="s0">def </span><span class="s1">get_type_name(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Returns the type name of the PKCS7 structure 
 
        :return: A string with the typename 
        &quot;&quot;&quot;</span>
        <span class="s1">nid = _lib.OBJ_obj2nid(self._pkcs7.type)</span>
        <span class="s1">string_type = _lib.OBJ_nid2sn(nid)</span>
        <span class="s0">return </span><span class="s1">_ffi.string(string_type)</span>


<span class="s0">class </span><span class="s1">PKCS12(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    A PKCS #12 archive. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._pkey = </span><span class="s0">None</span>
        <span class="s1">self._cert = </span><span class="s0">None</span>
        <span class="s1">self._cacerts = </span><span class="s0">None</span>
        <span class="s1">self._friendlyname = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">get_certificate(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the certificate in the PKCS #12 structure. 
 
        :return: The certificate, or :py:const:`None` if there is none. 
        :rtype: :py:class:`X509` or :py:const:`None` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._cert</span>

    <span class="s0">def </span><span class="s1">set_certificate(self</span><span class="s0">, </span><span class="s1">cert):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the certificate in the PKCS #12 structure. 
 
        :param cert: The new certificate, or :py:const:`None` to unset it. 
        :type cert: :py:class:`X509` or :py:const:`None` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(cert</span><span class="s0">, </span><span class="s1">X509):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;cert must be an X509 instance&quot;</span><span class="s1">)</span>
        <span class="s1">self._cert = cert</span>

    <span class="s0">def </span><span class="s1">get_privatekey(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the private key in the PKCS #12 structure. 
 
        :return: The private key, or :py:const:`None` if there is none. 
        :rtype: :py:class:`PKey` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._pkey</span>

    <span class="s0">def </span><span class="s1">set_privatekey(self</span><span class="s0">, </span><span class="s1">pkey):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the certificate portion of the PKCS #12 structure. 
 
        :param pkey: The new private key, or :py:const:`None` to unset it. 
        :type pkey: :py:class:`PKey` or :py:const:`None` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(pkey</span><span class="s0">, </span><span class="s1">PKey):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">&quot;pkey must be a PKey instance&quot;</span><span class="s1">)</span>
        <span class="s1">self._pkey = pkey</span>

    <span class="s0">def </span><span class="s1">get_ca_certificates(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the CA certificates in the PKCS #12 structure. 
 
        :return: A tuple with the CA certificates in the chain, or 
            :py:const:`None` if there are none. 
        :rtype: :py:class:`tuple` of :py:class:`X509` or :py:const:`None` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self._cacerts </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">tuple(self._cacerts)</span>

    <span class="s0">def </span><span class="s1">set_ca_certificates(self</span><span class="s0">, </span><span class="s1">cacerts):</span>
        <span class="s5">&quot;&quot;&quot; 
        Replace or set the CA certificates within the PKCS12 object. 
 
        :param cacerts: The new CA certificates, or :py:const:`None` to unset 
            them. 
        :type cacerts: An iterable of :py:class:`X509` or :py:const:`None` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">cacerts </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._cacerts = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">cacerts = list(cacerts)</span>
            <span class="s0">for </span><span class="s1">cert </span><span class="s0">in </span><span class="s1">cacerts:</span>
                <span class="s0">if not </span><span class="s1">isinstance(cert</span><span class="s0">, </span><span class="s1">X509):</span>
                    <span class="s0">raise </span><span class="s1">TypeError(</span>
                        <span class="s2">&quot;iterable must only contain X509 instances&quot;</span>
                    <span class="s1">)</span>
            <span class="s1">self._cacerts = cacerts</span>

    <span class="s0">def </span><span class="s1">set_friendlyname(self</span><span class="s0">, </span><span class="s1">name):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the friendly name in the PKCS #12 structure. 
 
        :param name: The new friendly name, or :py:const:`None` to unset. 
        :type name: :py:class:`bytes` or :py:const:`None` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">self._friendlyname = </span><span class="s0">None</span>
        <span class="s0">elif not </span><span class="s1">isinstance(name</span><span class="s0">, </span><span class="s1">bytes):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;name must be a byte string or None (not %r)&quot; </span><span class="s1">% (name</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">self._friendlyname = name</span>

    <span class="s0">def </span><span class="s1">get_friendlyname(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the friendly name in the PKCS# 12 structure. 
 
        :returns: The friendly name,  or :py:const:`None` if there is none. 
        :rtype: :py:class:`bytes` or :py:const:`None` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._friendlyname</span>

    <span class="s0">def </span><span class="s1">export(self</span><span class="s0">, </span><span class="s1">passphrase=</span><span class="s0">None, </span><span class="s1">iter=</span><span class="s4">2048</span><span class="s0">, </span><span class="s1">maciter=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s5">&quot;&quot;&quot; 
        Dump a PKCS12 object as a string. 
 
        For more information, see the :c:func:`PKCS12_create` man page. 
 
        :param passphrase: The passphrase used to encrypt the structure. Unlike 
            some other passphrase arguments, this *must* be a string, not a 
            callback. 
        :type passphrase: :py:data:`bytes` 
 
        :param iter: Number of times to repeat the encryption step. 
        :type iter: :py:data:`int` 
 
        :param maciter: Number of times to repeat the MAC step. 
        :type maciter: :py:data:`int` 
 
        :return: The string representation of the PKCS #12 structure. 
        :rtype: 
        &quot;&quot;&quot;</span>
        <span class="s1">passphrase = _text_to_bytes_and_warn(</span><span class="s2">&quot;passphrase&quot;</span><span class="s0">, </span><span class="s1">passphrase)</span>

        <span class="s0">if </span><span class="s1">self._cacerts </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">cacerts = _ffi.NULL</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">cacerts = _lib.sk_X509_new_null()</span>
            <span class="s1">cacerts = _ffi.gc(cacerts</span><span class="s0">, </span><span class="s1">_lib.sk_X509_free)</span>
            <span class="s0">for </span><span class="s1">cert </span><span class="s0">in </span><span class="s1">self._cacerts:</span>
                <span class="s1">_lib.sk_X509_push(cacerts</span><span class="s0">, </span><span class="s1">cert._x509)</span>

        <span class="s0">if </span><span class="s1">passphrase </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">passphrase = _ffi.NULL</span>

        <span class="s1">friendlyname = self._friendlyname</span>
        <span class="s0">if </span><span class="s1">friendlyname </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">friendlyname = _ffi.NULL</span>

        <span class="s0">if </span><span class="s1">self._pkey </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">pkey = _ffi.NULL</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">pkey = self._pkey._pkey</span>

        <span class="s0">if </span><span class="s1">self._cert </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">cert = _ffi.NULL</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">cert = self._cert._x509</span>

        <span class="s1">pkcs12 = _lib.PKCS12_create(</span>
            <span class="s1">passphrase</span><span class="s0">,</span>
            <span class="s1">friendlyname</span><span class="s0">,</span>
            <span class="s1">pkey</span><span class="s0">,</span>
            <span class="s1">cert</span><span class="s0">,</span>
            <span class="s1">cacerts</span><span class="s0">,</span>
            <span class="s1">_lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC</span><span class="s0">,</span>
            <span class="s1">_lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC</span><span class="s0">,</span>
            <span class="s1">iter</span><span class="s0">,</span>
            <span class="s1">maciter</span><span class="s0">,</span>
            <span class="s4">0</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">pkcs12 == _ffi.NULL:</span>
            <span class="s1">_raise_current_error()</span>
        <span class="s1">pkcs12 = _ffi.gc(pkcs12</span><span class="s0">, </span><span class="s1">_lib.PKCS12_free)</span>

        <span class="s1">bio = _new_mem_buf()</span>
        <span class="s1">_lib.i2d_PKCS12_bio(bio</span><span class="s0">, </span><span class="s1">pkcs12)</span>
        <span class="s0">return </span><span class="s1">_bio_to_string(bio)</span>


<span class="s0">class </span><span class="s1">NetscapeSPKI(object):</span>
    <span class="s5">&quot;&quot;&quot; 
    A Netscape SPKI object. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">spki = _lib.NETSCAPE_SPKI_new()</span>
        <span class="s1">self._spki = _ffi.gc(spki</span><span class="s0">, </span><span class="s1">_lib.NETSCAPE_SPKI_free)</span>

    <span class="s0">def </span><span class="s1">sign(self</span><span class="s0">, </span><span class="s1">pkey</span><span class="s0">, </span><span class="s1">digest):</span>
        <span class="s5">&quot;&quot;&quot; 
        Sign the certificate request with this key and digest type. 
 
        :param pkey: The private key to sign with. 
        :type pkey: :py:class:`PKey` 
 
        :param digest: The message digest to use. 
        :type digest: :py:class:`bytes` 
 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">pkey._only_public:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Key has only public part&quot;</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">pkey._initialized:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Key is uninitialized&quot;</span><span class="s1">)</span>

        <span class="s1">digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))</span>
        <span class="s0">if </span><span class="s1">digest_obj == _ffi.NULL:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No such digest method&quot;</span><span class="s1">)</span>

        <span class="s1">sign_result = _lib.NETSCAPE_SPKI_sign(</span>
            <span class="s1">self._spki</span><span class="s0">, </span><span class="s1">pkey._pkey</span><span class="s0">, </span><span class="s1">digest_obj</span>
        <span class="s1">)</span>
        <span class="s1">_openssl_assert(sign_result &gt; </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">verify(self</span><span class="s0">, </span><span class="s1">key):</span>
        <span class="s5">&quot;&quot;&quot; 
        Verifies a signature on a certificate request. 
 
        :param PKey key: The public key that signature is supposedly from. 
 
        :return: ``True`` if the signature is correct. 
        :rtype: bool 
 
        :raises OpenSSL.crypto.Error: If the signature is invalid, or there was 
            a problem verifying the signature. 
        &quot;&quot;&quot;</span>
        <span class="s1">answer = _lib.NETSCAPE_SPKI_verify(self._spki</span><span class="s0">, </span><span class="s1">key._pkey)</span>
        <span class="s0">if </span><span class="s1">answer &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">_raise_current_error()</span>
        <span class="s0">return True</span>

    <span class="s0">def </span><span class="s1">b64_encode(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Generate a base64 encoded representation of this SPKI object. 
 
        :return: The base64 encoded string. 
        :rtype: :py:class:`bytes` 
        &quot;&quot;&quot;</span>
        <span class="s1">encoded = _lib.NETSCAPE_SPKI_b64_encode(self._spki)</span>
        <span class="s1">result = _ffi.string(encoded)</span>
        <span class="s1">_lib.OPENSSL_free(encoded)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">get_pubkey(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Get the public key of this certificate. 
 
        :return: The public key. 
        :rtype: :py:class:`PKey` 
        &quot;&quot;&quot;</span>
        <span class="s1">pkey = PKey.__new__(PKey)</span>
        <span class="s1">pkey._pkey = _lib.NETSCAPE_SPKI_get_pubkey(self._spki)</span>
        <span class="s1">_openssl_assert(pkey._pkey != _ffi.NULL)</span>
        <span class="s1">pkey._pkey = _ffi.gc(pkey._pkey</span><span class="s0">, </span><span class="s1">_lib.EVP_PKEY_free)</span>
        <span class="s1">pkey._only_public = </span><span class="s0">True</span>
        <span class="s0">return </span><span class="s1">pkey</span>

    <span class="s0">def </span><span class="s1">set_pubkey(self</span><span class="s0">, </span><span class="s1">pkey):</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the public key of the certificate 
 
        :param pkey: The public key 
        :return: ``None`` 
        &quot;&quot;&quot;</span>
        <span class="s1">set_result = _lib.NETSCAPE_SPKI_set_pubkey(self._spki</span><span class="s0">, </span><span class="s1">pkey._pkey)</span>
        <span class="s1">_openssl_assert(set_result == </span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">_PassphraseHelper(object):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">passphrase</span><span class="s0">, </span><span class="s1">more_args=</span><span class="s0">False, </span><span class="s1">truncate=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">type != FILETYPE_PEM </span><span class="s0">and </span><span class="s1">passphrase </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;only FILETYPE_PEM key format supports encryption&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self._passphrase = passphrase</span>
        <span class="s1">self._more_args = more_args</span>
        <span class="s1">self._truncate = truncate</span>
        <span class="s1">self._problems = []</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">callback(self):</span>
        <span class="s0">if </span><span class="s1">self._passphrase </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">_ffi.NULL</span>
        <span class="s0">elif </span><span class="s1">isinstance(self._passphrase</span><span class="s0">, </span><span class="s1">bytes) </span><span class="s0">or </span><span class="s1">callable(self._passphrase):</span>
            <span class="s0">return </span><span class="s1">_ffi.callback(</span><span class="s2">&quot;pem_password_cb&quot;</span><span class="s0">, </span><span class="s1">self._read_passphrase)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;Last argument must be a byte string or a callable.&quot;</span>
            <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">callback_args(self):</span>
        <span class="s0">if </span><span class="s1">self._passphrase </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">_ffi.NULL</span>
        <span class="s0">elif </span><span class="s1">isinstance(self._passphrase</span><span class="s0">, </span><span class="s1">bytes) </span><span class="s0">or </span><span class="s1">callable(self._passphrase):</span>
            <span class="s0">return </span><span class="s1">_ffi.NULL</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s2">&quot;Last argument must be a byte string or a callable.&quot;</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">raise_if_problem(self</span><span class="s0">, </span><span class="s1">exceptionType=Error):</span>
        <span class="s0">if </span><span class="s1">self._problems:</span>

            <span class="s3"># Flush the OpenSSL error queue</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">_exception_from_error_queue(exceptionType)</span>
            <span class="s0">except </span><span class="s1">exceptionType:</span>
                <span class="s0">pass</span>

            <span class="s0">raise </span><span class="s1">self._problems.pop(</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_read_passphrase(self</span><span class="s0">, </span><span class="s1">buf</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">rwflag</span><span class="s0">, </span><span class="s1">userdata):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">callable(self._passphrase):</span>
                <span class="s0">if </span><span class="s1">self._more_args:</span>
                    <span class="s1">result = self._passphrase(size</span><span class="s0">, </span><span class="s1">rwflag</span><span class="s0">, </span><span class="s1">userdata)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">result = self._passphrase(rwflag)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = self._passphrase</span>
            <span class="s0">if not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">bytes):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Bytes expected&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(result) &gt; size:</span>
                <span class="s0">if </span><span class="s1">self._truncate:</span>
                    <span class="s1">result = result[:size]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">&quot;passphrase returned by callback is too long&quot;</span>
                    <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(result)):</span>
                <span class="s1">buf[i] = result[i : i + </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">len(result)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">self._problems.append(e)</span>
            <span class="s0">return </span><span class="s4">0</span>


<span class="s0">def </span><span class="s1">load_publickey(type</span><span class="s0">, </span><span class="s1">buffer):</span>
    <span class="s5">&quot;&quot;&quot; 
    Load a public key from a buffer. 
 
    :param type: The file type (one of :data:`FILETYPE_PEM`, 
        :data:`FILETYPE_ASN1`). 
    :param buffer: The buffer the key is stored in. 
    :type buffer: A Python string object, either unicode or bytestring. 
    :return: The PKey object. 
    :rtype: :class:`PKey` 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">_text_type):</span>
        <span class="s1">buffer = buffer.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s1">bio = _new_mem_buf(buffer)</span>

    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">evp_pkey = _lib.PEM_read_bio_PUBKEY(</span>
            <span class="s1">bio</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">evp_pkey = _lib.d2i_PUBKEY_bio(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">evp_pkey == _ffi.NULL:</span>
        <span class="s1">_raise_current_error()</span>

    <span class="s1">pkey = PKey.__new__(PKey)</span>
    <span class="s1">pkey._pkey = _ffi.gc(evp_pkey</span><span class="s0">, </span><span class="s1">_lib.EVP_PKEY_free)</span>
    <span class="s1">pkey._only_public = </span><span class="s0">True</span>
    <span class="s0">return </span><span class="s1">pkey</span>


<span class="s0">def </span><span class="s1">load_privatekey(type</span><span class="s0">, </span><span class="s1">buffer</span><span class="s0">, </span><span class="s1">passphrase=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Load a private key (PKey) from the string *buffer* encoded with the type 
    *type*. 
 
    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1) 
    :param buffer: The buffer the key is stored in 
    :param passphrase: (optional) if encrypted PEM format, this can be 
                       either the passphrase to use, or a callback for 
                       providing the passphrase. 
 
    :return: The PKey object 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">_text_type):</span>
        <span class="s1">buffer = buffer.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s1">bio = _new_mem_buf(buffer)</span>

    <span class="s1">helper = _PassphraseHelper(type</span><span class="s0">, </span><span class="s1">passphrase)</span>
    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">evp_pkey = _lib.PEM_read_bio_PrivateKey(</span>
            <span class="s1">bio</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">helper.callback</span><span class="s0">, </span><span class="s1">helper.callback_args</span>
        <span class="s1">)</span>
        <span class="s1">helper.raise_if_problem()</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">evp_pkey = _lib.d2i_PrivateKey_bio(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">evp_pkey == _ffi.NULL:</span>
        <span class="s1">_raise_current_error()</span>

    <span class="s1">pkey = PKey.__new__(PKey)</span>
    <span class="s1">pkey._pkey = _ffi.gc(evp_pkey</span><span class="s0">, </span><span class="s1">_lib.EVP_PKEY_free)</span>
    <span class="s0">return </span><span class="s1">pkey</span>


<span class="s0">def </span><span class="s1">dump_certificate_request(type</span><span class="s0">, </span><span class="s1">req):</span>
    <span class="s5">&quot;&quot;&quot; 
    Dump the certificate request *req* into a buffer string encoded with the 
    type *type*. 
 
    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1) 
    :param req: The certificate request to dump 
    :return: The buffer with the dumped certificate request in 
    &quot;&quot;&quot;</span>
    <span class="s1">bio = _new_mem_buf()</span>

    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">result_code = _lib.PEM_write_bio_X509_REQ(bio</span><span class="s0">, </span><span class="s1">req._req)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">result_code = _lib.i2d_X509_REQ_bio(bio</span><span class="s0">, </span><span class="s1">req._req)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_TEXT:</span>
        <span class="s1">result_code = _lib.X509_REQ_print_ex(bio</span><span class="s0">, </span><span class="s1">req._req</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;type argument must be FILETYPE_PEM, FILETYPE_ASN1, or &quot;</span>
            <span class="s2">&quot;FILETYPE_TEXT&quot;</span>
        <span class="s1">)</span>

    <span class="s1">_openssl_assert(result_code != </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">_bio_to_string(bio)</span>


<span class="s0">def </span><span class="s1">load_certificate_request(type</span><span class="s0">, </span><span class="s1">buffer):</span>
    <span class="s5">&quot;&quot;&quot; 
    Load a certificate request (X509Req) from the string *buffer* encoded with 
    the type *type*. 
 
    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1) 
    :param buffer: The buffer the certificate request is stored in 
    :return: The X509Req object 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">_text_type):</span>
        <span class="s1">buffer = buffer.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s1">bio = _new_mem_buf(buffer)</span>

    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">req = _lib.PEM_read_bio_X509_REQ(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">req = _lib.d2i_X509_REQ_bio(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;</span><span class="s1">)</span>

    <span class="s1">_openssl_assert(req != _ffi.NULL)</span>

    <span class="s1">x509req = X509Req.__new__(X509Req)</span>
    <span class="s1">x509req._req = _ffi.gc(req</span><span class="s0">, </span><span class="s1">_lib.X509_REQ_free)</span>
    <span class="s0">return </span><span class="s1">x509req</span>


<span class="s0">def </span><span class="s1">sign(pkey</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">digest):</span>
    <span class="s5">&quot;&quot;&quot; 
    Sign a data string using the given key and message digest. 
 
    :param pkey: PKey to sign with 
    :param data: data to be signed 
    :param digest: message digest to use 
    :return: signature 
 
    .. versionadded:: 0.11 
    &quot;&quot;&quot;</span>
    <span class="s1">data = _text_to_bytes_and_warn(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s1">data)</span>

    <span class="s1">digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))</span>
    <span class="s0">if </span><span class="s1">digest_obj == _ffi.NULL:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No such digest method&quot;</span><span class="s1">)</span>

    <span class="s1">md_ctx = _lib.Cryptography_EVP_MD_CTX_new()</span>
    <span class="s1">md_ctx = _ffi.gc(md_ctx</span><span class="s0">, </span><span class="s1">_lib.Cryptography_EVP_MD_CTX_free)</span>

    <span class="s1">_lib.EVP_SignInit(md_ctx</span><span class="s0">, </span><span class="s1">digest_obj)</span>
    <span class="s1">_lib.EVP_SignUpdate(md_ctx</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">len(data))</span>

    <span class="s1">length = _lib.EVP_PKEY_size(pkey._pkey)</span>
    <span class="s1">_openssl_assert(length &gt; </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">signature_buffer = _ffi.new(</span><span class="s2">&quot;unsigned char[]&quot;</span><span class="s0">, </span><span class="s1">length)</span>
    <span class="s1">signature_length = _ffi.new(</span><span class="s2">&quot;unsigned int *&quot;</span><span class="s1">)</span>
    <span class="s1">final_result = _lib.EVP_SignFinal(</span>
        <span class="s1">md_ctx</span><span class="s0">, </span><span class="s1">signature_buffer</span><span class="s0">, </span><span class="s1">signature_length</span><span class="s0">, </span><span class="s1">pkey._pkey</span>
    <span class="s1">)</span>
    <span class="s1">_openssl_assert(final_result == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">_ffi.buffer(signature_buffer</span><span class="s0">, </span><span class="s1">signature_length[</span><span class="s4">0</span><span class="s1">])[:]</span>


<span class="s0">def </span><span class="s1">verify(cert</span><span class="s0">, </span><span class="s1">signature</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">digest):</span>
    <span class="s5">&quot;&quot;&quot; 
    Verify the signature for a data string. 
 
    :param cert: signing certificate (X509 object) corresponding to the 
        private key which generated the signature. 
    :param signature: signature returned by sign function 
    :param data: data to be verified 
    :param digest: message digest to use 
    :return: ``None`` if the signature is correct, raise exception otherwise. 
 
    .. versionadded:: 0.11 
    &quot;&quot;&quot;</span>
    <span class="s1">data = _text_to_bytes_and_warn(</span><span class="s2">&quot;data&quot;</span><span class="s0">, </span><span class="s1">data)</span>

    <span class="s1">digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))</span>
    <span class="s0">if </span><span class="s1">digest_obj == _ffi.NULL:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;No such digest method&quot;</span><span class="s1">)</span>

    <span class="s1">pkey = _lib.X509_get_pubkey(cert._x509)</span>
    <span class="s1">_openssl_assert(pkey != _ffi.NULL)</span>
    <span class="s1">pkey = _ffi.gc(pkey</span><span class="s0">, </span><span class="s1">_lib.EVP_PKEY_free)</span>

    <span class="s1">md_ctx = _lib.Cryptography_EVP_MD_CTX_new()</span>
    <span class="s1">md_ctx = _ffi.gc(md_ctx</span><span class="s0">, </span><span class="s1">_lib.Cryptography_EVP_MD_CTX_free)</span>

    <span class="s1">_lib.EVP_VerifyInit(md_ctx</span><span class="s0">, </span><span class="s1">digest_obj)</span>
    <span class="s1">_lib.EVP_VerifyUpdate(md_ctx</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">len(data))</span>
    <span class="s1">verify_result = _lib.EVP_VerifyFinal(</span>
        <span class="s1">md_ctx</span><span class="s0">, </span><span class="s1">signature</span><span class="s0">, </span><span class="s1">len(signature)</span><span class="s0">, </span><span class="s1">pkey</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">verify_result != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">_raise_current_error()</span>


<span class="s0">def </span><span class="s1">dump_crl(type</span><span class="s0">, </span><span class="s1">crl):</span>
    <span class="s5">&quot;&quot;&quot; 
    Dump a certificate revocation list to a buffer. 
 
    :param type: The file type (one of ``FILETYPE_PEM``, ``FILETYPE_ASN1``, or 
        ``FILETYPE_TEXT``). 
    :param CRL crl: The CRL to dump. 
 
    :return: The buffer with the CRL. 
    :rtype: bytes 
    &quot;&quot;&quot;</span>
    <span class="s1">bio = _new_mem_buf()</span>

    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">ret = _lib.PEM_write_bio_X509_CRL(bio</span><span class="s0">, </span><span class="s1">crl._crl)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">ret = _lib.i2d_X509_CRL_bio(bio</span><span class="s0">, </span><span class="s1">crl._crl)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_TEXT:</span>
        <span class="s1">ret = _lib.X509_CRL_print(bio</span><span class="s0">, </span><span class="s1">crl._crl)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;type argument must be FILETYPE_PEM, FILETYPE_ASN1, or &quot;</span>
            <span class="s2">&quot;FILETYPE_TEXT&quot;</span>
        <span class="s1">)</span>

    <span class="s1">_openssl_assert(ret == </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">_bio_to_string(bio)</span>


<span class="s0">def </span><span class="s1">load_crl(type</span><span class="s0">, </span><span class="s1">buffer):</span>
    <span class="s5">&quot;&quot;&quot; 
    Load Certificate Revocation List (CRL) data from a string *buffer*. 
    *buffer* encoded with the type *type*. 
 
    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1) 
    :param buffer: The buffer the CRL is stored in 
 
    :return: The PKey object 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">_text_type):</span>
        <span class="s1">buffer = buffer.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s1">bio = _new_mem_buf(buffer)</span>

    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">crl = _lib.PEM_read_bio_X509_CRL(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">crl = _lib.d2i_X509_CRL_bio(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">crl == _ffi.NULL:</span>
        <span class="s1">_raise_current_error()</span>

    <span class="s1">result = CRL.__new__(CRL)</span>
    <span class="s1">result._crl = _ffi.gc(crl</span><span class="s0">, </span><span class="s1">_lib.X509_CRL_free)</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">load_pkcs7_data(type</span><span class="s0">, </span><span class="s1">buffer):</span>
    <span class="s5">&quot;&quot;&quot; 
    Load pkcs7 data from the string *buffer* encoded with the type 
    *type*. 
 
    :param type: The file type (one of FILETYPE_PEM or FILETYPE_ASN1) 
    :param buffer: The buffer with the pkcs7 data. 
    :return: The PKCS7 object 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">_text_type):</span>
        <span class="s1">buffer = buffer.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s1">bio = _new_mem_buf(buffer)</span>

    <span class="s0">if </span><span class="s1">type == FILETYPE_PEM:</span>
        <span class="s1">pkcs7 = _lib.PEM_read_bio_PKCS7(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">elif </span><span class="s1">type == FILETYPE_ASN1:</span>
        <span class="s1">pkcs7 = _lib.d2i_PKCS7_bio(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;type argument must be FILETYPE_PEM or FILETYPE_ASN1&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">pkcs7 == _ffi.NULL:</span>
        <span class="s1">_raise_current_error()</span>

    <span class="s1">pypkcs7 = PKCS7.__new__(PKCS7)</span>
    <span class="s1">pypkcs7._pkcs7 = _ffi.gc(pkcs7</span><span class="s0">, </span><span class="s1">_lib.PKCS7_free)</span>
    <span class="s0">return </span><span class="s1">pypkcs7</span>


<span class="s1">load_pkcs7_data = utils.deprecated(</span>
    <span class="s1">load_pkcs7_data</span><span class="s0">,</span>
    <span class="s1">__name__</span><span class="s0">,</span>
    <span class="s1">(</span>
        <span class="s2">&quot;PKCS#7 support in pyOpenSSL is deprecated. You should use the APIs &quot;</span>
        <span class="s2">&quot;in cryptography.&quot;</span>
    <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">DeprecationWarning</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">load_pkcs12(buffer</span><span class="s0">, </span><span class="s1">passphrase=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Load pkcs12 data from the string *buffer*. If the pkcs12 structure is 
    encrypted, a *passphrase* must be included.  The MAC is always 
    checked and thus required. 
 
    See also the man page for the C function :py:func:`PKCS12_parse`. 
 
    :param buffer: The buffer the certificate is stored in 
    :param passphrase: (Optional) The password to decrypt the PKCS12 lump 
    :returns: The PKCS12 object 
    &quot;&quot;&quot;</span>
    <span class="s1">passphrase = _text_to_bytes_and_warn(</span><span class="s2">&quot;passphrase&quot;</span><span class="s0">, </span><span class="s1">passphrase)</span>

    <span class="s0">if </span><span class="s1">isinstance(buffer</span><span class="s0">, </span><span class="s1">_text_type):</span>
        <span class="s1">buffer = buffer.encode(</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s1">bio = _new_mem_buf(buffer)</span>

    <span class="s3"># Use null passphrase if passphrase is None or empty string. With PKCS#12</span>
    <span class="s3"># password based encryption no password and a zero length password are two</span>
    <span class="s3"># different things, but OpenSSL implementation will try both to figure out</span>
    <span class="s3"># which one works.</span>
    <span class="s0">if not </span><span class="s1">passphrase:</span>
        <span class="s1">passphrase = _ffi.NULL</span>

    <span class="s1">p12 = _lib.d2i_PKCS12_bio(bio</span><span class="s0">, </span><span class="s1">_ffi.NULL)</span>
    <span class="s0">if </span><span class="s1">p12 == _ffi.NULL:</span>
        <span class="s1">_raise_current_error()</span>
    <span class="s1">p12 = _ffi.gc(p12</span><span class="s0">, </span><span class="s1">_lib.PKCS12_free)</span>

    <span class="s1">pkey = _ffi.new(</span><span class="s2">&quot;EVP_PKEY**&quot;</span><span class="s1">)</span>
    <span class="s1">cert = _ffi.new(</span><span class="s2">&quot;X509**&quot;</span><span class="s1">)</span>
    <span class="s1">cacerts = _ffi.new(</span><span class="s2">&quot;Cryptography_STACK_OF_X509**&quot;</span><span class="s1">)</span>

    <span class="s1">parse_result = _lib.PKCS12_parse(p12</span><span class="s0">, </span><span class="s1">passphrase</span><span class="s0">, </span><span class="s1">pkey</span><span class="s0">, </span><span class="s1">cert</span><span class="s0">, </span><span class="s1">cacerts)</span>
    <span class="s0">if not </span><span class="s1">parse_result:</span>
        <span class="s1">_raise_current_error()</span>

    <span class="s1">cacerts = _ffi.gc(cacerts[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">_lib.sk_X509_free)</span>

    <span class="s3"># openssl 1.0.0 sometimes leaves an X509_check_private_key error in the</span>
    <span class="s3"># queue for no particular reason.  This error isn't interesting to anyone</span>
    <span class="s3"># outside this function.  It's not even interesting to us.  Get rid of it.</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">_raise_current_error()</span>
    <span class="s0">except </span><span class="s1">Error:</span>
        <span class="s0">pass</span>

    <span class="s0">if </span><span class="s1">pkey[</span><span class="s4">0</span><span class="s1">] == _ffi.NULL:</span>
        <span class="s1">pykey = </span><span class="s0">None</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">pykey = PKey.__new__(PKey)</span>
        <span class="s1">pykey._pkey = _ffi.gc(pkey[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">_lib.EVP_PKEY_free)</span>

    <span class="s0">if </span><span class="s1">cert[</span><span class="s4">0</span><span class="s1">] == _ffi.NULL:</span>
        <span class="s1">pycert = </span><span class="s0">None</span>
        <span class="s1">friendlyname = </span><span class="s0">None</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">pycert = X509._from_raw_x509_ptr(cert[</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">friendlyname_length = _ffi.new(</span><span class="s2">&quot;int*&quot;</span><span class="s1">)</span>
        <span class="s1">friendlyname_buffer = _lib.X509_alias_get0(</span>
            <span class="s1">cert[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">friendlyname_length</span>
        <span class="s1">)</span>
        <span class="s1">friendlyname = _ffi.buffer(</span>
            <span class="s1">friendlyname_buffer</span><span class="s0">, </span><span class="s1">friendlyname_length[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">)[:]</span>
        <span class="s0">if </span><span class="s1">friendlyname_buffer == _ffi.NULL:</span>
            <span class="s1">friendlyname = </span><span class="s0">None</span>

    <span class="s1">pycacerts = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(_lib.sk_X509_num(cacerts)):</span>
        <span class="s1">x509 = _lib.sk_X509_value(cacerts</span><span class="s0">, </span><span class="s1">i)</span>
        <span class="s1">pycacert = X509._from_raw_x509_ptr(x509)</span>
        <span class="s1">pycacerts.append(pycacert)</span>
    <span class="s0">if not </span><span class="s1">pycacerts:</span>
        <span class="s1">pycacerts = </span><span class="s0">None</span>

    <span class="s1">pkcs12 = PKCS12.__new__(PKCS12)</span>
    <span class="s1">pkcs12._pkey = pykey</span>
    <span class="s1">pkcs12._cert = pycert</span>
    <span class="s1">pkcs12._cacerts = pycacerts</span>
    <span class="s1">pkcs12._friendlyname = friendlyname</span>
    <span class="s0">return </span><span class="s1">pkcs12</span>


<span class="s1">load_pkcs12 = utils.deprecated(</span>
    <span class="s1">load_pkcs12</span><span class="s0">,</span>
    <span class="s1">__name__</span><span class="s0">,</span>
    <span class="s1">(</span>
        <span class="s2">&quot;PKCS#12 support in pyOpenSSL is deprecated. You should use the APIs &quot;</span>
        <span class="s2">&quot;in cryptography.&quot;</span>
    <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">DeprecationWarning</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s3"># There are no direct unit tests for this initialization.  It is tested</span>
<span class="s3"># indirectly since it is necessary for functions like dump_privatekey when</span>
<span class="s3"># using encryption.</span>
<span class="s3">#</span>
<span class="s3"># Thus OpenSSL.test.test_crypto.FunctionTests.test_dump_privatekey_passphrase</span>
<span class="s3"># and some other similar tests may fail without this (though they may not if</span>
<span class="s3"># the Python runtime has already done some initialization of the underlying</span>
<span class="s3"># OpenSSL library (and is linked against the same one that cryptography is</span>
<span class="s3"># using)).</span>
<span class="s1">_lib.OpenSSL_add_all_algorithms()</span>

<span class="s3"># This is similar but exercised mainly by exception_from_error_queue.  It calls</span>
<span class="s3"># both ERR_load_crypto_strings() and ERR_load_SSL_strings().</span>
<span class="s1">_lib.SSL_load_error_strings()</span>


<span class="s3"># Set the default string mask to match OpenSSL upstream (since 2005) and</span>
<span class="s3"># RFC5280 recommendations.</span>
<span class="s1">_lib.ASN1_STRING_set_default_mask_asc(</span><span class="s6">b&quot;utf8only&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>