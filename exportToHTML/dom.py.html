<html>
<head>
<title>dom.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dom.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: DOM</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">page</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">runtime</span>


<span class="s2">class </span><span class="s1">NodeId(int):</span>
    <span class="s3">''' 
    Unique DOM node identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: int) -&gt; NodeId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'NodeId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">BackendNodeId(int):</span>
    <span class="s3">''' 
    Unique DOM node identifier used to reference a node that may not have been pushed to the 
    front-end. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; int:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: int) -&gt; BackendNodeId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'BackendNodeId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">BackendNode:</span>
    <span class="s3">''' 
    Backend node with a friendly name. 
    '''</span>
    <span class="s0">#: ``Node``'s nodeType.</span>
    <span class="s1">node_type: int</span>

    <span class="s0">#: ``Node``'s nodeName.</span>
    <span class="s1">node_name: str</span>

    <span class="s1">backend_node_id: BackendNodeId</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'nodeType'</span><span class="s1">] = self.node_type</span>
        <span class="s1">json[</span><span class="s4">'nodeName'</span><span class="s1">] = self.node_name</span>
        <span class="s1">json[</span><span class="s4">'backendNodeId'</span><span class="s1">] = self.backend_node_id.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">node_type=int(json[</span><span class="s4">'nodeType'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">node_name=str(json[</span><span class="s4">'nodeName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">backend_node_id=BackendNodeId.from_json(json[</span><span class="s4">'backendNodeId'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">PseudoType(enum.Enum):</span>
    <span class="s3">''' 
    Pseudo element type. 
    '''</span>
    <span class="s1">FIRST_LINE = </span><span class="s4">&quot;first-line&quot;</span>
    <span class="s1">FIRST_LETTER = </span><span class="s4">&quot;first-letter&quot;</span>
    <span class="s1">BEFORE = </span><span class="s4">&quot;before&quot;</span>
    <span class="s1">AFTER = </span><span class="s4">&quot;after&quot;</span>
    <span class="s1">MARKER = </span><span class="s4">&quot;marker&quot;</span>
    <span class="s1">BACKDROP = </span><span class="s4">&quot;backdrop&quot;</span>
    <span class="s1">SELECTION = </span><span class="s4">&quot;selection&quot;</span>
    <span class="s1">TARGET_TEXT = </span><span class="s4">&quot;target-text&quot;</span>
    <span class="s1">SPELLING_ERROR = </span><span class="s4">&quot;spelling-error&quot;</span>
    <span class="s1">GRAMMAR_ERROR = </span><span class="s4">&quot;grammar-error&quot;</span>
    <span class="s1">FIRST_LINE_INHERITED = </span><span class="s4">&quot;first-line-inherited&quot;</span>
    <span class="s1">SCROLLBAR = </span><span class="s4">&quot;scrollbar&quot;</span>
    <span class="s1">SCROLLBAR_THUMB = </span><span class="s4">&quot;scrollbar-thumb&quot;</span>
    <span class="s1">SCROLLBAR_BUTTON = </span><span class="s4">&quot;scrollbar-button&quot;</span>
    <span class="s1">SCROLLBAR_TRACK = </span><span class="s4">&quot;scrollbar-track&quot;</span>
    <span class="s1">SCROLLBAR_TRACK_PIECE = </span><span class="s4">&quot;scrollbar-track-piece&quot;</span>
    <span class="s1">SCROLLBAR_CORNER = </span><span class="s4">&quot;scrollbar-corner&quot;</span>
    <span class="s1">RESIZER = </span><span class="s4">&quot;resizer&quot;</span>
    <span class="s1">INPUT_LIST_BUTTON = </span><span class="s4">&quot;input-list-button&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">ShadowRootType(enum.Enum):</span>
    <span class="s3">''' 
    Shadow root type. 
    '''</span>
    <span class="s1">USER_AGENT = </span><span class="s4">&quot;user-agent&quot;</span>
    <span class="s1">OPEN_ = </span><span class="s4">&quot;open&quot;</span>
    <span class="s1">CLOSED = </span><span class="s4">&quot;closed&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Node:</span>
    <span class="s3">''' 
    DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. 
    DOMNode is a base node mirror type. 
    '''</span>
    <span class="s0">#: Node identifier that is passed into the rest of the DOM messages as the ``nodeId``. Backend</span>
    <span class="s0">#: will only push node with given ``id`` once. It is aware of all requested nodes and will only</span>
    <span class="s0">#: fire DOM events for nodes known to the client.</span>
    <span class="s1">node_id: NodeId</span>

    <span class="s0">#: The BackendNodeId for this node.</span>
    <span class="s1">backend_node_id: BackendNodeId</span>

    <span class="s0">#: ``Node``'s nodeType.</span>
    <span class="s1">node_type: int</span>

    <span class="s0">#: ``Node``'s nodeName.</span>
    <span class="s1">node_name: str</span>

    <span class="s0">#: ``Node``'s localName.</span>
    <span class="s1">local_name: str</span>

    <span class="s0">#: ``Node``'s nodeValue.</span>
    <span class="s1">node_value: str</span>

    <span class="s0">#: The id of the parent node if any.</span>
    <span class="s1">parent_id: typing.Optional[NodeId] = </span><span class="s2">None</span>

    <span class="s0">#: Child count for ``Container`` nodes.</span>
    <span class="s1">child_node_count: typing.Optional[int] = </span><span class="s2">None</span>

    <span class="s0">#: Child nodes of this node when requested with children.</span>
    <span class="s1">children: typing.Optional[typing.List[Node]] = </span><span class="s2">None</span>

    <span class="s0">#: Attributes of the ``Element`` node in the form of flat array ``[name1, value1, name2, value2]``.</span>
    <span class="s1">attributes: typing.Optional[typing.List[str]] = </span><span class="s2">None</span>

    <span class="s0">#: Document URL that ``Document`` or ``FrameOwner`` node points to.</span>
    <span class="s1">document_url: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Base URL that ``Document`` or ``FrameOwner`` node uses for URL completion.</span>
    <span class="s1">base_url: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: ``DocumentType``'s publicId.</span>
    <span class="s1">public_id: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: ``DocumentType``'s systemId.</span>
    <span class="s1">system_id: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: ``DocumentType``'s internalSubset.</span>
    <span class="s1">internal_subset: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: ``Document``'s XML version in case of XML documents.</span>
    <span class="s1">xml_version: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: ``Attr``'s name.</span>
    <span class="s1">name: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: ``Attr``'s value.</span>
    <span class="s1">value: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Pseudo element type for this node.</span>
    <span class="s1">pseudo_type: typing.Optional[PseudoType] = </span><span class="s2">None</span>

    <span class="s0">#: Shadow root type.</span>
    <span class="s1">shadow_root_type: typing.Optional[ShadowRootType] = </span><span class="s2">None</span>

    <span class="s0">#: Frame ID for frame owner elements.</span>
    <span class="s1">frame_id: typing.Optional[page.FrameId] = </span><span class="s2">None</span>

    <span class="s0">#: Content document for frame owner elements.</span>
    <span class="s1">content_document: typing.Optional[Node] = </span><span class="s2">None</span>

    <span class="s0">#: Shadow root list for given element host.</span>
    <span class="s1">shadow_roots: typing.Optional[typing.List[Node]] = </span><span class="s2">None</span>

    <span class="s0">#: Content document fragment for template elements.</span>
    <span class="s1">template_content: typing.Optional[Node] = </span><span class="s2">None</span>

    <span class="s0">#: Pseudo elements associated with this node.</span>
    <span class="s1">pseudo_elements: typing.Optional[typing.List[Node]] = </span><span class="s2">None</span>

    <span class="s0">#: Import document for the HTMLImport links.</span>
    <span class="s1">imported_document: typing.Optional[Node] = </span><span class="s2">None</span>

    <span class="s0">#: Distributed nodes for given insertion point.</span>
    <span class="s1">distributed_nodes: typing.Optional[typing.List[BackendNode]] = </span><span class="s2">None</span>

    <span class="s0">#: Whether the node is SVG.</span>
    <span class="s1">is_svg: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'nodeId'</span><span class="s1">] = self.node_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'backendNodeId'</span><span class="s1">] = self.backend_node_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'nodeType'</span><span class="s1">] = self.node_type</span>
        <span class="s1">json[</span><span class="s4">'nodeName'</span><span class="s1">] = self.node_name</span>
        <span class="s1">json[</span><span class="s4">'localName'</span><span class="s1">] = self.local_name</span>
        <span class="s1">json[</span><span class="s4">'nodeValue'</span><span class="s1">] = self.node_value</span>
        <span class="s2">if </span><span class="s1">self.parent_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'parentId'</span><span class="s1">] = self.parent_id.to_json()</span>
        <span class="s2">if </span><span class="s1">self.child_node_count </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'childNodeCount'</span><span class="s1">] = self.child_node_count</span>
        <span class="s2">if </span><span class="s1">self.children </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'children'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.children]</span>
        <span class="s2">if </span><span class="s1">self.attributes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'attributes'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.attributes]</span>
        <span class="s2">if </span><span class="s1">self.document_url </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'documentURL'</span><span class="s1">] = self.document_url</span>
        <span class="s2">if </span><span class="s1">self.base_url </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'baseURL'</span><span class="s1">] = self.base_url</span>
        <span class="s2">if </span><span class="s1">self.public_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'publicId'</span><span class="s1">] = self.public_id</span>
        <span class="s2">if </span><span class="s1">self.system_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'systemId'</span><span class="s1">] = self.system_id</span>
        <span class="s2">if </span><span class="s1">self.internal_subset </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'internalSubset'</span><span class="s1">] = self.internal_subset</span>
        <span class="s2">if </span><span class="s1">self.xml_version </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'xmlVersion'</span><span class="s1">] = self.xml_version</span>
        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s2">if </span><span class="s1">self.value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s2">if </span><span class="s1">self.pseudo_type </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'pseudoType'</span><span class="s1">] = self.pseudo_type.to_json()</span>
        <span class="s2">if </span><span class="s1">self.shadow_root_type </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'shadowRootType'</span><span class="s1">] = self.shadow_root_type.to_json()</span>
        <span class="s2">if </span><span class="s1">self.frame_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'frameId'</span><span class="s1">] = self.frame_id.to_json()</span>
        <span class="s2">if </span><span class="s1">self.content_document </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'contentDocument'</span><span class="s1">] = self.content_document.to_json()</span>
        <span class="s2">if </span><span class="s1">self.shadow_roots </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'shadowRoots'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.shadow_roots]</span>
        <span class="s2">if </span><span class="s1">self.template_content </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'templateContent'</span><span class="s1">] = self.template_content.to_json()</span>
        <span class="s2">if </span><span class="s1">self.pseudo_elements </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'pseudoElements'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.pseudo_elements]</span>
        <span class="s2">if </span><span class="s1">self.imported_document </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'importedDocument'</span><span class="s1">] = self.imported_document.to_json()</span>
        <span class="s2">if </span><span class="s1">self.distributed_nodes </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'distributedNodes'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.distributed_nodes]</span>
        <span class="s2">if </span><span class="s1">self.is_svg </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'isSVG'</span><span class="s1">] = self.is_svg</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">node_id=NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">backend_node_id=BackendNodeId.from_json(json[</span><span class="s4">'backendNodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">node_type=int(json[</span><span class="s4">'nodeType'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">node_name=str(json[</span><span class="s4">'nodeName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">local_name=str(json[</span><span class="s4">'localName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">node_value=str(json[</span><span class="s4">'nodeValue'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">parent_id=NodeId.from_json(json[</span><span class="s4">'parentId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'parentId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">child_node_count=int(json[</span><span class="s4">'childNodeCount'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'childNodeCount' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">children=[Node.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'children'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'children' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">attributes=[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'attributes'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'attributes' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">document_url=str(json[</span><span class="s4">'documentURL'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'documentURL' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">base_url=str(json[</span><span class="s4">'baseURL'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'baseURL' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">public_id=str(json[</span><span class="s4">'publicId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'publicId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">system_id=str(json[</span><span class="s4">'systemId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'systemId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">internal_subset=str(json[</span><span class="s4">'internalSubset'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'internalSubset' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">xml_version=str(json[</span><span class="s4">'xmlVersion'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'xmlVersion' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'name' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">value=str(json[</span><span class="s4">'value'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'value' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">pseudo_type=PseudoType.from_json(json[</span><span class="s4">'pseudoType'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'pseudoType' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">shadow_root_type=ShadowRootType.from_json(json[</span><span class="s4">'shadowRootType'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'shadowRootType' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">frame_id=page.FrameId.from_json(json[</span><span class="s4">'frameId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'frameId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">content_document=Node.from_json(json[</span><span class="s4">'contentDocument'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'contentDocument' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">shadow_roots=[Node.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'shadowRoots'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'shadowRoots' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">template_content=Node.from_json(json[</span><span class="s4">'templateContent'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'templateContent' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">pseudo_elements=[Node.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'pseudoElements'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'pseudoElements' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">imported_document=Node.from_json(json[</span><span class="s4">'importedDocument'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'importedDocument' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">distributed_nodes=[BackendNode.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'distributedNodes'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'distributedNodes' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">is_svg=bool(json[</span><span class="s4">'isSVG'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'isSVG' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RGBA:</span>
    <span class="s3">''' 
    A structure holding an RGBA color. 
    '''</span>
    <span class="s0">#: The red component, in the [0-255] range.</span>
    <span class="s1">r: int</span>

    <span class="s0">#: The green component, in the [0-255] range.</span>
    <span class="s1">g: int</span>

    <span class="s0">#: The blue component, in the [0-255] range.</span>
    <span class="s1">b: int</span>

    <span class="s0">#: The alpha component, in the [0-1] range (default: 1).</span>
    <span class="s1">a: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'r'</span><span class="s1">] = self.r</span>
        <span class="s1">json[</span><span class="s4">'g'</span><span class="s1">] = self.g</span>
        <span class="s1">json[</span><span class="s4">'b'</span><span class="s1">] = self.b</span>
        <span class="s2">if </span><span class="s1">self.a </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'a'</span><span class="s1">] = self.a</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">r=int(json[</span><span class="s4">'r'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">g=int(json[</span><span class="s4">'g'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">b=int(json[</span><span class="s4">'b'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">a=float(json[</span><span class="s4">'a'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'a' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Quad(list):</span>
    <span class="s3">''' 
    An array of quad vertices, x immediately followed by y for each point, points clock-wise. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; typing.List[float]:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: typing.List[float]) -&gt; Quad:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'Quad({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">BoxModel:</span>
    <span class="s3">''' 
    Box model. 
    '''</span>
    <span class="s0">#: Content box</span>
    <span class="s1">content: Quad</span>

    <span class="s0">#: Padding box</span>
    <span class="s1">padding: Quad</span>

    <span class="s0">#: Border box</span>
    <span class="s1">border: Quad</span>

    <span class="s0">#: Margin box</span>
    <span class="s1">margin: Quad</span>

    <span class="s0">#: Node width</span>
    <span class="s1">width: int</span>

    <span class="s0">#: Node height</span>
    <span class="s1">height: int</span>

    <span class="s0">#: Shape outside coordinates</span>
    <span class="s1">shape_outside: typing.Optional[ShapeOutsideInfo] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'content'</span><span class="s1">] = self.content.to_json()</span>
        <span class="s1">json[</span><span class="s4">'padding'</span><span class="s1">] = self.padding.to_json()</span>
        <span class="s1">json[</span><span class="s4">'border'</span><span class="s1">] = self.border.to_json()</span>
        <span class="s1">json[</span><span class="s4">'margin'</span><span class="s1">] = self.margin.to_json()</span>
        <span class="s1">json[</span><span class="s4">'width'</span><span class="s1">] = self.width</span>
        <span class="s1">json[</span><span class="s4">'height'</span><span class="s1">] = self.height</span>
        <span class="s2">if </span><span class="s1">self.shape_outside </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'shapeOutside'</span><span class="s1">] = self.shape_outside.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">content=Quad.from_json(json[</span><span class="s4">'content'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">padding=Quad.from_json(json[</span><span class="s4">'padding'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">border=Quad.from_json(json[</span><span class="s4">'border'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">margin=Quad.from_json(json[</span><span class="s4">'margin'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">width=int(json[</span><span class="s4">'width'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">height=int(json[</span><span class="s4">'height'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">shape_outside=ShapeOutsideInfo.from_json(json[</span><span class="s4">'shapeOutside'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'shapeOutside' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ShapeOutsideInfo:</span>
    <span class="s3">''' 
    CSS Shape Outside details. 
    '''</span>
    <span class="s0">#: Shape bounds</span>
    <span class="s1">bounds: Quad</span>

    <span class="s0">#: Shape coordinate details</span>
    <span class="s1">shape: typing.List[typing.Any]</span>

    <span class="s0">#: Margin shape bounds</span>
    <span class="s1">margin_shape: typing.List[typing.Any]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'bounds'</span><span class="s1">] = self.bounds.to_json()</span>
        <span class="s1">json[</span><span class="s4">'shape'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.shape]</span>
        <span class="s1">json[</span><span class="s4">'marginShape'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.margin_shape]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">bounds=Quad.from_json(json[</span><span class="s4">'bounds'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">shape=[i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'shape'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">margin_shape=[i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'marginShape'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Rect:</span>
    <span class="s3">''' 
    Rectangle. 
    '''</span>
    <span class="s0">#: X coordinate</span>
    <span class="s1">x: float</span>

    <span class="s0">#: Y coordinate</span>
    <span class="s1">y: float</span>

    <span class="s0">#: Rectangle width</span>
    <span class="s1">width: float</span>

    <span class="s0">#: Rectangle height</span>
    <span class="s1">height: float</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'x'</span><span class="s1">] = self.x</span>
        <span class="s1">json[</span><span class="s4">'y'</span><span class="s1">] = self.y</span>
        <span class="s1">json[</span><span class="s4">'width'</span><span class="s1">] = self.width</span>
        <span class="s1">json[</span><span class="s4">'height'</span><span class="s1">] = self.height</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">x=float(json[</span><span class="s4">'x'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">y=float(json[</span><span class="s4">'y'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">width=float(json[</span><span class="s4">'width'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">height=float(json[</span><span class="s4">'height'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CSSComputedStyleProperty:</span>
    <span class="s0">#: Computed style property name.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: Computed style property value.</span>
    <span class="s1">value: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=str(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">collect_class_names_from_subtree(</span>
        <span class="s1">node_id: NodeId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[str]]:</span>
    <span class="s3">''' 
    Collects class names for the node with given id and all of it's child nodes. 
 
    **EXPERIMENTAL** 
 
    :param node_id: Id of the node to collect class names. 
    :returns: Class name list. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.collectClassNamesFromSubtree'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'classNames'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">copy_to(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">target_node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">insert_before_node_id: typing.Optional[NodeId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">NodeId]:</span>
    <span class="s3">''' 
    Creates a deep copy of the specified node and places it into the target container before the 
    given anchor. 
 
    **EXPERIMENTAL** 
 
    :param node_id: Id of the node to copy. 
    :param target_node_id: Id of the element to drop the copy into. 
    :param insert_before_node_id: *(Optional)* Drop the copy before this node (if absent, the copy becomes the last child of ```targetNodeId```). 
    :returns: Id of the node clone. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'targetNodeId'</span><span class="s1">] = target_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">insert_before_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'insertBeforeNodeId'</span><span class="s1">] = insert_before_node_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.copyTo'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">describe_node(</span>
        <span class="s1">node_id: typing.Optional[NodeId] = </span><span class="s2">None,</span>
        <span class="s1">backend_node_id: typing.Optional[BackendNodeId] = </span><span class="s2">None,</span>
        <span class="s1">object_id: typing.Optional[runtime.RemoteObjectId] = </span><span class="s2">None,</span>
        <span class="s1">depth: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">pierce: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">Node]:</span>
    <span class="s3">''' 
    Describes node given its id, does not require domain to be enabled. Does not start tracking any 
    objects, can be used for automation. 
 
    :param node_id: *(Optional)* Identifier of the node. 
    :param backend_node_id: *(Optional)* Identifier of the backend node. 
    :param object_id: *(Optional)* JavaScript object id of the node wrapper. 
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0. 
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false). 
    :returns: Node description. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'backendNodeId'</span><span class="s1">] = backend_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s2">if </span><span class="s1">depth </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'depth'</span><span class="s1">] = depth</span>
    <span class="s2">if </span><span class="s1">pierce </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'pierce'</span><span class="s1">] = pierce</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.describeNode'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">Node.from_json(json[</span><span class="s4">'node'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">scroll_into_view_if_needed(</span>
        <span class="s1">node_id: typing.Optional[NodeId] = </span><span class="s2">None,</span>
        <span class="s1">backend_node_id: typing.Optional[BackendNodeId] = </span><span class="s2">None,</span>
        <span class="s1">object_id: typing.Optional[runtime.RemoteObjectId] = </span><span class="s2">None,</span>
        <span class="s1">rect: typing.Optional[Rect] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Scrolls the specified rect of the given node into view if not already visible. 
    Note: exactly one between nodeId, backendNodeId and objectId should be passed 
    to identify the node. 
 
    **EXPERIMENTAL** 
 
    :param node_id: *(Optional)* Identifier of the node. 
    :param backend_node_id: *(Optional)* Identifier of the backend node. 
    :param object_id: *(Optional)* JavaScript object id of the node wrapper. 
    :param rect: *(Optional)* The rect to be scrolled into view, relative to the node's border box, in CSS pixels. When omitted, center of the node will be used, similar to Element.scrollIntoView. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'backendNodeId'</span><span class="s1">] = backend_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s2">if </span><span class="s1">rect </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'rect'</span><span class="s1">] = rect.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.scrollIntoViewIfNeeded'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">disable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disables DOM agent for the given page. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.disable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">discard_search_results(</span>
        <span class="s1">search_id: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Discards search results from the session with the given id. ``getSearchResults`` should no longer 
    be called for that search. 
 
    **EXPERIMENTAL** 
 
    :param search_id: Unique search session identifier. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'searchId'</span><span class="s1">] = search_id</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.discardSearchResults'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">enable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables DOM agent for the given page. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.enable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">focus(</span>
        <span class="s1">node_id: typing.Optional[NodeId] = </span><span class="s2">None,</span>
        <span class="s1">backend_node_id: typing.Optional[BackendNodeId] = </span><span class="s2">None,</span>
        <span class="s1">object_id: typing.Optional[runtime.RemoteObjectId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Focuses the given element. 
 
    :param node_id: *(Optional)* Identifier of the node. 
    :param backend_node_id: *(Optional)* Identifier of the backend node. 
    :param object_id: *(Optional)* JavaScript object id of the node wrapper. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'backendNodeId'</span><span class="s1">] = backend_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.focus'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_attributes(</span>
        <span class="s1">node_id: NodeId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[str]]:</span>
    <span class="s3">''' 
    Returns attributes for the specified node. 
 
    :param node_id: Id of the node to retrieve attibutes for. 
    :returns: An interleaved array of node attribute names and values. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getAttributes'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'attributes'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">get_box_model(</span>
        <span class="s1">node_id: typing.Optional[NodeId] = </span><span class="s2">None,</span>
        <span class="s1">backend_node_id: typing.Optional[BackendNodeId] = </span><span class="s2">None,</span>
        <span class="s1">object_id: typing.Optional[runtime.RemoteObjectId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">BoxModel]:</span>
    <span class="s3">''' 
    Returns boxes for the given node. 
 
    :param node_id: *(Optional)* Identifier of the node. 
    :param backend_node_id: *(Optional)* Identifier of the backend node. 
    :param object_id: *(Optional)* JavaScript object id of the node wrapper. 
    :returns: Box model for the node. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'backendNodeId'</span><span class="s1">] = backend_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getBoxModel'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">BoxModel.from_json(json[</span><span class="s4">'model'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_content_quads(</span>
        <span class="s1">node_id: typing.Optional[NodeId] = </span><span class="s2">None,</span>
        <span class="s1">backend_node_id: typing.Optional[BackendNodeId] = </span><span class="s2">None,</span>
        <span class="s1">object_id: typing.Optional[runtime.RemoteObjectId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[Quad]]:</span>
    <span class="s3">''' 
    Returns quads that describe node position on the page. This method 
    might return multiple quads for inline nodes. 
 
    **EXPERIMENTAL** 
 
    :param node_id: *(Optional)* Identifier of the node. 
    :param backend_node_id: *(Optional)* Identifier of the backend node. 
    :param object_id: *(Optional)* JavaScript object id of the node wrapper. 
    :returns: Quads that describe node layout relative to viewport. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'backendNodeId'</span><span class="s1">] = backend_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getContentQuads'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[Quad.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'quads'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">get_document(</span>
        <span class="s1">depth: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">pierce: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">Node]:</span>
    <span class="s3">''' 
    Returns the root DOM node (and optionally the subtree) to the caller. 
 
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0. 
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false). 
    :returns: Resulting node. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">depth </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'depth'</span><span class="s1">] = depth</span>
    <span class="s2">if </span><span class="s1">pierce </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'pierce'</span><span class="s1">] = pierce</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getDocument'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">Node.from_json(json[</span><span class="s4">'root'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_flattened_document(</span>
        <span class="s1">depth: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">pierce: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[Node]]:</span>
    <span class="s3">''' 
    Returns the root DOM node (and optionally the subtree) to the caller. 
    Deprecated, as it is not designed to work well with the rest of the DOM agent. 
    Use DOMSnapshot.captureSnapshot instead. 
 
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0. 
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the subtree (default is false). 
    :returns: Resulting node. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">depth </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'depth'</span><span class="s1">] = depth</span>
    <span class="s2">if </span><span class="s1">pierce </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'pierce'</span><span class="s1">] = pierce</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getFlattenedDocument'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[Node.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'nodes'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">get_nodes_for_subtree_by_style(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">computed_styles: typing.List[CSSComputedStyleProperty]</span><span class="s2">,</span>
        <span class="s1">pierce: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[NodeId]]:</span>
    <span class="s3">''' 
    Finds nodes with a given computed style in a subtree. 
 
    **EXPERIMENTAL** 
 
    :param node_id: Node ID pointing to the root of a subtree. 
    :param computed_styles: The style to filter nodes by (includes nodes if any of properties matches). 
    :param pierce: *(Optional)* Whether or not iframes and shadow roots in the same target should be traversed when returning the results (default is false). 
    :returns: Resulting nodes. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'computedStyles'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">computed_styles]</span>
    <span class="s2">if </span><span class="s1">pierce </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'pierce'</span><span class="s1">] = pierce</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getNodesForSubtreeByStyle'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[NodeId.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'nodeIds'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">get_node_for_location(</span>
        <span class="s1">x: int</span><span class="s2">,</span>
        <span class="s1">y: int</span><span class="s2">,</span>
        <span class="s1">include_user_agent_shadow_dom: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">ignore_pointer_events_none: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[BackendNodeId</span><span class="s2">, </span><span class="s1">page.FrameId</span><span class="s2">, </span><span class="s1">typing.Optional[NodeId]]]:</span>
    <span class="s3">''' 
    Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is 
    either returned or not. 
 
    :param x: X coordinate. 
    :param y: Y coordinate. 
    :param include_user_agent_shadow_dom: *(Optional)* False to skip to the nearest non-UA shadow root ancestor (default: false). 
    :param ignore_pointer_events_none: *(Optional)* Whether to ignore pointer-events: none on elements and hit test them. 
    :returns: A tuple with the following items: 
 
        0. **backendNodeId** - Resulting node. 
        1. **frameId** - Frame this node belongs to. 
        2. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'x'</span><span class="s1">] = x</span>
    <span class="s1">params[</span><span class="s4">'y'</span><span class="s1">] = y</span>
    <span class="s2">if </span><span class="s1">include_user_agent_shadow_dom </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'includeUserAgentShadowDOM'</span><span class="s1">] = include_user_agent_shadow_dom</span>
    <span class="s2">if </span><span class="s1">ignore_pointer_events_none </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'ignorePointerEventsNone'</span><span class="s1">] = ignore_pointer_events_none</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getNodeForLocation'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">BackendNodeId.from_json(json[</span><span class="s4">'backendNodeId'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">page.FrameId.from_json(json[</span><span class="s4">'frameId'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'nodeId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_outer_html(</span>
        <span class="s1">node_id: typing.Optional[NodeId] = </span><span class="s2">None,</span>
        <span class="s1">backend_node_id: typing.Optional[BackendNodeId] = </span><span class="s2">None,</span>
        <span class="s1">object_id: typing.Optional[runtime.RemoteObjectId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">str]:</span>
    <span class="s3">''' 
    Returns node's HTML markup. 
 
    :param node_id: *(Optional)* Identifier of the node. 
    :param backend_node_id: *(Optional)* Identifier of the backend node. 
    :param object_id: *(Optional)* JavaScript object id of the node wrapper. 
    :returns: Outer HTML markup. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'backendNodeId'</span><span class="s1">] = backend_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getOuterHTML'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">str(json[</span><span class="s4">'outerHTML'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_relayout_boundary(</span>
        <span class="s1">node_id: NodeId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">NodeId]:</span>
    <span class="s3">''' 
    Returns the id of the nearest ancestor that is a relayout boundary. 
 
    **EXPERIMENTAL** 
 
    :param node_id: Id of the node. 
    :returns: Relayout boundary node id for the given node. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getRelayoutBoundary'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_search_results(</span>
        <span class="s1">search_id: str</span><span class="s2">,</span>
        <span class="s1">from_index: int</span><span class="s2">,</span>
        <span class="s1">to_index: int</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[NodeId]]:</span>
    <span class="s3">''' 
    Returns search results from given ``fromIndex`` to given ``toIndex`` from the search with the given 
    identifier. 
 
    **EXPERIMENTAL** 
 
    :param search_id: Unique search session identifier. 
    :param from_index: Start index of the search result to be returned. 
    :param to_index: End index of the search result to be returned. 
    :returns: Ids of the search result nodes. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'searchId'</span><span class="s1">] = search_id</span>
    <span class="s1">params[</span><span class="s4">'fromIndex'</span><span class="s1">] = from_index</span>
    <span class="s1">params[</span><span class="s4">'toIndex'</span><span class="s1">] = to_index</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getSearchResults'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[NodeId.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'nodeIds'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">hide_highlight() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Hides any highlight. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.hideHighlight'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">highlight_node() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Highlights DOM node. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.highlightNode'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">highlight_rect() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Highlights given rectangle. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.highlightRect'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">mark_undoable_state() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Marks last undoable state. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.markUndoableState'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">move_to(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">target_node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">insert_before_node_id: typing.Optional[NodeId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">NodeId]:</span>
    <span class="s3">''' 
    Moves node into the new container, places it before the given anchor. 
 
    :param node_id: Id of the node to move. 
    :param target_node_id: Id of the element to drop the moved node into. 
    :param insert_before_node_id: *(Optional)* Drop node before this one (if absent, the moved node becomes the last child of ```targetNodeId```). 
    :returns: New id of the moved node. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'targetNodeId'</span><span class="s1">] = target_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">insert_before_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'insertBeforeNodeId'</span><span class="s1">] = insert_before_node_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.moveTo'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">perform_search(</span>
        <span class="s1">query: str</span><span class="s2">,</span>
        <span class="s1">include_user_agent_shadow_dom: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[str</span><span class="s2">, </span><span class="s1">int]]:</span>
    <span class="s3">''' 
    Searches for a given string in the DOM tree. Use ``getSearchResults`` to access search results or 
    ``cancelSearch`` to end this search session. 
 
    **EXPERIMENTAL** 
 
    :param query: Plain text or query selector or XPath search query. 
    :param include_user_agent_shadow_dom: *(Optional)* True to search in user agent shadow DOM. 
    :returns: A tuple with the following items: 
 
        0. **searchId** - Unique search session identifier. 
        1. **resultCount** - Number of search results. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'query'</span><span class="s1">] = query</span>
    <span class="s2">if </span><span class="s1">include_user_agent_shadow_dom </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'includeUserAgentShadowDOM'</span><span class="s1">] = include_user_agent_shadow_dom</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.performSearch'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">str(json[</span><span class="s4">'searchId'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">int(json[</span><span class="s4">'resultCount'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">push_node_by_path_to_frontend(</span>
        <span class="s1">path: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">NodeId]:</span>
    <span class="s3">''' 
    Requests that the node is sent to the caller given its path. // FIXME, use XPath 
 
    **EXPERIMENTAL** 
 
    :param path: Path to node in the proprietary format. 
    :returns: Id of the node for given path. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'path'</span><span class="s1">] = path</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.pushNodeByPathToFrontend'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">push_nodes_by_backend_ids_to_frontend(</span>
        <span class="s1">backend_node_ids: typing.List[BackendNodeId]</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[NodeId]]:</span>
    <span class="s3">''' 
    Requests that a batch of nodes is sent to the caller given their backend node ids. 
 
    **EXPERIMENTAL** 
 
    :param backend_node_ids: The array of backend node ids. 
    :returns: The array of ids of pushed nodes that correspond to the backend ids specified in backendNodeIds. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'backendNodeIds'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">backend_node_ids]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.pushNodesByBackendIdsToFrontend'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[NodeId.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'nodeIds'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">query_selector(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">selector: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">NodeId]:</span>
    <span class="s3">''' 
    Executes ``querySelector`` on a given node. 
 
    :param node_id: Id of the node to query upon. 
    :param selector: Selector string. 
    :returns: Query selector result. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'selector'</span><span class="s1">] = selector</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.querySelector'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">query_selector_all(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">selector: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[NodeId]]:</span>
    <span class="s3">''' 
    Executes ``querySelectorAll`` on a given node. 
 
    :param node_id: Id of the node to query upon. 
    :param selector: Selector string. 
    :returns: Query selector result. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'selector'</span><span class="s1">] = selector</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.querySelectorAll'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[NodeId.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'nodeIds'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">redo() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Re-does the last undone action. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.redo'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">remove_attribute(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">name: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Removes attribute with given name from an element with given id. 
 
    :param node_id: Id of the element to remove attribute from. 
    :param name: Name of the attribute to remove. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'name'</span><span class="s1">] = name</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.removeAttribute'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">remove_node(</span>
        <span class="s1">node_id: NodeId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Removes node with given id. 
 
    :param node_id: Id of the node to remove. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.removeNode'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">request_child_nodes(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">depth: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">pierce: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Requests that children of the node with given id are returned to the caller in form of 
    ``setChildNodes`` events where not only immediate children are retrieved, but all children down to 
    the specified depth. 
 
    :param node_id: Id of the node to get children for. 
    :param depth: *(Optional)* The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0. 
    :param pierce: *(Optional)* Whether or not iframes and shadow roots should be traversed when returning the sub-tree (default is false). 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">depth </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'depth'</span><span class="s1">] = depth</span>
    <span class="s2">if </span><span class="s1">pierce </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'pierce'</span><span class="s1">] = pierce</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.requestChildNodes'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">request_node(</span>
        <span class="s1">object_id: runtime.RemoteObjectId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">NodeId]:</span>
    <span class="s3">''' 
    Requests that the node is sent to the caller given the JavaScript node object reference. All 
    nodes that form the path from the node to the root are also sent to the client as a series of 
    ``setChildNodes`` notifications. 
 
    :param object_id: JavaScript object id to convert into node. 
    :returns: Node id for given object. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.requestNode'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">resolve_node(</span>
        <span class="s1">node_id: typing.Optional[NodeId] = </span><span class="s2">None,</span>
        <span class="s1">backend_node_id: typing.Optional[BackendNodeId] = </span><span class="s2">None,</span>
        <span class="s1">object_group: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">execution_context_id: typing.Optional[runtime.ExecutionContextId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">runtime.RemoteObject]:</span>
    <span class="s3">''' 
    Resolves the JavaScript node object for a given NodeId or BackendNodeId. 
 
    :param node_id: *(Optional)* Id of the node to resolve. 
    :param backend_node_id: *(Optional)* Backend identifier of the node to resolve. 
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. 
    :param execution_context_id: *(Optional)* Execution context in which to resolve the node. 
    :returns: JavaScript object wrapper for given node. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'backendNodeId'</span><span class="s1">] = backend_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_group </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectGroup'</span><span class="s1">] = object_group</span>
    <span class="s2">if </span><span class="s1">execution_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'executionContextId'</span><span class="s1">] = execution_context_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.resolveNode'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">runtime.RemoteObject.from_json(json[</span><span class="s4">'object'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">set_attribute_value(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">value: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets attribute for an element with given id. 
 
    :param node_id: Id of the element to set attribute for. 
    :param name: Attribute name. 
    :param value: Attribute value. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'name'</span><span class="s1">] = name</span>
    <span class="s1">params[</span><span class="s4">'value'</span><span class="s1">] = value</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.setAttributeValue'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_attributes_as_text(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">text: str</span><span class="s2">,</span>
        <span class="s1">name: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets attributes on element with given id. This method is useful when user edits some existing 
    attribute value and types in several attribute name/value pairs. 
 
    :param node_id: Id of the element to set attributes for. 
    :param text: Text with a number of attributes. Will parse this text using HTML parser. 
    :param name: *(Optional)* Attribute name to replace with new attributes derived from text in case text parsed successfully. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'text'</span><span class="s1">] = text</span>
    <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'name'</span><span class="s1">] = name</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.setAttributesAsText'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_file_input_files(</span>
        <span class="s1">files: typing.List[str]</span><span class="s2">,</span>
        <span class="s1">node_id: typing.Optional[NodeId] = </span><span class="s2">None,</span>
        <span class="s1">backend_node_id: typing.Optional[BackendNodeId] = </span><span class="s2">None,</span>
        <span class="s1">object_id: typing.Optional[runtime.RemoteObjectId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets files for the given file input element. 
 
    :param files: Array of file paths to set. 
    :param node_id: *(Optional)* Identifier of the node. 
    :param backend_node_id: *(Optional)* Identifier of the backend node. 
    :param object_id: *(Optional)* JavaScript object id of the node wrapper. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'files'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">files]</span>
    <span class="s2">if </span><span class="s1">node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'backendNodeId'</span><span class="s1">] = backend_node_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.setFileInputFiles'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_node_stack_traces_enabled(</span>
        <span class="s1">enable: bool</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets if stack traces should be captured for Nodes. See ``Node.getNodeStackTraces``. Default is disabled. 
 
    **EXPERIMENTAL** 
 
    :param enable: Enable or disable. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'enable'</span><span class="s1">] = enable</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.setNodeStackTracesEnabled'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_node_stack_traces(</span>
        <span class="s1">node_id: NodeId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Optional[runtime.StackTrace]]:</span>
    <span class="s3">''' 
    Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation. 
 
    **EXPERIMENTAL** 
 
    :param node_id: Id of the node to get stack traces for. 
    :returns: *(Optional)* Creation stack trace, if available. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getNodeStackTraces'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">runtime.StackTrace.from_json(json[</span><span class="s4">'creation'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'creation' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>


<span class="s2">def </span><span class="s1">get_file_info(</span>
        <span class="s1">object_id: runtime.RemoteObjectId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">str]:</span>
    <span class="s3">''' 
    Returns file information for the given 
    File wrapper. 
 
    **EXPERIMENTAL** 
 
    :param object_id: JavaScript object id of the node wrapper. 
    :returns:  
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getFileInfo'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">str(json[</span><span class="s4">'path'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">set_inspected_node(</span>
        <span class="s1">node_id: NodeId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables console to refer to the node with given id via $x (see Command Line API for more details 
    $x functions). 
 
    **EXPERIMENTAL** 
 
    :param node_id: DOM node id to be accessible by means of $x command line API. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.setInspectedNode'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_node_name(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">name: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">NodeId]:</span>
    <span class="s3">''' 
    Sets node name for a node with given id. 
 
    :param node_id: Id of the node to set name for. 
    :param name: New node's name. 
    :returns: New node's id. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'name'</span><span class="s1">] = name</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.setNodeName'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">set_node_value(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">value: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets node value for a node with given id. 
 
    :param node_id: Id of the node to set value for. 
    :param value: New node's value. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'value'</span><span class="s1">] = value</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.setNodeValue'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_outer_html(</span>
        <span class="s1">node_id: NodeId</span><span class="s2">,</span>
        <span class="s1">outer_html: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets node HTML markup, returns new node id. 
 
    :param node_id: Id of the node to set markup for. 
    :param outer_html: Outer HTML markup to set. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'nodeId'</span><span class="s1">] = node_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'outerHTML'</span><span class="s1">] = outer_html</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.setOuterHTML'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">undo() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Undoes the last performed action. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.undo'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_frame_owner(</span>
        <span class="s1">frame_id: page.FrameId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[BackendNodeId</span><span class="s2">, </span><span class="s1">typing.Optional[NodeId]]]:</span>
    <span class="s3">''' 
    Returns iframe node that owns iframe with the given domain. 
 
    **EXPERIMENTAL** 
 
    :param frame_id: 
    :returns: A tuple with the following items: 
 
        0. **backendNodeId** - Resulting node. 
        1. **nodeId** - *(Optional)* Id of the node at given coordinates, only when enabled and requested document. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'frameId'</span><span class="s1">] = frame_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'DOM.getFrameOwner'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">BackendNodeId.from_json(json[</span><span class="s4">'backendNodeId'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'nodeId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.attributeModified'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">AttributeModified:</span>
    <span class="s3">''' 
    Fired when ``Element``'s attribute is modified. 
    '''</span>
    <span class="s0">#: Id of the node that has changed.</span>
    <span class="s1">node_id: NodeId</span>
    <span class="s0">#: Attribute name.</span>
    <span class="s1">name: str</span>
    <span class="s0">#: Attribute value.</span>
    <span class="s1">value: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; AttributeModified:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">node_id=NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=str(json[</span><span class="s4">'value'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.attributeRemoved'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">AttributeRemoved:</span>
    <span class="s3">''' 
    Fired when ``Element``'s attribute is removed. 
    '''</span>
    <span class="s0">#: Id of the node that has changed.</span>
    <span class="s1">node_id: NodeId</span>
    <span class="s0">#: A ttribute name.</span>
    <span class="s1">name: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; AttributeRemoved:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">node_id=NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.characterDataModified'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CharacterDataModified:</span>
    <span class="s3">''' 
    Mirrors ``DOMCharacterDataModified`` event. 
    '''</span>
    <span class="s0">#: Id of the node that has changed.</span>
    <span class="s1">node_id: NodeId</span>
    <span class="s0">#: New text value.</span>
    <span class="s1">character_data: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; CharacterDataModified:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">node_id=NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">character_data=str(json[</span><span class="s4">'characterData'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.childNodeCountUpdated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ChildNodeCountUpdated:</span>
    <span class="s3">''' 
    Fired when ``Container``'s child node count has changed. 
    '''</span>
    <span class="s0">#: Id of the node that has changed.</span>
    <span class="s1">node_id: NodeId</span>
    <span class="s0">#: New node count.</span>
    <span class="s1">child_node_count: int</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ChildNodeCountUpdated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">node_id=NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">child_node_count=int(json[</span><span class="s4">'childNodeCount'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.childNodeInserted'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ChildNodeInserted:</span>
    <span class="s3">''' 
    Mirrors ``DOMNodeInserted`` event. 
    '''</span>
    <span class="s0">#: Id of the node that has changed.</span>
    <span class="s1">parent_node_id: NodeId</span>
    <span class="s0">#: If of the previous siblint.</span>
    <span class="s1">previous_node_id: NodeId</span>
    <span class="s0">#: Inserted node data.</span>
    <span class="s1">node: Node</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ChildNodeInserted:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">parent_node_id=NodeId.from_json(json[</span><span class="s4">'parentNodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">previous_node_id=NodeId.from_json(json[</span><span class="s4">'previousNodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">node=Node.from_json(json[</span><span class="s4">'node'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.childNodeRemoved'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ChildNodeRemoved:</span>
    <span class="s3">''' 
    Mirrors ``DOMNodeRemoved`` event. 
    '''</span>
    <span class="s0">#: Parent id.</span>
    <span class="s1">parent_node_id: NodeId</span>
    <span class="s0">#: Id of the node that has been removed.</span>
    <span class="s1">node_id: NodeId</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ChildNodeRemoved:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">parent_node_id=NodeId.from_json(json[</span><span class="s4">'parentNodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">node_id=NodeId.from_json(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.distributedNodesUpdated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">DistributedNodesUpdated:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Called when distrubution is changed. 
    '''</span>
    <span class="s0">#: Insertion point where distrubuted nodes were updated.</span>
    <span class="s1">insertion_point_id: NodeId</span>
    <span class="s0">#: Distributed nodes for given insertion point.</span>
    <span class="s1">distributed_nodes: typing.List[BackendNode]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; DistributedNodesUpdated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">insertion_point_id=NodeId.from_json(json[</span><span class="s4">'insertionPointId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">distributed_nodes=[BackendNode.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'distributedNodes'</span><span class="s1">]]</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.documentUpdated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">DocumentUpdated:</span>
    <span class="s3">''' 
    Fired when ``Document`` has been totally updated. Node ids are no longer valid. 
    '''</span>


    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; DocumentUpdated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>

        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.inlineStyleInvalidated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">InlineStyleInvalidated:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Fired when ``Element``'s inline style is modified via a CSS property modification. 
    '''</span>
    <span class="s0">#: Ids of the nodes for which the inline styles have been invalidated.</span>
    <span class="s1">node_ids: typing.List[NodeId]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; InlineStyleInvalidated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">node_ids=[NodeId.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'nodeIds'</span><span class="s1">]]</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.pseudoElementAdded'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PseudoElementAdded:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Called when a pseudo element is added to an element. 
    '''</span>
    <span class="s0">#: Pseudo element's parent element id.</span>
    <span class="s1">parent_id: NodeId</span>
    <span class="s0">#: The added pseudo element.</span>
    <span class="s1">pseudo_element: Node</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; PseudoElementAdded:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">parent_id=NodeId.from_json(json[</span><span class="s4">'parentId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">pseudo_element=Node.from_json(json[</span><span class="s4">'pseudoElement'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.pseudoElementRemoved'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PseudoElementRemoved:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Called when a pseudo element is removed from an element. 
    '''</span>
    <span class="s0">#: Pseudo element's parent element id.</span>
    <span class="s1">parent_id: NodeId</span>
    <span class="s0">#: The removed pseudo element id.</span>
    <span class="s1">pseudo_element_id: NodeId</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; PseudoElementRemoved:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">parent_id=NodeId.from_json(json[</span><span class="s4">'parentId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">pseudo_element_id=NodeId.from_json(json[</span><span class="s4">'pseudoElementId'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.setChildNodes'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SetChildNodes:</span>
    <span class="s3">''' 
    Fired when backend wants to provide client with the missing DOM structure. This happens upon 
    most of the calls requesting node ids. 
    '''</span>
    <span class="s0">#: Parent node id to populate with children.</span>
    <span class="s1">parent_id: NodeId</span>
    <span class="s0">#: Child nodes array.</span>
    <span class="s1">nodes: typing.List[Node]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; SetChildNodes:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">parent_id=NodeId.from_json(json[</span><span class="s4">'parentId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">nodes=[Node.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'nodes'</span><span class="s1">]]</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.shadowRootPopped'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ShadowRootPopped:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Called when shadow root is popped from the element. 
    '''</span>
    <span class="s0">#: Host element id.</span>
    <span class="s1">host_id: NodeId</span>
    <span class="s0">#: Shadow root id.</span>
    <span class="s1">root_id: NodeId</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ShadowRootPopped:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">host_id=NodeId.from_json(json[</span><span class="s4">'hostId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">root_id=NodeId.from_json(json[</span><span class="s4">'rootId'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'DOM.shadowRootPushed'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ShadowRootPushed:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Called when shadow root is pushed into the element. 
    '''</span>
    <span class="s0">#: Host element id.</span>
    <span class="s1">host_id: NodeId</span>
    <span class="s0">#: Shadow root.</span>
    <span class="s1">root: Node</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ShadowRootPushed:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">host_id=NodeId.from_json(json[</span><span class="s4">'hostId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">root=Node.from_json(json[</span><span class="s4">'root'</span><span class="s1">])</span>
        <span class="s1">)</span>
</pre>
</body>
</html>