<html>
<head>
<title>backend.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #a5c261;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
backend.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is dual licensed under the terms of the Apache License, Version</span>
<span class="s0"># 2.0, and the BSD License. See the LICENSE file in the root of this repository</span>
<span class="s0"># for complete details.</span>


<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">contextlib </span><span class="s2">import </span><span class="s1">contextmanager</span>

<span class="s2">from </span><span class="s1">cryptography </span><span class="s2">import </span><span class="s1">utils</span><span class="s2">, </span><span class="s1">x509</span>
<span class="s2">from </span><span class="s1">cryptography.exceptions </span><span class="s2">import </span><span class="s1">UnsupportedAlgorithm</span><span class="s2">, </span><span class="s1">_Reasons</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat._der </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">INTEGER</span><span class="s2">,</span>
    <span class="s1">NULL</span><span class="s2">,</span>
    <span class="s1">SEQUENCE</span><span class="s2">,</span>
    <span class="s1">encode_der</span><span class="s2">,</span>
    <span class="s1">encode_der_integer</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.interfaces </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CMACBackend</span><span class="s2">,</span>
    <span class="s1">CipherBackend</span><span class="s2">,</span>
    <span class="s1">DERSerializationBackend</span><span class="s2">,</span>
    <span class="s1">DHBackend</span><span class="s2">,</span>
    <span class="s1">DSABackend</span><span class="s2">,</span>
    <span class="s1">EllipticCurveBackend</span><span class="s2">,</span>
    <span class="s1">HMACBackend</span><span class="s2">,</span>
    <span class="s1">HashBackend</span><span class="s2">,</span>
    <span class="s1">PBKDF2HMACBackend</span><span class="s2">,</span>
    <span class="s1">PEMSerializationBackend</span><span class="s2">,</span>
    <span class="s1">RSABackend</span><span class="s2">,</span>
    <span class="s1">ScryptBackend</span><span class="s2">,</span>
    <span class="s1">X509Backend</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl </span><span class="s2">import </span><span class="s1">aead</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.ciphers </span><span class="s2">import </span><span class="s1">_CipherContext</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.cmac </span><span class="s2">import </span><span class="s1">_CMACContext</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.decode_asn1 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_CRL_ENTRY_REASON_ENUM_TO_CODE</span><span class="s2">,</span>
    <span class="s1">_CRL_EXTENSION_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_EXTENSION_HANDLERS_BASE</span><span class="s2">,</span>
    <span class="s1">_EXTENSION_HANDLERS_SCT</span><span class="s2">,</span>
    <span class="s1">_OCSP_BASICRESP_EXTENSION_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_OCSP_REQ_EXTENSION_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_OCSP_SINGLERESP_EXTENSION_HANDLERS_SCT</span><span class="s2">,</span>
    <span class="s1">_REVOKED_EXTENSION_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_X509ExtensionParser</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.dh </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_DHParameters</span><span class="s2">,</span>
    <span class="s1">_DHPrivateKey</span><span class="s2">,</span>
    <span class="s1">_DHPublicKey</span><span class="s2">,</span>
    <span class="s1">_dh_params_dup</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.dsa </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_DSAParameters</span><span class="s2">,</span>
    <span class="s1">_DSAPrivateKey</span><span class="s2">,</span>
    <span class="s1">_DSAPublicKey</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.ec </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_EllipticCurvePrivateKey</span><span class="s2">,</span>
    <span class="s1">_EllipticCurvePublicKey</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.ed25519 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_Ed25519PrivateKey</span><span class="s2">,</span>
    <span class="s1">_Ed25519PublicKey</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.ed448 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_ED448_KEY_SIZE</span><span class="s2">,</span>
    <span class="s1">_Ed448PrivateKey</span><span class="s2">,</span>
    <span class="s1">_Ed448PublicKey</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.encode_asn1 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_CRL_ENTRY_EXTENSION_ENCODE_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_CRL_EXTENSION_ENCODE_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_EXTENSION_ENCODE_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_OCSP_BASICRESP_EXTENSION_ENCODE_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_OCSP_REQUEST_EXTENSION_ENCODE_HANDLERS</span><span class="s2">,</span>
    <span class="s1">_encode_asn1_int_gc</span><span class="s2">,</span>
    <span class="s1">_encode_asn1_str_gc</span><span class="s2">,</span>
    <span class="s1">_encode_name_gc</span><span class="s2">,</span>
    <span class="s1">_txt2obj_gc</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.hashes </span><span class="s2">import </span><span class="s1">_HashContext</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.hmac </span><span class="s2">import </span><span class="s1">_HMACContext</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.ocsp </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_OCSPRequest</span><span class="s2">,</span>
    <span class="s1">_OCSPResponse</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.poly1305 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_POLY1305_KEY_SIZE</span><span class="s2">,</span>
    <span class="s1">_Poly1305Context</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.rsa </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_RSAPrivateKey</span><span class="s2">,</span>
    <span class="s1">_RSAPublicKey</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.x25519 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_X25519PrivateKey</span><span class="s2">,</span>
    <span class="s1">_X25519PublicKey</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.x448 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_X448PrivateKey</span><span class="s2">,</span>
    <span class="s1">_X448PublicKey</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.backends.openssl.x509 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_Certificate</span><span class="s2">,</span>
    <span class="s1">_CertificateRevocationList</span><span class="s2">,</span>
    <span class="s1">_CertificateSigningRequest</span><span class="s2">,</span>
    <span class="s1">_RevokedCertificate</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.bindings.openssl </span><span class="s2">import </span><span class="s1">binding</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives </span><span class="s2">import </span><span class="s1">hashes</span><span class="s2">, </span><span class="s1">serialization</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.asymmetric </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">dh</span><span class="s2">,</span>
    <span class="s1">dsa</span><span class="s2">,</span>
    <span class="s1">ec</span><span class="s2">,</span>
    <span class="s1">ed25519</span><span class="s2">,</span>
    <span class="s1">ed448</span><span class="s2">,</span>
    <span class="s1">rsa</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.asymmetric.padding </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">MGF1</span><span class="s2">,</span>
    <span class="s1">OAEP</span><span class="s2">,</span>
    <span class="s1">PKCS1v15</span><span class="s2">,</span>
    <span class="s1">PSS</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.ciphers.algorithms </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">AES</span><span class="s2">,</span>
    <span class="s1">ARC4</span><span class="s2">,</span>
    <span class="s1">Blowfish</span><span class="s2">,</span>
    <span class="s1">CAST5</span><span class="s2">,</span>
    <span class="s1">Camellia</span><span class="s2">,</span>
    <span class="s1">ChaCha20</span><span class="s2">,</span>
    <span class="s1">IDEA</span><span class="s2">,</span>
    <span class="s1">SEED</span><span class="s2">,</span>
    <span class="s1">TripleDES</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.ciphers.modes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">CBC</span><span class="s2">,</span>
    <span class="s1">CFB</span><span class="s2">,</span>
    <span class="s1">CFB8</span><span class="s2">,</span>
    <span class="s1">CTR</span><span class="s2">,</span>
    <span class="s1">ECB</span><span class="s2">,</span>
    <span class="s1">GCM</span><span class="s2">,</span>
    <span class="s1">OFB</span><span class="s2">,</span>
    <span class="s1">XTS</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.kdf </span><span class="s2">import </span><span class="s1">scrypt</span>
<span class="s2">from </span><span class="s1">cryptography.hazmat.primitives.serialization </span><span class="s2">import </span><span class="s1">pkcs7</span><span class="s2">, </span><span class="s1">ssh</span>
<span class="s2">from </span><span class="s1">cryptography.x509 </span><span class="s2">import </span><span class="s1">ocsp</span>


<span class="s1">_MemoryBIO = collections.namedtuple(</span><span class="s3">&quot;_MemoryBIO&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;bio&quot;</span><span class="s2">, </span><span class="s3">&quot;char_ptr&quot;</span><span class="s1">])</span>


<span class="s0"># Not actually supported, just used as a marker for some serialization tests.</span>
<span class="s2">class </span><span class="s1">_RC2(object):</span>
    <span class="s2">pass</span>


<span class="s1">@utils.register_interface(CipherBackend)</span>
<span class="s1">@utils.register_interface(CMACBackend)</span>
<span class="s1">@utils.register_interface(DERSerializationBackend)</span>
<span class="s1">@utils.register_interface(DHBackend)</span>
<span class="s1">@utils.register_interface(DSABackend)</span>
<span class="s1">@utils.register_interface(EllipticCurveBackend)</span>
<span class="s1">@utils.register_interface(HashBackend)</span>
<span class="s1">@utils.register_interface(HMACBackend)</span>
<span class="s1">@utils.register_interface(PBKDF2HMACBackend)</span>
<span class="s1">@utils.register_interface(RSABackend)</span>
<span class="s1">@utils.register_interface(PEMSerializationBackend)</span>
<span class="s1">@utils.register_interface(X509Backend)</span>
<span class="s1">@utils.register_interface_if(</span>
    <span class="s1">binding.Binding().lib.Cryptography_HAS_SCRYPT</span><span class="s2">, </span><span class="s1">ScryptBackend</span>
<span class="s1">)</span>
<span class="s2">class </span><span class="s1">Backend(object):</span>
    <span class="s4">&quot;&quot;&quot; 
    OpenSSL API binding interfaces. 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s3">&quot;openssl&quot;</span>

    <span class="s0"># FIPS has opinions about acceptable algorithms and key sizes, but the</span>
    <span class="s0"># disallowed algorithms are still present in OpenSSL. They just error if</span>
    <span class="s0"># you try to use them. To avoid that we allowlist the algorithms in</span>
    <span class="s0"># FIPS 140-3. This isn't ideal, but FIPS 140-3 is trash so here we are.</span>
    <span class="s1">_fips_aead = {</span>
        <span class="s5">b&quot;aes-128-ccm&quot;</span><span class="s2">,</span>
        <span class="s5">b&quot;aes-192-ccm&quot;</span><span class="s2">,</span>
        <span class="s5">b&quot;aes-256-ccm&quot;</span><span class="s2">,</span>
        <span class="s5">b&quot;aes-128-gcm&quot;</span><span class="s2">,</span>
        <span class="s5">b&quot;aes-192-gcm&quot;</span><span class="s2">,</span>
        <span class="s5">b&quot;aes-256-gcm&quot;</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">_fips_ciphers = (AES</span><span class="s2">, </span><span class="s1">TripleDES)</span>
    <span class="s1">_fips_hashes = (</span>
        <span class="s1">hashes.SHA1</span><span class="s2">,</span>
        <span class="s1">hashes.SHA224</span><span class="s2">,</span>
        <span class="s1">hashes.SHA256</span><span class="s2">,</span>
        <span class="s1">hashes.SHA384</span><span class="s2">,</span>
        <span class="s1">hashes.SHA512</span><span class="s2">,</span>
        <span class="s1">hashes.SHA512_224</span><span class="s2">,</span>
        <span class="s1">hashes.SHA512_256</span><span class="s2">,</span>
        <span class="s1">hashes.SHA3_224</span><span class="s2">,</span>
        <span class="s1">hashes.SHA3_256</span><span class="s2">,</span>
        <span class="s1">hashes.SHA3_384</span><span class="s2">,</span>
        <span class="s1">hashes.SHA3_512</span><span class="s2">,</span>
        <span class="s1">hashes.SHAKE128</span><span class="s2">,</span>
        <span class="s1">hashes.SHAKE256</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">_fips_rsa_min_key_size = </span><span class="s6">2048</span>
    <span class="s1">_fips_rsa_min_public_exponent = </span><span class="s6">65537</span>
    <span class="s1">_fips_dsa_min_modulus = </span><span class="s6">1 </span><span class="s1">&lt;&lt; </span><span class="s6">2048</span>
    <span class="s1">_fips_dh_min_key_size = </span><span class="s6">2048</span>
    <span class="s1">_fips_dh_min_modulus = </span><span class="s6">1 </span><span class="s1">&lt;&lt; _fips_dh_min_key_size</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._binding = binding.Binding()</span>
        <span class="s1">self._ffi = self._binding.ffi</span>
        <span class="s1">self._lib = self._binding.lib</span>
        <span class="s1">self._fips_enabled = self._is_fips_enabled()</span>

        <span class="s1">self._cipher_registry = {}</span>
        <span class="s1">self._register_default_ciphers()</span>
        <span class="s1">self._register_x509_ext_parsers()</span>
        <span class="s1">self._register_x509_encoders()</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled </span><span class="s2">and </span><span class="s1">self._lib.CRYPTOGRAPHY_NEEDS_OSRANDOM_ENGINE:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;OpenSSL FIPS mode is enabled. Can't enable DRBG fork safety.&quot;</span><span class="s2">,</span>
                <span class="s1">UserWarning</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.activate_osrandom_engine()</span>
        <span class="s1">self._dh_types = [self._lib.EVP_PKEY_DH]</span>
        <span class="s2">if </span><span class="s1">self._lib.Cryptography_HAS_EVP_PKEY_DHX:</span>
            <span class="s1">self._dh_types.append(self._lib.EVP_PKEY_DHX)</span>

    <span class="s2">def </span><span class="s1">openssl_assert(self</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">, </span><span class="s1">errors=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">binding._openssl_assert(self._lib</span><span class="s2">, </span><span class="s1">ok</span><span class="s2">, </span><span class="s1">errors=errors)</span>

    <span class="s2">def </span><span class="s1">_is_fips_enabled(self):</span>
        <span class="s1">fips_mode = getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;FIPS_mode&quot;</span><span class="s2">, lambda</span><span class="s1">: </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s1">mode = fips_mode()</span>
        <span class="s2">if </span><span class="s1">mode == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s0"># OpenSSL without FIPS pushes an error on the error stack</span>
            <span class="s1">self._lib.ERR_clear_error()</span>
        <span class="s2">return </span><span class="s1">bool(mode)</span>

    <span class="s2">def </span><span class="s1">activate_builtin_random(self):</span>
        <span class="s2">if </span><span class="s1">self._lib.CRYPTOGRAPHY_NEEDS_OSRANDOM_ENGINE:</span>
            <span class="s0"># Obtain a new structural reference.</span>
            <span class="s1">e = self._lib.ENGINE_get_default_RAND()</span>
            <span class="s2">if </span><span class="s1">e != self._ffi.NULL:</span>
                <span class="s1">self._lib.ENGINE_unregister_RAND(e)</span>
                <span class="s0"># Reset the RNG to use the built-in.</span>
                <span class="s1">res = self._lib.RAND_set_rand_method(self._ffi.NULL)</span>
                <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
                <span class="s0"># decrement the structural reference from get_default_RAND</span>
                <span class="s1">res = self._lib.ENGINE_finish(e)</span>
                <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">_get_osurandom_engine(self):</span>
        <span class="s0"># Fetches an engine by id and returns it. This creates a structural</span>
        <span class="s0"># reference.</span>
        <span class="s1">e = self._lib.ENGINE_by_id(self._lib.Cryptography_osrandom_engine_id)</span>
        <span class="s1">self.openssl_assert(e != self._ffi.NULL)</span>
        <span class="s0"># Initialize the engine for use. This adds a functional reference.</span>
        <span class="s1">res = self._lib.ENGINE_init(e)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">e</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s0"># Decrement the structural ref incremented by ENGINE_by_id.</span>
            <span class="s1">res = self._lib.ENGINE_free(e)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s0"># Decrement the functional ref incremented by ENGINE_init.</span>
            <span class="s1">res = self._lib.ENGINE_finish(e)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">activate_osrandom_engine(self):</span>
        <span class="s2">if </span><span class="s1">self._lib.CRYPTOGRAPHY_NEEDS_OSRANDOM_ENGINE:</span>
            <span class="s0"># Unregister and free the current engine.</span>
            <span class="s1">self.activate_builtin_random()</span>
            <span class="s2">with </span><span class="s1">self._get_osurandom_engine() </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s0"># Set the engine as the default RAND provider.</span>
                <span class="s1">res = self._lib.ENGINE_set_default_RAND(e)</span>
                <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s0"># Reset the RNG to use the engine</span>
            <span class="s1">res = self._lib.RAND_set_rand_method(self._ffi.NULL)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">osrandom_engine_implementation(self):</span>
        <span class="s1">buf = self._ffi.new(</span><span class="s3">&quot;char[]&quot;</span><span class="s2">, </span><span class="s6">64</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self._get_osurandom_engine() </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">res = self._lib.ENGINE_ctrl_cmd(</span>
                <span class="s1">e</span><span class="s2">, </span><span class="s5">b&quot;get_implementation&quot;</span><span class="s2">, </span><span class="s1">len(buf)</span><span class="s2">, </span><span class="s1">buf</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s6">0</span>
            <span class="s1">)</span>
            <span class="s1">self.openssl_assert(res &gt; </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._ffi.string(buf).decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">openssl_version_text(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Friendly string name of the loaded OpenSSL library. This is not 
        necessarily the same version as it was compiled against. 
 
        Example: OpenSSL 1.1.1d  10 Sep 2019 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._ffi.string(</span>
            <span class="s1">self._lib.OpenSSL_version(self._lib.OPENSSL_VERSION)</span>
        <span class="s1">).decode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">openssl_version_number(self):</span>
        <span class="s2">return </span><span class="s1">self._lib.OpenSSL_version_num()</span>

    <span class="s2">def </span><span class="s1">create_hmac_ctx(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">return </span><span class="s1">_HMACContext(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">algorithm)</span>

    <span class="s2">def </span><span class="s1">_evp_md_from_algorithm(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">if </span><span class="s1">algorithm.name == </span><span class="s3">&quot;blake2b&quot; </span><span class="s2">or </span><span class="s1">algorithm.name == </span><span class="s3">&quot;blake2s&quot;</span><span class="s1">:</span>
            <span class="s1">alg = </span><span class="s3">&quot;{}{}&quot;</span><span class="s1">.format(</span>
                <span class="s1">algorithm.name</span><span class="s2">, </span><span class="s1">algorithm.digest_size * </span><span class="s6">8</span>
            <span class="s1">).encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">alg = algorithm.name.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>

        <span class="s1">evp_md = self._lib.EVP_get_digestbyname(alg)</span>
        <span class="s2">return </span><span class="s1">evp_md</span>

    <span class="s2">def </span><span class="s1">_evp_md_non_null_from_algorithm(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s1">evp_md = self._evp_md_from_algorithm(algorithm)</span>
        <span class="s1">self.openssl_assert(evp_md != self._ffi.NULL)</span>
        <span class="s2">return </span><span class="s1">evp_md</span>

    <span class="s2">def </span><span class="s1">hash_supported(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled </span><span class="s2">and not </span><span class="s1">isinstance(algorithm</span><span class="s2">, </span><span class="s1">self._fips_hashes):</span>
            <span class="s2">return False</span>

        <span class="s1">evp_md = self._evp_md_from_algorithm(algorithm)</span>
        <span class="s2">return </span><span class="s1">evp_md != self._ffi.NULL</span>

    <span class="s2">def </span><span class="s1">hmac_supported(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">return </span><span class="s1">self.hash_supported(algorithm)</span>

    <span class="s2">def </span><span class="s1">create_hash_ctx(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">return </span><span class="s1">_HashContext(self</span><span class="s2">, </span><span class="s1">algorithm)</span>

    <span class="s2">def </span><span class="s1">cipher_supported(self</span><span class="s2">, </span><span class="s1">cipher</span><span class="s2">, </span><span class="s1">mode):</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled </span><span class="s2">and not </span><span class="s1">isinstance(cipher</span><span class="s2">, </span><span class="s1">self._fips_ciphers):</span>
            <span class="s2">return False</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">adapter = self._cipher_registry[type(cipher)</span><span class="s2">, </span><span class="s1">type(mode)]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">return False</span>
        <span class="s1">evp_cipher = adapter(self</span><span class="s2">, </span><span class="s1">cipher</span><span class="s2">, </span><span class="s1">mode)</span>
        <span class="s2">return </span><span class="s1">self._ffi.NULL != evp_cipher</span>

    <span class="s2">def </span><span class="s1">register_cipher_adapter(self</span><span class="s2">, </span><span class="s1">cipher_cls</span><span class="s2">, </span><span class="s1">mode_cls</span><span class="s2">, </span><span class="s1">adapter):</span>
        <span class="s2">if </span><span class="s1">(cipher_cls</span><span class="s2">, </span><span class="s1">mode_cls) </span><span class="s2">in </span><span class="s1">self._cipher_registry:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Duplicate registration for: {} {}.&quot;</span><span class="s1">.format(</span>
                    <span class="s1">cipher_cls</span><span class="s2">, </span><span class="s1">mode_cls</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">self._cipher_registry[cipher_cls</span><span class="s2">, </span><span class="s1">mode_cls] = adapter</span>

    <span class="s2">def </span><span class="s1">_register_default_ciphers(self):</span>
        <span class="s2">for </span><span class="s1">mode_cls </span><span class="s2">in </span><span class="s1">[CBC</span><span class="s2">, </span><span class="s1">CTR</span><span class="s2">, </span><span class="s1">ECB</span><span class="s2">, </span><span class="s1">OFB</span><span class="s2">, </span><span class="s1">CFB</span><span class="s2">, </span><span class="s1">CFB8</span><span class="s2">, </span><span class="s1">GCM]:</span>
            <span class="s1">self.register_cipher_adapter(</span>
                <span class="s1">AES</span><span class="s2">,</span>
                <span class="s1">mode_cls</span><span class="s2">,</span>
                <span class="s1">GetCipherByName(</span><span class="s3">&quot;{cipher.name}-{cipher.key_size}-{mode.name}&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">mode_cls </span><span class="s2">in </span><span class="s1">[CBC</span><span class="s2">, </span><span class="s1">CTR</span><span class="s2">, </span><span class="s1">ECB</span><span class="s2">, </span><span class="s1">OFB</span><span class="s2">, </span><span class="s1">CFB]:</span>
            <span class="s1">self.register_cipher_adapter(</span>
                <span class="s1">Camellia</span><span class="s2">,</span>
                <span class="s1">mode_cls</span><span class="s2">,</span>
                <span class="s1">GetCipherByName(</span><span class="s3">&quot;{cipher.name}-{cipher.key_size}-{mode.name}&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">mode_cls </span><span class="s2">in </span><span class="s1">[CBC</span><span class="s2">, </span><span class="s1">CFB</span><span class="s2">, </span><span class="s1">CFB8</span><span class="s2">, </span><span class="s1">OFB]:</span>
            <span class="s1">self.register_cipher_adapter(</span>
                <span class="s1">TripleDES</span><span class="s2">, </span><span class="s1">mode_cls</span><span class="s2">, </span><span class="s1">GetCipherByName(</span><span class="s3">&quot;des-ede3-{mode.name}&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">self.register_cipher_adapter(</span>
            <span class="s1">TripleDES</span><span class="s2">, </span><span class="s1">ECB</span><span class="s2">, </span><span class="s1">GetCipherByName(</span><span class="s3">&quot;des-ede3&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">mode_cls </span><span class="s2">in </span><span class="s1">[CBC</span><span class="s2">, </span><span class="s1">CFB</span><span class="s2">, </span><span class="s1">OFB</span><span class="s2">, </span><span class="s1">ECB]:</span>
            <span class="s1">self.register_cipher_adapter(</span>
                <span class="s1">Blowfish</span><span class="s2">, </span><span class="s1">mode_cls</span><span class="s2">, </span><span class="s1">GetCipherByName(</span><span class="s3">&quot;bf-{mode.name}&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">mode_cls </span><span class="s2">in </span><span class="s1">[CBC</span><span class="s2">, </span><span class="s1">CFB</span><span class="s2">, </span><span class="s1">OFB</span><span class="s2">, </span><span class="s1">ECB]:</span>
            <span class="s1">self.register_cipher_adapter(</span>
                <span class="s1">SEED</span><span class="s2">, </span><span class="s1">mode_cls</span><span class="s2">, </span><span class="s1">GetCipherByName(</span><span class="s3">&quot;seed-{mode.name}&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">cipher_cls</span><span class="s2">, </span><span class="s1">mode_cls </span><span class="s2">in </span><span class="s1">itertools.product(</span>
            <span class="s1">[CAST5</span><span class="s2">, </span><span class="s1">IDEA]</span><span class="s2">,</span>
            <span class="s1">[CBC</span><span class="s2">, </span><span class="s1">OFB</span><span class="s2">, </span><span class="s1">CFB</span><span class="s2">, </span><span class="s1">ECB]</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">self.register_cipher_adapter(</span>
                <span class="s1">cipher_cls</span><span class="s2">,</span>
                <span class="s1">mode_cls</span><span class="s2">,</span>
                <span class="s1">GetCipherByName(</span><span class="s3">&quot;{cipher.name}-{mode.name}&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">self.register_cipher_adapter(ARC4</span><span class="s2">, </span><span class="s1">type(</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">GetCipherByName(</span><span class="s3">&quot;rc4&quot;</span><span class="s1">))</span>
        <span class="s0"># We don't actually support RC2, this is just used by some tests.</span>
        <span class="s1">self.register_cipher_adapter(_RC2</span><span class="s2">, </span><span class="s1">type(</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">GetCipherByName(</span><span class="s3">&quot;rc2&quot;</span><span class="s1">))</span>
        <span class="s1">self.register_cipher_adapter(</span>
            <span class="s1">ChaCha20</span><span class="s2">, </span><span class="s1">type(</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">GetCipherByName(</span><span class="s3">&quot;chacha20&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">self.register_cipher_adapter(AES</span><span class="s2">, </span><span class="s1">XTS</span><span class="s2">, </span><span class="s1">_get_xts_cipher)</span>

    <span class="s2">def </span><span class="s1">_register_x509_ext_parsers(self):</span>
        <span class="s1">ext_handlers = _EXTENSION_HANDLERS_BASE.copy()</span>
        <span class="s0"># All revoked extensions are valid single response extensions, see:</span>
        <span class="s0"># https://tools.ietf.org/html/rfc6960#section-4.4.5</span>
        <span class="s1">singleresp_handlers = _REVOKED_EXTENSION_HANDLERS.copy()</span>

        <span class="s2">if </span><span class="s1">self._lib.Cryptography_HAS_SCT:</span>
            <span class="s1">ext_handlers.update(_EXTENSION_HANDLERS_SCT)</span>
            <span class="s1">singleresp_handlers.update(_OCSP_SINGLERESP_EXTENSION_HANDLERS_SCT)</span>

        <span class="s1">self._certificate_extension_parser = _X509ExtensionParser(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">ext_count=self._lib.X509_get_ext_count</span><span class="s2">,</span>
            <span class="s1">get_ext=self._lib.X509_get_ext</span><span class="s2">,</span>
            <span class="s1">handlers=ext_handlers</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._csr_extension_parser = _X509ExtensionParser(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">ext_count=self._lib.sk_X509_EXTENSION_num</span><span class="s2">,</span>
            <span class="s1">get_ext=self._lib.sk_X509_EXTENSION_value</span><span class="s2">,</span>
            <span class="s1">handlers=ext_handlers</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._revoked_cert_extension_parser = _X509ExtensionParser(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">ext_count=self._lib.X509_REVOKED_get_ext_count</span><span class="s2">,</span>
            <span class="s1">get_ext=self._lib.X509_REVOKED_get_ext</span><span class="s2">,</span>
            <span class="s1">handlers=_REVOKED_EXTENSION_HANDLERS</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._crl_extension_parser = _X509ExtensionParser(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">ext_count=self._lib.X509_CRL_get_ext_count</span><span class="s2">,</span>
            <span class="s1">get_ext=self._lib.X509_CRL_get_ext</span><span class="s2">,</span>
            <span class="s1">handlers=_CRL_EXTENSION_HANDLERS</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._ocsp_req_ext_parser = _X509ExtensionParser(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">ext_count=self._lib.OCSP_REQUEST_get_ext_count</span><span class="s2">,</span>
            <span class="s1">get_ext=self._lib.OCSP_REQUEST_get_ext</span><span class="s2">,</span>
            <span class="s1">handlers=_OCSP_REQ_EXTENSION_HANDLERS</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._ocsp_basicresp_ext_parser = _X509ExtensionParser(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">ext_count=self._lib.OCSP_BASICRESP_get_ext_count</span><span class="s2">,</span>
            <span class="s1">get_ext=self._lib.OCSP_BASICRESP_get_ext</span><span class="s2">,</span>
            <span class="s1">handlers=_OCSP_BASICRESP_EXTENSION_HANDLERS</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self._ocsp_singleresp_ext_parser = _X509ExtensionParser(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">ext_count=self._lib.OCSP_SINGLERESP_get_ext_count</span><span class="s2">,</span>
            <span class="s1">get_ext=self._lib.OCSP_SINGLERESP_get_ext</span><span class="s2">,</span>
            <span class="s1">handlers=singleresp_handlers</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_register_x509_encoders(self):</span>
        <span class="s1">self._extension_encode_handlers = _EXTENSION_ENCODE_HANDLERS.copy()</span>
        <span class="s1">self._crl_extension_encode_handlers = (</span>
            <span class="s1">_CRL_EXTENSION_ENCODE_HANDLERS.copy()</span>
        <span class="s1">)</span>
        <span class="s1">self._crl_entry_extension_encode_handlers = (</span>
            <span class="s1">_CRL_ENTRY_EXTENSION_ENCODE_HANDLERS.copy()</span>
        <span class="s1">)</span>
        <span class="s1">self._ocsp_request_extension_encode_handlers = (</span>
            <span class="s1">_OCSP_REQUEST_EXTENSION_ENCODE_HANDLERS.copy()</span>
        <span class="s1">)</span>
        <span class="s1">self._ocsp_basicresp_extension_encode_handlers = (</span>
            <span class="s1">_OCSP_BASICRESP_EXTENSION_ENCODE_HANDLERS.copy()</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">create_symmetric_encryption_ctx(self</span><span class="s2">, </span><span class="s1">cipher</span><span class="s2">, </span><span class="s1">mode):</span>
        <span class="s2">return </span><span class="s1">_CipherContext(self</span><span class="s2">, </span><span class="s1">cipher</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">_CipherContext._ENCRYPT)</span>

    <span class="s2">def </span><span class="s1">create_symmetric_decryption_ctx(self</span><span class="s2">, </span><span class="s1">cipher</span><span class="s2">, </span><span class="s1">mode):</span>
        <span class="s2">return </span><span class="s1">_CipherContext(self</span><span class="s2">, </span><span class="s1">cipher</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">_CipherContext._DECRYPT)</span>

    <span class="s2">def </span><span class="s1">pbkdf2_hmac_supported(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">return </span><span class="s1">self.hmac_supported(algorithm)</span>

    <span class="s2">def </span><span class="s1">derive_pbkdf2_hmac(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">algorithm</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">salt</span><span class="s2">, </span><span class="s1">iterations</span><span class="s2">, </span><span class="s1">key_material</span>
    <span class="s1">):</span>
        <span class="s1">buf = self._ffi.new(</span><span class="s3">&quot;unsigned char[]&quot;</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s1">evp_md = self._evp_md_non_null_from_algorithm(algorithm)</span>
        <span class="s1">key_material_ptr = self._ffi.from_buffer(key_material)</span>
        <span class="s1">res = self._lib.PKCS5_PBKDF2_HMAC(</span>
            <span class="s1">key_material_ptr</span><span class="s2">,</span>
            <span class="s1">len(key_material)</span><span class="s2">,</span>
            <span class="s1">salt</span><span class="s2">,</span>
            <span class="s1">len(salt)</span><span class="s2">,</span>
            <span class="s1">iterations</span><span class="s2">,</span>
            <span class="s1">evp_md</span><span class="s2">,</span>
            <span class="s1">length</span><span class="s2">,</span>
            <span class="s1">buf</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._ffi.buffer(buf)[:]</span>

    <span class="s2">def </span><span class="s1">_consume_errors(self):</span>
        <span class="s2">return </span><span class="s1">binding._consume_errors(self._lib)</span>

    <span class="s2">def </span><span class="s1">_consume_errors_with_text(self):</span>
        <span class="s2">return </span><span class="s1">binding._consume_errors_with_text(self._lib)</span>

    <span class="s2">def </span><span class="s1">_bn_to_int(self</span><span class="s2">, </span><span class="s1">bn):</span>
        <span class="s2">assert </span><span class="s1">bn != self._ffi.NULL</span>

        <span class="s1">bn_num_bytes = self._lib.BN_num_bytes(bn)</span>
        <span class="s1">bin_ptr = self._ffi.new(</span><span class="s3">&quot;unsigned char[]&quot;</span><span class="s2">, </span><span class="s1">bn_num_bytes)</span>
        <span class="s1">bin_len = self._lib.BN_bn2bin(bn</span><span class="s2">, </span><span class="s1">bin_ptr)</span>
        <span class="s0"># A zero length means the BN has value 0</span>
        <span class="s1">self.openssl_assert(bin_len &gt;= </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s1">val = int.from_bytes(self._ffi.buffer(bin_ptr)[:bin_len]</span><span class="s2">, </span><span class="s3">&quot;big&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._lib.BN_is_negative(bn):</span>
            <span class="s1">val = -val</span>
        <span class="s2">return </span><span class="s1">val</span>

    <span class="s2">def </span><span class="s1">_int_to_bn(self</span><span class="s2">, </span><span class="s1">num</span><span class="s2">, </span><span class="s1">bn=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot; 
        Converts a python integer to a BIGNUM. The returned BIGNUM will not 
        be garbage collected (to support adding them to structs that take 
        ownership of the object). Be sure to register it for GC if it will 
        be discarded after use. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">bn </span><span class="s2">is None or </span><span class="s1">bn != self._ffi.NULL</span>

        <span class="s2">if </span><span class="s1">bn </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bn = self._ffi.NULL</span>

        <span class="s1">binary = num.to_bytes(int(num.bit_length() / </span><span class="s6">8.0 </span><span class="s1">+ </span><span class="s6">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;big&quot;</span><span class="s1">)</span>
        <span class="s1">bn_ptr = self._lib.BN_bin2bn(binary</span><span class="s2">, </span><span class="s1">len(binary)</span><span class="s2">, </span><span class="s1">bn)</span>
        <span class="s1">self.openssl_assert(bn_ptr != self._ffi.NULL)</span>
        <span class="s2">return </span><span class="s1">bn_ptr</span>

    <span class="s2">def </span><span class="s1">generate_rsa_private_key(self</span><span class="s2">, </span><span class="s1">public_exponent</span><span class="s2">, </span><span class="s1">key_size):</span>
        <span class="s1">rsa._verify_rsa_parameters(public_exponent</span><span class="s2">, </span><span class="s1">key_size)</span>

        <span class="s1">rsa_cdata = self._lib.RSA_new()</span>
        <span class="s1">self.openssl_assert(rsa_cdata != self._ffi.NULL)</span>
        <span class="s1">rsa_cdata = self._ffi.gc(rsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.RSA_free)</span>

        <span class="s1">bn = self._int_to_bn(public_exponent)</span>
        <span class="s1">bn = self._ffi.gc(bn</span><span class="s2">, </span><span class="s1">self._lib.BN_free)</span>

        <span class="s1">res = self._lib.RSA_generate_key_ex(</span>
            <span class="s1">rsa_cdata</span><span class="s2">, </span><span class="s1">key_size</span><span class="s2">, </span><span class="s1">bn</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)</span>

        <span class="s2">return </span><span class="s1">_RSAPrivateKey(self</span><span class="s2">, </span><span class="s1">rsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">generate_rsa_parameters_supported(self</span><span class="s2">, </span><span class="s1">public_exponent</span><span class="s2">, </span><span class="s1">key_size):</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">public_exponent &gt;= </span><span class="s6">3</span>
            <span class="s2">and </span><span class="s1">public_exponent &amp; </span><span class="s6">1 </span><span class="s1">!= </span><span class="s6">0</span>
            <span class="s2">and </span><span class="s1">key_size &gt;= </span><span class="s6">512</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">load_rsa_private_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">rsa._check_private_key_components(</span>
            <span class="s1">numbers.p</span><span class="s2">,</span>
            <span class="s1">numbers.q</span><span class="s2">,</span>
            <span class="s1">numbers.d</span><span class="s2">,</span>
            <span class="s1">numbers.dmp1</span><span class="s2">,</span>
            <span class="s1">numbers.dmq1</span><span class="s2">,</span>
            <span class="s1">numbers.iqmp</span><span class="s2">,</span>
            <span class="s1">numbers.public_numbers.e</span><span class="s2">,</span>
            <span class="s1">numbers.public_numbers.n</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">rsa_cdata = self._lib.RSA_new()</span>
        <span class="s1">self.openssl_assert(rsa_cdata != self._ffi.NULL)</span>
        <span class="s1">rsa_cdata = self._ffi.gc(rsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.RSA_free)</span>
        <span class="s1">p = self._int_to_bn(numbers.p)</span>
        <span class="s1">q = self._int_to_bn(numbers.q)</span>
        <span class="s1">d = self._int_to_bn(numbers.d)</span>
        <span class="s1">dmp1 = self._int_to_bn(numbers.dmp1)</span>
        <span class="s1">dmq1 = self._int_to_bn(numbers.dmq1)</span>
        <span class="s1">iqmp = self._int_to_bn(numbers.iqmp)</span>
        <span class="s1">e = self._int_to_bn(numbers.public_numbers.e)</span>
        <span class="s1">n = self._int_to_bn(numbers.public_numbers.n)</span>
        <span class="s1">res = self._lib.RSA_set0_factors(rsa_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">res = self._lib.RSA_set0_key(rsa_cdata</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">res = self._lib.RSA_set0_crt_params(rsa_cdata</span><span class="s2">, </span><span class="s1">dmp1</span><span class="s2">, </span><span class="s1">dmq1</span><span class="s2">, </span><span class="s1">iqmp)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)</span>

        <span class="s2">return </span><span class="s1">_RSAPrivateKey(self</span><span class="s2">, </span><span class="s1">rsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">load_rsa_public_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">rsa._check_public_key_components(numbers.e</span><span class="s2">, </span><span class="s1">numbers.n)</span>
        <span class="s1">rsa_cdata = self._lib.RSA_new()</span>
        <span class="s1">self.openssl_assert(rsa_cdata != self._ffi.NULL)</span>
        <span class="s1">rsa_cdata = self._ffi.gc(rsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.RSA_free)</span>
        <span class="s1">e = self._int_to_bn(numbers.e)</span>
        <span class="s1">n = self._int_to_bn(numbers.n)</span>
        <span class="s1">res = self._lib.RSA_set0_key(rsa_cdata</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">e</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)</span>

        <span class="s2">return </span><span class="s1">_RSAPublicKey(self</span><span class="s2">, </span><span class="s1">rsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">_create_evp_pkey_gc(self):</span>
        <span class="s1">evp_pkey = self._lib.EVP_PKEY_new()</span>
        <span class="s1">self.openssl_assert(evp_pkey != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
        <span class="s2">return </span><span class="s1">evp_pkey</span>

    <span class="s2">def </span><span class="s1">_rsa_cdata_to_evp_pkey(self</span><span class="s2">, </span><span class="s1">rsa_cdata):</span>
        <span class="s1">evp_pkey = self._create_evp_pkey_gc()</span>
        <span class="s1">res = self._lib.EVP_PKEY_set1_RSA(evp_pkey</span><span class="s2">, </span><span class="s1">rsa_cdata)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">evp_pkey</span>

    <span class="s2">def </span><span class="s1">_bytes_to_bio(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return a _MemoryBIO namedtuple of (BIO, char*). 
 
        The char* is the storage for the BIO and it must stay alive until the 
        BIO is finished with. 
        &quot;&quot;&quot;</span>
        <span class="s1">data_ptr = self._ffi.from_buffer(data)</span>
        <span class="s1">bio = self._lib.BIO_new_mem_buf(data_ptr</span><span class="s2">, </span><span class="s1">len(data))</span>
        <span class="s1">self.openssl_assert(bio != self._ffi.NULL)</span>

        <span class="s2">return </span><span class="s1">_MemoryBIO(self._ffi.gc(bio</span><span class="s2">, </span><span class="s1">self._lib.BIO_free)</span><span class="s2">, </span><span class="s1">data_ptr)</span>

    <span class="s2">def </span><span class="s1">_create_mem_bio_gc(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Creates an empty memory BIO. 
        &quot;&quot;&quot;</span>
        <span class="s1">bio_method = self._lib.BIO_s_mem()</span>
        <span class="s1">self.openssl_assert(bio_method != self._ffi.NULL)</span>
        <span class="s1">bio = self._lib.BIO_new(bio_method)</span>
        <span class="s1">self.openssl_assert(bio != self._ffi.NULL)</span>
        <span class="s1">bio = self._ffi.gc(bio</span><span class="s2">, </span><span class="s1">self._lib.BIO_free)</span>
        <span class="s2">return </span><span class="s1">bio</span>

    <span class="s2">def </span><span class="s1">_read_mem_bio(self</span><span class="s2">, </span><span class="s1">bio):</span>
        <span class="s4">&quot;&quot;&quot; 
        Reads a memory BIO. This only works on memory BIOs. 
        &quot;&quot;&quot;</span>
        <span class="s1">buf = self._ffi.new(</span><span class="s3">&quot;char **&quot;</span><span class="s1">)</span>
        <span class="s1">buf_len = self._lib.BIO_get_mem_data(bio</span><span class="s2">, </span><span class="s1">buf)</span>
        <span class="s1">self.openssl_assert(buf_len &gt; </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s1">self.openssl_assert(buf[</span><span class="s6">0</span><span class="s1">] != self._ffi.NULL)</span>
        <span class="s1">bio_data = self._ffi.buffer(buf[</span><span class="s6">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">buf_len)[:]</span>
        <span class="s2">return </span><span class="s1">bio_data</span>

    <span class="s2">def </span><span class="s1">_evp_pkey_to_private_key(self</span><span class="s2">, </span><span class="s1">evp_pkey):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the appropriate type of PrivateKey given an evp_pkey cdata 
        pointer. 
        &quot;&quot;&quot;</span>

        <span class="s1">key_type = self._lib.EVP_PKEY_id(evp_pkey)</span>

        <span class="s2">if </span><span class="s1">key_type == self._lib.EVP_PKEY_RSA:</span>
            <span class="s1">rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)</span>
            <span class="s1">self.openssl_assert(rsa_cdata != self._ffi.NULL)</span>
            <span class="s1">rsa_cdata = self._ffi.gc(rsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.RSA_free)</span>
            <span class="s2">return </span><span class="s1">_RSAPrivateKey(self</span><span class="s2">, </span><span class="s1">rsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == self._lib.EVP_PKEY_DSA:</span>
            <span class="s1">dsa_cdata = self._lib.EVP_PKEY_get1_DSA(evp_pkey)</span>
            <span class="s1">self.openssl_assert(dsa_cdata != self._ffi.NULL)</span>
            <span class="s1">dsa_cdata = self._ffi.gc(dsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.DSA_free)</span>
            <span class="s2">return </span><span class="s1">_DSAPrivateKey(self</span><span class="s2">, </span><span class="s1">dsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == self._lib.EVP_PKEY_EC:</span>
            <span class="s1">ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)</span>
            <span class="s1">self.openssl_assert(ec_cdata != self._ffi.NULL)</span>
            <span class="s1">ec_cdata = self._ffi.gc(ec_cdata</span><span class="s2">, </span><span class="s1">self._lib.EC_KEY_free)</span>
            <span class="s2">return </span><span class="s1">_EllipticCurvePrivateKey(self</span><span class="s2">, </span><span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type </span><span class="s2">in </span><span class="s1">self._dh_types:</span>
            <span class="s1">dh_cdata = self._lib.EVP_PKEY_get1_DH(evp_pkey)</span>
            <span class="s1">self.openssl_assert(dh_cdata != self._ffi.NULL)</span>
            <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>
            <span class="s2">return </span><span class="s1">_DHPrivateKey(self</span><span class="s2">, </span><span class="s1">dh_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;EVP_PKEY_ED25519&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s0"># EVP_PKEY_ED25519 is not present in OpenSSL &lt; 1.1.1</span>
            <span class="s2">return </span><span class="s1">_Ed25519PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;EVP_PKEY_X448&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s0"># EVP_PKEY_X448 is not present in OpenSSL &lt; 1.1.1</span>
            <span class="s2">return </span><span class="s1">_X448PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;EVP_PKEY_X25519&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s0"># EVP_PKEY_X25519 is not present in OpenSSL &lt; 1.1.0</span>
            <span class="s2">return </span><span class="s1">_X25519PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;EVP_PKEY_ED448&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s0"># EVP_PKEY_ED448 is not present in OpenSSL &lt; 1.1.1</span>
            <span class="s2">return </span><span class="s1">_Ed448PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">UnsupportedAlgorithm(</span><span class="s3">&quot;Unsupported key type.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_evp_pkey_to_public_key(self</span><span class="s2">, </span><span class="s1">evp_pkey):</span>
        <span class="s4">&quot;&quot;&quot; 
        Return the appropriate type of PublicKey given an evp_pkey cdata 
        pointer. 
        &quot;&quot;&quot;</span>

        <span class="s1">key_type = self._lib.EVP_PKEY_id(evp_pkey)</span>

        <span class="s2">if </span><span class="s1">key_type == self._lib.EVP_PKEY_RSA:</span>
            <span class="s1">rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)</span>
            <span class="s1">self.openssl_assert(rsa_cdata != self._ffi.NULL)</span>
            <span class="s1">rsa_cdata = self._ffi.gc(rsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.RSA_free)</span>
            <span class="s2">return </span><span class="s1">_RSAPublicKey(self</span><span class="s2">, </span><span class="s1">rsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == self._lib.EVP_PKEY_DSA:</span>
            <span class="s1">dsa_cdata = self._lib.EVP_PKEY_get1_DSA(evp_pkey)</span>
            <span class="s1">self.openssl_assert(dsa_cdata != self._ffi.NULL)</span>
            <span class="s1">dsa_cdata = self._ffi.gc(dsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.DSA_free)</span>
            <span class="s2">return </span><span class="s1">_DSAPublicKey(self</span><span class="s2">, </span><span class="s1">dsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == self._lib.EVP_PKEY_EC:</span>
            <span class="s1">ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)</span>
            <span class="s1">self.openssl_assert(ec_cdata != self._ffi.NULL)</span>
            <span class="s1">ec_cdata = self._ffi.gc(ec_cdata</span><span class="s2">, </span><span class="s1">self._lib.EC_KEY_free)</span>
            <span class="s2">return </span><span class="s1">_EllipticCurvePublicKey(self</span><span class="s2">, </span><span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type </span><span class="s2">in </span><span class="s1">self._dh_types:</span>
            <span class="s1">dh_cdata = self._lib.EVP_PKEY_get1_DH(evp_pkey)</span>
            <span class="s1">self.openssl_assert(dh_cdata != self._ffi.NULL)</span>
            <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>
            <span class="s2">return </span><span class="s1">_DHPublicKey(self</span><span class="s2">, </span><span class="s1">dh_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;EVP_PKEY_ED25519&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s0"># EVP_PKEY_ED25519 is not present in OpenSSL &lt; 1.1.1</span>
            <span class="s2">return </span><span class="s1">_Ed25519PublicKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;EVP_PKEY_X448&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s0"># EVP_PKEY_X448 is not present in OpenSSL &lt; 1.1.1</span>
            <span class="s2">return </span><span class="s1">_X448PublicKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;EVP_PKEY_X25519&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s0"># EVP_PKEY_X25519 is not present in OpenSSL &lt; 1.1.0</span>
            <span class="s2">return </span><span class="s1">_X25519PublicKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">elif </span><span class="s1">key_type == getattr(self._lib</span><span class="s2">, </span><span class="s3">&quot;EVP_PKEY_ED448&quot;</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s0"># EVP_PKEY_X25519 is not present in OpenSSL &lt; 1.1.1</span>
            <span class="s2">return </span><span class="s1">_Ed448PublicKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">UnsupportedAlgorithm(</span><span class="s3">&quot;Unsupported key type.&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_oaep_hash_supported(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">if </span><span class="s1">self._lib.Cryptography_HAS_RSA_OAEP_MD:</span>
            <span class="s2">return </span><span class="s1">isinstance(</span>
                <span class="s1">algorithm</span><span class="s2">,</span>
                <span class="s1">(</span>
                    <span class="s1">hashes.SHA1</span><span class="s2">,</span>
                    <span class="s1">hashes.SHA224</span><span class="s2">,</span>
                    <span class="s1">hashes.SHA256</span><span class="s2">,</span>
                    <span class="s1">hashes.SHA384</span><span class="s2">,</span>
                    <span class="s1">hashes.SHA512</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">isinstance(algorithm</span><span class="s2">, </span><span class="s1">hashes.SHA1)</span>

    <span class="s2">def </span><span class="s1">rsa_padding_supported(self</span><span class="s2">, </span><span class="s1">padding):</span>
        <span class="s2">if </span><span class="s1">isinstance(padding</span><span class="s2">, </span><span class="s1">PKCS1v15):</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">isinstance(padding</span><span class="s2">, </span><span class="s1">PSS) </span><span class="s2">and </span><span class="s1">isinstance(padding._mgf</span><span class="s2">, </span><span class="s1">MGF1):</span>
            <span class="s2">return </span><span class="s1">self.hash_supported(padding._mgf._algorithm)</span>
        <span class="s2">elif </span><span class="s1">isinstance(padding</span><span class="s2">, </span><span class="s1">OAEP) </span><span class="s2">and </span><span class="s1">isinstance(padding._mgf</span><span class="s2">, </span><span class="s1">MGF1):</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s1">self._oaep_hash_supported(padding._mgf._algorithm)</span>
                <span class="s2">and </span><span class="s1">self._oaep_hash_supported(padding._algorithm)</span>
                <span class="s2">and </span><span class="s1">(</span>
                    <span class="s1">(padding._label </span><span class="s2">is None or </span><span class="s1">len(padding._label) == </span><span class="s6">0</span><span class="s1">)</span>
                    <span class="s2">or </span><span class="s1">self._lib.Cryptography_HAS_RSA_OAEP_LABEL == </span><span class="s6">1</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">generate_dsa_parameters(self</span><span class="s2">, </span><span class="s1">key_size):</span>
        <span class="s2">if </span><span class="s1">key_size </span><span class="s2">not in </span><span class="s1">(</span><span class="s6">1024</span><span class="s2">, </span><span class="s6">2048</span><span class="s2">, </span><span class="s6">3072</span><span class="s2">, </span><span class="s6">4096</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Key size must be 1024, 2048, 3072, or 4096 bits.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">ctx = self._lib.DSA_new()</span>
        <span class="s1">self.openssl_assert(ctx != self._ffi.NULL)</span>
        <span class="s1">ctx = self._ffi.gc(ctx</span><span class="s2">, </span><span class="s1">self._lib.DSA_free)</span>

        <span class="s1">res = self._lib.DSA_generate_parameters_ex(</span>
            <span class="s1">ctx</span><span class="s2">,</span>
            <span class="s1">key_size</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s6">0</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">_DSAParameters(self</span><span class="s2">, </span><span class="s1">ctx)</span>

    <span class="s2">def </span><span class="s1">generate_dsa_private_key(self</span><span class="s2">, </span><span class="s1">parameters):</span>
        <span class="s1">ctx = self._lib.DSAparams_dup(parameters._dsa_cdata)</span>
        <span class="s1">self.openssl_assert(ctx != self._ffi.NULL)</span>
        <span class="s1">ctx = self._ffi.gc(ctx</span><span class="s2">, </span><span class="s1">self._lib.DSA_free)</span>
        <span class="s1">self._lib.DSA_generate_key(ctx)</span>
        <span class="s1">evp_pkey = self._dsa_cdata_to_evp_pkey(ctx)</span>

        <span class="s2">return </span><span class="s1">_DSAPrivateKey(self</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">generate_dsa_private_key_and_parameters(self</span><span class="s2">, </span><span class="s1">key_size):</span>
        <span class="s1">parameters = self.generate_dsa_parameters(key_size)</span>
        <span class="s2">return </span><span class="s1">self.generate_dsa_private_key(parameters)</span>

    <span class="s2">def </span><span class="s1">_dsa_cdata_set_values(self</span><span class="s2">, </span><span class="s1">dsa_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">pub_key</span><span class="s2">, </span><span class="s1">priv_key):</span>
        <span class="s1">res = self._lib.DSA_set0_pqg(dsa_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">res = self._lib.DSA_set0_key(dsa_cdata</span><span class="s2">, </span><span class="s1">pub_key</span><span class="s2">, </span><span class="s1">priv_key)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">load_dsa_private_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">dsa._check_dsa_private_numbers(numbers)</span>
        <span class="s1">parameter_numbers = numbers.public_numbers.parameter_numbers</span>

        <span class="s1">dsa_cdata = self._lib.DSA_new()</span>
        <span class="s1">self.openssl_assert(dsa_cdata != self._ffi.NULL)</span>
        <span class="s1">dsa_cdata = self._ffi.gc(dsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.DSA_free)</span>

        <span class="s1">p = self._int_to_bn(parameter_numbers.p)</span>
        <span class="s1">q = self._int_to_bn(parameter_numbers.q)</span>
        <span class="s1">g = self._int_to_bn(parameter_numbers.g)</span>
        <span class="s1">pub_key = self._int_to_bn(numbers.public_numbers.y)</span>
        <span class="s1">priv_key = self._int_to_bn(numbers.x)</span>
        <span class="s1">self._dsa_cdata_set_values(dsa_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">pub_key</span><span class="s2">, </span><span class="s1">priv_key)</span>

        <span class="s1">evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)</span>

        <span class="s2">return </span><span class="s1">_DSAPrivateKey(self</span><span class="s2">, </span><span class="s1">dsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">load_dsa_public_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">dsa._check_dsa_parameters(numbers.parameter_numbers)</span>
        <span class="s1">dsa_cdata = self._lib.DSA_new()</span>
        <span class="s1">self.openssl_assert(dsa_cdata != self._ffi.NULL)</span>
        <span class="s1">dsa_cdata = self._ffi.gc(dsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.DSA_free)</span>

        <span class="s1">p = self._int_to_bn(numbers.parameter_numbers.p)</span>
        <span class="s1">q = self._int_to_bn(numbers.parameter_numbers.q)</span>
        <span class="s1">g = self._int_to_bn(numbers.parameter_numbers.g)</span>
        <span class="s1">pub_key = self._int_to_bn(numbers.y)</span>
        <span class="s1">priv_key = self._ffi.NULL</span>
        <span class="s1">self._dsa_cdata_set_values(dsa_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">pub_key</span><span class="s2">, </span><span class="s1">priv_key)</span>

        <span class="s1">evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)</span>

        <span class="s2">return </span><span class="s1">_DSAPublicKey(self</span><span class="s2">, </span><span class="s1">dsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">load_dsa_parameter_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">dsa._check_dsa_parameters(numbers)</span>
        <span class="s1">dsa_cdata = self._lib.DSA_new()</span>
        <span class="s1">self.openssl_assert(dsa_cdata != self._ffi.NULL)</span>
        <span class="s1">dsa_cdata = self._ffi.gc(dsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.DSA_free)</span>

        <span class="s1">p = self._int_to_bn(numbers.p)</span>
        <span class="s1">q = self._int_to_bn(numbers.q)</span>
        <span class="s1">g = self._int_to_bn(numbers.g)</span>
        <span class="s1">res = self._lib.DSA_set0_pqg(dsa_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">_DSAParameters(self</span><span class="s2">, </span><span class="s1">dsa_cdata)</span>

    <span class="s2">def </span><span class="s1">_dsa_cdata_to_evp_pkey(self</span><span class="s2">, </span><span class="s1">dsa_cdata):</span>
        <span class="s1">evp_pkey = self._create_evp_pkey_gc()</span>
        <span class="s1">res = self._lib.EVP_PKEY_set1_DSA(evp_pkey</span><span class="s2">, </span><span class="s1">dsa_cdata)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">evp_pkey</span>

    <span class="s2">def </span><span class="s1">dsa_hash_supported(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">return </span><span class="s1">self.hash_supported(algorithm)</span>

    <span class="s2">def </span><span class="s1">dsa_parameters_supported(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g):</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">cmac_algorithm_supported(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">return </span><span class="s1">self.cipher_supported(</span>
            <span class="s1">algorithm</span><span class="s2">, </span><span class="s1">CBC(</span><span class="s5">b&quot;</span><span class="s2">\x00</span><span class="s5">&quot; </span><span class="s1">* algorithm.block_size)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">create_cmac_ctx(self</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">return </span><span class="s1">_CMACContext(self</span><span class="s2">, </span><span class="s1">algorithm)</span>

    <span class="s2">def </span><span class="s1">_x509_check_signature_params(self</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">if </span><span class="s1">isinstance(</span>
            <span class="s1">private_key</span><span class="s2">, </span><span class="s1">(ed25519.Ed25519PrivateKey</span><span class="s2">, </span><span class="s1">ed448.Ed448PrivateKey)</span>
        <span class="s1">):</span>
            <span class="s2">if </span><span class="s1">algorithm </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;algorithm must be None when signing via ed25519 or ed448&quot;</span>
                <span class="s1">)</span>
        <span class="s2">elif not </span><span class="s1">isinstance(</span>
            <span class="s1">private_key</span><span class="s2">,</span>
            <span class="s1">(rsa.RSAPrivateKey</span><span class="s2">, </span><span class="s1">dsa.DSAPrivateKey</span><span class="s2">, </span><span class="s1">ec.EllipticCurvePrivateKey)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;Key must be an rsa, dsa, ec, ed25519, or ed448 private key.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">elif not </span><span class="s1">isinstance(algorithm</span><span class="s2">, </span><span class="s1">hashes.HashAlgorithm):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Algorithm must be a registered hash algorithm.&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(algorithm</span><span class="s2">, </span><span class="s1">hashes.MD5) </span><span class="s2">and not </span><span class="s1">isinstance(</span>
            <span class="s1">private_key</span><span class="s2">, </span><span class="s1">rsa.RSAPrivateKey</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;MD5 hash algorithm is only supported with RSA keys&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">create_x509_csr(self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">if not </span><span class="s1">isinstance(builder</span><span class="s2">, </span><span class="s1">x509.CertificateSigningRequestBuilder):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Builder type mismatch.&quot;</span><span class="s1">)</span>
        <span class="s1">self._x509_check_signature_params(private_key</span><span class="s2">, </span><span class="s1">algorithm)</span>

        <span class="s0"># Resolve the signature algorithm.</span>
        <span class="s1">evp_md = self._evp_md_x509_null_if_eddsa(private_key</span><span class="s2">, </span><span class="s1">algorithm)</span>

        <span class="s0"># Create an empty request.</span>
        <span class="s1">x509_req = self._lib.X509_REQ_new()</span>
        <span class="s1">self.openssl_assert(x509_req != self._ffi.NULL)</span>
        <span class="s1">x509_req = self._ffi.gc(x509_req</span><span class="s2">, </span><span class="s1">self._lib.X509_REQ_free)</span>

        <span class="s0"># Set x509 version.</span>
        <span class="s1">res = self._lib.X509_REQ_set_version(x509_req</span><span class="s2">, </span><span class="s1">x509.Version.v1.value)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set subject name.</span>
        <span class="s1">res = self._lib.X509_REQ_set_subject_name(</span>
            <span class="s1">x509_req</span><span class="s2">, </span><span class="s1">_encode_name_gc(self</span><span class="s2">, </span><span class="s1">builder._subject_name)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set subject public key.</span>
        <span class="s1">public_key = private_key.public_key()</span>
        <span class="s1">res = self._lib.X509_REQ_set_pubkey(x509_req</span><span class="s2">, </span><span class="s1">public_key._evp_pkey)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Add extensions.</span>
        <span class="s1">sk_extension = self._lib.sk_X509_EXTENSION_new_null()</span>
        <span class="s1">self.openssl_assert(sk_extension != self._ffi.NULL)</span>
        <span class="s1">sk_extension = self._ffi.gc(</span>
            <span class="s1">sk_extension</span><span class="s2">,</span>
            <span class="s2">lambda </span><span class="s1">x: self._lib.sk_X509_EXTENSION_pop_free(</span>
                <span class="s1">x</span><span class="s2">,</span>
                <span class="s1">self._ffi.addressof(</span>
                    <span class="s1">self._lib._original_lib</span><span class="s2">, </span><span class="s3">&quot;X509_EXTENSION_free&quot;</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s0"># Don't GC individual extensions because the memory is owned by</span>
        <span class="s0"># sk_extensions and will be freed along with it.</span>
        <span class="s1">self._create_x509_extensions(</span>
            <span class="s1">extensions=builder._extensions</span><span class="s2">,</span>
            <span class="s1">handlers=self._extension_encode_handlers</span><span class="s2">,</span>
            <span class="s1">x509_obj=sk_extension</span><span class="s2">,</span>
            <span class="s1">add_func=self._lib.sk_X509_EXTENSION_insert</span><span class="s2">,</span>
            <span class="s1">gc=</span><span class="s2">False,</span>
        <span class="s1">)</span>
        <span class="s1">res = self._lib.X509_REQ_add_extensions(x509_req</span><span class="s2">, </span><span class="s1">sk_extension)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Add attributes (all bytes encoded as ASN1 UTF8_STRING)</span>
        <span class="s2">for </span><span class="s1">attr_oid</span><span class="s2">, </span><span class="s1">attr_val </span><span class="s2">in </span><span class="s1">builder._attributes:</span>
            <span class="s1">obj = _txt2obj_gc(self</span><span class="s2">, </span><span class="s1">attr_oid.dotted_string)</span>
            <span class="s1">res = self._lib.X509_REQ_add1_attr_by_OBJ(</span>
                <span class="s1">x509_req</span><span class="s2">,</span>
                <span class="s1">obj</span><span class="s2">,</span>
                <span class="s1">x509.name._ASN1Type.UTF8String.value</span><span class="s2">,</span>
                <span class="s1">attr_val</span><span class="s2">,</span>
                <span class="s1">len(attr_val)</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Sign the request using the requester's private key.</span>
        <span class="s1">res = self._lib.X509_REQ_sign(x509_req</span><span class="s2">, </span><span class="s1">private_key._evp_pkey</span><span class="s2">, </span><span class="s1">evp_md)</span>
        <span class="s2">if </span><span class="s1">res == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">errors = self._consume_errors_with_text()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Signing failed&quot;</span><span class="s2">, </span><span class="s1">errors)</span>

        <span class="s2">return </span><span class="s1">_CertificateSigningRequest(self</span><span class="s2">, </span><span class="s1">x509_req)</span>

    <span class="s2">def </span><span class="s1">create_x509_certificate(self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">if not </span><span class="s1">isinstance(builder</span><span class="s2">, </span><span class="s1">x509.CertificateBuilder):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Builder type mismatch.&quot;</span><span class="s1">)</span>
        <span class="s1">self._x509_check_signature_params(private_key</span><span class="s2">, </span><span class="s1">algorithm)</span>

        <span class="s0"># Resolve the signature algorithm.</span>
        <span class="s1">evp_md = self._evp_md_x509_null_if_eddsa(private_key</span><span class="s2">, </span><span class="s1">algorithm)</span>

        <span class="s0"># Create an empty certificate.</span>
        <span class="s1">x509_cert = self._lib.X509_new()</span>
        <span class="s1">x509_cert = self._ffi.gc(x509_cert</span><span class="s2">, </span><span class="s1">self._lib.X509_free)</span>

        <span class="s0"># Set the x509 version.</span>
        <span class="s1">res = self._lib.X509_set_version(x509_cert</span><span class="s2">, </span><span class="s1">builder._version.value)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set the subject's name.</span>
        <span class="s1">res = self._lib.X509_set_subject_name(</span>
            <span class="s1">x509_cert</span><span class="s2">, </span><span class="s1">_encode_name_gc(self</span><span class="s2">, </span><span class="s1">builder._subject_name)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set the subject's public key.</span>
        <span class="s1">res = self._lib.X509_set_pubkey(</span>
            <span class="s1">x509_cert</span><span class="s2">, </span><span class="s1">builder._public_key._evp_pkey</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set the certificate serial number.</span>
        <span class="s1">serial_number = _encode_asn1_int_gc(self</span><span class="s2">, </span><span class="s1">builder._serial_number)</span>
        <span class="s1">res = self._lib.X509_set_serialNumber(x509_cert</span><span class="s2">, </span><span class="s1">serial_number)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set the &quot;not before&quot; time.</span>
        <span class="s1">self._set_asn1_time(</span>
            <span class="s1">self._lib.X509_getm_notBefore(x509_cert)</span><span class="s2">, </span><span class="s1">builder._not_valid_before</span>
        <span class="s1">)</span>

        <span class="s0"># Set the &quot;not after&quot; time.</span>
        <span class="s1">self._set_asn1_time(</span>
            <span class="s1">self._lib.X509_getm_notAfter(x509_cert)</span><span class="s2">, </span><span class="s1">builder._not_valid_after</span>
        <span class="s1">)</span>

        <span class="s0"># Add extensions.</span>
        <span class="s1">self._create_x509_extensions(</span>
            <span class="s1">extensions=builder._extensions</span><span class="s2">,</span>
            <span class="s1">handlers=self._extension_encode_handlers</span><span class="s2">,</span>
            <span class="s1">x509_obj=x509_cert</span><span class="s2">,</span>
            <span class="s1">add_func=self._lib.X509_add_ext</span><span class="s2">,</span>
            <span class="s1">gc=</span><span class="s2">True,</span>
        <span class="s1">)</span>

        <span class="s0"># Set the issuer name.</span>
        <span class="s1">res = self._lib.X509_set_issuer_name(</span>
            <span class="s1">x509_cert</span><span class="s2">, </span><span class="s1">_encode_name_gc(self</span><span class="s2">, </span><span class="s1">builder._issuer_name)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Sign the certificate with the issuer's private key.</span>
        <span class="s1">res = self._lib.X509_sign(x509_cert</span><span class="s2">, </span><span class="s1">private_key._evp_pkey</span><span class="s2">, </span><span class="s1">evp_md)</span>
        <span class="s2">if </span><span class="s1">res == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">errors = self._consume_errors_with_text()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Signing failed&quot;</span><span class="s2">, </span><span class="s1">errors)</span>

        <span class="s2">return </span><span class="s1">_Certificate(self</span><span class="s2">, </span><span class="s1">x509_cert)</span>

    <span class="s2">def </span><span class="s1">_evp_md_x509_null_if_eddsa(self</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">if </span><span class="s1">isinstance(</span>
            <span class="s1">private_key</span><span class="s2">, </span><span class="s1">(ed25519.Ed25519PrivateKey</span><span class="s2">, </span><span class="s1">ed448.Ed448PrivateKey)</span>
        <span class="s1">):</span>
            <span class="s0"># OpenSSL requires us to pass NULL for EVP_MD for ed25519/ed448</span>
            <span class="s2">return </span><span class="s1">self._ffi.NULL</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._evp_md_non_null_from_algorithm(algorithm)</span>

    <span class="s2">def </span><span class="s1">_set_asn1_time(self</span><span class="s2">, </span><span class="s1">asn1_time</span><span class="s2">, </span><span class="s1">time):</span>
        <span class="s2">if </span><span class="s1">time.year &gt;= </span><span class="s6">2050</span><span class="s1">:</span>
            <span class="s1">asn1_str = time.strftime(</span><span class="s3">&quot;%Y%m%d%H%M%SZ&quot;</span><span class="s1">).encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">asn1_str = time.strftime(</span><span class="s3">&quot;%y%m%d%H%M%SZ&quot;</span><span class="s1">).encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._lib.ASN1_TIME_set_string(asn1_time</span><span class="s2">, </span><span class="s1">asn1_str)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_create_asn1_time(self</span><span class="s2">, </span><span class="s1">time):</span>
        <span class="s1">asn1_time = self._lib.ASN1_TIME_new()</span>
        <span class="s1">self.openssl_assert(asn1_time != self._ffi.NULL)</span>
        <span class="s1">asn1_time = self._ffi.gc(asn1_time</span><span class="s2">, </span><span class="s1">self._lib.ASN1_TIME_free)</span>
        <span class="s1">self._set_asn1_time(asn1_time</span><span class="s2">, </span><span class="s1">time)</span>
        <span class="s2">return </span><span class="s1">asn1_time</span>

    <span class="s2">def </span><span class="s1">create_x509_crl(self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s2">if not </span><span class="s1">isinstance(builder</span><span class="s2">, </span><span class="s1">x509.CertificateRevocationListBuilder):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Builder type mismatch.&quot;</span><span class="s1">)</span>
        <span class="s1">self._x509_check_signature_params(private_key</span><span class="s2">, </span><span class="s1">algorithm)</span>

        <span class="s1">evp_md = self._evp_md_x509_null_if_eddsa(private_key</span><span class="s2">, </span><span class="s1">algorithm)</span>

        <span class="s0"># Create an empty CRL.</span>
        <span class="s1">x509_crl = self._lib.X509_CRL_new()</span>
        <span class="s1">x509_crl = self._ffi.gc(x509_crl</span><span class="s2">, </span><span class="s1">self._lib.X509_CRL_free)</span>

        <span class="s0"># Set the x509 CRL version. We only support v2 (integer value 1).</span>
        <span class="s1">res = self._lib.X509_CRL_set_version(x509_crl</span><span class="s2">, </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set the issuer name.</span>
        <span class="s1">res = self._lib.X509_CRL_set_issuer_name(</span>
            <span class="s1">x509_crl</span><span class="s2">, </span><span class="s1">_encode_name_gc(self</span><span class="s2">, </span><span class="s1">builder._issuer_name)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set the last update time.</span>
        <span class="s1">last_update = self._create_asn1_time(builder._last_update)</span>
        <span class="s1">res = self._lib.X509_CRL_set1_lastUpdate(x509_crl</span><span class="s2">, </span><span class="s1">last_update)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Set the next update time.</span>
        <span class="s1">next_update = self._create_asn1_time(builder._next_update)</span>
        <span class="s1">res = self._lib.X509_CRL_set1_nextUpdate(x509_crl</span><span class="s2">, </span><span class="s1">next_update)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># Add extensions.</span>
        <span class="s1">self._create_x509_extensions(</span>
            <span class="s1">extensions=builder._extensions</span><span class="s2">,</span>
            <span class="s1">handlers=self._crl_extension_encode_handlers</span><span class="s2">,</span>
            <span class="s1">x509_obj=x509_crl</span><span class="s2">,</span>
            <span class="s1">add_func=self._lib.X509_CRL_add_ext</span><span class="s2">,</span>
            <span class="s1">gc=</span><span class="s2">True,</span>
        <span class="s1">)</span>

        <span class="s0"># add revoked certificates</span>
        <span class="s2">for </span><span class="s1">revoked_cert </span><span class="s2">in </span><span class="s1">builder._revoked_certificates:</span>
            <span class="s0"># Duplicating because the X509_CRL takes ownership and will free</span>
            <span class="s0"># this memory when X509_CRL_free is called.</span>
            <span class="s1">revoked = self._lib.X509_REVOKED_dup(revoked_cert._x509_revoked)</span>
            <span class="s1">self.openssl_assert(revoked != self._ffi.NULL)</span>
            <span class="s1">res = self._lib.X509_CRL_add0_revoked(x509_crl</span><span class="s2">, </span><span class="s1">revoked)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">res = self._lib.X509_CRL_sign(x509_crl</span><span class="s2">, </span><span class="s1">private_key._evp_pkey</span><span class="s2">, </span><span class="s1">evp_md)</span>
        <span class="s2">if </span><span class="s1">res == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">errors = self._consume_errors_with_text()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Signing failed&quot;</span><span class="s2">, </span><span class="s1">errors)</span>

        <span class="s2">return </span><span class="s1">_CertificateRevocationList(self</span><span class="s2">, </span><span class="s1">x509_crl)</span>

    <span class="s2">def </span><span class="s1">_create_x509_extensions(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">extensions</span><span class="s2">, </span><span class="s1">handlers</span><span class="s2">, </span><span class="s1">x509_obj</span><span class="s2">, </span><span class="s1">add_func</span><span class="s2">, </span><span class="s1">gc</span>
    <span class="s1">):</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">extension </span><span class="s2">in </span><span class="s1">enumerate(extensions):</span>
            <span class="s1">x509_extension = self._create_x509_extension(handlers</span><span class="s2">, </span><span class="s1">extension)</span>
            <span class="s1">self.openssl_assert(x509_extension != self._ffi.NULL)</span>

            <span class="s2">if </span><span class="s1">gc:</span>
                <span class="s1">x509_extension = self._ffi.gc(</span>
                    <span class="s1">x509_extension</span><span class="s2">, </span><span class="s1">self._lib.X509_EXTENSION_free</span>
                <span class="s1">)</span>
            <span class="s1">res = add_func(x509_obj</span><span class="s2">, </span><span class="s1">x509_extension</span><span class="s2">, </span><span class="s1">i)</span>
            <span class="s1">self.openssl_assert(res &gt;= </span><span class="s6">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_create_raw_x509_extension(self</span><span class="s2">, </span><span class="s1">extension</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">obj = _txt2obj_gc(self</span><span class="s2">, </span><span class="s1">extension.oid.dotted_string)</span>
        <span class="s2">return </span><span class="s1">self._lib.X509_EXTENSION_create_by_OBJ(</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">extension.critical </span><span class="s2">else </span><span class="s6">0</span><span class="s2">, </span><span class="s1">value</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_create_x509_extension(self</span><span class="s2">, </span><span class="s1">handlers</span><span class="s2">, </span><span class="s1">extension):</span>
        <span class="s2">if </span><span class="s1">isinstance(extension.value</span><span class="s2">, </span><span class="s1">x509.UnrecognizedExtension):</span>
            <span class="s1">value = _encode_asn1_str_gc(self</span><span class="s2">, </span><span class="s1">extension.value.value)</span>
            <span class="s2">return </span><span class="s1">self._create_raw_x509_extension(extension</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">elif </span><span class="s1">isinstance(extension.value</span><span class="s2">, </span><span class="s1">x509.TLSFeature):</span>
            <span class="s1">asn1 = encode_der(</span>
                <span class="s1">SEQUENCE</span><span class="s2">,</span>
                <span class="s1">*[</span>
                    <span class="s1">encode_der(INTEGER</span><span class="s2">, </span><span class="s1">encode_der_integer(x.value))</span>
                    <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">extension.value</span>
                <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">value = _encode_asn1_str_gc(self</span><span class="s2">, </span><span class="s1">asn1)</span>
            <span class="s2">return </span><span class="s1">self._create_raw_x509_extension(extension</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">elif </span><span class="s1">isinstance(extension.value</span><span class="s2">, </span><span class="s1">x509.PrecertPoison):</span>
            <span class="s1">value = _encode_asn1_str_gc(self</span><span class="s2">, </span><span class="s1">encode_der(NULL))</span>
            <span class="s2">return </span><span class="s1">self._create_raw_x509_extension(extension</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">encode = handlers[extension.oid]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s3">&quot;Extension not supported: {}&quot;</span><span class="s1">.format(extension.oid)</span>
                <span class="s1">)</span>

            <span class="s1">ext_struct = encode(self</span><span class="s2">, </span><span class="s1">extension.value)</span>
            <span class="s1">nid = self._lib.OBJ_txt2nid(</span>
                <span class="s1">extension.oid.dotted_string.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">self.openssl_assert(nid != self._lib.NID_undef)</span>
            <span class="s2">return </span><span class="s1">self._lib.X509V3_EXT_i2d(</span>
                <span class="s1">nid</span><span class="s2">, </span><span class="s6">1 </span><span class="s2">if </span><span class="s1">extension.critical </span><span class="s2">else </span><span class="s6">0</span><span class="s2">, </span><span class="s1">ext_struct</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">create_x509_revoked_certificate(self</span><span class="s2">, </span><span class="s1">builder):</span>
        <span class="s2">if not </span><span class="s1">isinstance(builder</span><span class="s2">, </span><span class="s1">x509.RevokedCertificateBuilder):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Builder type mismatch.&quot;</span><span class="s1">)</span>

        <span class="s1">x509_revoked = self._lib.X509_REVOKED_new()</span>
        <span class="s1">self.openssl_assert(x509_revoked != self._ffi.NULL)</span>
        <span class="s1">x509_revoked = self._ffi.gc(x509_revoked</span><span class="s2">, </span><span class="s1">self._lib.X509_REVOKED_free)</span>
        <span class="s1">serial_number = _encode_asn1_int_gc(self</span><span class="s2">, </span><span class="s1">builder._serial_number)</span>
        <span class="s1">res = self._lib.X509_REVOKED_set_serialNumber(</span>
            <span class="s1">x509_revoked</span><span class="s2">, </span><span class="s1">serial_number</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">rev_date = self._create_asn1_time(builder._revocation_date)</span>
        <span class="s1">res = self._lib.X509_REVOKED_set_revocationDate(x509_revoked</span><span class="s2">, </span><span class="s1">rev_date)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s0"># add CRL entry extensions</span>
        <span class="s1">self._create_x509_extensions(</span>
            <span class="s1">extensions=builder._extensions</span><span class="s2">,</span>
            <span class="s1">handlers=self._crl_entry_extension_encode_handlers</span><span class="s2">,</span>
            <span class="s1">x509_obj=x509_revoked</span><span class="s2">,</span>
            <span class="s1">add_func=self._lib.X509_REVOKED_add_ext</span><span class="s2">,</span>
            <span class="s1">gc=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">_RevokedCertificate(self</span><span class="s2">, None, </span><span class="s1">x509_revoked)</span>

    <span class="s2">def </span><span class="s1">load_pem_private_key(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">password):</span>
        <span class="s2">return </span><span class="s1">self._load_key(</span>
            <span class="s1">self._lib.PEM_read_bio_PrivateKey</span><span class="s2">,</span>
            <span class="s1">self._evp_pkey_to_private_key</span><span class="s2">,</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">password</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">load_pem_public_key(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">evp_pkey = self._lib.PEM_read_bio_PUBKEY(</span>
            <span class="s1">mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">evp_pkey != self._ffi.NULL:</span>
            <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
            <span class="s2">return </span><span class="s1">self._evp_pkey_to_public_key(evp_pkey)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># It's not a (RSA/DSA/ECDSA) subjectPublicKeyInfo, but we still</span>
            <span class="s0"># need to check to see if it is a pure PKCS1 RSA public key (not</span>
            <span class="s0"># embedded in a subjectPublicKeyInfo)</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s1">res = self._lib.BIO_reset(mem_bio.bio)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">rsa_cdata = self._lib.PEM_read_bio_RSAPublicKey(</span>
                <span class="s1">mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">rsa_cdata != self._ffi.NULL:</span>
                <span class="s1">rsa_cdata = self._ffi.gc(rsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.RSA_free)</span>
                <span class="s1">evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)</span>
                <span class="s2">return </span><span class="s1">_RSAPublicKey(self</span><span class="s2">, </span><span class="s1">rsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._handle_key_loading_error()</span>

    <span class="s2">def </span><span class="s1">load_pem_parameters(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s0"># only DH is supported currently</span>
        <span class="s1">dh_cdata = self._lib.PEM_read_bio_DHparams(</span>
            <span class="s1">mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">dh_cdata != self._ffi.NULL:</span>
            <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>
            <span class="s2">return </span><span class="s1">_DHParameters(self</span><span class="s2">, </span><span class="s1">dh_cdata)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._handle_key_loading_error()</span>

    <span class="s2">def </span><span class="s1">load_der_private_key(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">password):</span>
        <span class="s0"># OpenSSL has a function called d2i_AutoPrivateKey that in theory</span>
        <span class="s0"># handles this automatically, however it doesn't handle encrypted</span>
        <span class="s0"># private keys. Instead we try to load the key two different ways.</span>
        <span class="s0"># First we'll try to load it as a traditional key.</span>
        <span class="s1">bio_data = self._bytes_to_bio(data)</span>
        <span class="s1">key = self._evp_pkey_from_der_traditional_key(bio_data</span><span class="s2">, </span><span class="s1">password)</span>
        <span class="s2">if </span><span class="s1">key:</span>
            <span class="s2">return </span><span class="s1">self._evp_pkey_to_private_key(key)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Finally we try to load it with the method that handles encrypted</span>
            <span class="s0"># PKCS8 properly.</span>
            <span class="s2">return </span><span class="s1">self._load_key(</span>
                <span class="s1">self._lib.d2i_PKCS8PrivateKey_bio</span><span class="s2">,</span>
                <span class="s1">self._evp_pkey_to_private_key</span><span class="s2">,</span>
                <span class="s1">data</span><span class="s2">,</span>
                <span class="s1">password</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_evp_pkey_from_der_traditional_key(self</span><span class="s2">, </span><span class="s1">bio_data</span><span class="s2">, </span><span class="s1">password):</span>
        <span class="s1">key = self._lib.d2i_PrivateKey_bio(bio_data.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">key != self._ffi.NULL:</span>
            <span class="s1">key = self._ffi.gc(key</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
            <span class="s2">if </span><span class="s1">password </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span>
                    <span class="s3">&quot;Password was given but private key is not encrypted.&quot;</span>
                <span class="s1">)</span>

            <span class="s2">return </span><span class="s1">key</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">load_der_public_key(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">evp_pkey = self._lib.d2i_PUBKEY_bio(mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">evp_pkey != self._ffi.NULL:</span>
            <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
            <span class="s2">return </span><span class="s1">self._evp_pkey_to_public_key(evp_pkey)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># It's not a (RSA/DSA/ECDSA) subjectPublicKeyInfo, but we still</span>
            <span class="s0"># need to check to see if it is a pure PKCS1 RSA public key (not</span>
            <span class="s0"># embedded in a subjectPublicKeyInfo)</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s1">res = self._lib.BIO_reset(mem_bio.bio)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">rsa_cdata = self._lib.d2i_RSAPublicKey_bio(</span>
                <span class="s1">mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">rsa_cdata != self._ffi.NULL:</span>
                <span class="s1">rsa_cdata = self._ffi.gc(rsa_cdata</span><span class="s2">, </span><span class="s1">self._lib.RSA_free)</span>
                <span class="s1">evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)</span>
                <span class="s2">return </span><span class="s1">_RSAPublicKey(self</span><span class="s2">, </span><span class="s1">rsa_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._handle_key_loading_error()</span>

    <span class="s2">def </span><span class="s1">load_der_parameters(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">dh_cdata = self._lib.d2i_DHparams_bio(mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">dh_cdata != self._ffi.NULL:</span>
            <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>
            <span class="s2">return </span><span class="s1">_DHParameters(self</span><span class="s2">, </span><span class="s1">dh_cdata)</span>
        <span class="s2">elif </span><span class="s1">self._lib.Cryptography_HAS_EVP_PKEY_DHX:</span>
            <span class="s0"># We check to see if the is dhx.</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s1">res = self._lib.BIO_reset(mem_bio.bio)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">dh_cdata = self._lib.Cryptography_d2i_DHxparams_bio(</span>
                <span class="s1">mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">dh_cdata != self._ffi.NULL:</span>
                <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>
                <span class="s2">return </span><span class="s1">_DHParameters(self</span><span class="s2">, </span><span class="s1">dh_cdata)</span>

        <span class="s1">self._handle_key_loading_error()</span>

    <span class="s2">def </span><span class="s1">load_pem_x509_certificate(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">x509 = self._lib.PEM_read_bio_X509(</span>
            <span class="s1">mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">x509 == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Unable to load certificate. See https://cryptography.io/en/&quot;</span>
                <span class="s3">&quot;latest/faq.html#why-can-t-i-import-my-pem-file for more&quot;</span>
                <span class="s3">&quot; details.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">x509 = self._ffi.gc(x509</span><span class="s2">, </span><span class="s1">self._lib.X509_free)</span>
        <span class="s2">return </span><span class="s1">_Certificate(self</span><span class="s2">, </span><span class="s1">x509)</span>

    <span class="s2">def </span><span class="s1">load_der_x509_certificate(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">x509 = self._lib.d2i_X509_bio(mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">x509 == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unable to load certificate&quot;</span><span class="s1">)</span>

        <span class="s1">x509 = self._ffi.gc(x509</span><span class="s2">, </span><span class="s1">self._lib.X509_free)</span>
        <span class="s2">return </span><span class="s1">_Certificate(self</span><span class="s2">, </span><span class="s1">x509)</span>

    <span class="s2">def </span><span class="s1">load_pem_x509_crl(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">x509_crl = self._lib.PEM_read_bio_X509_CRL(</span>
            <span class="s1">mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">x509_crl == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Unable to load CRL. See https://cryptography.io/en/la&quot;</span>
                <span class="s3">&quot;test/faq.html#why-can-t-i-import-my-pem-file for more&quot;</span>
                <span class="s3">&quot; details.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">x509_crl = self._ffi.gc(x509_crl</span><span class="s2">, </span><span class="s1">self._lib.X509_CRL_free)</span>
        <span class="s2">return </span><span class="s1">_CertificateRevocationList(self</span><span class="s2">, </span><span class="s1">x509_crl)</span>

    <span class="s2">def </span><span class="s1">load_der_x509_crl(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">x509_crl = self._lib.d2i_X509_CRL_bio(mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">x509_crl == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unable to load CRL&quot;</span><span class="s1">)</span>

        <span class="s1">x509_crl = self._ffi.gc(x509_crl</span><span class="s2">, </span><span class="s1">self._lib.X509_CRL_free)</span>
        <span class="s2">return </span><span class="s1">_CertificateRevocationList(self</span><span class="s2">, </span><span class="s1">x509_crl)</span>

    <span class="s2">def </span><span class="s1">load_pem_x509_csr(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">x509_req = self._lib.PEM_read_bio_X509_REQ(</span>
            <span class="s1">mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">x509_req == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Unable to load request. See https://cryptography.io/en/&quot;</span>
                <span class="s3">&quot;latest/faq.html#why-can-t-i-import-my-pem-file for more&quot;</span>
                <span class="s3">&quot; details.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">x509_req = self._ffi.gc(x509_req</span><span class="s2">, </span><span class="s1">self._lib.X509_REQ_free)</span>
        <span class="s2">return </span><span class="s1">_CertificateSigningRequest(self</span><span class="s2">, </span><span class="s1">x509_req)</span>

    <span class="s2">def </span><span class="s1">load_der_x509_csr(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">x509_req = self._lib.d2i_X509_REQ_bio(mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">x509_req == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unable to load request&quot;</span><span class="s1">)</span>

        <span class="s1">x509_req = self._ffi.gc(x509_req</span><span class="s2">, </span><span class="s1">self._lib.X509_REQ_free)</span>
        <span class="s2">return </span><span class="s1">_CertificateSigningRequest(self</span><span class="s2">, </span><span class="s1">x509_req)</span>

    <span class="s2">def </span><span class="s1">_load_key(self</span><span class="s2">, </span><span class="s1">openssl_read_func</span><span class="s2">, </span><span class="s1">convert_func</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">password):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>

        <span class="s1">userdata = self._ffi.new(</span><span class="s3">&quot;CRYPTOGRAPHY_PASSWORD_DATA *&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">password </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">utils._check_byteslike(</span><span class="s3">&quot;password&quot;</span><span class="s2">, </span><span class="s1">password)</span>
            <span class="s1">password_ptr = self._ffi.from_buffer(password)</span>
            <span class="s1">userdata.password = password_ptr</span>
            <span class="s1">userdata.length = len(password)</span>

        <span class="s1">evp_pkey = openssl_read_func(</span>
            <span class="s1">mem_bio.bio</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s1">self._ffi.addressof(</span>
                <span class="s1">self._lib._original_lib</span><span class="s2">, </span><span class="s3">&quot;Cryptography_pem_password_cb&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">userdata</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">evp_pkey == self._ffi.NULL:</span>
            <span class="s2">if </span><span class="s1">userdata.error != </span><span class="s6">0</span><span class="s1">:</span>
                <span class="s1">self._consume_errors()</span>
                <span class="s2">if </span><span class="s1">userdata.error == -</span><span class="s6">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">TypeError(</span>
                        <span class="s3">&quot;Password was not given but private key is encrypted&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">assert </span><span class="s1">userdata.error == -</span><span class="s6">2</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;Passwords longer than {} bytes are not supported &quot;</span>
                        <span class="s3">&quot;by this backend.&quot;</span><span class="s1">.format(userdata.maxsize - </span><span class="s6">1</span><span class="s1">)</span>
                    <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._handle_key_loading_error()</span>

        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>

        <span class="s2">if </span><span class="s1">password </span><span class="s2">is not None and </span><span class="s1">userdata.called == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;Password was given but private key is not encrypted.&quot;</span>
            <span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">password </span><span class="s2">is not None and </span><span class="s1">userdata.called == </span><span class="s6">1</span>
        <span class="s1">) </span><span class="s2">or </span><span class="s1">password </span><span class="s2">is None</span>

        <span class="s2">return </span><span class="s1">convert_func(evp_pkey)</span>

    <span class="s2">def </span><span class="s1">_handle_key_loading_error(self):</span>
        <span class="s1">errors = self._consume_errors()</span>

        <span class="s2">if not </span><span class="s1">errors:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Could not deserialize key data. The data may be in an &quot;</span>
                <span class="s3">&quot;incorrect format or it may be encrypted with an unsupported &quot;</span>
                <span class="s3">&quot;algorithm.&quot;</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">errors[</span><span class="s6">0</span><span class="s1">]._lib_reason_match(</span>
            <span class="s1">self._lib.ERR_LIB_EVP</span><span class="s2">, </span><span class="s1">self._lib.EVP_R_BAD_DECRYPT</span>
        <span class="s1">) </span><span class="s2">or </span><span class="s1">errors[</span><span class="s6">0</span><span class="s1">]._lib_reason_match(</span>
            <span class="s1">self._lib.ERR_LIB_PKCS12</span><span class="s2">,</span>
            <span class="s1">self._lib.PKCS12_R_PKCS12_CIPHERFINAL_ERROR</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Bad decrypt. Incorrect password?&quot;</span><span class="s1">)</span>

        <span class="s2">elif </span><span class="s1">any(</span>
            <span class="s1">error._lib_reason_match(</span>
                <span class="s1">self._lib.ERR_LIB_EVP</span><span class="s2">,</span>
                <span class="s1">self._lib.EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s2">for </span><span class="s1">error </span><span class="s2">in </span><span class="s1">errors</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unsupported public key algorithm.&quot;</span><span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Could not deserialize key data. The data may be in an &quot;</span>
                <span class="s3">&quot;incorrect format or it may be encrypted with an unsupported &quot;</span>
                <span class="s3">&quot;algorithm.&quot;</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">elliptic_curve_supported(self</span><span class="s2">, </span><span class="s1">curve):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">curve_nid = self._elliptic_curve_to_nid(curve)</span>
        <span class="s2">except </span><span class="s1">UnsupportedAlgorithm:</span>
            <span class="s1">curve_nid = self._lib.NID_undef</span>

        <span class="s1">group = self._lib.EC_GROUP_new_by_curve_name(curve_nid)</span>

        <span class="s2">if </span><span class="s1">group == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">return False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.openssl_assert(curve_nid != self._lib.NID_undef)</span>
            <span class="s1">self._lib.EC_GROUP_free(group)</span>
            <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">elliptic_curve_signature_algorithm_supported(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">signature_algorithm</span><span class="s2">, </span><span class="s1">curve</span>
    <span class="s1">):</span>
        <span class="s0"># We only support ECDSA right now.</span>
        <span class="s2">if not </span><span class="s1">isinstance(signature_algorithm</span><span class="s2">, </span><span class="s1">ec.ECDSA):</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">self.elliptic_curve_supported(curve)</span>

    <span class="s2">def </span><span class="s1">generate_elliptic_curve_private_key(self</span><span class="s2">, </span><span class="s1">curve):</span>
        <span class="s4">&quot;&quot;&quot; 
        Generate a new private key on the named curve. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.elliptic_curve_supported(curve):</span>
            <span class="s1">ec_cdata = self._ec_key_new_by_curve(curve)</span>

            <span class="s1">res = self._lib.EC_KEY_generate_key(ec_cdata)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

            <span class="s1">evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)</span>

            <span class="s2">return </span><span class="s1">_EllipticCurvePrivateKey(self</span><span class="s2">, </span><span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">UnsupportedAlgorithm(</span>
                <span class="s3">&quot;Backend object does not support {}.&quot;</span><span class="s1">.format(curve.name)</span><span class="s2">,</span>
                <span class="s1">_Reasons.UNSUPPORTED_ELLIPTIC_CURVE</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">load_elliptic_curve_private_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">public = numbers.public_numbers</span>

        <span class="s1">ec_cdata = self._ec_key_new_by_curve(public.curve)</span>

        <span class="s1">private_value = self._ffi.gc(</span>
            <span class="s1">self._int_to_bn(numbers.private_value)</span><span class="s2">, </span><span class="s1">self._lib.BN_clear_free</span>
        <span class="s1">)</span>
        <span class="s1">res = self._lib.EC_KEY_set_private_key(ec_cdata</span><span class="s2">, </span><span class="s1">private_value)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">ec_cdata = self._ec_key_set_public_key_affine_coordinates(</span>
            <span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">public.x</span><span class="s2">, </span><span class="s1">public.y</span>
        <span class="s1">)</span>

        <span class="s1">evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)</span>

        <span class="s2">return </span><span class="s1">_EllipticCurvePrivateKey(self</span><span class="s2">, </span><span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">load_elliptic_curve_public_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">ec_cdata = self._ec_key_new_by_curve(numbers.curve)</span>
        <span class="s1">ec_cdata = self._ec_key_set_public_key_affine_coordinates(</span>
            <span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">numbers.x</span><span class="s2">, </span><span class="s1">numbers.y</span>
        <span class="s1">)</span>
        <span class="s1">evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)</span>

        <span class="s2">return </span><span class="s1">_EllipticCurvePublicKey(self</span><span class="s2">, </span><span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">load_elliptic_curve_public_bytes(self</span><span class="s2">, </span><span class="s1">curve</span><span class="s2">, </span><span class="s1">point_bytes):</span>
        <span class="s1">ec_cdata = self._ec_key_new_by_curve(curve)</span>
        <span class="s1">group = self._lib.EC_KEY_get0_group(ec_cdata)</span>
        <span class="s1">self.openssl_assert(group != self._ffi.NULL)</span>
        <span class="s1">point = self._lib.EC_POINT_new(group)</span>
        <span class="s1">self.openssl_assert(point != self._ffi.NULL)</span>
        <span class="s1">point = self._ffi.gc(point</span><span class="s2">, </span><span class="s1">self._lib.EC_POINT_free)</span>
        <span class="s2">with </span><span class="s1">self._tmp_bn_ctx() </span><span class="s2">as </span><span class="s1">bn_ctx:</span>
            <span class="s1">res = self._lib.EC_POINT_oct2point(</span>
                <span class="s1">group</span><span class="s2">, </span><span class="s1">point</span><span class="s2">, </span><span class="s1">point_bytes</span><span class="s2">, </span><span class="s1">len(point_bytes)</span><span class="s2">, </span><span class="s1">bn_ctx</span>
            <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">res != </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s1">self._consume_errors()</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid public bytes for the given curve&quot;</span><span class="s1">)</span>

        <span class="s1">res = self._lib.EC_KEY_set_public_key(ec_cdata</span><span class="s2">, </span><span class="s1">point)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)</span>
        <span class="s2">return </span><span class="s1">_EllipticCurvePublicKey(self</span><span class="s2">, </span><span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">derive_elliptic_curve_private_key(self</span><span class="s2">, </span><span class="s1">private_value</span><span class="s2">, </span><span class="s1">curve):</span>
        <span class="s1">ec_cdata = self._ec_key_new_by_curve(curve)</span>

        <span class="s1">get_func</span><span class="s2">, </span><span class="s1">group = self._ec_key_determine_group_get_func(ec_cdata)</span>

        <span class="s1">point = self._lib.EC_POINT_new(group)</span>
        <span class="s1">self.openssl_assert(point != self._ffi.NULL)</span>
        <span class="s1">point = self._ffi.gc(point</span><span class="s2">, </span><span class="s1">self._lib.EC_POINT_free)</span>

        <span class="s1">value = self._int_to_bn(private_value)</span>
        <span class="s1">value = self._ffi.gc(value</span><span class="s2">, </span><span class="s1">self._lib.BN_clear_free)</span>

        <span class="s2">with </span><span class="s1">self._tmp_bn_ctx() </span><span class="s2">as </span><span class="s1">bn_ctx:</span>
            <span class="s1">res = self._lib.EC_POINT_mul(</span>
                <span class="s1">group</span><span class="s2">, </span><span class="s1">point</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">bn_ctx</span>
            <span class="s1">)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

            <span class="s1">bn_x = self._lib.BN_CTX_get(bn_ctx)</span>
            <span class="s1">bn_y = self._lib.BN_CTX_get(bn_ctx)</span>

            <span class="s1">res = get_func(group</span><span class="s2">, </span><span class="s1">point</span><span class="s2">, </span><span class="s1">bn_x</span><span class="s2">, </span><span class="s1">bn_y</span><span class="s2">, </span><span class="s1">bn_ctx)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">res = self._lib.EC_KEY_set_public_key(ec_cdata</span><span class="s2">, </span><span class="s1">point)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">private = self._int_to_bn(private_value)</span>
        <span class="s1">private = self._ffi.gc(private</span><span class="s2">, </span><span class="s1">self._lib.BN_clear_free)</span>
        <span class="s1">res = self._lib.EC_KEY_set_private_key(ec_cdata</span><span class="s2">, </span><span class="s1">private)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)</span>

        <span class="s2">return </span><span class="s1">_EllipticCurvePrivateKey(self</span><span class="s2">, </span><span class="s1">ec_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">_ec_key_new_by_curve(self</span><span class="s2">, </span><span class="s1">curve):</span>
        <span class="s1">curve_nid = self._elliptic_curve_to_nid(curve)</span>
        <span class="s2">return </span><span class="s1">self._ec_key_new_by_curve_nid(curve_nid)</span>

    <span class="s2">def </span><span class="s1">_ec_key_new_by_curve_nid(self</span><span class="s2">, </span><span class="s1">curve_nid):</span>
        <span class="s1">ec_cdata = self._lib.EC_KEY_new_by_curve_name(curve_nid)</span>
        <span class="s1">self.openssl_assert(ec_cdata != self._ffi.NULL)</span>
        <span class="s2">return </span><span class="s1">self._ffi.gc(ec_cdata</span><span class="s2">, </span><span class="s1">self._lib.EC_KEY_free)</span>

    <span class="s2">def </span><span class="s1">load_der_ocsp_request(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">request = self._lib.d2i_OCSP_REQUEST_bio(mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">request == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unable to load OCSP request&quot;</span><span class="s1">)</span>

        <span class="s1">request = self._ffi.gc(request</span><span class="s2">, </span><span class="s1">self._lib.OCSP_REQUEST_free)</span>
        <span class="s2">return </span><span class="s1">_OCSPRequest(self</span><span class="s2">, </span><span class="s1">request)</span>

    <span class="s2">def </span><span class="s1">load_der_ocsp_response(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">mem_bio = self._bytes_to_bio(data)</span>
        <span class="s1">response = self._lib.d2i_OCSP_RESPONSE_bio(mem_bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">response == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unable to load OCSP response&quot;</span><span class="s1">)</span>

        <span class="s1">response = self._ffi.gc(response</span><span class="s2">, </span><span class="s1">self._lib.OCSP_RESPONSE_free)</span>
        <span class="s2">return </span><span class="s1">_OCSPResponse(self</span><span class="s2">, </span><span class="s1">response)</span>

    <span class="s2">def </span><span class="s1">create_ocsp_request(self</span><span class="s2">, </span><span class="s1">builder):</span>
        <span class="s1">ocsp_req = self._lib.OCSP_REQUEST_new()</span>
        <span class="s1">self.openssl_assert(ocsp_req != self._ffi.NULL)</span>
        <span class="s1">ocsp_req = self._ffi.gc(ocsp_req</span><span class="s2">, </span><span class="s1">self._lib.OCSP_REQUEST_free)</span>
        <span class="s1">cert</span><span class="s2">, </span><span class="s1">issuer</span><span class="s2">, </span><span class="s1">algorithm = builder._request</span>
        <span class="s1">evp_md = self._evp_md_non_null_from_algorithm(algorithm)</span>
        <span class="s1">certid = self._lib.OCSP_cert_to_id(evp_md</span><span class="s2">, </span><span class="s1">cert._x509</span><span class="s2">, </span><span class="s1">issuer._x509)</span>
        <span class="s1">self.openssl_assert(certid != self._ffi.NULL)</span>
        <span class="s1">onereq = self._lib.OCSP_request_add0_id(ocsp_req</span><span class="s2">, </span><span class="s1">certid)</span>
        <span class="s1">self.openssl_assert(onereq != self._ffi.NULL)</span>
        <span class="s1">self._create_x509_extensions(</span>
            <span class="s1">extensions=builder._extensions</span><span class="s2">,</span>
            <span class="s1">handlers=self._ocsp_request_extension_encode_handlers</span><span class="s2">,</span>
            <span class="s1">x509_obj=ocsp_req</span><span class="s2">,</span>
            <span class="s1">add_func=self._lib.OCSP_REQUEST_add_ext</span><span class="s2">,</span>
            <span class="s1">gc=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">_OCSPRequest(self</span><span class="s2">, </span><span class="s1">ocsp_req)</span>

    <span class="s2">def </span><span class="s1">_create_ocsp_basic_response(self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">algorithm):</span>
        <span class="s1">self._x509_check_signature_params(private_key</span><span class="s2">, </span><span class="s1">algorithm)</span>

        <span class="s1">basic = self._lib.OCSP_BASICRESP_new()</span>
        <span class="s1">self.openssl_assert(basic != self._ffi.NULL)</span>
        <span class="s1">basic = self._ffi.gc(basic</span><span class="s2">, </span><span class="s1">self._lib.OCSP_BASICRESP_free)</span>
        <span class="s1">evp_md = self._evp_md_non_null_from_algorithm(</span>
            <span class="s1">builder._response._algorithm</span>
        <span class="s1">)</span>
        <span class="s1">certid = self._lib.OCSP_cert_to_id(</span>
            <span class="s1">evp_md</span><span class="s2">,</span>
            <span class="s1">builder._response._cert._x509</span><span class="s2">,</span>
            <span class="s1">builder._response._issuer._x509</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(certid != self._ffi.NULL)</span>
        <span class="s1">certid = self._ffi.gc(certid</span><span class="s2">, </span><span class="s1">self._lib.OCSP_CERTID_free)</span>
        <span class="s2">if </span><span class="s1">builder._response._revocation_reason </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">reason = -</span><span class="s6">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">reason = _CRL_ENTRY_REASON_ENUM_TO_CODE[</span>
                <span class="s1">builder._response._revocation_reason</span>
            <span class="s1">]</span>
        <span class="s2">if </span><span class="s1">builder._response._revocation_time </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rev_time = self._ffi.NULL</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rev_time = self._create_asn1_time(</span>
                <span class="s1">builder._response._revocation_time</span>
            <span class="s1">)</span>

        <span class="s1">next_update = self._ffi.NULL</span>
        <span class="s2">if </span><span class="s1">builder._response._next_update </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">next_update = self._create_asn1_time(</span>
                <span class="s1">builder._response._next_update</span>
            <span class="s1">)</span>

        <span class="s1">this_update = self._create_asn1_time(builder._response._this_update)</span>

        <span class="s1">res = self._lib.OCSP_basic_add1_status(</span>
            <span class="s1">basic</span><span class="s2">,</span>
            <span class="s1">certid</span><span class="s2">,</span>
            <span class="s1">builder._response._cert_status.value</span><span class="s2">,</span>
            <span class="s1">reason</span><span class="s2">,</span>
            <span class="s1">rev_time</span><span class="s2">,</span>
            <span class="s1">this_update</span><span class="s2">,</span>
            <span class="s1">next_update</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res != self._ffi.NULL)</span>
        <span class="s0"># okay, now sign the basic structure</span>
        <span class="s1">evp_md = self._evp_md_x509_null_if_eddsa(private_key</span><span class="s2">, </span><span class="s1">algorithm)</span>
        <span class="s1">responder_cert</span><span class="s2">, </span><span class="s1">responder_encoding = builder._responder_id</span>
        <span class="s1">flags = self._lib.OCSP_NOCERTS</span>
        <span class="s2">if </span><span class="s1">responder_encoding </span><span class="s2">is </span><span class="s1">ocsp.OCSPResponderEncoding.HASH:</span>
            <span class="s1">flags |= self._lib.OCSP_RESPID_KEY</span>

        <span class="s2">if </span><span class="s1">builder._certs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">cert </span><span class="s2">in </span><span class="s1">builder._certs:</span>
                <span class="s1">res = self._lib.OCSP_basic_add1_cert(basic</span><span class="s2">, </span><span class="s1">cert._x509)</span>
                <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">self._create_x509_extensions(</span>
            <span class="s1">extensions=builder._extensions</span><span class="s2">,</span>
            <span class="s1">handlers=self._ocsp_basicresp_extension_encode_handlers</span><span class="s2">,</span>
            <span class="s1">x509_obj=basic</span><span class="s2">,</span>
            <span class="s1">add_func=self._lib.OCSP_BASICRESP_add_ext</span><span class="s2">,</span>
            <span class="s1">gc=</span><span class="s2">True,</span>
        <span class="s1">)</span>

        <span class="s1">res = self._lib.OCSP_basic_sign(</span>
            <span class="s1">basic</span><span class="s2">,</span>
            <span class="s1">responder_cert._x509</span><span class="s2">,</span>
            <span class="s1">private_key._evp_pkey</span><span class="s2">,</span>
            <span class="s1">evp_md</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s1">flags</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">res != </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s1">errors = self._consume_errors_with_text()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Error while signing. responder_cert must be signed &quot;</span>
                <span class="s3">&quot;by private_key&quot;</span><span class="s2">,</span>
                <span class="s1">errors</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">basic</span>

    <span class="s2">def </span><span class="s1">create_ocsp_response(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">response_status</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">algorithm</span>
    <span class="s1">):</span>
        <span class="s2">if </span><span class="s1">response_status </span><span class="s2">is </span><span class="s1">ocsp.OCSPResponseStatus.SUCCESSFUL:</span>
            <span class="s1">basic = self._create_ocsp_basic_response(</span>
                <span class="s1">builder</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">algorithm</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">basic = self._ffi.NULL</span>

        <span class="s1">ocsp_resp = self._lib.OCSP_response_create(</span>
            <span class="s1">response_status.value</span><span class="s2">, </span><span class="s1">basic</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(ocsp_resp != self._ffi.NULL)</span>
        <span class="s1">ocsp_resp = self._ffi.gc(ocsp_resp</span><span class="s2">, </span><span class="s1">self._lib.OCSP_RESPONSE_free)</span>
        <span class="s2">return </span><span class="s1">_OCSPResponse(self</span><span class="s2">, </span><span class="s1">ocsp_resp)</span>

    <span class="s2">def </span><span class="s1">elliptic_curve_exchange_algorithm_supported(self</span><span class="s2">, </span><span class="s1">algorithm</span><span class="s2">, </span><span class="s1">curve):</span>
        <span class="s2">return </span><span class="s1">self.elliptic_curve_supported(curve) </span><span class="s2">and </span><span class="s1">isinstance(</span>
            <span class="s1">algorithm</span><span class="s2">, </span><span class="s1">ec.ECDH</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_ec_cdata_to_evp_pkey(self</span><span class="s2">, </span><span class="s1">ec_cdata):</span>
        <span class="s1">evp_pkey = self._create_evp_pkey_gc()</span>
        <span class="s1">res = self._lib.EVP_PKEY_set1_EC_KEY(evp_pkey</span><span class="s2">, </span><span class="s1">ec_cdata)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">evp_pkey</span>

    <span class="s2">def </span><span class="s1">_elliptic_curve_to_nid(self</span><span class="s2">, </span><span class="s1">curve):</span>
        <span class="s4">&quot;&quot;&quot; 
        Get the NID for a curve name. 
        &quot;&quot;&quot;</span>

        <span class="s1">curve_aliases = {</span><span class="s3">&quot;secp192r1&quot;</span><span class="s1">: </span><span class="s3">&quot;prime192v1&quot;</span><span class="s2">, </span><span class="s3">&quot;secp256r1&quot;</span><span class="s1">: </span><span class="s3">&quot;prime256v1&quot;</span><span class="s1">}</span>

        <span class="s1">curve_name = curve_aliases.get(curve.name</span><span class="s2">, </span><span class="s1">curve.name)</span>

        <span class="s1">curve_nid = self._lib.OBJ_sn2nid(curve_name.encode())</span>
        <span class="s2">if </span><span class="s1">curve_nid == self._lib.NID_undef:</span>
            <span class="s2">raise </span><span class="s1">UnsupportedAlgorithm(</span>
                <span class="s3">&quot;{} is not a supported elliptic curve&quot;</span><span class="s1">.format(curve.name)</span><span class="s2">,</span>
                <span class="s1">_Reasons.UNSUPPORTED_ELLIPTIC_CURVE</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">curve_nid</span>

    <span class="s1">@contextmanager</span>
    <span class="s2">def </span><span class="s1">_tmp_bn_ctx(self):</span>
        <span class="s1">bn_ctx = self._lib.BN_CTX_new()</span>
        <span class="s1">self.openssl_assert(bn_ctx != self._ffi.NULL)</span>
        <span class="s1">bn_ctx = self._ffi.gc(bn_ctx</span><span class="s2">, </span><span class="s1">self._lib.BN_CTX_free)</span>
        <span class="s1">self._lib.BN_CTX_start(bn_ctx)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">bn_ctx</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self._lib.BN_CTX_end(bn_ctx)</span>

    <span class="s2">def </span><span class="s1">_ec_key_determine_group_get_func(self</span><span class="s2">, </span><span class="s1">ctx):</span>
        <span class="s4">&quot;&quot;&quot; 
        Given an EC_KEY determine the group and what function is required to 
        get point coordinates. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.openssl_assert(ctx != self._ffi.NULL)</span>

        <span class="s1">nid_two_field = self._lib.OBJ_sn2nid(</span><span class="s5">b&quot;characteristic-two-field&quot;</span><span class="s1">)</span>
        <span class="s1">self.openssl_assert(nid_two_field != self._lib.NID_undef)</span>

        <span class="s1">group = self._lib.EC_KEY_get0_group(ctx)</span>
        <span class="s1">self.openssl_assert(group != self._ffi.NULL)</span>

        <span class="s1">method = self._lib.EC_GROUP_method_of(group)</span>
        <span class="s1">self.openssl_assert(method != self._ffi.NULL)</span>

        <span class="s1">nid = self._lib.EC_METHOD_get_field_type(method)</span>
        <span class="s1">self.openssl_assert(nid != self._lib.NID_undef)</span>

        <span class="s2">if </span><span class="s1">nid == nid_two_field </span><span class="s2">and </span><span class="s1">self._lib.Cryptography_HAS_EC2M:</span>
            <span class="s1">get_func = self._lib.EC_POINT_get_affine_coordinates_GF2m</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">get_func = self._lib.EC_POINT_get_affine_coordinates_GFp</span>

        <span class="s2">assert </span><span class="s1">get_func</span>

        <span class="s2">return </span><span class="s1">get_func</span><span class="s2">, </span><span class="s1">group</span>

    <span class="s2">def </span><span class="s1">_ec_key_set_public_key_affine_coordinates(self</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y):</span>
        <span class="s4">&quot;&quot;&quot; 
        Sets the public key point in the EC_KEY context to the affine x and y 
        values. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">x &lt; </span><span class="s6">0 </span><span class="s2">or </span><span class="s1">y &lt; </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;Invalid EC key. Both x and y must be non-negative.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">x = self._ffi.gc(self._int_to_bn(x)</span><span class="s2">, </span><span class="s1">self._lib.BN_free)</span>
        <span class="s1">y = self._ffi.gc(self._int_to_bn(y)</span><span class="s2">, </span><span class="s1">self._lib.BN_free)</span>
        <span class="s1">res = self._lib.EC_KEY_set_public_key_affine_coordinates(ctx</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y)</span>
        <span class="s2">if </span><span class="s1">res != </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid EC key.&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">ctx</span>

    <span class="s2">def </span><span class="s1">_private_key_bytes(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">encryption_algorithm</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">evp_pkey</span><span class="s2">, </span><span class="s1">cdata</span>
    <span class="s1">):</span>
        <span class="s0"># validate argument types</span>
        <span class="s2">if not </span><span class="s1">isinstance(encoding</span><span class="s2">, </span><span class="s1">serialization.Encoding):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;encoding must be an item from the Encoding enum&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(format</span><span class="s2">, </span><span class="s1">serialization.PrivateFormat):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;format must be an item from the PrivateFormat enum&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(</span>
            <span class="s1">encryption_algorithm</span><span class="s2">, </span><span class="s1">serialization.KeySerializationEncryption</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;Encryption algorithm must be a KeySerializationEncryption &quot;</span>
                <span class="s3">&quot;instance&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># validate password</span>
        <span class="s2">if </span><span class="s1">isinstance(encryption_algorithm</span><span class="s2">, </span><span class="s1">serialization.NoEncryption):</span>
            <span class="s1">password = </span><span class="s5">b&quot;&quot;</span>
        <span class="s2">elif </span><span class="s1">isinstance(</span>
            <span class="s1">encryption_algorithm</span><span class="s2">, </span><span class="s1">serialization.BestAvailableEncryption</span>
        <span class="s1">):</span>
            <span class="s1">password = encryption_algorithm.password</span>
            <span class="s2">if </span><span class="s1">len(password) &gt; </span><span class="s6">1023</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Passwords longer than 1023 bytes are not supported by &quot;</span>
                    <span class="s3">&quot;this backend&quot;</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unsupported encryption type&quot;</span><span class="s1">)</span>

        <span class="s0"># PKCS8 + PEM/DER</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is </span><span class="s1">serialization.PrivateFormat.PKCS8:</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.PEM:</span>
                <span class="s1">write_bio = self._lib.PEM_write_bio_PKCS8PrivateKey</span>
            <span class="s2">elif </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.DER:</span>
                <span class="s1">write_bio = self._lib.i2d_PKCS8PrivateKey_bio</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unsupported encoding for PKCS8&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self._private_key_bytes_via_bio(</span>
                <span class="s1">write_bio</span><span class="s2">, </span><span class="s1">evp_pkey</span><span class="s2">, </span><span class="s1">password</span>
            <span class="s1">)</span>

        <span class="s0"># TraditionalOpenSSL + PEM/DER</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is </span><span class="s1">serialization.PrivateFormat.TraditionalOpenSSL:</span>
            <span class="s2">if </span><span class="s1">self._fips_enabled </span><span class="s2">and not </span><span class="s1">isinstance(</span>
                <span class="s1">encryption_algorithm</span><span class="s2">, </span><span class="s1">serialization.NoEncryption</span>
            <span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Encrypted traditional OpenSSL format is not &quot;</span>
                    <span class="s3">&quot;supported in FIPS mode.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">key_type = self._lib.EVP_PKEY_id(evp_pkey)</span>

            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.PEM:</span>
                <span class="s2">if </span><span class="s1">key_type == self._lib.EVP_PKEY_RSA:</span>
                    <span class="s1">write_bio = self._lib.PEM_write_bio_RSAPrivateKey</span>
                <span class="s2">elif </span><span class="s1">key_type == self._lib.EVP_PKEY_DSA:</span>
                    <span class="s1">write_bio = self._lib.PEM_write_bio_DSAPrivateKey</span>
                <span class="s2">elif </span><span class="s1">key_type == self._lib.EVP_PKEY_EC:</span>
                    <span class="s1">write_bio = self._lib.PEM_write_bio_ECPrivateKey</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;Unsupported key type for TraditionalOpenSSL&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">self._private_key_bytes_via_bio(</span>
                    <span class="s1">write_bio</span><span class="s2">, </span><span class="s1">cdata</span><span class="s2">, </span><span class="s1">password</span>
                <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.DER:</span>
                <span class="s2">if </span><span class="s1">password:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;Encryption is not supported for DER encoded &quot;</span>
                        <span class="s3">&quot;traditional OpenSSL keys&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">key_type == self._lib.EVP_PKEY_RSA:</span>
                    <span class="s1">write_bio = self._lib.i2d_RSAPrivateKey_bio</span>
                <span class="s2">elif </span><span class="s1">key_type == self._lib.EVP_PKEY_EC:</span>
                    <span class="s1">write_bio = self._lib.i2d_ECPrivateKey_bio</span>
                <span class="s2">elif </span><span class="s1">key_type == self._lib.EVP_PKEY_DSA:</span>
                    <span class="s1">write_bio = self._lib.i2d_DSAPrivateKey_bio</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;Unsupported key type for TraditionalOpenSSL&quot;</span>
                    <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">self._bio_func_output(write_bio</span><span class="s2">, </span><span class="s1">cdata)</span>

            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unsupported encoding for TraditionalOpenSSL&quot;</span><span class="s1">)</span>

        <span class="s0"># OpenSSH + PEM</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is </span><span class="s1">serialization.PrivateFormat.OpenSSH:</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.PEM:</span>
                <span class="s2">return </span><span class="s1">ssh.serialize_ssh_private_key(key</span><span class="s2">, </span><span class="s1">password)</span>

            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;OpenSSH private key format can only be used&quot;</span>
                <span class="s3">&quot; with PEM encoding&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># Anything that key-specific code was supposed to handle earlier,</span>
        <span class="s0"># like Raw.</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;format is invalid with this key&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_private_key_bytes_via_bio(self</span><span class="s2">, </span><span class="s1">write_bio</span><span class="s2">, </span><span class="s1">evp_pkey</span><span class="s2">, </span><span class="s1">password):</span>
        <span class="s2">if not </span><span class="s1">password:</span>
            <span class="s1">evp_cipher = self._ffi.NULL</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># This is a curated value that we will update over time.</span>
            <span class="s1">evp_cipher = self._lib.EVP_get_cipherbyname(</span><span class="s5">b&quot;aes-256-cbc&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._bio_func_output(</span>
            <span class="s1">write_bio</span><span class="s2">,</span>
            <span class="s1">evp_pkey</span><span class="s2">,</span>
            <span class="s1">evp_cipher</span><span class="s2">,</span>
            <span class="s1">password</span><span class="s2">,</span>
            <span class="s1">len(password)</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_bio_func_output(self</span><span class="s2">, </span><span class="s1">write_bio</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">bio = self._create_mem_bio_gc()</span>
        <span class="s1">res = write_bio(bio</span><span class="s2">, </span><span class="s1">*args)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._read_mem_bio(bio)</span>

    <span class="s2">def </span><span class="s1">_public_key_bytes(self</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">evp_pkey</span><span class="s2">, </span><span class="s1">cdata):</span>
        <span class="s2">if not </span><span class="s1">isinstance(encoding</span><span class="s2">, </span><span class="s1">serialization.Encoding):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;encoding must be an item from the Encoding enum&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(format</span><span class="s2">, </span><span class="s1">serialization.PublicFormat):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s3">&quot;format must be an item from the PublicFormat enum&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># SubjectPublicKeyInfo + PEM/DER</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is </span><span class="s1">serialization.PublicFormat.SubjectPublicKeyInfo:</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.PEM:</span>
                <span class="s1">write_bio = self._lib.PEM_write_bio_PUBKEY</span>
            <span class="s2">elif </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.DER:</span>
                <span class="s1">write_bio = self._lib.i2d_PUBKEY_bio</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;SubjectPublicKeyInfo works only with PEM or DER encoding&quot;</span>
                <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self._bio_func_output(write_bio</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

        <span class="s0"># PKCS1 + PEM/DER</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is </span><span class="s1">serialization.PublicFormat.PKCS1:</span>
            <span class="s0"># Only RSA is supported here.</span>
            <span class="s1">key_type = self._lib.EVP_PKEY_id(evp_pkey)</span>
            <span class="s2">if </span><span class="s1">key_type != self._lib.EVP_PKEY_RSA:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;PKCS1 format is supported only for RSA keys&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.PEM:</span>
                <span class="s1">write_bio = self._lib.PEM_write_bio_RSAPublicKey</span>
            <span class="s2">elif </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.DER:</span>
                <span class="s1">write_bio = self._lib.i2d_RSAPublicKey_bio</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;PKCS1 works only with PEM or DER encoding&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">self._bio_func_output(write_bio</span><span class="s2">, </span><span class="s1">cdata)</span>

        <span class="s0"># OpenSSH + OpenSSH</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is </span><span class="s1">serialization.PublicFormat.OpenSSH:</span>
            <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.OpenSSH:</span>
                <span class="s2">return </span><span class="s1">ssh.serialize_ssh_public_key(key)</span>

            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;OpenSSH format must be used with OpenSSH encoding&quot;</span>
            <span class="s1">)</span>

        <span class="s0"># Anything that key-specific code was supposed to handle earlier,</span>
        <span class="s0"># like Raw, CompressedPoint, UncompressedPoint</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;format is invalid with this key&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_parameter_bytes(self</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">cdata):</span>
        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.OpenSSH:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;OpenSSH encoding is not supported&quot;</span><span class="s1">)</span>

        <span class="s0"># Only DH is supported here currently.</span>
        <span class="s1">q = self._ffi.new(</span><span class="s3">&quot;BIGNUM **&quot;</span><span class="s1">)</span>
        <span class="s1">self._lib.DH_get0_pqg(cdata</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.PEM:</span>
            <span class="s2">if </span><span class="s1">q[</span><span class="s6">0</span><span class="s1">] != self._ffi.NULL:</span>
                <span class="s1">write_bio = self._lib.PEM_write_bio_DHxparams</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">write_bio = self._lib.PEM_write_bio_DHparams</span>
        <span class="s2">elif </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.DER:</span>
            <span class="s2">if </span><span class="s1">q[</span><span class="s6">0</span><span class="s1">] != self._ffi.NULL:</span>
                <span class="s1">write_bio = self._lib.Cryptography_i2d_DHxparams_bio</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">write_bio = self._lib.i2d_DHparams_bio</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;encoding must be an item from the Encoding enum&quot;</span><span class="s1">)</span>

        <span class="s1">bio = self._create_mem_bio_gc()</span>
        <span class="s1">res = write_bio(bio</span><span class="s2">, </span><span class="s1">cdata)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._read_mem_bio(bio)</span>

    <span class="s2">def </span><span class="s1">generate_dh_parameters(self</span><span class="s2">, </span><span class="s1">generator</span><span class="s2">, </span><span class="s1">key_size):</span>
        <span class="s2">if </span><span class="s1">key_size &lt; dh._MIN_MODULUS_SIZE:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;DH key_size must be at least {} bits&quot;</span><span class="s1">.format(</span>
                    <span class="s1">dh._MIN_MODULUS_SIZE</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">generator </span><span class="s2">not in </span><span class="s1">(</span><span class="s6">2</span><span class="s2">, </span><span class="s6">5</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;DH generator must be 2 or 5&quot;</span><span class="s1">)</span>

        <span class="s1">dh_param_cdata = self._lib.DH_new()</span>
        <span class="s1">self.openssl_assert(dh_param_cdata != self._ffi.NULL)</span>
        <span class="s1">dh_param_cdata = self._ffi.gc(dh_param_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>

        <span class="s1">res = self._lib.DH_generate_parameters_ex(</span>
            <span class="s1">dh_param_cdata</span><span class="s2">, </span><span class="s1">key_size</span><span class="s2">, </span><span class="s1">generator</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">_DHParameters(self</span><span class="s2">, </span><span class="s1">dh_param_cdata)</span>

    <span class="s2">def </span><span class="s1">_dh_cdata_to_evp_pkey(self</span><span class="s2">, </span><span class="s1">dh_cdata):</span>
        <span class="s1">evp_pkey = self._create_evp_pkey_gc()</span>
        <span class="s1">res = self._lib.EVP_PKEY_set1_DH(evp_pkey</span><span class="s2">, </span><span class="s1">dh_cdata)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">evp_pkey</span>

    <span class="s2">def </span><span class="s1">generate_dh_private_key(self</span><span class="s2">, </span><span class="s1">parameters):</span>
        <span class="s1">dh_key_cdata = _dh_params_dup(parameters._dh_cdata</span><span class="s2">, </span><span class="s1">self)</span>

        <span class="s1">res = self._lib.DH_generate_key(dh_key_cdata)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">evp_pkey = self._dh_cdata_to_evp_pkey(dh_key_cdata)</span>

        <span class="s2">return </span><span class="s1">_DHPrivateKey(self</span><span class="s2">, </span><span class="s1">dh_key_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">generate_dh_private_key_and_parameters(self</span><span class="s2">, </span><span class="s1">generator</span><span class="s2">, </span><span class="s1">key_size):</span>
        <span class="s2">return </span><span class="s1">self.generate_dh_private_key(</span>
            <span class="s1">self.generate_dh_parameters(generator</span><span class="s2">, </span><span class="s1">key_size)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">load_dh_private_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">parameter_numbers = numbers.public_numbers.parameter_numbers</span>

        <span class="s1">dh_cdata = self._lib.DH_new()</span>
        <span class="s1">self.openssl_assert(dh_cdata != self._ffi.NULL)</span>
        <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>

        <span class="s1">p = self._int_to_bn(parameter_numbers.p)</span>
        <span class="s1">g = self._int_to_bn(parameter_numbers.g)</span>

        <span class="s2">if </span><span class="s1">parameter_numbers.q </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">q = self._int_to_bn(parameter_numbers.q)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">q = self._ffi.NULL</span>

        <span class="s1">pub_key = self._int_to_bn(numbers.public_numbers.y)</span>
        <span class="s1">priv_key = self._int_to_bn(numbers.x)</span>

        <span class="s1">res = self._lib.DH_set0_pqg(dh_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">res = self._lib.DH_set0_key(dh_cdata</span><span class="s2">, </span><span class="s1">pub_key</span><span class="s2">, </span><span class="s1">priv_key)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">codes = self._ffi.new(</span><span class="s3">&quot;int[]&quot;</span><span class="s2">, </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">res = self._lib.Cryptography_DH_check(dh_cdata</span><span class="s2">, </span><span class="s1">codes)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s0"># DH_check will return DH_NOT_SUITABLE_GENERATOR if p % 24 does not</span>
        <span class="s0"># equal 11 when the generator is 2 (a quadratic nonresidue).</span>
        <span class="s0"># We want to ignore that error because p % 24 == 23 is also fine.</span>
        <span class="s0"># Specifically, g is then a quadratic residue. Within the context of</span>
        <span class="s0"># Diffie-Hellman this means it can only generate half the possible</span>
        <span class="s0"># values. That sounds bad, but quadratic nonresidues leak a bit of</span>
        <span class="s0"># the key to the attacker in exchange for having the full key space</span>
        <span class="s0"># available. See: https://crypto.stackexchange.com/questions/12961</span>
        <span class="s2">if </span><span class="s1">codes[</span><span class="s6">0</span><span class="s1">] != </span><span class="s6">0 </span><span class="s2">and not </span><span class="s1">(</span>
            <span class="s1">parameter_numbers.g == </span><span class="s6">2</span>
            <span class="s2">and </span><span class="s1">codes[</span><span class="s6">0</span><span class="s1">] ^ self._lib.DH_NOT_SUITABLE_GENERATOR == </span><span class="s6">0</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;DH private numbers did not pass safety checks.&quot;</span><span class="s1">)</span>

        <span class="s1">evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)</span>

        <span class="s2">return </span><span class="s1">_DHPrivateKey(self</span><span class="s2">, </span><span class="s1">dh_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">load_dh_public_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">dh_cdata = self._lib.DH_new()</span>
        <span class="s1">self.openssl_assert(dh_cdata != self._ffi.NULL)</span>
        <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>

        <span class="s1">parameter_numbers = numbers.parameter_numbers</span>

        <span class="s1">p = self._int_to_bn(parameter_numbers.p)</span>
        <span class="s1">g = self._int_to_bn(parameter_numbers.g)</span>

        <span class="s2">if </span><span class="s1">parameter_numbers.q </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">q = self._int_to_bn(parameter_numbers.q)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">q = self._ffi.NULL</span>

        <span class="s1">pub_key = self._int_to_bn(numbers.y)</span>

        <span class="s1">res = self._lib.DH_set0_pqg(dh_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">res = self._lib.DH_set0_key(dh_cdata</span><span class="s2">, </span><span class="s1">pub_key</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)</span>

        <span class="s2">return </span><span class="s1">_DHPublicKey(self</span><span class="s2">, </span><span class="s1">dh_cdata</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">load_dh_parameter_numbers(self</span><span class="s2">, </span><span class="s1">numbers):</span>
        <span class="s1">dh_cdata = self._lib.DH_new()</span>
        <span class="s1">self.openssl_assert(dh_cdata != self._ffi.NULL)</span>
        <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>

        <span class="s1">p = self._int_to_bn(numbers.p)</span>
        <span class="s1">g = self._int_to_bn(numbers.g)</span>

        <span class="s2">if </span><span class="s1">numbers.q </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">q = self._int_to_bn(numbers.q)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">q = self._ffi.NULL</span>

        <span class="s1">res = self._lib.DH_set0_pqg(dh_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">_DHParameters(self</span><span class="s2">, </span><span class="s1">dh_cdata)</span>

    <span class="s2">def </span><span class="s1">dh_parameters_supported(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">q=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">dh_cdata = self._lib.DH_new()</span>
        <span class="s1">self.openssl_assert(dh_cdata != self._ffi.NULL)</span>
        <span class="s1">dh_cdata = self._ffi.gc(dh_cdata</span><span class="s2">, </span><span class="s1">self._lib.DH_free)</span>

        <span class="s1">p = self._int_to_bn(p)</span>
        <span class="s1">g = self._int_to_bn(g)</span>

        <span class="s2">if </span><span class="s1">q </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">q = self._int_to_bn(q)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">q = self._ffi.NULL</span>

        <span class="s1">res = self._lib.DH_set0_pqg(dh_cdata</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">g)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s1">codes = self._ffi.new(</span><span class="s3">&quot;int[]&quot;</span><span class="s2">, </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">res = self._lib.Cryptography_DH_check(dh_cdata</span><span class="s2">, </span><span class="s1">codes)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">codes[</span><span class="s6">0</span><span class="s1">] == </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">dh_x942_serialization_supported(self):</span>
        <span class="s2">return </span><span class="s1">self._lib.Cryptography_HAS_EVP_PKEY_DHX == </span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">x509_name_bytes(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">x509_name = _encode_name_gc(self</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s1">pp = self._ffi.new(</span><span class="s3">&quot;unsigned char **&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._lib.i2d_X509_NAME(x509_name</span><span class="s2">, </span><span class="s1">pp)</span>
        <span class="s1">self.openssl_assert(pp[</span><span class="s6">0</span><span class="s1">] != self._ffi.NULL)</span>
        <span class="s1">pp = self._ffi.gc(</span>
            <span class="s1">pp</span><span class="s2">, lambda </span><span class="s1">pointer: self._lib.OPENSSL_free(pointer[</span><span class="s6">0</span><span class="s1">])</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res &gt; </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._ffi.buffer(pp[</span><span class="s6">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res)[:]</span>

    <span class="s2">def </span><span class="s1">x25519_load_public_bytes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0"># When we drop support for CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 we can</span>
        <span class="s0"># switch this to EVP_PKEY_new_raw_public_key</span>
        <span class="s2">if </span><span class="s1">len(data) != </span><span class="s6">32</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;An X25519 public key is 32 bytes long&quot;</span><span class="s1">)</span>

        <span class="s1">evp_pkey = self._create_evp_pkey_gc()</span>
        <span class="s1">res = self._lib.EVP_PKEY_set_type(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.NID_X25519)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">res = self._lib.EVP_PKEY_set1_tls_encodedpoint(</span>
            <span class="s1">evp_pkey</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">len(data)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">_X25519PublicKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">x25519_load_private_bytes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0"># When we drop support for CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 we can</span>
        <span class="s0"># switch this to EVP_PKEY_new_raw_private_key and drop the</span>
        <span class="s0"># zeroed_bytearray garbage.</span>
        <span class="s0"># OpenSSL only has facilities for loading PKCS8 formatted private</span>
        <span class="s0"># keys using the algorithm identifiers specified in</span>
        <span class="s0"># https://tools.ietf.org/html/draft-ietf-curdle-pkix-09.</span>
        <span class="s0"># This is the standard PKCS8 prefix for a 32 byte X25519 key.</span>
        <span class="s0"># The form is:</span>
        <span class="s0">#    0:d=0  hl=2 l=  46 cons: SEQUENCE</span>
        <span class="s0">#    2:d=1  hl=2 l=   1 prim: INTEGER           :00</span>
        <span class="s0">#    5:d=1  hl=2 l=   5 cons: SEQUENCE</span>
        <span class="s0">#    7:d=2  hl=2 l=   3 prim: OBJECT            :1.3.101.110</span>
        <span class="s0">#    12:d=1  hl=2 l=  34 prim: OCTET STRING      (the key)</span>
        <span class="s0"># Of course there's a bit more complexity. In reality OCTET STRING</span>
        <span class="s0"># contains an OCTET STRING of length 32! So the last two bytes here</span>
        <span class="s0"># are \x04\x20, which is an OCTET STRING of length 32.</span>
        <span class="s2">if </span><span class="s1">len(data) != </span><span class="s6">32</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;An X25519 private key is 32 bytes long&quot;</span><span class="s1">)</span>

        <span class="s1">pkcs8_prefix = </span><span class="s5">b'0.</span><span class="s2">\x02\x01\x00</span><span class="s5">0</span><span class="s2">\x05\x06\x03</span><span class="s5">+en</span><span class="s2">\x04</span><span class="s5">&quot;</span><span class="s2">\x04 </span><span class="s5">'</span>
        <span class="s2">with </span><span class="s1">self._zeroed_bytearray(</span><span class="s6">48</span><span class="s1">) </span><span class="s2">as </span><span class="s1">ba:</span>
            <span class="s1">ba[</span><span class="s6">0</span><span class="s1">:</span><span class="s6">16</span><span class="s1">] = pkcs8_prefix</span>
            <span class="s1">ba[</span><span class="s6">16</span><span class="s1">:] = data</span>
            <span class="s1">bio = self._bytes_to_bio(ba)</span>
            <span class="s1">evp_pkey = self._lib.d2i_PrivateKey_bio(bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>

        <span class="s1">self.openssl_assert(evp_pkey != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
        <span class="s1">self.openssl_assert(</span>
            <span class="s1">self._lib.EVP_PKEY_id(evp_pkey) == self._lib.EVP_PKEY_X25519</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">_X25519PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">_evp_pkey_keygen_gc(self</span><span class="s2">, </span><span class="s1">nid):</span>
        <span class="s1">evp_pkey_ctx = self._lib.EVP_PKEY_CTX_new_id(nid</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s1">self.openssl_assert(evp_pkey_ctx != self._ffi.NULL)</span>
        <span class="s1">evp_pkey_ctx = self._ffi.gc(evp_pkey_ctx</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_CTX_free)</span>
        <span class="s1">res = self._lib.EVP_PKEY_keygen_init(evp_pkey_ctx)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">evp_ppkey = self._ffi.new(</span><span class="s3">&quot;EVP_PKEY **&quot;</span><span class="s1">)</span>
        <span class="s1">res = self._lib.EVP_PKEY_keygen(evp_pkey_ctx</span><span class="s2">, </span><span class="s1">evp_ppkey)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s1">self.openssl_assert(evp_ppkey[</span><span class="s6">0</span><span class="s1">] != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_ppkey[</span><span class="s6">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
        <span class="s2">return </span><span class="s1">evp_pkey</span>

    <span class="s2">def </span><span class="s1">x25519_generate_key(self):</span>
        <span class="s1">evp_pkey = self._evp_pkey_keygen_gc(self._lib.NID_X25519)</span>
        <span class="s2">return </span><span class="s1">_X25519PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">x25519_supported(self):</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled:</span>
            <span class="s2">return False</span>
        <span class="s2">return not </span><span class="s1">self._lib.CRYPTOGRAPHY_IS_LIBRESSL</span>

    <span class="s2">def </span><span class="s1">x448_load_public_bytes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">if </span><span class="s1">len(data) != </span><span class="s6">56</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;An X448 public key is 56 bytes long&quot;</span><span class="s1">)</span>

        <span class="s1">evp_pkey = self._lib.EVP_PKEY_new_raw_public_key(</span>
            <span class="s1">self._lib.NID_X448</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">len(data)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(evp_pkey != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
        <span class="s2">return </span><span class="s1">_X448PublicKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">x448_load_private_bytes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">if </span><span class="s1">len(data) != </span><span class="s6">56</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;An X448 private key is 56 bytes long&quot;</span><span class="s1">)</span>

        <span class="s1">data_ptr = self._ffi.from_buffer(data)</span>
        <span class="s1">evp_pkey = self._lib.EVP_PKEY_new_raw_private_key(</span>
            <span class="s1">self._lib.NID_X448</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">data_ptr</span><span class="s2">, </span><span class="s1">len(data)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(evp_pkey != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
        <span class="s2">return </span><span class="s1">_X448PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">x448_generate_key(self):</span>
        <span class="s1">evp_pkey = self._evp_pkey_keygen_gc(self._lib.NID_X448)</span>
        <span class="s2">return </span><span class="s1">_X448PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">x448_supported(self):</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled:</span>
            <span class="s2">return False</span>
        <span class="s2">return not </span><span class="s1">self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111</span>

    <span class="s2">def </span><span class="s1">ed25519_supported(self):</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled:</span>
            <span class="s2">return False</span>
        <span class="s2">return not </span><span class="s1">self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111B</span>

    <span class="s2">def </span><span class="s1">ed25519_load_public_bytes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">utils._check_bytes(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s2">if </span><span class="s1">len(data) != ed25519._ED25519_KEY_SIZE:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;An Ed25519 public key is 32 bytes long&quot;</span><span class="s1">)</span>

        <span class="s1">evp_pkey = self._lib.EVP_PKEY_new_raw_public_key(</span>
            <span class="s1">self._lib.NID_ED25519</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">len(data)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(evp_pkey != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>

        <span class="s2">return </span><span class="s1">_Ed25519PublicKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">ed25519_load_private_bytes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s2">if </span><span class="s1">len(data) != ed25519._ED25519_KEY_SIZE:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;An Ed25519 private key is 32 bytes long&quot;</span><span class="s1">)</span>

        <span class="s1">utils._check_byteslike(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">data_ptr = self._ffi.from_buffer(data)</span>
        <span class="s1">evp_pkey = self._lib.EVP_PKEY_new_raw_private_key(</span>
            <span class="s1">self._lib.NID_ED25519</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">data_ptr</span><span class="s2">, </span><span class="s1">len(data)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(evp_pkey != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>

        <span class="s2">return </span><span class="s1">_Ed25519PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">ed25519_generate_key(self):</span>
        <span class="s1">evp_pkey = self._evp_pkey_keygen_gc(self._lib.NID_ED25519)</span>
        <span class="s2">return </span><span class="s1">_Ed25519PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">ed448_supported(self):</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled:</span>
            <span class="s2">return False</span>
        <span class="s2">return not </span><span class="s1">self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111B</span>

    <span class="s2">def </span><span class="s1">ed448_load_public_bytes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">utils._check_bytes(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s2">if </span><span class="s1">len(data) != _ED448_KEY_SIZE:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;An Ed448 public key is 57 bytes long&quot;</span><span class="s1">)</span>

        <span class="s1">evp_pkey = self._lib.EVP_PKEY_new_raw_public_key(</span>
            <span class="s1">self._lib.NID_ED448</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">len(data)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(evp_pkey != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>

        <span class="s2">return </span><span class="s1">_Ed448PublicKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">ed448_load_private_bytes(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">utils._check_byteslike(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s2">if </span><span class="s1">len(data) != _ED448_KEY_SIZE:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;An Ed448 private key is 57 bytes long&quot;</span><span class="s1">)</span>

        <span class="s1">data_ptr = self._ffi.from_buffer(data)</span>
        <span class="s1">evp_pkey = self._lib.EVP_PKEY_new_raw_private_key(</span>
            <span class="s1">self._lib.NID_ED448</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">data_ptr</span><span class="s2">, </span><span class="s1">len(data)</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(evp_pkey != self._ffi.NULL)</span>
        <span class="s1">evp_pkey = self._ffi.gc(evp_pkey</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>

        <span class="s2">return </span><span class="s1">_Ed448PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">ed448_generate_key(self):</span>
        <span class="s1">evp_pkey = self._evp_pkey_keygen_gc(self._lib.NID_ED448)</span>
        <span class="s2">return </span><span class="s1">_Ed448PrivateKey(self</span><span class="s2">, </span><span class="s1">evp_pkey)</span>

    <span class="s2">def </span><span class="s1">derive_scrypt(self</span><span class="s2">, </span><span class="s1">key_material</span><span class="s2">, </span><span class="s1">salt</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s1">buf = self._ffi.new(</span><span class="s3">&quot;unsigned char[]&quot;</span><span class="s2">, </span><span class="s1">length)</span>
        <span class="s1">key_material_ptr = self._ffi.from_buffer(key_material)</span>
        <span class="s1">res = self._lib.EVP_PBE_scrypt(</span>
            <span class="s1">key_material_ptr</span><span class="s2">,</span>
            <span class="s1">len(key_material)</span><span class="s2">,</span>
            <span class="s1">salt</span><span class="s2">,</span>
            <span class="s1">len(salt)</span><span class="s2">,</span>
            <span class="s1">n</span><span class="s2">,</span>
            <span class="s1">r</span><span class="s2">,</span>
            <span class="s1">p</span><span class="s2">,</span>
            <span class="s1">scrypt._MEM_LIMIT</span><span class="s2">,</span>
            <span class="s1">buf</span><span class="s2">,</span>
            <span class="s1">length</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">res != </span><span class="s6">1</span><span class="s1">:</span>
            <span class="s1">errors = self._consume_errors_with_text()</span>
            <span class="s0"># memory required formula explained here:</span>
            <span class="s0"># https://blog.filippo.io/the-scrypt-parameters/</span>
            <span class="s1">min_memory = </span><span class="s6">128 </span><span class="s1">* n * r // (</span><span class="s6">1024 </span><span class="s1">** </span><span class="s6">2</span><span class="s1">)</span>
            <span class="s2">raise </span><span class="s1">MemoryError(</span>
                <span class="s3">&quot;Not enough memory to derive key. These parameters require&quot;</span>
                <span class="s3">&quot; {} MB of memory.&quot;</span><span class="s1">.format(min_memory)</span><span class="s2">,</span>
                <span class="s1">errors</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._ffi.buffer(buf)[:]</span>

    <span class="s2">def </span><span class="s1">aead_cipher_supported(self</span><span class="s2">, </span><span class="s1">cipher):</span>
        <span class="s1">cipher_name = aead._aead_cipher_name(cipher)</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled </span><span class="s2">and </span><span class="s1">cipher_name </span><span class="s2">not in </span><span class="s1">self._fips_aead:</span>
            <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">self._lib.EVP_get_cipherbyname(cipher_name) != self._ffi.NULL</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">_zeroed_bytearray(self</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s4">&quot;&quot;&quot; 
        This method creates a bytearray, which we copy data into (hopefully 
        also from a mutable buffer that can be dynamically erased!), and then 
        zero when we're done. 
        &quot;&quot;&quot;</span>
        <span class="s1">ba = bytearray(length)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">ba</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self._zero_data(ba</span><span class="s2">, </span><span class="s1">length)</span>

    <span class="s2">def </span><span class="s1">_zero_data(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">length):</span>
        <span class="s0"># We clear things this way because at the moment we're not</span>
        <span class="s0"># sure of a better way that can guarantee it overwrites the</span>
        <span class="s0"># memory of a bytearray and doesn't just replace the underlying char *.</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(length):</span>
            <span class="s1">data[i] = </span><span class="s6">0</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">_zeroed_null_terminated_buf(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s4">&quot;&quot;&quot; 
        This method takes bytes, which can be a bytestring or a mutable 
        buffer like a bytearray, and yields a null-terminated version of that 
        data. This is required because PKCS12_parse doesn't take a length with 
        its password char * and ffi.from_buffer doesn't provide null 
        termination. So, to support zeroing the data via bytearray we 
        need to build this ridiculous construct that copies the memory, but 
        zeroes it after use. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">data </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">self._ffi.NULL</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data_len = len(data)</span>
            <span class="s1">buf = self._ffi.new(</span><span class="s3">&quot;char[]&quot;</span><span class="s2">, </span><span class="s1">data_len + </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">self._ffi.memmove(buf</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">data_len)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">yield </span><span class="s1">buf</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s0"># Cast to a uint8_t * so we can assign by integer</span>
                <span class="s1">self._zero_data(self._ffi.cast(</span><span class="s3">&quot;uint8_t *&quot;</span><span class="s2">, </span><span class="s1">buf)</span><span class="s2">, </span><span class="s1">data_len)</span>

    <span class="s2">def </span><span class="s1">load_key_and_certificates_from_pkcs12(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">password):</span>
        <span class="s2">if </span><span class="s1">password </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">utils._check_byteslike(</span><span class="s3">&quot;password&quot;</span><span class="s2">, </span><span class="s1">password)</span>

        <span class="s1">bio = self._bytes_to_bio(data)</span>
        <span class="s1">p12 = self._lib.d2i_PKCS12_bio(bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">p12 == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Could not deserialize PKCS12 data&quot;</span><span class="s1">)</span>

        <span class="s1">p12 = self._ffi.gc(p12</span><span class="s2">, </span><span class="s1">self._lib.PKCS12_free)</span>
        <span class="s1">evp_pkey_ptr = self._ffi.new(</span><span class="s3">&quot;EVP_PKEY **&quot;</span><span class="s1">)</span>
        <span class="s1">x509_ptr = self._ffi.new(</span><span class="s3">&quot;X509 **&quot;</span><span class="s1">)</span>
        <span class="s1">sk_x509_ptr = self._ffi.new(</span><span class="s3">&quot;Cryptography_STACK_OF_X509 **&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">self._zeroed_null_terminated_buf(password) </span><span class="s2">as </span><span class="s1">password_buf:</span>
            <span class="s1">res = self._lib.PKCS12_parse(</span>
                <span class="s1">p12</span><span class="s2">, </span><span class="s1">password_buf</span><span class="s2">, </span><span class="s1">evp_pkey_ptr</span><span class="s2">, </span><span class="s1">x509_ptr</span><span class="s2">, </span><span class="s1">sk_x509_ptr</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">res == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid password or PKCS12 data&quot;</span><span class="s1">)</span>

        <span class="s1">cert = </span><span class="s2">None</span>
        <span class="s1">key = </span><span class="s2">None</span>
        <span class="s1">additional_certificates = []</span>

        <span class="s2">if </span><span class="s1">evp_pkey_ptr[</span><span class="s6">0</span><span class="s1">] != self._ffi.NULL:</span>
            <span class="s1">evp_pkey = self._ffi.gc(evp_pkey_ptr[</span><span class="s6">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._lib.EVP_PKEY_free)</span>
            <span class="s1">key = self._evp_pkey_to_private_key(evp_pkey)</span>

        <span class="s2">if </span><span class="s1">x509_ptr[</span><span class="s6">0</span><span class="s1">] != self._ffi.NULL:</span>
            <span class="s1">x509 = self._ffi.gc(x509_ptr[</span><span class="s6">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._lib.X509_free)</span>
            <span class="s1">cert = _Certificate(self</span><span class="s2">, </span><span class="s1">x509)</span>

        <span class="s2">if </span><span class="s1">sk_x509_ptr[</span><span class="s6">0</span><span class="s1">] != self._ffi.NULL:</span>
            <span class="s1">sk_x509 = self._ffi.gc(sk_x509_ptr[</span><span class="s6">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self._lib.sk_X509_free)</span>
            <span class="s1">num = self._lib.sk_X509_num(sk_x509_ptr[</span><span class="s6">0</span><span class="s1">])</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num):</span>
                <span class="s1">x509 = self._lib.sk_X509_value(sk_x509</span><span class="s2">, </span><span class="s1">i)</span>
                <span class="s1">self.openssl_assert(x509 != self._ffi.NULL)</span>
                <span class="s1">x509 = self._ffi.gc(x509</span><span class="s2">, </span><span class="s1">self._lib.X509_free)</span>
                <span class="s1">additional_certificates.append(_Certificate(self</span><span class="s2">, </span><span class="s1">x509))</span>

        <span class="s2">return </span><span class="s1">(key</span><span class="s2">, </span><span class="s1">cert</span><span class="s2">, </span><span class="s1">additional_certificates)</span>

    <span class="s2">def </span><span class="s1">serialize_key_and_certificates_to_pkcs12(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">cert</span><span class="s2">, </span><span class="s1">cas</span><span class="s2">, </span><span class="s1">encryption_algorithm</span>
    <span class="s1">):</span>
        <span class="s1">password = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">utils._check_bytes(</span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s1">name)</span>

        <span class="s2">if </span><span class="s1">isinstance(encryption_algorithm</span><span class="s2">, </span><span class="s1">serialization.NoEncryption):</span>
            <span class="s1">nid_cert = -</span><span class="s6">1</span>
            <span class="s1">nid_key = -</span><span class="s6">1</span>
            <span class="s1">pkcs12_iter = </span><span class="s6">0</span>
            <span class="s1">mac_iter = </span><span class="s6">0</span>
        <span class="s2">elif </span><span class="s1">isinstance(</span>
            <span class="s1">encryption_algorithm</span><span class="s2">, </span><span class="s1">serialization.BestAvailableEncryption</span>
        <span class="s1">):</span>
            <span class="s0"># PKCS12 encryption is hopeless trash and can never be fixed.</span>
            <span class="s0"># This is the least terrible option.</span>
            <span class="s1">nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC</span>
            <span class="s1">nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC</span>
            <span class="s0"># At least we can set this higher than OpenSSL's default</span>
            <span class="s1">pkcs12_iter = </span><span class="s6">20000</span>
            <span class="s0"># mac_iter chosen for compatibility reasons, see:</span>
            <span class="s0"># https://www.openssl.org/docs/man1.1.1/man3/PKCS12_create.html</span>
            <span class="s0"># Did we mention how lousy PKCS12 encryption is?</span>
            <span class="s1">mac_iter = </span><span class="s6">1</span>
            <span class="s1">password = encryption_algorithm.password</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unsupported key encryption type&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">cas </span><span class="s2">is None or </span><span class="s1">len(cas) == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">sk_x509 = self._ffi.NULL</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sk_x509 = self._lib.sk_X509_new_null()</span>
            <span class="s1">sk_x509 = self._ffi.gc(sk_x509</span><span class="s2">, </span><span class="s1">self._lib.sk_X509_free)</span>

            <span class="s0"># reverse the list when building the stack so that they're encoded</span>
            <span class="s0"># in the order they were originally provided. it is a mystery</span>
            <span class="s2">for </span><span class="s1">ca </span><span class="s2">in </span><span class="s1">reversed(cas):</span>
                <span class="s1">res = self._lib.sk_X509_push(sk_x509</span><span class="s2">, </span><span class="s1">ca._x509)</span>
                <span class="s1">backend.openssl_assert(res &gt;= </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">self._zeroed_null_terminated_buf(password) </span><span class="s2">as </span><span class="s1">password_buf:</span>
            <span class="s2">with </span><span class="s1">self._zeroed_null_terminated_buf(name) </span><span class="s2">as </span><span class="s1">name_buf:</span>
                <span class="s1">p12 = self._lib.PKCS12_create(</span>
                    <span class="s1">password_buf</span><span class="s2">,</span>
                    <span class="s1">name_buf</span><span class="s2">,</span>
                    <span class="s1">key._evp_pkey </span><span class="s2">if </span><span class="s1">key </span><span class="s2">else </span><span class="s1">self._ffi.NULL</span><span class="s2">,</span>
                    <span class="s1">cert._x509 </span><span class="s2">if </span><span class="s1">cert </span><span class="s2">else </span><span class="s1">self._ffi.NULL</span><span class="s2">,</span>
                    <span class="s1">sk_x509</span><span class="s2">,</span>
                    <span class="s1">nid_key</span><span class="s2">,</span>
                    <span class="s1">nid_cert</span><span class="s2">,</span>
                    <span class="s1">pkcs12_iter</span><span class="s2">,</span>
                    <span class="s1">mac_iter</span><span class="s2">,</span>
                    <span class="s6">0</span><span class="s2">,</span>
                <span class="s1">)</span>

        <span class="s1">self.openssl_assert(p12 != self._ffi.NULL)</span>
        <span class="s1">p12 = self._ffi.gc(p12</span><span class="s2">, </span><span class="s1">self._lib.PKCS12_free)</span>

        <span class="s1">bio = self._create_mem_bio_gc()</span>
        <span class="s1">res = self._lib.i2d_PKCS12_bio(bio</span><span class="s2">, </span><span class="s1">p12)</span>
        <span class="s1">self.openssl_assert(res &gt; </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._read_mem_bio(bio)</span>

    <span class="s2">def </span><span class="s1">poly1305_supported(self):</span>
        <span class="s2">if </span><span class="s1">self._fips_enabled:</span>
            <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">self._lib.Cryptography_HAS_POLY1305 == </span><span class="s6">1</span>

    <span class="s2">def </span><span class="s1">create_poly1305_ctx(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s1">utils._check_byteslike(</span><span class="s3">&quot;key&quot;</span><span class="s2">, </span><span class="s1">key)</span>
        <span class="s2">if </span><span class="s1">len(key) != _POLY1305_KEY_SIZE:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;A poly1305 key is 32 bytes long&quot;</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">_Poly1305Context(self</span><span class="s2">, </span><span class="s1">key)</span>

    <span class="s2">def </span><span class="s1">load_pem_pkcs7_certificates(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">utils._check_bytes(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">bio = self._bytes_to_bio(data)</span>
        <span class="s1">p7 = self._lib.PEM_read_bio_PKCS7(</span>
            <span class="s1">bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span><span class="s2">, </span><span class="s1">self._ffi.NULL</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">p7 == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unable to parse PKCS7 data&quot;</span><span class="s1">)</span>

        <span class="s1">p7 = self._ffi.gc(p7</span><span class="s2">, </span><span class="s1">self._lib.PKCS7_free)</span>
        <span class="s2">return </span><span class="s1">self._load_pkcs7_certificates(p7)</span>

    <span class="s2">def </span><span class="s1">load_der_pkcs7_certificates(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">utils._check_bytes(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">bio = self._bytes_to_bio(data)</span>
        <span class="s1">p7 = self._lib.d2i_PKCS7_bio(bio.bio</span><span class="s2">, </span><span class="s1">self._ffi.NULL)</span>
        <span class="s2">if </span><span class="s1">p7 == self._ffi.NULL:</span>
            <span class="s1">self._consume_errors()</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Unable to parse PKCS7 data&quot;</span><span class="s1">)</span>

        <span class="s1">p7 = self._ffi.gc(p7</span><span class="s2">, </span><span class="s1">self._lib.PKCS7_free)</span>
        <span class="s2">return </span><span class="s1">self._load_pkcs7_certificates(p7)</span>

    <span class="s2">def </span><span class="s1">_load_pkcs7_certificates(self</span><span class="s2">, </span><span class="s1">p7):</span>
        <span class="s1">nid = self._lib.OBJ_obj2nid(p7.type)</span>
        <span class="s1">self.openssl_assert(nid != self._lib.NID_undef)</span>
        <span class="s2">if </span><span class="s1">nid != self._lib.NID_pkcs7_signed:</span>
            <span class="s2">raise </span><span class="s1">UnsupportedAlgorithm(</span>
                <span class="s3">&quot;Only basic signed structures are currently supported. NID&quot;</span>
                <span class="s3">&quot; for this data was {}&quot;</span><span class="s1">.format(nid)</span><span class="s2">,</span>
                <span class="s1">_Reasons.UNSUPPORTED_SERIALIZATION</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">sk_x509 = p7.d.sign.cert</span>
        <span class="s1">num = self._lib.sk_X509_num(sk_x509)</span>
        <span class="s1">certs = []</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(num):</span>
            <span class="s1">x509 = self._lib.sk_X509_value(sk_x509</span><span class="s2">, </span><span class="s1">i)</span>
            <span class="s1">self.openssl_assert(x509 != self._ffi.NULL)</span>
            <span class="s1">res = self._lib.X509_up_ref(x509)</span>
            <span class="s0"># When OpenSSL is less than 1.1.0 up_ref returns the current</span>
            <span class="s0"># refcount. On 1.1.0+ it returns 1 for success.</span>
            <span class="s1">self.openssl_assert(res &gt;= </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">x509 = self._ffi.gc(x509</span><span class="s2">, </span><span class="s1">self._lib.X509_free)</span>
            <span class="s1">certs.append(_Certificate(self</span><span class="s2">, </span><span class="s1">x509))</span>

        <span class="s2">return </span><span class="s1">certs</span>

    <span class="s2">def </span><span class="s1">pkcs7_sign(self</span><span class="s2">, </span><span class="s1">builder</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">, </span><span class="s1">options):</span>
        <span class="s1">bio = self._bytes_to_bio(builder._data)</span>
        <span class="s1">init_flags = self._lib.PKCS7_PARTIAL</span>
        <span class="s1">final_flags = </span><span class="s6">0</span>

        <span class="s2">if </span><span class="s1">len(builder._additional_certs) == </span><span class="s6">0</span><span class="s1">:</span>
            <span class="s1">certs = self._ffi.NULL</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">certs = self._lib.sk_X509_new_null()</span>
            <span class="s1">certs = self._ffi.gc(certs</span><span class="s2">, </span><span class="s1">self._lib.sk_X509_free)</span>
            <span class="s2">for </span><span class="s1">cert </span><span class="s2">in </span><span class="s1">builder._additional_certs:</span>
                <span class="s1">res = self._lib.sk_X509_push(certs</span><span class="s2">, </span><span class="s1">cert._x509)</span>
                <span class="s1">self.openssl_assert(res &gt;= </span><span class="s6">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">pkcs7.PKCS7Options.DetachedSignature </span><span class="s2">in </span><span class="s1">options:</span>
            <span class="s0"># Don't embed the data in the PKCS7 structure</span>
            <span class="s1">init_flags |= self._lib.PKCS7_DETACHED</span>
            <span class="s1">final_flags |= self._lib.PKCS7_DETACHED</span>

        <span class="s0"># This just inits a structure for us. However, there</span>
        <span class="s0"># are flags we need to set, joy.</span>
        <span class="s1">p7 = self._lib.PKCS7_sign(</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s1">certs</span><span class="s2">,</span>
            <span class="s1">self._ffi.NULL</span><span class="s2">,</span>
            <span class="s1">init_flags</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.openssl_assert(p7 != self._ffi.NULL)</span>
        <span class="s1">p7 = self._ffi.gc(p7</span><span class="s2">, </span><span class="s1">self._lib.PKCS7_free)</span>
        <span class="s1">signer_flags = </span><span class="s6">0</span>
        <span class="s0"># These flags are configurable on a per-signature basis</span>
        <span class="s0"># but we've deliberately chosen to make the API only allow</span>
        <span class="s0"># setting it across all signatures for now.</span>
        <span class="s2">if </span><span class="s1">pkcs7.PKCS7Options.NoCapabilities </span><span class="s2">in </span><span class="s1">options:</span>
            <span class="s1">signer_flags |= self._lib.PKCS7_NOSMIMECAP</span>
        <span class="s2">elif </span><span class="s1">pkcs7.PKCS7Options.NoAttributes </span><span class="s2">in </span><span class="s1">options:</span>
            <span class="s1">signer_flags |= self._lib.PKCS7_NOATTR</span>

        <span class="s2">if </span><span class="s1">pkcs7.PKCS7Options.NoCerts </span><span class="s2">in </span><span class="s1">options:</span>
            <span class="s1">signer_flags |= self._lib.PKCS7_NOCERTS</span>

        <span class="s2">for </span><span class="s1">certificate</span><span class="s2">, </span><span class="s1">private_key</span><span class="s2">, </span><span class="s1">hash_algorithm </span><span class="s2">in </span><span class="s1">builder._signers:</span>
            <span class="s1">md = self._evp_md_non_null_from_algorithm(hash_algorithm)</span>
            <span class="s1">p7signerinfo = self._lib.PKCS7_sign_add_signer(</span>
                <span class="s1">p7</span><span class="s2">, </span><span class="s1">certificate._x509</span><span class="s2">, </span><span class="s1">private_key._evp_pkey</span><span class="s2">, </span><span class="s1">md</span><span class="s2">, </span><span class="s1">signer_flags</span>
            <span class="s1">)</span>
            <span class="s1">self.openssl_assert(p7signerinfo != self._ffi.NULL)</span>

        <span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">options:</span>
            <span class="s0"># DetachedSignature, NoCapabilities, and NoAttributes are already</span>
            <span class="s0"># handled so we just need to check these last two options.</span>
            <span class="s2">if </span><span class="s1">option </span><span class="s2">is </span><span class="s1">pkcs7.PKCS7Options.Text:</span>
                <span class="s1">final_flags |= self._lib.PKCS7_TEXT</span>
            <span class="s2">elif </span><span class="s1">option </span><span class="s2">is </span><span class="s1">pkcs7.PKCS7Options.Binary:</span>
                <span class="s1">final_flags |= self._lib.PKCS7_BINARY</span>

        <span class="s1">bio_out = self._create_mem_bio_gc()</span>
        <span class="s2">if </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.SMIME:</span>
            <span class="s0"># This finalizes the structure</span>
            <span class="s1">res = self._lib.SMIME_write_PKCS7(</span>
                <span class="s1">bio_out</span><span class="s2">, </span><span class="s1">p7</span><span class="s2">, </span><span class="s1">bio.bio</span><span class="s2">, </span><span class="s1">final_flags</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.PEM:</span>
            <span class="s1">res = self._lib.PKCS7_final(p7</span><span class="s2">, </span><span class="s1">bio.bio</span><span class="s2">, </span><span class="s1">final_flags)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">res = self._lib.PEM_write_bio_PKCS7_stream(</span>
                <span class="s1">bio_out</span><span class="s2">, </span><span class="s1">p7</span><span class="s2">, </span><span class="s1">bio.bio</span><span class="s2">, </span><span class="s1">final_flags</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">encoding </span><span class="s2">is </span><span class="s1">serialization.Encoding.DER</span>
            <span class="s0"># We need to call finalize here becauase i2d_PKCS7_bio does not</span>
            <span class="s0"># finalize.</span>
            <span class="s1">res = self._lib.PKCS7_final(p7</span><span class="s2">, </span><span class="s1">bio.bio</span><span class="s2">, </span><span class="s1">final_flags)</span>
            <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
            <span class="s1">res = self._lib.i2d_PKCS7_bio(bio_out</span><span class="s2">, </span><span class="s1">p7)</span>
        <span class="s1">self.openssl_assert(res == </span><span class="s6">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._read_mem_bio(bio_out)</span>


<span class="s2">class </span><span class="s1">GetCipherByName(object):</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fmt):</span>
        <span class="s1">self._fmt = fmt</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">backend</span><span class="s2">, </span><span class="s1">cipher</span><span class="s2">, </span><span class="s1">mode):</span>
        <span class="s1">cipher_name = self._fmt.format(cipher=cipher</span><span class="s2">, </span><span class="s1">mode=mode).lower()</span>
        <span class="s2">return </span><span class="s1">backend._lib.EVP_get_cipherbyname(cipher_name.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">_get_xts_cipher(backend</span><span class="s2">, </span><span class="s1">cipher</span><span class="s2">, </span><span class="s1">mode):</span>
    <span class="s1">cipher_name = </span><span class="s3">&quot;aes-{}-xts&quot;</span><span class="s1">.format(cipher.key_size // </span><span class="s6">2</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">backend._lib.EVP_get_cipherbyname(cipher_name.encode(</span><span class="s3">&quot;ascii&quot;</span><span class="s1">))</span>


<span class="s1">backend = Backend()</span>
</pre>
</body>
</html>