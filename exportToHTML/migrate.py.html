<html>
<head>
<title>migrate.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
migrate.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">from </span><span class="s1">importlib </span><span class="s0">import </span><span class="s1">import_module</span>

<span class="s0">from </span><span class="s1">django.apps </span><span class="s0">import </span><span class="s1">apps</span>
<span class="s0">from </span><span class="s1">django.core.management.base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">BaseCommand</span><span class="s0">, </span><span class="s1">CommandError</span><span class="s0">, </span><span class="s1">no_translations</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">django.core.management.sql </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">emit_post_migrate_signal</span><span class="s0">, </span><span class="s1">emit_pre_migrate_signal</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">django.db </span><span class="s0">import </span><span class="s1">DEFAULT_DB_ALIAS</span><span class="s0">, </span><span class="s1">connections</span><span class="s0">, </span><span class="s1">router</span>
<span class="s0">from </span><span class="s1">django.db.migrations.autodetector </span><span class="s0">import </span><span class="s1">MigrationAutodetector</span>
<span class="s0">from </span><span class="s1">django.db.migrations.executor </span><span class="s0">import </span><span class="s1">MigrationExecutor</span>
<span class="s0">from </span><span class="s1">django.db.migrations.loader </span><span class="s0">import </span><span class="s1">AmbiguityError</span>
<span class="s0">from </span><span class="s1">django.db.migrations.state </span><span class="s0">import </span><span class="s1">ModelState</span><span class="s0">, </span><span class="s1">ProjectState</span>
<span class="s0">from </span><span class="s1">django.utils.module_loading </span><span class="s0">import </span><span class="s1">module_has_submodule</span>
<span class="s0">from </span><span class="s1">django.utils.text </span><span class="s0">import </span><span class="s1">Truncator</span>


<span class="s0">class </span><span class="s1">Command(BaseCommand):</span>
    <span class="s1">help = </span><span class="s2">&quot;Updates database schema. Manages both apps with migrations and those without.&quot;</span>
    <span class="s1">requires_system_checks = []</span>

    <span class="s0">def </span><span class="s1">add_arguments(self</span><span class="s0">, </span><span class="s1">parser):</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'--skip-checks'</span><span class="s0">, </span><span class="s1">action=</span><span class="s2">'store_true'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Skip system checks.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'app_label'</span><span class="s0">, </span><span class="s1">nargs=</span><span class="s2">'?'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'App label of an application to synchronize the state.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'migration_name'</span><span class="s0">, </span><span class="s1">nargs=</span><span class="s2">'?'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Database state will be brought to the state after that '</span>
                 <span class="s2">'migration. Use the name &quot;zero&quot; to unapply all migrations.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'--noinput'</span><span class="s0">, </span><span class="s2">'--no-input'</span><span class="s0">, </span><span class="s1">action=</span><span class="s2">'store_false'</span><span class="s0">, </span><span class="s1">dest=</span><span class="s2">'interactive'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Tells Django to NOT prompt the user for input of any kind.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'--database'</span><span class="s0">,</span>
            <span class="s1">default=DEFAULT_DB_ALIAS</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Nominates a database to synchronize. Defaults to the &quot;default&quot; database.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'--fake'</span><span class="s0">, </span><span class="s1">action=</span><span class="s2">'store_true'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Mark migrations as run without actually running them.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'--fake-initial'</span><span class="s0">, </span><span class="s1">action=</span><span class="s2">'store_true'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Detect if tables already exist and fake-apply initial migrations if so. Make sure '</span>
                 <span class="s2">'that the current database schema matches your initial migration before using this '</span>
                 <span class="s2">'flag. Django will only check for an existing table name.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'--plan'</span><span class="s0">, </span><span class="s1">action=</span><span class="s2">'store_true'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Shows a list of the migration actions that will be performed.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'--run-syncdb'</span><span class="s0">, </span><span class="s1">action=</span><span class="s2">'store_true'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Creates tables for apps without migrations.'</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">parser.add_argument(</span>
            <span class="s2">'--check'</span><span class="s0">, </span><span class="s1">action=</span><span class="s2">'store_true'</span><span class="s0">, </span><span class="s1">dest=</span><span class="s2">'check_unapplied'</span><span class="s0">,</span>
            <span class="s1">help=</span><span class="s2">'Exits with a non-zero status if unapplied migrations exist.'</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@no_translations</span>
    <span class="s0">def </span><span class="s1">handle(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**options):</span>
        <span class="s1">database = options[</span><span class="s2">'database'</span><span class="s1">]</span>
        <span class="s0">if not </span><span class="s1">options[</span><span class="s2">'skip_checks'</span><span class="s1">]:</span>
            <span class="s1">self.check(databases=[database])</span>

        <span class="s1">self.verbosity = options[</span><span class="s2">'verbosity'</span><span class="s1">]</span>
        <span class="s1">self.interactive = options[</span><span class="s2">'interactive'</span><span class="s1">]</span>

        <span class="s3"># Import the 'management' module within each installed app, to register</span>
        <span class="s3"># dispatcher events.</span>
        <span class="s0">for </span><span class="s1">app_config </span><span class="s0">in </span><span class="s1">apps.get_app_configs():</span>
            <span class="s0">if </span><span class="s1">module_has_submodule(app_config.module</span><span class="s0">, </span><span class="s2">&quot;management&quot;</span><span class="s1">):</span>
                <span class="s1">import_module(</span><span class="s2">'.management'</span><span class="s0">, </span><span class="s1">app_config.name)</span>

        <span class="s3"># Get the database we're operating from</span>
        <span class="s1">connection = connections[database]</span>

        <span class="s3"># Hook for backends needing any database preparation</span>
        <span class="s1">connection.prepare_database()</span>
        <span class="s3"># Work out which apps have migrations and which do not</span>
        <span class="s1">executor = MigrationExecutor(connection</span><span class="s0">, </span><span class="s1">self.migration_progress_callback)</span>

        <span class="s3"># Raise an error if any migrations are applied before their dependencies.</span>
        <span class="s1">executor.loader.check_consistent_history(connection)</span>

        <span class="s3"># Before anything else, see if there's conflicting apps and drop out</span>
        <span class="s3"># hard if there are any</span>
        <span class="s1">conflicts = executor.loader.detect_conflicts()</span>
        <span class="s0">if </span><span class="s1">conflicts:</span>
            <span class="s1">name_str = </span><span class="s2">&quot;; &quot;</span><span class="s1">.join(</span>
                <span class="s2">&quot;%s in %s&quot; </span><span class="s1">% (</span><span class="s2">&quot;, &quot;</span><span class="s1">.join(names)</span><span class="s0">, </span><span class="s1">app)</span>
                <span class="s0">for </span><span class="s1">app</span><span class="s0">, </span><span class="s1">names </span><span class="s0">in </span><span class="s1">conflicts.items()</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">CommandError(</span>
                <span class="s2">&quot;Conflicting migrations detected; multiple leaf nodes in the &quot;</span>
                <span class="s2">&quot;migration graph: (%s).</span><span class="s0">\n</span><span class="s2">To fix them run &quot;</span>
                <span class="s2">&quot;'python manage.py makemigrations --merge'&quot; </span><span class="s1">% name_str</span>
            <span class="s1">)</span>

        <span class="s3"># If they supplied command line arguments, work out what they mean.</span>
        <span class="s1">run_syncdb = options[</span><span class="s2">'run_syncdb'</span><span class="s1">]</span>
        <span class="s1">target_app_labels_only = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">options[</span><span class="s2">'app_label'</span><span class="s1">]:</span>
            <span class="s3"># Validate app_label.</span>
            <span class="s1">app_label = options[</span><span class="s2">'app_label'</span><span class="s1">]</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">apps.get_app_config(app_label)</span>
            <span class="s0">except </span><span class="s1">LookupError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">raise </span><span class="s1">CommandError(str(err))</span>
            <span class="s0">if </span><span class="s1">run_syncdb:</span>
                <span class="s0">if </span><span class="s1">app_label </span><span class="s0">in </span><span class="s1">executor.loader.migrated_apps:</span>
                    <span class="s0">raise </span><span class="s1">CommandError(</span><span class="s2">&quot;Can't use run_syncdb with app '%s' as it has migrations.&quot; </span><span class="s1">% app_label)</span>
            <span class="s0">elif </span><span class="s1">app_label </span><span class="s0">not in </span><span class="s1">executor.loader.migrated_apps:</span>
                <span class="s0">raise </span><span class="s1">CommandError(</span><span class="s2">&quot;App '%s' does not have migrations.&quot; </span><span class="s1">% app_label)</span>

        <span class="s0">if </span><span class="s1">options[</span><span class="s2">'app_label'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">options[</span><span class="s2">'migration_name'</span><span class="s1">]:</span>
            <span class="s1">migration_name = options[</span><span class="s2">'migration_name'</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">migration_name == </span><span class="s2">&quot;zero&quot;</span><span class="s1">:</span>
                <span class="s1">targets = [(app_label</span><span class="s0">, None</span><span class="s1">)]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">migration = executor.loader.get_migration_by_prefix(app_label</span><span class="s0">, </span><span class="s1">migration_name)</span>
                <span class="s0">except </span><span class="s1">AmbiguityError:</span>
                    <span class="s0">raise </span><span class="s1">CommandError(</span>
                        <span class="s2">&quot;More than one migration matches '%s' in app '%s'. &quot;</span>
                        <span class="s2">&quot;Please be more specific.&quot; </span><span class="s1">%</span>
                        <span class="s1">(migration_name</span><span class="s0">, </span><span class="s1">app_label)</span>
                    <span class="s1">)</span>
                <span class="s0">except </span><span class="s1">KeyError:</span>
                    <span class="s0">raise </span><span class="s1">CommandError(</span><span class="s2">&quot;Cannot find a migration matching '%s' from app '%s'.&quot; </span><span class="s1">% (</span>
                        <span class="s1">migration_name</span><span class="s0">, </span><span class="s1">app_label))</span>
                <span class="s1">target = (app_label</span><span class="s0">, </span><span class="s1">migration.name)</span>
                <span class="s3"># Partially applied squashed migrations are not included in the</span>
                <span class="s3"># graph, use the last replacement instead.</span>
                <span class="s0">if </span><span class="s1">(</span>
                    <span class="s1">target </span><span class="s0">not in </span><span class="s1">executor.loader.graph.nodes </span><span class="s0">and</span>
                    <span class="s1">target </span><span class="s0">in </span><span class="s1">executor.loader.replacements</span>
                <span class="s1">):</span>
                    <span class="s1">incomplete_migration = executor.loader.replacements[target]</span>
                    <span class="s1">target = incomplete_migration.replaces[-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">targets = [target]</span>
            <span class="s1">target_app_labels_only = </span><span class="s0">False</span>
        <span class="s0">elif </span><span class="s1">options[</span><span class="s2">'app_label'</span><span class="s1">]:</span>
            <span class="s1">targets = [key </span><span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">executor.loader.graph.leaf_nodes() </span><span class="s0">if </span><span class="s1">key[</span><span class="s4">0</span><span class="s1">] == app_label]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">targets = executor.loader.graph.leaf_nodes()</span>

        <span class="s1">plan = executor.migration_plan(targets)</span>
        <span class="s1">exit_dry = plan </span><span class="s0">and </span><span class="s1">options[</span><span class="s2">'check_unapplied'</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">options[</span><span class="s2">'plan'</span><span class="s1">]:</span>
            <span class="s1">self.stdout.write(</span><span class="s2">'Planned operations:'</span><span class="s0">, </span><span class="s1">self.style.MIGRATE_LABEL)</span>
            <span class="s0">if not </span><span class="s1">plan:</span>
                <span class="s1">self.stdout.write(</span><span class="s2">'  No planned migration operations.'</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">migration</span><span class="s0">, </span><span class="s1">backwards </span><span class="s0">in </span><span class="s1">plan:</span>
                <span class="s1">self.stdout.write(str(migration)</span><span class="s0">, </span><span class="s1">self.style.MIGRATE_HEADING)</span>
                <span class="s0">for </span><span class="s1">operation </span><span class="s0">in </span><span class="s1">migration.operations:</span>
                    <span class="s1">message</span><span class="s0">, </span><span class="s1">is_error = self.describe_operation(operation</span><span class="s0">, </span><span class="s1">backwards)</span>
                    <span class="s1">style = self.style.WARNING </span><span class="s0">if </span><span class="s1">is_error </span><span class="s0">else None</span>
                    <span class="s1">self.stdout.write(</span><span class="s2">'    ' </span><span class="s1">+ message</span><span class="s0">, </span><span class="s1">style)</span>
            <span class="s0">if </span><span class="s1">exit_dry:</span>
                <span class="s1">sys.exit(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s0">return</span>
        <span class="s0">if </span><span class="s1">exit_dry:</span>
            <span class="s1">sys.exit(</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s3"># At this point, ignore run_syncdb if there aren't any apps to sync.</span>
        <span class="s1">run_syncdb = options[</span><span class="s2">'run_syncdb'</span><span class="s1">] </span><span class="s0">and </span><span class="s1">executor.loader.unmigrated_apps</span>
        <span class="s3"># Print some useful info</span>
        <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self.stdout.write(self.style.MIGRATE_HEADING(</span><span class="s2">&quot;Operations to perform:&quot;</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">run_syncdb:</span>
                <span class="s0">if </span><span class="s1">options[</span><span class="s2">'app_label'</span><span class="s1">]:</span>
                    <span class="s1">self.stdout.write(</span>
                        <span class="s1">self.style.MIGRATE_LABEL(</span><span class="s2">&quot;  Synchronize unmigrated app: %s&quot; </span><span class="s1">% app_label)</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.stdout.write(</span>
                        <span class="s1">self.style.MIGRATE_LABEL(</span><span class="s2">&quot;  Synchronize unmigrated apps: &quot;</span><span class="s1">) +</span>
                        <span class="s1">(</span><span class="s2">&quot;, &quot;</span><span class="s1">.join(sorted(executor.loader.unmigrated_apps)))</span>
                    <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">target_app_labels_only:</span>
                <span class="s1">self.stdout.write(</span>
                    <span class="s1">self.style.MIGRATE_LABEL(</span><span class="s2">&quot;  Apply all migrations: &quot;</span><span class="s1">) +</span>
                    <span class="s1">(</span><span class="s2">&quot;, &quot;</span><span class="s1">.join(sorted({a </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">targets})) </span><span class="s0">or </span><span class="s2">&quot;(none)&quot;</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">targets[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">] </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">self.stdout.write(</span>
                        <span class="s1">self.style.MIGRATE_LABEL(</span><span class="s2">'  Unapply all migrations: '</span><span class="s1">) +</span>
                        <span class="s1">str(targets[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.stdout.write(self.style.MIGRATE_LABEL(</span>
                        <span class="s2">&quot;  Target specific migration: &quot;</span><span class="s1">) + </span><span class="s2">&quot;%s, from %s&quot;</span>
                        <span class="s1">% (targets[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">targets[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">)</span>

        <span class="s1">pre_migrate_state = executor._create_project_state(with_applied_migrations=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">pre_migrate_apps = pre_migrate_state.apps</span>
        <span class="s1">emit_pre_migrate_signal(</span>
            <span class="s1">self.verbosity</span><span class="s0">, </span><span class="s1">self.interactive</span><span class="s0">, </span><span class="s1">connection.alias</span><span class="s0">, </span><span class="s1">stdout=self.stdout</span><span class="s0">, </span><span class="s1">apps=pre_migrate_apps</span><span class="s0">, </span><span class="s1">plan=plan</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s3"># Run the syncdb phase.</span>
        <span class="s0">if </span><span class="s1">run_syncdb:</span>
            <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self.stdout.write(self.style.MIGRATE_HEADING(</span><span class="s2">&quot;Synchronizing apps without migrations:&quot;</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">options[</span><span class="s2">'app_label'</span><span class="s1">]:</span>
                <span class="s1">self.sync_apps(connection</span><span class="s0">, </span><span class="s1">[app_label])</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.sync_apps(connection</span><span class="s0">, </span><span class="s1">executor.loader.unmigrated_apps)</span>

        <span class="s3"># Migrate!</span>
        <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self.stdout.write(self.style.MIGRATE_HEADING(</span><span class="s2">&quot;Running migrations:&quot;</span><span class="s1">))</span>
        <span class="s0">if not </span><span class="s1">plan:</span>
            <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self.stdout.write(</span><span class="s2">&quot;  No migrations to apply.&quot;</span><span class="s1">)</span>
                <span class="s3"># If there's changes that aren't in migrations yet, tell them how to fix it.</span>
                <span class="s1">autodetector = MigrationAutodetector(</span>
                    <span class="s1">executor.loader.project_state()</span><span class="s0">,</span>
                    <span class="s1">ProjectState.from_apps(apps)</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s1">changes = autodetector.changes(graph=executor.loader.graph)</span>
                <span class="s0">if </span><span class="s1">changes:</span>
                    <span class="s1">self.stdout.write(self.style.NOTICE(</span>
                        <span class="s2">&quot;  Your models in app(s): %s have changes that are not &quot;</span>
                        <span class="s2">&quot;yet reflected in a migration, and so won't be &quot;</span>
                        <span class="s2">&quot;applied.&quot; </span><span class="s1">% </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(repr(app) </span><span class="s0">for </span><span class="s1">app </span><span class="s0">in </span><span class="s1">sorted(changes))</span>
                    <span class="s1">))</span>
                    <span class="s1">self.stdout.write(self.style.NOTICE(</span>
                        <span class="s2">&quot;  Run 'manage.py makemigrations' to make new &quot;</span>
                        <span class="s2">&quot;migrations, and then re-run 'manage.py migrate' to &quot;</span>
                        <span class="s2">&quot;apply them.&quot;</span>
                    <span class="s1">))</span>
            <span class="s1">fake = </span><span class="s0">False</span>
            <span class="s1">fake_initial = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fake = options[</span><span class="s2">'fake'</span><span class="s1">]</span>
            <span class="s1">fake_initial = options[</span><span class="s2">'fake_initial'</span><span class="s1">]</span>
        <span class="s1">post_migrate_state = executor.migrate(</span>
            <span class="s1">targets</span><span class="s0">, </span><span class="s1">plan=plan</span><span class="s0">, </span><span class="s1">state=pre_migrate_state.clone()</span><span class="s0">, </span><span class="s1">fake=fake</span><span class="s0">,</span>
            <span class="s1">fake_initial=fake_initial</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s3"># post_migrate signals have access to all models. Ensure that all models</span>
        <span class="s3"># are reloaded in case any are delayed.</span>
        <span class="s1">post_migrate_state.clear_delayed_apps_cache()</span>
        <span class="s1">post_migrate_apps = post_migrate_state.apps</span>

        <span class="s3"># Re-render models of real apps to include relationships now that</span>
        <span class="s3"># we've got a final state. This wouldn't be necessary if real apps</span>
        <span class="s3"># models were rendered with relationships in the first place.</span>
        <span class="s0">with </span><span class="s1">post_migrate_apps.bulk_update():</span>
            <span class="s1">model_keys = []</span>
            <span class="s0">for </span><span class="s1">model_state </span><span class="s0">in </span><span class="s1">post_migrate_apps.real_models:</span>
                <span class="s1">model_key = model_state.app_label</span><span class="s0">, </span><span class="s1">model_state.name_lower</span>
                <span class="s1">model_keys.append(model_key)</span>
                <span class="s1">post_migrate_apps.unregister_model(*model_key)</span>
        <span class="s1">post_migrate_apps.render_multiple([</span>
            <span class="s1">ModelState.from_model(apps.get_model(*model)) </span><span class="s0">for </span><span class="s1">model </span><span class="s0">in </span><span class="s1">model_keys</span>
        <span class="s1">])</span>

        <span class="s3"># Send the post_migrate signal, so individual apps can do whatever they need</span>
        <span class="s3"># to do at this point.</span>
        <span class="s1">emit_post_migrate_signal(</span>
            <span class="s1">self.verbosity</span><span class="s0">, </span><span class="s1">self.interactive</span><span class="s0">, </span><span class="s1">connection.alias</span><span class="s0">, </span><span class="s1">stdout=self.stdout</span><span class="s0">, </span><span class="s1">apps=post_migrate_apps</span><span class="s0">, </span><span class="s1">plan=plan</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">migration_progress_callback(self</span><span class="s0">, </span><span class="s1">action</span><span class="s0">, </span><span class="s1">migration=</span><span class="s0">None, </span><span class="s1">fake=</span><span class="s0">False</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">compute_time = self.verbosity &gt; </span><span class="s4">1</span>
            <span class="s0">if </span><span class="s1">action == </span><span class="s2">&quot;apply_start&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">compute_time:</span>
                    <span class="s1">self.start = time.monotonic()</span>
                <span class="s1">self.stdout.write(</span><span class="s2">&quot;  Applying %s...&quot; </span><span class="s1">% migration</span><span class="s0">, </span><span class="s1">ending=</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">self.stdout.flush()</span>
            <span class="s0">elif </span><span class="s1">action == </span><span class="s2">&quot;apply_success&quot;</span><span class="s1">:</span>
                <span class="s1">elapsed = </span><span class="s2">&quot; (%.3fs)&quot; </span><span class="s1">% (time.monotonic() - self.start) </span><span class="s0">if </span><span class="s1">compute_time </span><span class="s0">else </span><span class="s2">&quot;&quot;</span>
                <span class="s0">if </span><span class="s1">fake:</span>
                    <span class="s1">self.stdout.write(self.style.SUCCESS(</span><span class="s2">&quot; FAKED&quot; </span><span class="s1">+ elapsed))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.stdout.write(self.style.SUCCESS(</span><span class="s2">&quot; OK&quot; </span><span class="s1">+ elapsed))</span>
            <span class="s0">elif </span><span class="s1">action == </span><span class="s2">&quot;unapply_start&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">compute_time:</span>
                    <span class="s1">self.start = time.monotonic()</span>
                <span class="s1">self.stdout.write(</span><span class="s2">&quot;  Unapplying %s...&quot; </span><span class="s1">% migration</span><span class="s0">, </span><span class="s1">ending=</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">self.stdout.flush()</span>
            <span class="s0">elif </span><span class="s1">action == </span><span class="s2">&quot;unapply_success&quot;</span><span class="s1">:</span>
                <span class="s1">elapsed = </span><span class="s2">&quot; (%.3fs)&quot; </span><span class="s1">% (time.monotonic() - self.start) </span><span class="s0">if </span><span class="s1">compute_time </span><span class="s0">else </span><span class="s2">&quot;&quot;</span>
                <span class="s0">if </span><span class="s1">fake:</span>
                    <span class="s1">self.stdout.write(self.style.SUCCESS(</span><span class="s2">&quot; FAKED&quot; </span><span class="s1">+ elapsed))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.stdout.write(self.style.SUCCESS(</span><span class="s2">&quot; OK&quot; </span><span class="s1">+ elapsed))</span>
            <span class="s0">elif </span><span class="s1">action == </span><span class="s2">&quot;render_start&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">compute_time:</span>
                    <span class="s1">self.start = time.monotonic()</span>
                <span class="s1">self.stdout.write(</span><span class="s2">&quot;  Rendering model states...&quot;</span><span class="s0">, </span><span class="s1">ending=</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">self.stdout.flush()</span>
            <span class="s0">elif </span><span class="s1">action == </span><span class="s2">&quot;render_success&quot;</span><span class="s1">:</span>
                <span class="s1">elapsed = </span><span class="s2">&quot; (%.3fs)&quot; </span><span class="s1">% (time.monotonic() - self.start) </span><span class="s0">if </span><span class="s1">compute_time </span><span class="s0">else </span><span class="s2">&quot;&quot;</span>
                <span class="s1">self.stdout.write(self.style.SUCCESS(</span><span class="s2">&quot; DONE&quot; </span><span class="s1">+ elapsed))</span>

    <span class="s0">def </span><span class="s1">sync_apps(self</span><span class="s0">, </span><span class="s1">connection</span><span class="s0">, </span><span class="s1">app_labels):</span>
        <span class="s5">&quot;&quot;&quot;Run the old syncdb-style operation on a list of app_labels.&quot;&quot;&quot;</span>
        <span class="s0">with </span><span class="s1">connection.cursor() </span><span class="s0">as </span><span class="s1">cursor:</span>
            <span class="s1">tables = connection.introspection.table_names(cursor)</span>

        <span class="s3"># Build the manifest of apps and models that are to be synchronized.</span>
        <span class="s1">all_models = [</span>
            <span class="s1">(</span>
                <span class="s1">app_config.label</span><span class="s0">,</span>
                <span class="s1">router.get_migratable_models(app_config</span><span class="s0">, </span><span class="s1">connection.alias</span><span class="s0">, </span><span class="s1">include_auto_created=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">app_config </span><span class="s0">in </span><span class="s1">apps.get_app_configs()</span>
            <span class="s0">if </span><span class="s1">app_config.models_module </span><span class="s0">is not None and </span><span class="s1">app_config.label </span><span class="s0">in </span><span class="s1">app_labels</span>
        <span class="s1">]</span>

        <span class="s0">def </span><span class="s1">model_installed(model):</span>
            <span class="s1">opts = model._meta</span>
            <span class="s1">converter = connection.introspection.identifier_converter</span>
            <span class="s0">return not </span><span class="s1">(</span>
                <span class="s1">(converter(opts.db_table) </span><span class="s0">in </span><span class="s1">tables) </span><span class="s0">or</span>
                <span class="s1">(opts.auto_created </span><span class="s0">and </span><span class="s1">converter(opts.auto_created._meta.db_table) </span><span class="s0">in </span><span class="s1">tables)</span>
            <span class="s1">)</span>

        <span class="s1">manifest = {</span>
            <span class="s1">app_name: list(filter(model_installed</span><span class="s0">, </span><span class="s1">model_list))</span>
            <span class="s0">for </span><span class="s1">app_name</span><span class="s0">, </span><span class="s1">model_list </span><span class="s0">in </span><span class="s1">all_models</span>
        <span class="s1">}</span>

        <span class="s3"># Create the tables for each model</span>
        <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">self.stdout.write(</span><span class="s2">'  Creating tables...'</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">connection.schema_editor() </span><span class="s0">as </span><span class="s1">editor:</span>
            <span class="s0">for </span><span class="s1">app_name</span><span class="s0">, </span><span class="s1">model_list </span><span class="s0">in </span><span class="s1">manifest.items():</span>
                <span class="s0">for </span><span class="s1">model </span><span class="s0">in </span><span class="s1">model_list:</span>
                    <span class="s3"># Never install unmanaged models, etc.</span>
                    <span class="s0">if not </span><span class="s1">model._meta.can_migrate(connection):</span>
                        <span class="s0">continue</span>
                    <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">3</span><span class="s1">:</span>
                        <span class="s1">self.stdout.write(</span>
                            <span class="s2">'    Processing %s.%s model' </span><span class="s1">% (app_name</span><span class="s0">, </span><span class="s1">model._meta.object_name)</span>
                        <span class="s1">)</span>
                    <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">1</span><span class="s1">:</span>
                        <span class="s1">self.stdout.write(</span><span class="s2">'    Creating table %s' </span><span class="s1">% model._meta.db_table)</span>
                    <span class="s1">editor.create_model(model)</span>

            <span class="s3"># Deferred SQL is executed when exiting the editor's context.</span>
            <span class="s0">if </span><span class="s1">self.verbosity &gt;= </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self.stdout.write(</span><span class="s2">'    Running deferred SQL...'</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">describe_operation(operation</span><span class="s0">, </span><span class="s1">backwards):</span>
        <span class="s5">&quot;&quot;&quot;Return a string that describes a migration operation for --plan.&quot;&quot;&quot;</span>
        <span class="s1">prefix = </span><span class="s2">''</span>
        <span class="s1">is_error = </span><span class="s0">False</span>
        <span class="s0">if </span><span class="s1">hasattr(operation</span><span class="s0">, </span><span class="s2">'code'</span><span class="s1">):</span>
            <span class="s1">code = operation.reverse_code </span><span class="s0">if </span><span class="s1">backwards </span><span class="s0">else </span><span class="s1">operation.code</span>
            <span class="s1">action = (code.__doc__ </span><span class="s0">or </span><span class="s2">''</span><span class="s1">) </span><span class="s0">if </span><span class="s1">code </span><span class="s0">else None</span>
        <span class="s0">elif </span><span class="s1">hasattr(operation</span><span class="s0">, </span><span class="s2">'sql'</span><span class="s1">):</span>
            <span class="s1">action = operation.reverse_sql </span><span class="s0">if </span><span class="s1">backwards </span><span class="s0">else </span><span class="s1">operation.sql</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">action = </span><span class="s2">''</span>
            <span class="s0">if </span><span class="s1">backwards:</span>
                <span class="s1">prefix = </span><span class="s2">'Undo '</span>
        <span class="s0">if </span><span class="s1">action </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">action = str(action).replace(</span><span class="s2">'</span><span class="s0">\n</span><span class="s2">'</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">backwards:</span>
            <span class="s1">action = </span><span class="s2">'IRREVERSIBLE'</span>
            <span class="s1">is_error = </span><span class="s0">True</span>
        <span class="s0">if </span><span class="s1">action:</span>
            <span class="s1">action = </span><span class="s2">' -&gt; ' </span><span class="s1">+ action</span>
        <span class="s1">truncated = Truncator(action)</span>
        <span class="s0">return </span><span class="s1">prefix + operation.describe() + truncated.chars(</span><span class="s4">40</span><span class="s1">)</span><span class="s0">, </span><span class="s1">is_error</span>
</pre>
</body>
</html>