<html>
<head>
<title>test_sync.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_sync.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">weakref</span>

<span class="s0">from </span><span class="s1">..testing </span><span class="s0">import </span><span class="s1">wait_all_tasks_blocked</span><span class="s0">, </span><span class="s1">assert_checkpoints</span>

<span class="s0">from </span><span class="s1">.. </span><span class="s0">import </span><span class="s1">_core</span>
<span class="s0">from </span><span class="s1">.. </span><span class="s0">import </span><span class="s1">_timeouts</span>
<span class="s0">from </span><span class="s1">.._timeouts </span><span class="s0">import </span><span class="s1">sleep_forever</span><span class="s0">, </span><span class="s1">move_on_after</span>
<span class="s0">from </span><span class="s1">.._sync </span><span class="s0">import </span><span class="s1">*</span>


<span class="s0">async def </span><span class="s1">test_Event():</span>
    <span class="s1">e = Event()</span>
    <span class="s0">assert not </span><span class="s1">e.is_set()</span>
    <span class="s0">assert </span><span class="s1">e.statistics().tasks_waiting == </span><span class="s2">0</span>

    <span class="s1">e.set()</span>
    <span class="s0">assert </span><span class="s1">e.is_set()</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">await </span><span class="s1">e.wait()</span>

    <span class="s1">e = Event()</span>

    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">child():</span>
        <span class="s1">record.append(</span><span class="s3">&quot;sleeping&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">e.wait()</span>
        <span class="s1">record.append(</span><span class="s3">&quot;woken&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(child)</span>
        <span class="s1">nursery.start_soon(child)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">record == [</span><span class="s3">&quot;sleeping&quot;</span><span class="s0">, </span><span class="s3">&quot;sleeping&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">e.statistics().tasks_waiting == </span><span class="s2">2</span>
        <span class="s1">e.set()</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">record == [</span><span class="s3">&quot;sleeping&quot;</span><span class="s0">, </span><span class="s3">&quot;sleeping&quot;</span><span class="s0">, </span><span class="s3">&quot;woken&quot;</span><span class="s0">, </span><span class="s3">&quot;woken&quot;</span><span class="s1">]</span>


<span class="s0">async def </span><span class="s1">test_CapacityLimiter():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">CapacityLimiter(</span><span class="s2">1.0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">CapacityLimiter(-</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">c = CapacityLimiter(</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">repr(c)  </span><span class="s4"># smoke test</span>
    <span class="s0">assert </span><span class="s1">c.total_tokens == </span><span class="s2">2</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">c.available_tokens == </span><span class="s2">2</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">c.release()</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">0</span>
    <span class="s1">c.acquire_nowait()</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">1</span>
    <span class="s0">assert </span><span class="s1">c.available_tokens == </span><span class="s2">1</span>

    <span class="s1">stats = c.statistics()</span>
    <span class="s0">assert </span><span class="s1">stats.borrowed_tokens == </span><span class="s2">1</span>
    <span class="s0">assert </span><span class="s1">stats.total_tokens == </span><span class="s2">2</span>
    <span class="s0">assert </span><span class="s1">stats.borrowers == [_core.current_task()]</span>
    <span class="s0">assert </span><span class="s1">stats.tasks_waiting == </span><span class="s2">0</span>

    <span class="s4"># Can't re-acquire when we already have it</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">c.acquire_nowait()</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">1</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s0">await </span><span class="s1">c.acquire()</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">1</span>

    <span class="s4"># We can acquire on behalf of someone else though</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">await </span><span class="s1">c.acquire_on_behalf_of(</span><span class="s3">&quot;someone&quot;</span><span class="s1">)</span>

    <span class="s4"># But then we've run out of capacity</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">2</span>
    <span class="s0">with </span><span class="s1">pytest.raises(_core.WouldBlock):</span>
        <span class="s1">c.acquire_on_behalf_of_nowait(</span><span class="s3">&quot;third party&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">set(c.statistics().borrowers) == {_core.current_task()</span><span class="s0">, </span><span class="s3">&quot;someone&quot;</span><span class="s1">}</span>

    <span class="s4"># Until we release one</span>
    <span class="s1">c.release_on_behalf_of(_core.current_task())</span>
    <span class="s0">assert </span><span class="s1">c.statistics().borrowers == [</span><span class="s3">&quot;someone&quot;</span><span class="s1">]</span>

    <span class="s1">c.release_on_behalf_of(</span><span class="s3">&quot;someone&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">0</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">async with </span><span class="s1">c:</span>
            <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">1</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">await </span><span class="s1">c.acquire_on_behalf_of(</span><span class="s3">&quot;value 1&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">c.acquire_on_behalf_of(</span><span class="s3">&quot;value 2&quot;</span><span class="s1">)</span>
        <span class="s1">nursery.start_soon(c.acquire_on_behalf_of</span><span class="s0">, </span><span class="s3">&quot;value 3&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">2</span>
        <span class="s0">assert </span><span class="s1">c.statistics().tasks_waiting == </span><span class="s2">1</span>
        <span class="s1">c.release_on_behalf_of(</span><span class="s3">&quot;value 2&quot;</span><span class="s1">)</span>
        <span class="s4"># Fairness:</span>
        <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">2</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.WouldBlock):</span>
            <span class="s1">c.acquire_nowait()</span>

    <span class="s1">c.release_on_behalf_of(</span><span class="s3">&quot;value 3&quot;</span><span class="s1">)</span>
    <span class="s1">c.release_on_behalf_of(</span><span class="s3">&quot;value 1&quot;</span><span class="s1">)</span>


<span class="s0">async def </span><span class="s1">test_CapacityLimiter_inf():</span>
    <span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">inf</span>

    <span class="s1">c = CapacityLimiter(inf)</span>
    <span class="s1">repr(c)  </span><span class="s4"># smoke test</span>
    <span class="s0">assert </span><span class="s1">c.total_tokens == inf</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">c.available_tokens == inf</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">c.release()</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">0</span>
    <span class="s1">c.acquire_nowait()</span>
    <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">1</span>
    <span class="s0">assert </span><span class="s1">c.available_tokens == inf</span>


<span class="s0">async def </span><span class="s1">test_CapacityLimiter_change_total_tokens():</span>
    <span class="s1">c = CapacityLimiter(</span><span class="s2">2</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">c.total_tokens = </span><span class="s2">1.0</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">c.total_tokens = </span><span class="s2">0</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">c.total_tokens = -</span><span class="s2">10</span>

    <span class="s0">assert </span><span class="s1">c.total_tokens == </span><span class="s2">2</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">5</span><span class="s1">):</span>
            <span class="s1">nursery.start_soon(c.acquire_on_behalf_of</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">set(c.statistics().borrowers) == {</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">c.statistics().tasks_waiting == </span><span class="s2">3</span>
        <span class="s1">c.total_tokens += </span><span class="s2">2</span>
        <span class="s0">assert </span><span class="s1">set(c.statistics().borrowers) == {</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">c.statistics().tasks_waiting == </span><span class="s2">1</span>
        <span class="s1">c.total_tokens -= </span><span class="s2">3</span>
        <span class="s0">assert </span><span class="s1">c.borrowed_tokens == </span><span class="s2">4</span>
        <span class="s0">assert </span><span class="s1">c.total_tokens == </span><span class="s2">1</span>
        <span class="s1">c.release_on_behalf_of(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">c.release_on_behalf_of(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">c.release_on_behalf_of(</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">set(c.statistics().borrowers) == {</span><span class="s2">3</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">c.statistics().tasks_waiting == </span><span class="s2">1</span>
        <span class="s1">c.release_on_behalf_of(</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">set(c.statistics().borrowers) == {</span><span class="s2">4</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">c.statistics().tasks_waiting == </span><span class="s2">0</span>


<span class="s4"># regression test for issue #548</span>
<span class="s0">async def </span><span class="s1">test_CapacityLimiter_memleak_548():</span>
    <span class="s1">limiter = CapacityLimiter(total_tokens=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s0">await </span><span class="s1">limiter.acquire()</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">n:</span>
        <span class="s1">n.start_soon(limiter.acquire)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()  </span><span class="s4"># give it a chance to run the task</span>
        <span class="s1">n.cancel_scope.cancel()</span>

    <span class="s4"># if this is 1, the acquire call (despite being killed) is still there in the task, and will</span>
    <span class="s4"># leak memory all the while the limiter is active</span>
    <span class="s0">assert </span><span class="s1">len(limiter._pending_borrowers) == </span><span class="s2">0</span>


<span class="s0">async def </span><span class="s1">test_Semaphore():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">Semaphore(</span><span class="s2">1.0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">Semaphore(-</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">s = Semaphore(</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">repr(s)  </span><span class="s4"># smoke test</span>
    <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">1</span>
    <span class="s0">assert </span><span class="s1">s.max_value </span><span class="s0">is None</span>
    <span class="s1">s.release()</span>
    <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">2</span>
    <span class="s0">assert </span><span class="s1">s.statistics().tasks_waiting == </span><span class="s2">0</span>
    <span class="s1">s.acquire_nowait()</span>
    <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">1</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">await </span><span class="s1">s.acquire()</span>
    <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">0</span>
    <span class="s0">with </span><span class="s1">pytest.raises(_core.WouldBlock):</span>
        <span class="s1">s.acquire_nowait()</span>

    <span class="s1">s.release()</span>
    <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">1</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">async with </span><span class="s1">s:</span>
            <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">0</span>
    <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">1</span>
    <span class="s1">s.acquire_nowait()</span>

    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">do_acquire(s):</span>
        <span class="s1">record.append(</span><span class="s3">&quot;started&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">s.acquire()</span>
        <span class="s1">record.append(</span><span class="s3">&quot;finished&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(do_acquire</span><span class="s0">, </span><span class="s1">s)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">record == [</span><span class="s3">&quot;started&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">0</span>
        <span class="s1">s.release()</span>
        <span class="s4"># Fairness:</span>
        <span class="s0">assert </span><span class="s1">s.value == </span><span class="s2">0</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.WouldBlock):</span>
            <span class="s1">s.acquire_nowait()</span>
    <span class="s0">assert </span><span class="s1">record == [</span><span class="s3">&quot;started&quot;</span><span class="s0">, </span><span class="s3">&quot;finished&quot;</span><span class="s1">]</span>


<span class="s0">async def </span><span class="s1">test_Semaphore_bounded():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">Semaphore(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">max_value=</span><span class="s2">1.0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">Semaphore(</span><span class="s2">2</span><span class="s0">, </span><span class="s1">max_value=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">bs = Semaphore(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">max_value=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">bs.max_value == </span><span class="s2">1</span>
    <span class="s1">repr(bs)  </span><span class="s4"># smoke test</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">bs.release()</span>
    <span class="s0">assert </span><span class="s1">bs.value == </span><span class="s2">1</span>
    <span class="s1">bs.acquire_nowait()</span>
    <span class="s0">assert </span><span class="s1">bs.value == </span><span class="s2">0</span>
    <span class="s1">bs.release()</span>
    <span class="s0">assert </span><span class="s1">bs.value == </span><span class="s2">1</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;lockcls&quot;</span><span class="s0">, </span><span class="s1">[Lock</span><span class="s0">, </span><span class="s1">StrictFIFOLock]</span><span class="s0">, </span><span class="s1">ids=</span><span class="s0">lambda </span><span class="s1">fn: fn.__name__)</span>
<span class="s0">async def </span><span class="s1">test_Lock_and_StrictFIFOLock(lockcls):</span>
    <span class="s1">l = lockcls()  </span><span class="s4"># noqa</span>
    <span class="s0">assert not </span><span class="s1">l.locked()</span>

    <span class="s4"># make sure locks can be weakref'ed (gh-331)</span>
    <span class="s1">r = weakref.ref(l)</span>
    <span class="s0">assert </span><span class="s1">r() </span><span class="s0">is </span><span class="s1">l</span>

    <span class="s1">repr(l)  </span><span class="s4"># smoke test</span>
    <span class="s4"># make sure repr uses the right name for subclasses</span>
    <span class="s0">assert </span><span class="s1">lockcls.__name__ </span><span class="s0">in </span><span class="s1">repr(l)</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">async with </span><span class="s1">l:</span>
            <span class="s0">assert </span><span class="s1">l.locked()</span>
            <span class="s1">repr(l)  </span><span class="s4"># smoke test (repr branches on locked/unlocked)</span>
    <span class="s0">assert not </span><span class="s1">l.locked()</span>
    <span class="s1">l.acquire_nowait()</span>
    <span class="s0">assert </span><span class="s1">l.locked()</span>
    <span class="s1">l.release()</span>
    <span class="s0">assert not </span><span class="s1">l.locked()</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">await </span><span class="s1">l.acquire()</span>
    <span class="s0">assert </span><span class="s1">l.locked()</span>
    <span class="s1">l.release()</span>
    <span class="s0">assert not </span><span class="s1">l.locked()</span>

    <span class="s1">l.acquire_nowait()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s4"># Error out if we already own the lock</span>
        <span class="s1">l.acquire_nowait()</span>
    <span class="s1">l.release()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s4"># Error out if we don't own the lock</span>
        <span class="s1">l.release()</span>

    <span class="s1">holder_task = </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">holder():</span>
        <span class="s0">nonlocal </span><span class="s1">holder_task</span>
        <span class="s1">holder_task = _core.current_task()</span>
        <span class="s0">async with </span><span class="s1">l:</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">assert not </span><span class="s1">l.locked()</span>
        <span class="s1">nursery.start_soon(holder)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">l.locked()</span>
        <span class="s4"># WouldBlock if someone else holds the lock</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.WouldBlock):</span>
            <span class="s1">l.acquire_nowait()</span>
        <span class="s4"># Can't release a lock someone else holds</span>
        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
            <span class="s1">l.release()</span>

        <span class="s1">statistics = l.statistics()</span>
        <span class="s1">print(statistics)</span>
        <span class="s0">assert </span><span class="s1">statistics.locked</span>
        <span class="s0">assert </span><span class="s1">statistics.owner </span><span class="s0">is </span><span class="s1">holder_task</span>
        <span class="s0">assert </span><span class="s1">statistics.tasks_waiting == </span><span class="s2">0</span>

        <span class="s1">nursery.start_soon(holder)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s1">statistics = l.statistics()</span>
        <span class="s1">print(statistics)</span>
        <span class="s0">assert </span><span class="s1">statistics.tasks_waiting == </span><span class="s2">1</span>

        <span class="s1">nursery.cancel_scope.cancel()</span>

    <span class="s1">statistics = l.statistics()</span>
    <span class="s0">assert not </span><span class="s1">statistics.locked</span>
    <span class="s0">assert </span><span class="s1">statistics.owner </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">statistics.tasks_waiting == </span><span class="s2">0</span>


<span class="s0">async def </span><span class="s1">test_Condition():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">Condition(Semaphore(</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">Condition(StrictFIFOLock)</span>
    <span class="s1">l = Lock()  </span><span class="s4"># noqa</span>
    <span class="s1">c = Condition(l)</span>
    <span class="s0">assert not </span><span class="s1">l.locked()</span>
    <span class="s0">assert not </span><span class="s1">c.locked()</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">await </span><span class="s1">c.acquire()</span>
    <span class="s0">assert </span><span class="s1">l.locked()</span>
    <span class="s0">assert </span><span class="s1">c.locked()</span>

    <span class="s1">c = Condition()</span>
    <span class="s0">assert not </span><span class="s1">c.locked()</span>
    <span class="s1">c.acquire_nowait()</span>
    <span class="s0">assert </span><span class="s1">c.locked()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">c.acquire_nowait()</span>
    <span class="s1">c.release()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s4"># Can't wait without holding the lock</span>
        <span class="s0">await </span><span class="s1">c.wait()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s4"># Can't notify without holding the lock</span>
        <span class="s1">c.notify()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s4"># Can't notify without holding the lock</span>
        <span class="s1">c.notify_all()</span>

    <span class="s1">finished_waiters = set()</span>

    <span class="s0">async def </span><span class="s1">waiter(i):</span>
        <span class="s0">async with </span><span class="s1">c:</span>
            <span class="s0">await </span><span class="s1">c.wait()</span>
        <span class="s1">finished_waiters.add(i)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">):</span>
            <span class="s1">nursery.start_soon(waiter</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">async with </span><span class="s1">c:</span>
            <span class="s1">c.notify()</span>
        <span class="s0">assert </span><span class="s1">c.locked()</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">finished_waiters == {</span><span class="s2">0</span><span class="s1">}</span>
        <span class="s0">async with </span><span class="s1">c:</span>
            <span class="s1">c.notify_all()</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">finished_waiters == {</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">}</span>

    <span class="s1">finished_waiters = set()</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">3</span><span class="s1">):</span>
            <span class="s1">nursery.start_soon(waiter</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">async with </span><span class="s1">c:</span>
            <span class="s1">c.notify(</span><span class="s2">2</span><span class="s1">)</span>
            <span class="s1">statistics = c.statistics()</span>
            <span class="s1">print(statistics)</span>
            <span class="s0">assert </span><span class="s1">statistics.tasks_waiting == </span><span class="s2">1</span>
            <span class="s0">assert </span><span class="s1">statistics.lock_statistics.tasks_waiting == </span><span class="s2">2</span>
        <span class="s4"># exiting the context manager hands off the lock to the first task</span>
        <span class="s0">assert </span><span class="s1">c.statistics().lock_statistics.tasks_waiting == </span><span class="s2">1</span>

        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">finished_waiters == {</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">}</span>

        <span class="s0">async with </span><span class="s1">c:</span>
            <span class="s1">c.notify_all()</span>

    <span class="s4"># After being cancelled still hold the lock (!)</span>
    <span class="s4"># (Note that c.__aexit__ checks that we hold the lock as well)</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s0">async with </span><span class="s1">c:</span>
            <span class="s1">scope.cancel()</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">c.wait()</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">c.locked()</span>


<span class="s0">from </span><span class="s1">.._sync </span><span class="s0">import </span><span class="s1">async_cm</span>
<span class="s0">from </span><span class="s1">.._channel </span><span class="s0">import </span><span class="s1">open_memory_channel</span>

<span class="s4"># Three ways of implementing a Lock in terms of a channel. Used to let us put</span>
<span class="s4"># the channel through the generic lock tests.</span>


<span class="s1">@async_cm</span>
<span class="s0">class </span><span class="s1">ChannelLock1:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">capacity):</span>
        <span class="s1">self.s</span><span class="s0">, </span><span class="s1">self.r = open_memory_channel(capacity)</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(capacity - </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">self.s.send_nowait(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">acquire_nowait(self):</span>
        <span class="s1">self.s.send_nowait(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">acquire(self):</span>
        <span class="s0">await </span><span class="s1">self.s.send(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">release(self):</span>
        <span class="s1">self.r.receive_nowait()</span>


<span class="s1">@async_cm</span>
<span class="s0">class </span><span class="s1">ChannelLock2:</span>
    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.s</span><span class="s0">, </span><span class="s1">self.r = open_memory_channel(</span><span class="s2">10</span><span class="s1">)</span>
        <span class="s1">self.s.send_nowait(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">acquire_nowait(self):</span>
        <span class="s1">self.r.receive_nowait()</span>

    <span class="s0">async def </span><span class="s1">acquire(self):</span>
        <span class="s0">await </span><span class="s1">self.r.receive()</span>

    <span class="s0">def </span><span class="s1">release(self):</span>
        <span class="s1">self.s.send_nowait(</span><span class="s0">None</span><span class="s1">)</span>


<span class="s1">@async_cm</span>
<span class="s0">class </span><span class="s1">ChannelLock3:</span>
    <span class="s0">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.s</span><span class="s0">, </span><span class="s1">self.r = open_memory_channel(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s4"># self.acquired is true when one task acquires the lock and</span>
        <span class="s4"># only becomes false when it's released and no tasks are</span>
        <span class="s4"># waiting to acquire.</span>
        <span class="s1">self.acquired = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">acquire_nowait(self):</span>
        <span class="s0">assert not </span><span class="s1">self.acquired</span>
        <span class="s1">self.acquired = </span><span class="s0">True</span>

    <span class="s0">async def </span><span class="s1">acquire(self):</span>
        <span class="s0">if </span><span class="s1">self.acquired:</span>
            <span class="s0">await </span><span class="s1">self.s.send(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.acquired = </span><span class="s0">True</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s0">def </span><span class="s1">release(self):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">self.r.receive_nowait()</span>
        <span class="s0">except </span><span class="s1">_core.WouldBlock:</span>
            <span class="s0">assert </span><span class="s1">self.acquired</span>
            <span class="s1">self.acquired = </span><span class="s0">False</span>


<span class="s1">lock_factories = [</span>
    <span class="s0">lambda</span><span class="s1">: CapacityLimiter(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s0">lambda</span><span class="s1">: Semaphore(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">Lock</span><span class="s0">,</span>
    <span class="s1">StrictFIFOLock</span><span class="s0">,</span>
    <span class="s0">lambda</span><span class="s1">: ChannelLock1(</span><span class="s2">10</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s0">lambda</span><span class="s1">: ChannelLock1(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">ChannelLock2</span><span class="s0">,</span>
    <span class="s1">ChannelLock3</span><span class="s0">,</span>
<span class="s1">]</span>
<span class="s1">lock_factory_names = [</span>
    <span class="s3">&quot;CapacityLimiter(1)&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;Semaphore(1)&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;Lock&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;StrictFIFOLock&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ChannelLock1(10)&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ChannelLock1(1)&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ChannelLock2&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;ChannelLock3&quot;</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s1">generic_lock_test = pytest.mark.parametrize(</span>
    <span class="s3">&quot;lock_factory&quot;</span><span class="s0">, </span><span class="s1">lock_factories</span><span class="s0">, </span><span class="s1">ids=lock_factory_names</span>
<span class="s1">)</span>


<span class="s4"># Spawn a bunch of workers that take a lock and then yield; make sure that</span>
<span class="s4"># only one worker is ever in the critical section at a time.</span>
<span class="s1">@generic_lock_test</span>
<span class="s0">async def </span><span class="s1">test_generic_lock_exclusion(lock_factory):</span>
    <span class="s1">LOOPS = </span><span class="s2">10</span>
    <span class="s1">WORKERS = </span><span class="s2">5</span>
    <span class="s1">in_critical_section = </span><span class="s0">False</span>
    <span class="s1">acquires = </span><span class="s2">0</span>

    <span class="s0">async def </span><span class="s1">worker(lock_like):</span>
        <span class="s0">nonlocal </span><span class="s1">in_critical_section</span><span class="s0">, </span><span class="s1">acquires</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(LOOPS):</span>
            <span class="s0">async with </span><span class="s1">lock_like:</span>
                <span class="s1">acquires += </span><span class="s2">1</span>
                <span class="s0">assert not </span><span class="s1">in_critical_section</span>
                <span class="s1">in_critical_section = </span><span class="s0">True</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
                <span class="s0">assert </span><span class="s1">in_critical_section</span>
                <span class="s1">in_critical_section = </span><span class="s0">False</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">lock_like = lock_factory()</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(WORKERS):</span>
            <span class="s1">nursery.start_soon(worker</span><span class="s0">, </span><span class="s1">lock_like)</span>
    <span class="s0">assert not </span><span class="s1">in_critical_section</span>
    <span class="s0">assert </span><span class="s1">acquires == LOOPS * WORKERS</span>


<span class="s4"># Several workers queue on the same lock; make sure they each get it, in</span>
<span class="s4"># order.</span>
<span class="s1">@generic_lock_test</span>
<span class="s0">async def </span><span class="s1">test_generic_lock_fifo_fairness(lock_factory):</span>
    <span class="s1">initial_order = []</span>
    <span class="s1">record = []</span>
    <span class="s1">LOOPS = </span><span class="s2">5</span>

    <span class="s0">async def </span><span class="s1">loopy(name</span><span class="s0">, </span><span class="s1">lock_like):</span>
        <span class="s4"># Record the order each task was initially scheduled in</span>
        <span class="s1">initial_order.append(name)</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(LOOPS):</span>
            <span class="s0">async with </span><span class="s1">lock_like:</span>
                <span class="s1">record.append(name)</span>

    <span class="s1">lock_like = lock_factory()</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(loopy</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">lock_like)</span>
        <span class="s1">nursery.start_soon(loopy</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">lock_like)</span>
        <span class="s1">nursery.start_soon(loopy</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">lock_like)</span>
    <span class="s4"># The first three could be in any order due to scheduling randomness,</span>
    <span class="s4"># but after that they should repeat in the same order</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(LOOPS):</span>
        <span class="s0">assert </span><span class="s1">record[</span><span class="s2">3 </span><span class="s1">* i : </span><span class="s2">3 </span><span class="s1">* (i + </span><span class="s2">1</span><span class="s1">)] == initial_order</span>


<span class="s1">@generic_lock_test</span>
<span class="s0">async def </span><span class="s1">test_generic_lock_acquire_nowait_blocks_acquire(lock_factory):</span>
    <span class="s1">lock_like = lock_factory()</span>

    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">lock_taker():</span>
        <span class="s1">record.append(</span><span class="s3">&quot;started&quot;</span><span class="s1">)</span>
        <span class="s0">async with </span><span class="s1">lock_like:</span>
            <span class="s0">pass</span>
        <span class="s1">record.append(</span><span class="s3">&quot;finished&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">lock_like.acquire_nowait()</span>
        <span class="s1">nursery.start_soon(lock_taker)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">record == [</span><span class="s3">&quot;started&quot;</span><span class="s1">]</span>
        <span class="s1">lock_like.release()</span>
</pre>
</body>
</html>