<html>
<head>
<title>fetch.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
fetch.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: Fetch</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">io</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">network</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">page</span>


<span class="s2">class </span><span class="s1">RequestId(str):</span>
    <span class="s3">''' 
    Unique request identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; RequestId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'RequestId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">RequestStage(enum.Enum):</span>
    <span class="s3">''' 
    Stages of the request to handle. Request will intercept before the request is 
    sent. Response will intercept after the response is received (but before response 
    body is received. 
    '''</span>
    <span class="s1">REQUEST = </span><span class="s4">&quot;Request&quot;</span>
    <span class="s1">RESPONSE = </span><span class="s4">&quot;Response&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RequestPattern:</span>
    <span class="s0">#: Wildcards ('*' -&gt; zero or more, '?' -&gt; exactly one) are allowed. Escape character is</span>
    <span class="s0">#: backslash. Omitting is equivalent to &quot;*&quot;.</span>
    <span class="s1">url_pattern: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: If set, only requests for matching resource types will be intercepted.</span>
    <span class="s1">resource_type: typing.Optional[network.ResourceType] = </span><span class="s2">None</span>

    <span class="s0">#: Stage at wich to begin intercepting requests. Default is Request.</span>
    <span class="s1">request_stage: typing.Optional[RequestStage] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s2">if </span><span class="s1">self.url_pattern </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'urlPattern'</span><span class="s1">] = self.url_pattern</span>
        <span class="s2">if </span><span class="s1">self.resource_type </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'resourceType'</span><span class="s1">] = self.resource_type.to_json()</span>
        <span class="s2">if </span><span class="s1">self.request_stage </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'requestStage'</span><span class="s1">] = self.request_stage.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">url_pattern=str(json[</span><span class="s4">'urlPattern'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'urlPattern' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">resource_type=network.ResourceType.from_json(json[</span><span class="s4">'resourceType'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'resourceType' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">request_stage=RequestStage.from_json(json[</span><span class="s4">'requestStage'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'requestStage' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">HeaderEntry:</span>
    <span class="s3">''' 
    Response HTTP header entry 
    '''</span>
    <span class="s1">name: str</span>

    <span class="s1">value: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=str(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">AuthChallenge:</span>
    <span class="s3">''' 
    Authorization challenge for HTTP status code 401 or 407. 
    '''</span>
    <span class="s0">#: Origin of the challenger.</span>
    <span class="s1">origin: str</span>

    <span class="s0">#: The authentication scheme used, such as basic or digest</span>
    <span class="s1">scheme: str</span>

    <span class="s0">#: The realm of the challenge. May be empty.</span>
    <span class="s1">realm: str</span>

    <span class="s0">#: Source of the authentication challenge.</span>
    <span class="s1">source: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'origin'</span><span class="s1">] = self.origin</span>
        <span class="s1">json[</span><span class="s4">'scheme'</span><span class="s1">] = self.scheme</span>
        <span class="s1">json[</span><span class="s4">'realm'</span><span class="s1">] = self.realm</span>
        <span class="s2">if </span><span class="s1">self.source </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'source'</span><span class="s1">] = self.source</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">origin=str(json[</span><span class="s4">'origin'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">scheme=str(json[</span><span class="s4">'scheme'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">realm=str(json[</span><span class="s4">'realm'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">source=str(json[</span><span class="s4">'source'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'source' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">AuthChallengeResponse:</span>
    <span class="s3">''' 
    Response to an AuthChallenge. 
    '''</span>
    <span class="s0">#: The decision on what to do in response to the authorization challenge.  Default means</span>
    <span class="s0">#: deferring to the default behavior of the net stack, which will likely either the Cancel</span>
    <span class="s0">#: authentication or display a popup dialog box.</span>
    <span class="s1">response: str</span>

    <span class="s0">#: The username to provide, possibly empty. Should only be set if response is</span>
    <span class="s0">#: ProvideCredentials.</span>
    <span class="s1">username: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: The password to provide, possibly empty. Should only be set if response is</span>
    <span class="s0">#: ProvideCredentials.</span>
    <span class="s1">password: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'response'</span><span class="s1">] = self.response</span>
        <span class="s2">if </span><span class="s1">self.username </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'username'</span><span class="s1">] = self.username</span>
        <span class="s2">if </span><span class="s1">self.password </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'password'</span><span class="s1">] = self.password</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">response=str(json[</span><span class="s4">'response'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">username=str(json[</span><span class="s4">'username'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'username' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">password=str(json[</span><span class="s4">'password'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'password' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">disable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disables the fetch domain. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Fetch.disable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">enable(</span>
        <span class="s1">patterns: typing.Optional[typing.List[RequestPattern]] = </span><span class="s2">None,</span>
        <span class="s1">handle_auth_requests: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables issuing of requestPaused events. A request will be paused until client 
    calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth. 
 
    :param patterns: *(Optional)* If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected. 
    :param handle_auth_requests: *(Optional)* If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">patterns </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'patterns'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">patterns]</span>
    <span class="s2">if </span><span class="s1">handle_auth_requests </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'handleAuthRequests'</span><span class="s1">] = handle_auth_requests</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Fetch.enable'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">fail_request(</span>
        <span class="s1">request_id: RequestId</span><span class="s2">,</span>
        <span class="s1">error_reason: network.ErrorReason</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Causes the request to fail with specified reason. 
 
    :param request_id: An id the client received in requestPaused event. 
    :param error_reason: Causes the request to fail with the given reason. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'errorReason'</span><span class="s1">] = error_reason.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Fetch.failRequest'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">fulfill_request(</span>
        <span class="s1">request_id: RequestId</span><span class="s2">,</span>
        <span class="s1">response_code: int</span><span class="s2">,</span>
        <span class="s1">response_headers: typing.Optional[typing.List[HeaderEntry]] = </span><span class="s2">None,</span>
        <span class="s1">binary_response_headers: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">body: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">response_phrase: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Provides response to the request. 
 
    :param request_id: An id the client received in requestPaused event. 
    :param response_code: An HTTP response code. 
    :param response_headers: *(Optional)* Response headers. 
    :param binary_response_headers: *(Optional)* Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. 
    :param body: *(Optional)* A response body. 
    :param response_phrase: *(Optional)* A textual representation of responseCode. If absent, a standard phrase matching responseCode is used. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'responseCode'</span><span class="s1">] = response_code</span>
    <span class="s2">if </span><span class="s1">response_headers </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'responseHeaders'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">response_headers]</span>
    <span class="s2">if </span><span class="s1">binary_response_headers </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'binaryResponseHeaders'</span><span class="s1">] = binary_response_headers</span>
    <span class="s2">if </span><span class="s1">body </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'body'</span><span class="s1">] = body</span>
    <span class="s2">if </span><span class="s1">response_phrase </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'responsePhrase'</span><span class="s1">] = response_phrase</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Fetch.fulfillRequest'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">continue_request(</span>
        <span class="s1">request_id: RequestId</span><span class="s2">,</span>
        <span class="s1">url: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">method: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">post_data: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">headers: typing.Optional[typing.List[HeaderEntry]] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Continues the request, optionally modifying some of its parameters. 
 
    :param request_id: An id the client received in requestPaused event. 
    :param url: *(Optional)* If set, the request url will be modified in a way that's not observable by page. 
    :param method: *(Optional)* If set, the request method is overridden. 
    :param post_data: *(Optional)* If set, overrides the post data in the request. 
    :param headers: *(Optional)* If set, overrides the request headers. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s2">if </span><span class="s1">url </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'url'</span><span class="s1">] = url</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'method'</span><span class="s1">] = method</span>
    <span class="s2">if </span><span class="s1">post_data </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'postData'</span><span class="s1">] = post_data</span>
    <span class="s2">if </span><span class="s1">headers </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'headers'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">headers]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Fetch.continueRequest'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">continue_with_auth(</span>
        <span class="s1">request_id: RequestId</span><span class="s2">,</span>
        <span class="s1">auth_challenge_response: AuthChallengeResponse</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Continues a request supplying authChallengeResponse following authRequired event. 
 
    :param request_id: An id the client received in authRequired event. 
    :param auth_challenge_response: Response to  with an authChallenge. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'authChallengeResponse'</span><span class="s1">] = auth_challenge_response.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Fetch.continueWithAuth'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_response_body(</span>
        <span class="s1">request_id: RequestId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[str</span><span class="s2">, </span><span class="s1">bool]]:</span>
    <span class="s3">''' 
    Causes the body of the response to be received from the server and 
    returned as a single string. May only be issued for a request that 
    is paused in the Response stage and is mutually exclusive with 
    takeResponseBodyForInterceptionAsStream. Calling other methods that 
    affect the request or disabling fetch domain before body is received 
    results in an undefined behavior. 
 
    :param request_id: Identifier for the intercepted request to get body for. 
    :returns: A tuple with the following items: 
 
        0. **body** - Response body. 
        1. **base64Encoded** - True, if content was sent as base64. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Fetch.getResponseBody'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">str(json[</span><span class="s4">'body'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">bool(json[</span><span class="s4">'base64Encoded'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">take_response_body_as_stream(</span>
        <span class="s1">request_id: RequestId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">io.StreamHandle]:</span>
    <span class="s3">''' 
    Returns a handle to the stream representing the response body. 
    The request must be paused in the HeadersReceived stage. 
    Note that after this command the request can't be continued 
    as is -- client either needs to cancel it or to provide the 
    response body. 
    The stream only supports sequential read, IO.read will fail if the position 
    is specified. 
    This method is mutually exclusive with getResponseBody. 
    Calling other methods that affect the request or disabling fetch 
    domain before body is received results in an undefined behavior. 
 
    :param request_id: 
    :returns:  
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Fetch.takeResponseBodyAsStream'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">io.StreamHandle.from_json(json[</span><span class="s4">'stream'</span><span class="s1">])</span>


<span class="s1">@event_class(</span><span class="s4">'Fetch.requestPaused'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RequestPaused:</span>
    <span class="s3">''' 
    Issued when the domain is enabled and the request URL matches the 
    specified filter. The request is paused until the client responds 
    with one of continueRequest, failRequest or fulfillRequest. 
    The stage of the request can be determined by presence of responseErrorReason 
    and responseStatusCode -- the request is at the response stage if either 
    of these fields is present and in the request stage otherwise. 
    '''</span>
    <span class="s0">#: Each request the page makes will have a unique id.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: The details of the request.</span>
    <span class="s1">request: network.Request</span>
    <span class="s0">#: The id of the frame that initiated the request.</span>
    <span class="s1">frame_id: page.FrameId</span>
    <span class="s0">#: How the requested resource will be used.</span>
    <span class="s1">resource_type: network.ResourceType</span>
    <span class="s0">#: Response error if intercepted at response stage.</span>
    <span class="s1">response_error_reason: typing.Optional[network.ErrorReason]</span>
    <span class="s0">#: Response code if intercepted at response stage.</span>
    <span class="s1">response_status_code: typing.Optional[int]</span>
    <span class="s0">#: Response headers if intercepted at the response stage.</span>
    <span class="s1">response_headers: typing.Optional[typing.List[HeaderEntry]]</span>
    <span class="s0">#: If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,</span>
    <span class="s0">#: then this networkId will be the same as the requestId present in the requestWillBeSent event.</span>
    <span class="s1">network_id: typing.Optional[RequestId]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; RequestPaused:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">request=network.Request.from_json(json[</span><span class="s4">'request'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">frame_id=page.FrameId.from_json(json[</span><span class="s4">'frameId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">resource_type=network.ResourceType.from_json(json[</span><span class="s4">'resourceType'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">response_error_reason=network.ErrorReason.from_json(json[</span><span class="s4">'responseErrorReason'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'responseErrorReason' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">response_status_code=int(json[</span><span class="s4">'responseStatusCode'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'responseStatusCode' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">response_headers=[HeaderEntry.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'responseHeaders'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'responseHeaders' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">network_id=RequestId.from_json(json[</span><span class="s4">'networkId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'networkId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Fetch.authRequired'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">AuthRequired:</span>
    <span class="s3">''' 
    Issued when the domain is enabled with handleAuthRequests set to true. 
    The request is paused until client responds with continueWithAuth. 
    '''</span>
    <span class="s0">#: Each request the page makes will have a unique id.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: The details of the request.</span>
    <span class="s1">request: network.Request</span>
    <span class="s0">#: The id of the frame that initiated the request.</span>
    <span class="s1">frame_id: page.FrameId</span>
    <span class="s0">#: How the requested resource will be used.</span>
    <span class="s1">resource_type: network.ResourceType</span>
    <span class="s0">#: Details of the Authorization Challenge encountered.</span>
    <span class="s0">#: If this is set, client should respond with continueRequest that</span>
    <span class="s0">#: contains AuthChallengeResponse.</span>
    <span class="s1">auth_challenge: AuthChallenge</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; AuthRequired:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">request=network.Request.from_json(json[</span><span class="s4">'request'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">frame_id=page.FrameId.from_json(json[</span><span class="s4">'frameId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">resource_type=network.ResourceType.from_json(json[</span><span class="s4">'resourceType'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">auth_challenge=AuthChallenge.from_json(json[</span><span class="s4">'authChallenge'</span><span class="s1">])</span>
        <span class="s1">)</span>
</pre>
</body>
</html>