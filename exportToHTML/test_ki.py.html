<html>
<head>
<title>test_ki.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_ki.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">outcome</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">signal</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">contextlib</span>
<span class="s0">import </span><span class="s1">time</span>

<span class="s0">from </span><span class="s1">async_generator </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">async_generator</span><span class="s0">,</span>
    <span class="s1">yield_</span><span class="s0">,</span>
    <span class="s1">isasyncgenfunction</span><span class="s0">,</span>
    <span class="s1">asynccontextmanager</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">... </span><span class="s0">import </span><span class="s1">_core</span>
<span class="s0">from </span><span class="s1">...testing </span><span class="s0">import </span><span class="s1">wait_all_tasks_blocked</span>
<span class="s0">from </span><span class="s1">..._util </span><span class="s0">import </span><span class="s1">signal_raise</span><span class="s0">, </span><span class="s1">is_main_thread</span>
<span class="s0">from </span><span class="s1">..._timeouts </span><span class="s0">import </span><span class="s1">sleep</span>
<span class="s0">from </span><span class="s1">.tutil </span><span class="s0">import </span><span class="s1">slow</span>


<span class="s0">def </span><span class="s1">ki_self():</span>
    <span class="s1">signal_raise(signal.SIGINT)</span>


<span class="s0">def </span><span class="s1">test_ki_self():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
        <span class="s1">ki_self()</span>


<span class="s0">async def </span><span class="s1">test_ki_enabled():</span>
    <span class="s2"># Regular tasks aren't KI-protected</span>
    <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s2"># Low-level call-soon callbacks are KI-protected</span>
    <span class="s1">token = _core.current_trio_token()</span>
    <span class="s1">record = []</span>

    <span class="s0">def </span><span class="s1">check():</span>
        <span class="s1">record.append(_core.currently_ki_protected())</span>

    <span class="s1">token.run_sync_soon(check)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
    <span class="s0">assert </span><span class="s1">record == [</span><span class="s0">True</span><span class="s1">]</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">protected():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s1">unprotected()</span>

    <span class="s1">@_core.disable_ki_protection</span>
    <span class="s0">def </span><span class="s1">unprotected():</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s1">protected()</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">aprotected():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">await </span><span class="s1">aunprotected()</span>

    <span class="s1">@_core.disable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">aunprotected():</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s0">await </span><span class="s1">aprotected()</span>

    <span class="s2"># make sure that the decorator here overrides the automatic manipulation</span>
    <span class="s2"># that start_soon() does:</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(aprotected)</span>
        <span class="s1">nursery.start_soon(aunprotected)</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">gen_protected():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">yield</span>

    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">gen_protected():</span>
        <span class="s0">pass</span>

    <span class="s1">@_core.disable_ki_protection</span>
    <span class="s0">def </span><span class="s1">gen_unprotected():</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">yield</span>

    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">gen_unprotected():</span>
        <span class="s0">pass</span>


<span class="s2"># This used to be broken due to</span>
<span class="s2">#</span>
<span class="s2">#   https://bugs.python.org/issue29590</span>
<span class="s2">#</span>
<span class="s2"># Specifically, after a coroutine is resumed with .throw(), then the stack</span>
<span class="s2"># makes it look like the immediate caller is the function that called</span>
<span class="s2"># .throw(), not the actual caller. So child() here would have a caller deep in</span>
<span class="s2"># the guts of the run loop, and always be protected, even when it shouldn't</span>
<span class="s2"># have been. (Solution: we don't use .throw() anymore.)</span>
<span class="s0">async def </span><span class="s1">test_ki_enabled_after_yield_briefly():</span>
    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">protected():</span>
        <span class="s0">await </span><span class="s1">child(</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">@_core.disable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">unprotected():</span>
        <span class="s0">await </span><span class="s1">child(</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">child(expected):</span>
        <span class="s0">import </span><span class="s1">traceback</span>

        <span class="s1">traceback.print_stack()</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected() == expected</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s1">traceback.print_stack()</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected() == expected</span>

    <span class="s0">await </span><span class="s1">protected()</span>
    <span class="s0">await </span><span class="s1">unprotected()</span>


<span class="s2"># This also used to be broken due to</span>
<span class="s2">#   https://bugs.python.org/issue29590</span>
<span class="s0">async def </span><span class="s1">test_generator_based_context_manager_throw():</span>
    <span class="s1">@contextlib.contextmanager</span>
    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">def </span><span class="s1">protected_manager():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">yield</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s0">with </span><span class="s1">protected_manager():</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
        <span class="s2"># This is the one that used to fail</span>
        <span class="s0">with </span><span class="s1">protected_manager():</span>
            <span class="s0">raise </span><span class="s1">KeyError</span>


<span class="s0">async def </span><span class="s1">test_agen_protection():</span>
    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s1">@async_generator</span>
    <span class="s0">async def </span><span class="s1">agen_protected1():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">yield_()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s1">@_core.disable_ki_protection</span>
    <span class="s1">@async_generator</span>
    <span class="s0">async def </span><span class="s1">agen_unprotected1():</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">yield_()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s2"># Swap the order of the decorators:</span>
    <span class="s1">@async_generator</span>
    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">agen_protected2():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">yield_()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s1">@async_generator</span>
    <span class="s1">@_core.disable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">agen_unprotected2():</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">yield_()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s2"># Native async generators</span>
    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">agen_protected3():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">yield</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s1">@_core.disable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">agen_unprotected3():</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">yield</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s0">for </span><span class="s1">agen_fn </span><span class="s0">in </span><span class="s1">[</span>
        <span class="s1">agen_protected1</span><span class="s0">,</span>
        <span class="s1">agen_protected2</span><span class="s0">,</span>
        <span class="s1">agen_protected3</span><span class="s0">,</span>
        <span class="s1">agen_unprotected1</span><span class="s0">,</span>
        <span class="s1">agen_unprotected2</span><span class="s0">,</span>
        <span class="s1">agen_unprotected3</span><span class="s0">,</span>
    <span class="s1">]:</span>
        <span class="s0">async for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">agen_fn():  </span><span class="s2"># noqa</span>
            <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

        <span class="s2"># asynccontextmanager insists that the function passed must itself be an</span>
        <span class="s2"># async gen function, not a wrapper around one</span>
        <span class="s0">if </span><span class="s1">isasyncgenfunction(agen_fn):</span>
            <span class="s0">async with </span><span class="s1">asynccontextmanager(agen_fn)():</span>
                <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>

            <span class="s2"># Another case that's tricky due to:</span>
            <span class="s2">#   https://bugs.python.org/issue29590</span>
            <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
                <span class="s0">async with </span><span class="s1">asynccontextmanager(agen_fn)():</span>
                    <span class="s0">raise </span><span class="s1">KeyError</span>


<span class="s2"># Test the case where there's no magic local anywhere in the call stack</span>
<span class="s0">def </span><span class="s1">test_ki_disabled_out_of_context():</span>
    <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>


<span class="s0">def </span><span class="s1">test_ki_disabled_in_del():</span>
    <span class="s0">def </span><span class="s1">nestedfunction():</span>
        <span class="s0">return </span><span class="s1">_core.currently_ki_protected()</span>

    <span class="s0">def </span><span class="s1">__del__():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">assert </span><span class="s1">nestedfunction()</span>

    <span class="s1">@_core.disable_ki_protection</span>
    <span class="s0">def </span><span class="s1">outerfunction():</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">assert not </span><span class="s1">nestedfunction()</span>
        <span class="s1">__del__()</span>

    <span class="s1">__del__()</span>
    <span class="s1">outerfunction()</span>
    <span class="s0">assert </span><span class="s1">nestedfunction()</span>


<span class="s0">def </span><span class="s1">test_ki_protection_works():</span>
    <span class="s0">async def </span><span class="s1">sleeper(name</span><span class="s0">, </span><span class="s1">record):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
            <span class="s1">record.add(name + </span><span class="s3">&quot; ok&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">raiser(name</span><span class="s0">, </span><span class="s1">record):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># os.kill runs signal handlers before returning, so we don't need</span>
            <span class="s2"># to worry that the handler will be delayed</span>
            <span class="s1">print(</span><span class="s3">&quot;killing, protection =&quot;</span><span class="s0">, </span><span class="s1">_core.currently_ki_protected())</span>
            <span class="s1">ki_self()</span>
        <span class="s0">except </span><span class="s1">KeyboardInterrupt:</span>
            <span class="s1">print(</span><span class="s3">&quot;raised!&quot;</span><span class="s1">)</span>
            <span class="s2"># Make sure we aren't getting cancelled as well as siginted</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s1">record.add(name + </span><span class="s3">&quot; raise ok&quot;</span><span class="s1">)</span>
            <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s3">&quot;didn't raise!&quot;</span><span class="s1">)</span>
            <span class="s2"># If we didn't raise (b/c protected), then we *should* get</span>
            <span class="s2"># cancelled at the next opportunity</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">_core.wait_task_rescheduled(</span><span class="s0">lambda </span><span class="s1">_: _core.Abort.SUCCEEDED)</span>
            <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
                <span class="s1">record.add(name + </span><span class="s3">&quot; cancel ok&quot;</span><span class="s1">)</span>

    <span class="s2"># simulated control-C during raiser, which is *unprotected*</span>
    <span class="s1">print(</span><span class="s3">&quot;check 1&quot;</span><span class="s1">)</span>
    <span class="s1">record = set()</span>

    <span class="s0">async def </span><span class="s1">check_unprotected_kill():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(sleeper</span><span class="s0">, </span><span class="s3">&quot;s1&quot;</span><span class="s0">, </span><span class="s1">record)</span>
            <span class="s1">nursery.start_soon(sleeper</span><span class="s0">, </span><span class="s3">&quot;s2&quot;</span><span class="s0">, </span><span class="s1">record)</span>
            <span class="s1">nursery.start_soon(raiser</span><span class="s0">, </span><span class="s3">&quot;r1&quot;</span><span class="s0">, </span><span class="s1">record)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
        <span class="s1">_core.run(check_unprotected_kill)</span>
    <span class="s0">assert </span><span class="s1">record == {</span><span class="s3">&quot;s1 ok&quot;</span><span class="s0">, </span><span class="s3">&quot;s2 ok&quot;</span><span class="s0">, </span><span class="s3">&quot;r1 raise ok&quot;</span><span class="s1">}</span>

    <span class="s2"># simulated control-C during raiser, which is *protected*, so the KI gets</span>
    <span class="s2"># delivered to the main task instead</span>
    <span class="s1">print(</span><span class="s3">&quot;check 2&quot;</span><span class="s1">)</span>
    <span class="s1">record = set()</span>

    <span class="s0">async def </span><span class="s1">check_protected_kill():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(sleeper</span><span class="s0">, </span><span class="s3">&quot;s1&quot;</span><span class="s0">, </span><span class="s1">record)</span>
            <span class="s1">nursery.start_soon(sleeper</span><span class="s0">, </span><span class="s3">&quot;s2&quot;</span><span class="s0">, </span><span class="s1">record)</span>
            <span class="s1">nursery.start_soon(_core.enable_ki_protection(raiser)</span><span class="s0">, </span><span class="s3">&quot;r1&quot;</span><span class="s0">, </span><span class="s1">record)</span>
            <span class="s2"># __aexit__ blocks, and then receives the KI</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
        <span class="s1">_core.run(check_protected_kill)</span>
    <span class="s0">assert </span><span class="s1">record == {</span><span class="s3">&quot;s1 ok&quot;</span><span class="s0">, </span><span class="s3">&quot;s2 ok&quot;</span><span class="s0">, </span><span class="s3">&quot;r1 cancel ok&quot;</span><span class="s1">}</span>

    <span class="s2"># kill at last moment still raises (run_sync_soon until it raises an</span>
    <span class="s2"># error, then kill)</span>
    <span class="s1">print(</span><span class="s3">&quot;check 3&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">check_kill_during_shutdown():</span>
        <span class="s1">token = _core.current_trio_token()</span>

        <span class="s0">def </span><span class="s1">kill_during_shutdown():</span>
            <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">token.run_sync_soon(kill_during_shutdown)</span>
            <span class="s0">except </span><span class="s1">_core.RunFinishedError:</span>
                <span class="s2"># it's too late for regular handling! handle this!</span>
                <span class="s1">print(</span><span class="s3">&quot;kill! kill!&quot;</span><span class="s1">)</span>
                <span class="s1">ki_self()</span>

        <span class="s1">token.run_sync_soon(kill_during_shutdown)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
        <span class="s1">_core.run(check_kill_during_shutdown)</span>

    <span class="s2"># KI arrives very early, before main is even spawned</span>
    <span class="s1">print(</span><span class="s3">&quot;check 4&quot;</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">InstrumentOfDeath:</span>
        <span class="s0">def </span><span class="s1">before_run(self):</span>
            <span class="s1">ki_self()</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
        <span class="s1">_core.run(main</span><span class="s0">, </span><span class="s1">instruments=[InstrumentOfDeath()])</span>

    <span class="s2"># checkpoint_if_cancelled notices pending KI</span>
    <span class="s1">print(</span><span class="s3">&quot;check 5&quot;</span><span class="s1">)</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s1">ki_self()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint_if_cancelled()</span>

    <span class="s1">_core.run(main)</span>

    <span class="s2"># KI arrives while main task is not abortable, b/c already scheduled</span>
    <span class="s1">print(</span><span class="s3">&quot;check 6&quot;</span><span class="s1">)</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s1">ki_self()</span>
        <span class="s0">await </span><span class="s1">_core.cancel_shielded_checkpoint()</span>
        <span class="s0">await </span><span class="s1">_core.cancel_shielded_checkpoint()</span>
        <span class="s0">await </span><span class="s1">_core.cancel_shielded_checkpoint()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.run(main)</span>

    <span class="s2"># KI arrives while main task is not abortable, b/c refuses to be aborted</span>
    <span class="s1">print(</span><span class="s3">&quot;check 7&quot;</span><span class="s1">)</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s1">ki_self()</span>
        <span class="s1">task = _core.current_task()</span>

        <span class="s0">def </span><span class="s1">abort(_):</span>
            <span class="s1">_core.reschedule(task</span><span class="s0">, </span><span class="s1">outcome.Value(</span><span class="s4">1</span><span class="s1">))</span>
            <span class="s0">return </span><span class="s1">_core.Abort.FAILED</span>

        <span class="s0">assert await </span><span class="s1">_core.wait_task_rescheduled(abort) == </span><span class="s4">1</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.run(main)</span>

    <span class="s2"># KI delivered via slow abort</span>
    <span class="s1">print(</span><span class="s3">&quot;check 8&quot;</span><span class="s1">)</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s1">ki_self()</span>
        <span class="s1">task = _core.current_task()</span>

        <span class="s0">def </span><span class="s1">abort(raise_cancel):</span>
            <span class="s1">result = outcome.capture(raise_cancel)</span>
            <span class="s1">_core.reschedule(task</span><span class="s0">, </span><span class="s1">result)</span>
            <span class="s0">return </span><span class="s1">_core.Abort.FAILED</span>

        <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
            <span class="s0">assert await </span><span class="s1">_core.wait_task_rescheduled(abort)</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.run(main)</span>

    <span class="s2"># KI arrives just before main task exits, so the run_sync_soon machinery</span>
    <span class="s2"># is still functioning and will accept the callback to deliver the KI, but</span>
    <span class="s2"># by the time the callback is actually run, main has exited and can't be</span>
    <span class="s2"># aborted.</span>
    <span class="s1">print(</span><span class="s3">&quot;check 9&quot;</span><span class="s1">)</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">ki_self()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
        <span class="s1">_core.run(main)</span>

    <span class="s1">print(</span><span class="s3">&quot;check 10&quot;</span><span class="s1">)</span>
    <span class="s2"># KI in unprotected code, with</span>
    <span class="s2"># restrict_keyboard_interrupt_to_checkpoints=True</span>
    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s2"># We're not KI protected...</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s1">ki_self()</span>
        <span class="s2"># ...but even after the KI, we keep running uninterrupted...</span>
        <span class="s1">record.append(</span><span class="s3">&quot;ok&quot;</span><span class="s1">)</span>
        <span class="s2"># ...until we hit a checkpoint:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
            <span class="s0">await </span><span class="s1">sleep(</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s1">_core.run(main</span><span class="s0">, </span><span class="s1">restrict_keyboard_interrupt_to_checkpoints=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">record == [</span><span class="s3">&quot;ok&quot;</span><span class="s1">]</span>
    <span class="s1">record = []</span>
    <span class="s2"># Exact same code raises KI early if we leave off the argument, doesn't</span>
    <span class="s2"># even reach the record.append call:</span>
    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
        <span class="s1">_core.run(main)</span>
    <span class="s0">assert </span><span class="s1">record == []</span>

    <span class="s2"># KI arrives while main task is inside a cancelled cancellation scope</span>
    <span class="s2"># the KeyboardInterrupt should take priority</span>
    <span class="s1">print(</span><span class="s3">&quot;check 11&quot;</span><span class="s1">)</span>

    <span class="s1">@_core.enable_ki_protection</span>
    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">assert </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cancel_scope:</span>
            <span class="s1">cancel_scope.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s1">ki_self()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.run(main)</span>


<span class="s0">def </span><span class="s1">test_ki_is_good_neighbor():</span>
    <span class="s2"># in the unlikely event someone overwrites our signal handler, we leave</span>
    <span class="s2"># the overwritten one be</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">orig = signal.getsignal(signal.SIGINT)</span>

        <span class="s0">def </span><span class="s1">my_handler(signum</span><span class="s0">, </span><span class="s1">frame):  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">pass</span>

        <span class="s0">async def </span><span class="s1">main():</span>
            <span class="s1">signal.signal(signal.SIGINT</span><span class="s0">, </span><span class="s1">my_handler)</span>

        <span class="s1">_core.run(main)</span>

        <span class="s0">assert </span><span class="s1">signal.getsignal(signal.SIGINT) </span><span class="s0">is </span><span class="s1">my_handler</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">signal.signal(signal.SIGINT</span><span class="s0">, </span><span class="s1">orig)</span>


<span class="s2"># Regression test for #461</span>
<span class="s0">def </span><span class="s1">test_ki_with_broken_threads():</span>
    <span class="s1">thread = threading.main_thread()</span>

    <span class="s2"># scary!</span>
    <span class="s1">original = threading._active[thread.ident]</span>

    <span class="s2"># put this in a try finally so we don't have a chance of cascading a</span>
    <span class="s2"># breakage down to everything else</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">del </span><span class="s1">threading._active[thread.ident]</span>

        <span class="s1">@_core.enable_ki_protection</span>
        <span class="s0">async def </span><span class="s1">inner():</span>
            <span class="s0">assert </span><span class="s1">signal.getsignal(signal.SIGINT) != signal.default_int_handler</span>

        <span class="s1">_core.run(inner)</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">threading._active[thread.ident] = original</span>


<span class="s2"># For details on why this test is non-trivial, see:</span>
<span class="s2">#   https://github.com/python-trio/trio/issues/42</span>
<span class="s2">#   https://github.com/python-trio/trio/issues/109</span>
<span class="s1">@slow</span>
<span class="s0">def </span><span class="s1">test_ki_wakes_us_up():</span>
    <span class="s0">assert </span><span class="s1">is_main_thread()</span>

    <span class="s2"># This test is flaky due to a race condition on Windows; see:</span>
    <span class="s2">#   https://github.com/python-trio/trio/issues/119</span>
    <span class="s2">#   https://bugs.python.org/issue30038</span>
    <span class="s2"># I think the only fix is to wait for fixed CPython to be released, so in</span>
    <span class="s2"># the mean time, on affected versions we send two signals (equivalent to</span>
    <span class="s2"># hitting control-C twice). This works because the problem is that the C</span>
    <span class="s2"># level signal handler does</span>
    <span class="s2">#</span>
    <span class="s2">#   write-to-fd -&gt; set-flags</span>
    <span class="s2">#</span>
    <span class="s2"># and we need</span>
    <span class="s2">#</span>
    <span class="s2">#   set-flags -&gt; write-to-fd</span>
    <span class="s2">#</span>
    <span class="s2"># so running the C level signal handler twice does</span>
    <span class="s2">#</span>
    <span class="s2">#   write-to-fd -&gt; set-flags -&gt; write-to-fd -&gt; set-flags</span>
    <span class="s2">#</span>
    <span class="s2"># which contains the desired sequence.</span>
    <span class="s2">#</span>
    <span class="s2"># Affected version of CPython include 3.6.1 and earlier.</span>
    <span class="s2"># It's fixed in 3.6.2 and 3.7+</span>
    <span class="s2">#</span>
    <span class="s2"># PyPy was never affected.</span>
    <span class="s2">#</span>
    <span class="s2"># The problem technically can occur on Unix as well, if a signal is</span>
    <span class="s2"># delivered to a non-main thread, though we haven't observed this in</span>
    <span class="s2"># practice.</span>
    <span class="s2">#</span>
    <span class="s2"># There's also this theoretical problem, but hopefully it won't actually</span>
    <span class="s2"># bite us in practice:</span>
    <span class="s2">#   https://bugs.python.org/issue31119</span>
    <span class="s2">#   https://bitbucket.org/pypy/pypy/issues/2623</span>
    <span class="s0">import </span><span class="s1">platform</span>

    <span class="s1">buggy_wakeup_fd = (</span>
        <span class="s1">sys.version_info &lt; (</span><span class="s4">3</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">2</span><span class="s1">) </span><span class="s0">and </span><span class="s1">platform.python_implementation() == </span><span class="s3">&quot;CPython&quot;</span>
    <span class="s1">)</span>

    <span class="s2"># lock is only needed to avoid an annoying race condition where the</span>
    <span class="s2"># *second* ki_self() call arrives *after* the first one woke us up and its</span>
    <span class="s2"># KeyboardInterrupt was caught, and then generates a second</span>
    <span class="s2"># KeyboardInterrupt that aborts the test run. The kill_soon thread holds</span>
    <span class="s2"># the lock while doing the calls to ki_self, which means that it holds it</span>
    <span class="s2"># while the C-level signal handler is running. Then in the main thread,</span>
    <span class="s2"># when we're woken up we know that ki_self() has been run at least once;</span>
    <span class="s2"># if we then take the lock it guaranteeds that ki_self() has been run</span>
    <span class="s2"># twice, so if a second KeyboardInterrupt is going to arrive it should</span>
    <span class="s2"># arrive by the time we've acquired the lock. This lets us force it to</span>
    <span class="s2"># happen inside the pytest.raises block.</span>
    <span class="s2">#</span>
    <span class="s2"># It will be very nice when the buggy_wakeup_fd bug is fixed.</span>
    <span class="s1">lock = threading.Lock()</span>

    <span class="s0">def </span><span class="s1">kill_soon():</span>
        <span class="s2"># We want the signal to be raised after the main thread has entered</span>
        <span class="s2"># the IO manager blocking primitive. There really is no way to</span>
        <span class="s2"># deterministically interlock with that, so we have to use sleep and</span>
        <span class="s2"># hope it's long enough.</span>
        <span class="s1">time.sleep(</span><span class="s4">1.1</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">lock:</span>
            <span class="s1">print(</span><span class="s3">&quot;thread doing ki_self()&quot;</span><span class="s1">)</span>
            <span class="s1">ki_self()</span>
            <span class="s0">if </span><span class="s1">buggy_wakeup_fd:</span>
                <span class="s1">print(</span><span class="s3">&quot;buggy_wakeup_fd =&quot;</span><span class="s0">, </span><span class="s1">buggy_wakeup_fd)</span>
                <span class="s1">ki_self()</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">thread = threading.Thread(target=kill_soon)</span>
        <span class="s1">print(</span><span class="s3">&quot;Starting thread&quot;</span><span class="s1">)</span>
        <span class="s1">thread.start()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
                <span class="s2"># To limit the damage on CI if this does get broken (as</span>
                <span class="s2"># compared to sleep_forever())</span>
                <span class="s1">print(</span><span class="s3">&quot;Going to sleep&quot;</span><span class="s1">)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">await </span><span class="s1">sleep(</span><span class="s4">20</span><span class="s1">)</span>
                    <span class="s1">print(</span><span class="s3">&quot;Woke without raising?!&quot;</span><span class="s1">)  </span><span class="s2"># pragma: no cover</span>
                <span class="s2"># The only purpose of this finally: block is to soak up the</span>
                <span class="s2"># second KeyboardInterrupt that might arrive on</span>
                <span class="s2"># buggy_wakeup_fd platforms. So it might get aborted at any</span>
                <span class="s2"># moment randomly on some runs, so pragma: no cover avoids</span>
                <span class="s2"># coverage flapping:</span>
                <span class="s0">finally</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
                    <span class="s1">print(</span><span class="s3">&quot;waiting for lock&quot;</span><span class="s1">)</span>
                    <span class="s0">with </span><span class="s1">lock:</span>
                        <span class="s1">print(</span><span class="s3">&quot;got lock&quot;</span><span class="s1">)</span>
                    <span class="s2"># And then we want to force a PyErr_CheckSignals. Which is</span>
                    <span class="s2"># not so easy on Windows. Weird kluge: builtin_repr calls</span>
                    <span class="s2"># PyObject_Repr, which does an unconditional</span>
                    <span class="s2"># PyErr_CheckSignals for some reason.</span>
                    <span class="s1">print(repr(</span><span class="s0">None</span><span class="s1">))</span>
                    <span class="s2"># And finally, it's possible that the signal was delivered</span>
                    <span class="s2"># but at a moment when we had KI protection enabled, so we</span>
                    <span class="s2"># need to execute a checkpoint to ensure it's delivered</span>
                    <span class="s2"># before we exit main().</span>
                    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s3">&quot;joining thread&quot;</span><span class="s0">, </span><span class="s1">sys.exc_info())</span>
            <span class="s1">thread.join()</span>

    <span class="s1">start = time.perf_counter()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">_core.run(main)</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">end = time.perf_counter()</span>
        <span class="s1">print(</span><span class="s3">&quot;duration&quot;</span><span class="s0">, </span><span class="s1">end - start)</span>
        <span class="s1">print(</span><span class="s3">&quot;sys.exc_info&quot;</span><span class="s0">, </span><span class="s1">sys.exc_info())</span>
    <span class="s0">assert </span><span class="s4">1.0 </span><span class="s1">&lt;= (end - start) &lt; </span><span class="s4">2</span>
</pre>
</body>
</html>