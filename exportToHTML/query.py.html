<html>
<head>
<title>query.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
query.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Create SQL statements for QuerySets. 
 
The code in here encapsulates all of the SQL construction so that QuerySets 
themselves do not have to (and could be backed by things other than SQL 
databases). The abstraction barrier only works one way: this module has to know 
all about the internals of models in order to get the information it needs. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">copy</span>
<span class="s2">import </span><span class="s1">difflib</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">Counter</span><span class="s2">, </span><span class="s1">namedtuple</span>
<span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Iterator</span><span class="s2">, </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">chain</span><span class="s2">, </span><span class="s1">count</span><span class="s2">, </span><span class="s1">product</span>
<span class="s2">from </span><span class="s1">string </span><span class="s2">import </span><span class="s1">ascii_uppercase</span>

<span class="s2">from </span><span class="s1">django.core.exceptions </span><span class="s2">import </span><span class="s1">FieldDoesNotExist</span><span class="s2">, </span><span class="s1">FieldError</span>
<span class="s2">from </span><span class="s1">django.db </span><span class="s2">import </span><span class="s1">DEFAULT_DB_ALIAS</span><span class="s2">, </span><span class="s1">NotSupportedError</span><span class="s2">, </span><span class="s1">connections</span>
<span class="s2">from </span><span class="s1">django.db.models.aggregates </span><span class="s2">import </span><span class="s1">Count</span>
<span class="s2">from </span><span class="s1">django.db.models.constants </span><span class="s2">import </span><span class="s1">LOOKUP_SEP</span>
<span class="s2">from </span><span class="s1">django.db.models.expressions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseExpression</span><span class="s2">, </span><span class="s1">Col</span><span class="s2">, </span><span class="s1">Exists</span><span class="s2">, </span><span class="s1">F</span><span class="s2">, </span><span class="s1">OuterRef</span><span class="s2">, </span><span class="s1">Ref</span><span class="s2">, </span><span class="s1">ResolvedOuterRef</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">django.db.models.fields </span><span class="s2">import </span><span class="s1">Field</span>
<span class="s2">from </span><span class="s1">django.db.models.fields.related_lookups </span><span class="s2">import </span><span class="s1">MultiColSource</span>
<span class="s2">from </span><span class="s1">django.db.models.lookups </span><span class="s2">import </span><span class="s1">Lookup</span>
<span class="s2">from </span><span class="s1">django.db.models.query_utils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Q</span><span class="s2">, </span><span class="s1">check_rel_lookup_compatibility</span><span class="s2">, </span><span class="s1">refs_expression</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">django.db.models.sql.constants </span><span class="s2">import </span><span class="s1">INNER</span><span class="s2">, </span><span class="s1">LOUTER</span><span class="s2">, </span><span class="s1">ORDER_DIR</span><span class="s2">, </span><span class="s1">SINGLE</span>
<span class="s2">from </span><span class="s1">django.db.models.sql.datastructures </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseTable</span><span class="s2">, </span><span class="s1">Empty</span><span class="s2">, </span><span class="s1">Join</span><span class="s2">, </span><span class="s1">MultiJoin</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">django.db.models.sql.where </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">AND</span><span class="s2">, </span><span class="s1">OR</span><span class="s2">, </span><span class="s1">ExtraWhere</span><span class="s2">, </span><span class="s1">NothingNode</span><span class="s2">, </span><span class="s1">WhereNode</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">django.utils.functional </span><span class="s2">import </span><span class="s1">cached_property</span>
<span class="s2">from </span><span class="s1">django.utils.tree </span><span class="s2">import </span><span class="s1">Node</span>

<span class="s1">__all__ = [</span><span class="s3">'Query'</span><span class="s2">, </span><span class="s3">'RawQuery'</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">get_field_names_from_opts(opts):</span>
    <span class="s2">return </span><span class="s1">set(chain.from_iterable(</span>
        <span class="s1">(f.name</span><span class="s2">, </span><span class="s1">f.attname) </span><span class="s2">if </span><span class="s1">f.concrete </span><span class="s2">else </span><span class="s1">(f.name</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">opts.get_fields()</span>
    <span class="s1">))</span>


<span class="s2">def </span><span class="s1">get_children_from_q(q):</span>
    <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">q.children:</span>
        <span class="s2">if </span><span class="s1">isinstance(child</span><span class="s2">, </span><span class="s1">Node):</span>
            <span class="s2">yield from </span><span class="s1">get_children_from_q(child)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">child</span>


<span class="s1">JoinInfo = namedtuple(</span>
    <span class="s3">'JoinInfo'</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">'final_field'</span><span class="s2">, </span><span class="s3">'targets'</span><span class="s2">, </span><span class="s3">'opts'</span><span class="s2">, </span><span class="s3">'joins'</span><span class="s2">, </span><span class="s3">'path'</span><span class="s2">, </span><span class="s3">'transform_function'</span><span class="s1">)</span>
<span class="s1">)</span>


<span class="s2">class </span><span class="s1">RawQuery:</span>
    <span class="s0">&quot;&quot;&quot;A single raw SQL query.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">sql</span><span class="s2">, </span><span class="s1">using</span><span class="s2">, </span><span class="s1">params=()):</span>
        <span class="s1">self.params = params</span>
        <span class="s1">self.sql = sql</span>
        <span class="s1">self.using = using</span>
        <span class="s1">self.cursor = </span><span class="s2">None</span>

        <span class="s4"># Mirror some properties of a normal query so that</span>
        <span class="s4"># the compiler can be used to process results.</span>
        <span class="s1">self.low_mark</span><span class="s2">, </span><span class="s1">self.high_mark = </span><span class="s5">0</span><span class="s2">, None  </span><span class="s4"># Used for offset/limit</span>
        <span class="s1">self.extra_select = {}</span>
        <span class="s1">self.annotation_select = {}</span>

    <span class="s2">def </span><span class="s1">chain(self</span><span class="s2">, </span><span class="s1">using):</span>
        <span class="s2">return </span><span class="s1">self.clone(using)</span>

    <span class="s2">def </span><span class="s1">clone(self</span><span class="s2">, </span><span class="s1">using):</span>
        <span class="s2">return </span><span class="s1">RawQuery(self.sql</span><span class="s2">, </span><span class="s1">using</span><span class="s2">, </span><span class="s1">params=self.params)</span>

    <span class="s2">def </span><span class="s1">get_columns(self):</span>
        <span class="s2">if </span><span class="s1">self.cursor </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._execute_query()</span>
        <span class="s1">converter = connections[self.using].introspection.identifier_converter</span>
        <span class="s2">return </span><span class="s1">[converter(column_meta[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s2">for </span><span class="s1">column_meta </span><span class="s2">in </span><span class="s1">self.cursor.description]</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s4"># Always execute a new query for a new iterator.</span>
        <span class="s4"># This could be optimized with a cache at the expense of RAM.</span>
        <span class="s1">self._execute_query()</span>
        <span class="s2">if not </span><span class="s1">connections[self.using].features.can_use_chunked_reads:</span>
            <span class="s4"># If the database can't use chunked reads we need to make sure we</span>
            <span class="s4"># evaluate the entire query up front.</span>
            <span class="s1">result = list(self.cursor)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">result = self.cursor</span>
        <span class="s2">return </span><span class="s1">iter(result)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s3">&quot;&lt;%s: %s&gt;&quot; </span><span class="s1">% (self.__class__.__name__</span><span class="s2">, </span><span class="s1">self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">params_type(self):</span>
        <span class="s2">if </span><span class="s1">self.params </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">dict </span><span class="s2">if </span><span class="s1">isinstance(self.params</span><span class="s2">, </span><span class="s1">Mapping) </span><span class="s2">else </span><span class="s1">tuple</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">if </span><span class="s1">self.params_type </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.sql</span>
        <span class="s2">return </span><span class="s1">self.sql % self.params_type(self.params)</span>

    <span class="s2">def </span><span class="s1">_execute_query(self):</span>
        <span class="s1">connection = connections[self.using]</span>

        <span class="s4"># Adapt parameters to the database, as much as possible considering</span>
        <span class="s4"># that the target type isn't known. See #17755.</span>
        <span class="s1">params_type = self.params_type</span>
        <span class="s1">adapter = connection.ops.adapt_unknown_value</span>
        <span class="s2">if </span><span class="s1">params_type </span><span class="s2">is </span><span class="s1">tuple:</span>
            <span class="s1">params = tuple(adapter(val) </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self.params)</span>
        <span class="s2">elif </span><span class="s1">params_type </span><span class="s2">is </span><span class="s1">dict:</span>
            <span class="s1">params = {key: adapter(val) </span><span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">self.params.items()}</span>
        <span class="s2">elif </span><span class="s1">params_type </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">params = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;Unexpected params type: %s&quot; </span><span class="s1">% params_type)</span>

        <span class="s1">self.cursor = connection.cursor()</span>
        <span class="s1">self.cursor.execute(self.sql</span><span class="s2">, </span><span class="s1">params)</span>


<span class="s1">ExplainInfo = namedtuple(</span><span class="s3">'ExplainInfo'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'format'</span><span class="s2">, </span><span class="s3">'options'</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">Query(BaseExpression):</span>
    <span class="s0">&quot;&quot;&quot;A single SQL query.&quot;&quot;&quot;</span>

    <span class="s1">alias_prefix = </span><span class="s3">'T'</span>
    <span class="s1">empty_result_set_value = </span><span class="s2">None</span>
    <span class="s1">subq_aliases = frozenset([alias_prefix])</span>

    <span class="s1">compiler = </span><span class="s3">'SQLCompiler'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">alias_cols=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">self.model = model</span>
        <span class="s1">self.alias_refcount = {}</span>
        <span class="s4"># alias_map is the most important data structure regarding joins.</span>
        <span class="s4"># It's used for recording which joins exist in the query and what</span>
        <span class="s4"># types they are. The key is the alias of the joined table (possibly</span>
        <span class="s4"># the table name) and the value is a Join-like object (see</span>
        <span class="s4"># sql.datastructures.Join for more information).</span>
        <span class="s1">self.alias_map = {}</span>
        <span class="s4"># Whether to provide alias to columns during reference resolving.</span>
        <span class="s1">self.alias_cols = alias_cols</span>
        <span class="s4"># Sometimes the query contains references to aliases in outer queries (as</span>
        <span class="s4"># a result of split_exclude). Correct alias quoting needs to know these</span>
        <span class="s4"># aliases too.</span>
        <span class="s4"># Map external tables to whether they are aliased.</span>
        <span class="s1">self.external_aliases = {}</span>
        <span class="s1">self.table_map = {}     </span><span class="s4"># Maps table names to list of aliases.</span>
        <span class="s1">self.default_cols = </span><span class="s2">True</span>
        <span class="s1">self.default_ordering = </span><span class="s2">True</span>
        <span class="s1">self.standard_ordering = </span><span class="s2">True</span>
        <span class="s1">self.used_aliases = set()</span>
        <span class="s1">self.filter_is_sticky = </span><span class="s2">False</span>
        <span class="s1">self.subquery = </span><span class="s2">False</span>

        <span class="s4"># SQL-related attributes</span>
        <span class="s4"># Select and related select clauses are expressions to use in the</span>
        <span class="s4"># SELECT clause of the query.</span>
        <span class="s4"># The select is used for cases where we want to set up the select</span>
        <span class="s4"># clause to contain other than default fields (values(), subqueries...)</span>
        <span class="s4"># Note that annotations go to annotations dictionary.</span>
        <span class="s1">self.select = ()</span>
        <span class="s1">self.where = WhereNode()</span>
        <span class="s4"># The group_by attribute can have one of the following forms:</span>
        <span class="s4">#  - None: no group by at all in the query</span>
        <span class="s4">#  - A tuple of expressions: group by (at least) those expressions.</span>
        <span class="s4">#    String refs are also allowed for now.</span>
        <span class="s4">#  - True: group by all select fields of the model</span>
        <span class="s4"># See compiler.get_group_by() for details.</span>
        <span class="s1">self.group_by = </span><span class="s2">None</span>
        <span class="s1">self.order_by = ()</span>
        <span class="s1">self.low_mark</span><span class="s2">, </span><span class="s1">self.high_mark = </span><span class="s5">0</span><span class="s2">, None  </span><span class="s4"># Used for offset/limit</span>
        <span class="s1">self.distinct = </span><span class="s2">False</span>
        <span class="s1">self.distinct_fields = ()</span>
        <span class="s1">self.select_for_update = </span><span class="s2">False</span>
        <span class="s1">self.select_for_update_nowait = </span><span class="s2">False</span>
        <span class="s1">self.select_for_update_skip_locked = </span><span class="s2">False</span>
        <span class="s1">self.select_for_update_of = ()</span>
        <span class="s1">self.select_for_no_key_update = </span><span class="s2">False</span>

        <span class="s1">self.select_related = </span><span class="s2">False</span>
        <span class="s4"># Arbitrary limit for select_related to prevents infinite recursion.</span>
        <span class="s1">self.max_depth = </span><span class="s5">5</span>

        <span class="s4"># Holds the selects defined by a call to values() or values_list()</span>
        <span class="s4"># excluding annotation_select and extra_select.</span>
        <span class="s1">self.values_select = ()</span>

        <span class="s4"># SQL annotation-related attributes</span>
        <span class="s1">self.annotations = {}  </span><span class="s4"># Maps alias -&gt; Annotation Expression</span>
        <span class="s1">self.annotation_select_mask = </span><span class="s2">None</span>
        <span class="s1">self._annotation_select_cache = </span><span class="s2">None</span>

        <span class="s4"># Set combination attributes</span>
        <span class="s1">self.combinator = </span><span class="s2">None</span>
        <span class="s1">self.combinator_all = </span><span class="s2">False</span>
        <span class="s1">self.combined_queries = ()</span>

        <span class="s4"># These are for extensions. The contents are more or less appended</span>
        <span class="s4"># verbatim to the appropriate clause.</span>
        <span class="s1">self.extra = {}  </span><span class="s4"># Maps col_alias -&gt; (col_sql, params).</span>
        <span class="s1">self.extra_select_mask = </span><span class="s2">None</span>
        <span class="s1">self._extra_select_cache = </span><span class="s2">None</span>

        <span class="s1">self.extra_tables = ()</span>
        <span class="s1">self.extra_order_by = ()</span>

        <span class="s4"># A tuple that is a set of model field names and either True, if these</span>
        <span class="s4"># are the fields to defer, or False if these are the only fields to</span>
        <span class="s4"># load.</span>
        <span class="s1">self.deferred_loading = (frozenset()</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s1">self._filtered_relations = {}</span>

        <span class="s1">self.explain_info = </span><span class="s2">None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">output_field(self):</span>
        <span class="s2">if </span><span class="s1">len(self.select) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">select = self.select[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">return </span><span class="s1">getattr(select</span><span class="s2">, </span><span class="s3">'target'</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">select.field</span>
        <span class="s2">elif </span><span class="s1">len(self.annotation_select) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">next(iter(self.annotation_select.values())).output_field</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">has_select_fields(self):</span>
        <span class="s2">return </span><span class="s1">bool(self.select </span><span class="s2">or </span><span class="s1">self.annotation_select_mask </span><span class="s2">or </span><span class="s1">self.extra_select_mask)</span>

    <span class="s1">@cached_property</span>
    <span class="s2">def </span><span class="s1">base_table(self):</span>
        <span class="s2">for </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">self.alias_map:</span>
            <span class="s2">return </span><span class="s1">alias</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the query as a string of SQL with the parameter values 
        substituted in (use sql_with_params() to see the unsubstituted string). 
 
        Parameter values won't necessarily be quoted correctly, since that is 
        done by the database interface at execution time. 
        &quot;&quot;&quot;</span>
        <span class="s1">sql</span><span class="s2">, </span><span class="s1">params = self.sql_with_params()</span>
        <span class="s2">return </span><span class="s1">sql % params</span>

    <span class="s2">def </span><span class="s1">sql_with_params(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the query as an SQL string and the parameters that will be 
        substituted into the query. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.get_compiler(DEFAULT_DB_ALIAS).as_sql()</span>

    <span class="s2">def </span><span class="s1">__deepcopy__(self</span><span class="s2">, </span><span class="s1">memo):</span>
        <span class="s0">&quot;&quot;&quot;Limit the amount of work when a Query is deepcopied.&quot;&quot;&quot;</span>
        <span class="s1">result = self.clone()</span>
        <span class="s1">memo[id(self)] = result</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">get_compiler(self</span><span class="s2">, </span><span class="s1">using=</span><span class="s2">None, </span><span class="s1">connection=</span><span class="s2">None, </span><span class="s1">elide_empty=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">using </span><span class="s2">is None and </span><span class="s1">connection </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Need either using or connection&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">using:</span>
            <span class="s1">connection = connections[using]</span>
        <span class="s2">return </span><span class="s1">connection.ops.compiler(self.compiler)(self</span><span class="s2">, </span><span class="s1">connection</span><span class="s2">, </span><span class="s1">using</span><span class="s2">, </span><span class="s1">elide_empty)</span>

    <span class="s2">def </span><span class="s1">get_meta(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the Options instance (the model._meta) from which to start 
        processing. Normally, this is self.model._meta, but it can be changed 
        by subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.model._meta</span>

    <span class="s2">def </span><span class="s1">clone(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the current Query. A lightweight alternative to 
        to deepcopy(). 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = Empty()</span>
        <span class="s1">obj.__class__ = self.__class__</span>
        <span class="s4"># Copy references to everything.</span>
        <span class="s1">obj.__dict__ = self.__dict__.copy()</span>
        <span class="s4"># Clone attributes that can't use shallow copy.</span>
        <span class="s1">obj.alias_refcount = self.alias_refcount.copy()</span>
        <span class="s1">obj.alias_map = self.alias_map.copy()</span>
        <span class="s1">obj.external_aliases = self.external_aliases.copy()</span>
        <span class="s1">obj.table_map = self.table_map.copy()</span>
        <span class="s1">obj.where = self.where.clone()</span>
        <span class="s1">obj.annotations = self.annotations.copy()</span>
        <span class="s2">if </span><span class="s1">self.annotation_select_mask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">obj.annotation_select_mask = self.annotation_select_mask.copy()</span>
        <span class="s2">if </span><span class="s1">self.combined_queries:</span>
            <span class="s1">obj.combined_queries = tuple([</span>
                <span class="s1">query.clone() </span><span class="s2">for </span><span class="s1">query </span><span class="s2">in </span><span class="s1">self.combined_queries</span>
            <span class="s1">])</span>
        <span class="s4"># _annotation_select_cache cannot be copied, as doing so breaks the</span>
        <span class="s4"># (necessary) state in which both annotations and</span>
        <span class="s4"># _annotation_select_cache point to the same underlying objects.</span>
        <span class="s4"># It will get re-populated in the cloned queryset the next time it's</span>
        <span class="s4"># used.</span>
        <span class="s1">obj._annotation_select_cache = </span><span class="s2">None</span>
        <span class="s1">obj.extra = self.extra.copy()</span>
        <span class="s2">if </span><span class="s1">self.extra_select_mask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">obj.extra_select_mask = self.extra_select_mask.copy()</span>
        <span class="s2">if </span><span class="s1">self._extra_select_cache </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">obj._extra_select_cache = self._extra_select_cache.copy()</span>
        <span class="s2">if </span><span class="s1">self.select_related </span><span class="s2">is not False</span><span class="s1">:</span>
            <span class="s4"># Use deepcopy because select_related stores fields in nested</span>
            <span class="s4"># dicts.</span>
            <span class="s1">obj.select_related = copy.deepcopy(obj.select_related)</span>
        <span class="s2">if </span><span class="s3">'subq_aliases' </span><span class="s2">in </span><span class="s1">self.__dict__:</span>
            <span class="s1">obj.subq_aliases = self.subq_aliases.copy()</span>
        <span class="s1">obj.used_aliases = self.used_aliases.copy()</span>
        <span class="s1">obj._filtered_relations = self._filtered_relations.copy()</span>
        <span class="s4"># Clear the cached_property</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">obj.base_table</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">chain(self</span><span class="s2">, </span><span class="s1">klass=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a copy of the current Query that's ready for another operation. 
        The klass argument changes the type of the Query, e.g. UpdateQuery. 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = self.clone()</span>
        <span class="s2">if </span><span class="s1">klass </span><span class="s2">and </span><span class="s1">obj.__class__ != klass:</span>
            <span class="s1">obj.__class__ = klass</span>
        <span class="s2">if not </span><span class="s1">obj.filter_is_sticky:</span>
            <span class="s1">obj.used_aliases = set()</span>
        <span class="s1">obj.filter_is_sticky = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">hasattr(obj</span><span class="s2">, </span><span class="s3">'_setup_query'</span><span class="s1">):</span>
            <span class="s1">obj._setup_query()</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s2">def </span><span class="s1">relabeled_clone(self</span><span class="s2">, </span><span class="s1">change_map):</span>
        <span class="s1">clone = self.clone()</span>
        <span class="s1">clone.change_aliases(change_map)</span>
        <span class="s2">return </span><span class="s1">clone</span>

    <span class="s2">def </span><span class="s1">_get_col(self</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">alias):</span>
        <span class="s2">if not </span><span class="s1">self.alias_cols:</span>
            <span class="s1">alias = </span><span class="s2">None</span>
        <span class="s2">return </span><span class="s1">target.get_col(alias</span><span class="s2">, </span><span class="s1">field)</span>

    <span class="s2">def </span><span class="s1">rewrite_cols(self</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">col_cnt):</span>
        <span class="s4"># We must make sure the inner query has the referred columns in it.</span>
        <span class="s4"># If we are aggregating over an annotation, then Django uses Ref()</span>
        <span class="s4"># instances to note this. However, if we are annotating over a column</span>
        <span class="s4"># of a related model, then it might be that column isn't part of the</span>
        <span class="s4"># SELECT clause of the inner query, and we must manually make sure</span>
        <span class="s4"># the column is selected. An example case is:</span>
        <span class="s4">#    .aggregate(Sum('author__awards'))</span>
        <span class="s4"># Resolving this expression results in a join to author, but there</span>
        <span class="s4"># is no guarantee the awards column of author is in the select clause</span>
        <span class="s4"># of the query. Thus we must manually add the column to the inner</span>
        <span class="s4"># query.</span>
        <span class="s1">orig_exprs = annotation.get_source_expressions()</span>
        <span class="s1">new_exprs = []</span>
        <span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">orig_exprs:</span>
            <span class="s4"># FIXME: These conditions are fairly arbitrary. Identify a better</span>
            <span class="s4"># method of having expressions decide which code path they should</span>
            <span class="s4"># take.</span>
            <span class="s2">if </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">Ref):</span>
                <span class="s4"># Its already a Ref to subquery (see resolve_ref() for</span>
                <span class="s4"># details)</span>
                <span class="s1">new_exprs.append(expr)</span>
            <span class="s2">elif </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">(WhereNode</span><span class="s2">, </span><span class="s1">Lookup)):</span>
                <span class="s4"># Decompose the subexpressions further. The code here is</span>
                <span class="s4"># copied from the else clause, but this condition must appear</span>
                <span class="s4"># before the contains_aggregate/is_summary condition below.</span>
                <span class="s1">new_expr</span><span class="s2">, </span><span class="s1">col_cnt = self.rewrite_cols(expr</span><span class="s2">, </span><span class="s1">col_cnt)</span>
                <span class="s1">new_exprs.append(new_expr)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Reuse aliases of expressions already selected in subquery.</span>
                <span class="s2">for </span><span class="s1">col_alias</span><span class="s2">, </span><span class="s1">selected_annotation </span><span class="s2">in </span><span class="s1">self.annotation_select.items():</span>
                    <span class="s2">if </span><span class="s1">selected_annotation </span><span class="s2">is </span><span class="s1">expr:</span>
                        <span class="s1">new_expr = Ref(col_alias</span><span class="s2">, </span><span class="s1">expr)</span>
                        <span class="s2">break</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s4"># An expression that is not selected the subquery.</span>
                    <span class="s2">if </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">Col) </span><span class="s2">or </span><span class="s1">(expr.contains_aggregate </span><span class="s2">and not </span><span class="s1">expr.is_summary):</span>
                        <span class="s4"># Reference column or another aggregate. Select it</span>
                        <span class="s4"># under a non-conflicting alias.</span>
                        <span class="s1">col_cnt += </span><span class="s5">1</span>
                        <span class="s1">col_alias = </span><span class="s3">'__col%d' </span><span class="s1">% col_cnt</span>
                        <span class="s1">self.annotations[col_alias] = expr</span>
                        <span class="s1">self.append_annotation_mask([col_alias])</span>
                        <span class="s1">new_expr = Ref(col_alias</span><span class="s2">, </span><span class="s1">expr)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s4"># Some other expression not referencing database values</span>
                        <span class="s4"># directly. Its subexpression might contain Cols.</span>
                        <span class="s1">new_expr</span><span class="s2">, </span><span class="s1">col_cnt = self.rewrite_cols(expr</span><span class="s2">, </span><span class="s1">col_cnt)</span>
                <span class="s1">new_exprs.append(new_expr)</span>
        <span class="s1">annotation.set_source_expressions(new_exprs)</span>
        <span class="s2">return </span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">col_cnt</span>

    <span class="s2">def </span><span class="s1">get_aggregation(self</span><span class="s2">, </span><span class="s1">using</span><span class="s2">, </span><span class="s1">added_aggregate_names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the dictionary with the values of the existing aggregations. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.annotation_select:</span>
            <span class="s2">return </span><span class="s1">{}</span>
        <span class="s1">existing_annotations = [</span>
            <span class="s1">annotation </span><span class="s2">for </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">annotation</span>
            <span class="s2">in </span><span class="s1">self.annotations.items()</span>
            <span class="s2">if </span><span class="s1">alias </span><span class="s2">not in </span><span class="s1">added_aggregate_names</span>
        <span class="s1">]</span>
        <span class="s4"># Decide if we need to use a subquery.</span>
        <span class="s4">#</span>
        <span class="s4"># Existing annotations would cause incorrect results as get_aggregation()</span>
        <span class="s4"># must produce just one result and thus must not use GROUP BY. But we</span>
        <span class="s4"># aren't smart enough to remove the existing annotations from the</span>
        <span class="s4"># query, so those would force us to use GROUP BY.</span>
        <span class="s4">#</span>
        <span class="s4"># If the query has limit or distinct, or uses set operations, then</span>
        <span class="s4"># those operations must be done in a subquery so that the query</span>
        <span class="s4"># aggregates on the limit and/or distinct results instead of applying</span>
        <span class="s4"># the distinct and limit after the aggregation.</span>
        <span class="s2">if </span><span class="s1">(isinstance(self.group_by</span><span class="s2">, </span><span class="s1">tuple) </span><span class="s2">or </span><span class="s1">self.is_sliced </span><span class="s2">or </span><span class="s1">existing_annotations </span><span class="s2">or</span>
                <span class="s1">self.distinct </span><span class="s2">or </span><span class="s1">self.combinator):</span>
            <span class="s2">from </span><span class="s1">django.db.models.sql.subqueries </span><span class="s2">import </span><span class="s1">AggregateQuery</span>
            <span class="s1">inner_query = self.clone()</span>
            <span class="s1">inner_query.subquery = </span><span class="s2">True</span>
            <span class="s1">outer_query = AggregateQuery(self.model</span><span class="s2">, </span><span class="s1">inner_query)</span>
            <span class="s1">inner_query.select_for_update = </span><span class="s2">False</span>
            <span class="s1">inner_query.select_related = </span><span class="s2">False</span>
            <span class="s1">inner_query.set_annotation_mask(self.annotation_select)</span>
            <span class="s4"># Queries with distinct_fields need ordering and when a limit is</span>
            <span class="s4"># applied we must take the slice from the ordered query. Otherwise</span>
            <span class="s4"># no need for ordering.</span>
            <span class="s1">inner_query.clear_ordering(force=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">inner_query.distinct:</span>
                <span class="s4"># If the inner query uses default select and it has some</span>
                <span class="s4"># aggregate annotations, then we must make sure the inner</span>
                <span class="s4"># query is grouped by the main model's primary key. However,</span>
                <span class="s4"># clearing the select clause can alter results if distinct is</span>
                <span class="s4"># used.</span>
                <span class="s1">has_existing_aggregate_annotations = any(</span>
                    <span class="s1">annotation </span><span class="s2">for </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">existing_annotations</span>
                    <span class="s2">if </span><span class="s1">getattr(annotation</span><span class="s2">, </span><span class="s3">'contains_aggregate'</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">inner_query.default_cols </span><span class="s2">and </span><span class="s1">has_existing_aggregate_annotations:</span>
                    <span class="s1">inner_query.group_by = (self.model._meta.pk.get_col(inner_query.get_initial_alias())</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s1">inner_query.default_cols = </span><span class="s2">False</span>

            <span class="s1">relabels = {t: </span><span class="s3">'subquery' </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">inner_query.alias_map}</span>
            <span class="s1">relabels[</span><span class="s2">None</span><span class="s1">] = </span><span class="s3">'subquery'</span>
            <span class="s4"># Remove any aggregates marked for reduction from the subquery</span>
            <span class="s4"># and move them to the outer AggregateQuery.</span>
            <span class="s1">col_cnt = </span><span class="s5">0</span>
            <span class="s2">for </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">expression </span><span class="s2">in </span><span class="s1">list(inner_query.annotation_select.items()):</span>
                <span class="s1">annotation_select_mask = inner_query.annotation_select_mask</span>
                <span class="s2">if </span><span class="s1">expression.is_summary:</span>
                    <span class="s1">expression</span><span class="s2">, </span><span class="s1">col_cnt = inner_query.rewrite_cols(expression</span><span class="s2">, </span><span class="s1">col_cnt)</span>
                    <span class="s1">outer_query.annotations[alias] = expression.relabeled_clone(relabels)</span>
                    <span class="s2">del </span><span class="s1">inner_query.annotations[alias]</span>
                    <span class="s1">annotation_select_mask.remove(alias)</span>
                <span class="s4"># Make sure the annotation_select wont use cached results.</span>
                <span class="s1">inner_query.set_annotation_mask(inner_query.annotation_select_mask)</span>
            <span class="s2">if </span><span class="s1">inner_query.select == () </span><span class="s2">and not </span><span class="s1">inner_query.default_cols </span><span class="s2">and not </span><span class="s1">inner_query.annotation_select_mask:</span>
                <span class="s4"># In case of Model.objects[0:3].count(), there would be no</span>
                <span class="s4"># field selected in the inner query, yet we must use a subquery.</span>
                <span class="s4"># So, make sure at least one field is selected.</span>
                <span class="s1">inner_query.select = (self.model._meta.pk.get_col(inner_query.get_initial_alias())</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">outer_query = self</span>
            <span class="s1">self.select = ()</span>
            <span class="s1">self.default_cols = </span><span class="s2">False</span>
            <span class="s1">self.extra = {}</span>

        <span class="s1">empty_set_result = [</span>
            <span class="s1">expression.empty_result_set_value</span>
            <span class="s2">for </span><span class="s1">expression </span><span class="s2">in </span><span class="s1">outer_query.annotation_select.values()</span>
        <span class="s1">]</span>
        <span class="s1">elide_empty = </span><span class="s2">not </span><span class="s1">any(result </span><span class="s2">is </span><span class="s1">NotImplemented </span><span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">empty_set_result)</span>
        <span class="s1">outer_query.clear_ordering(force=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">outer_query.clear_limits()</span>
        <span class="s1">outer_query.select_for_update = </span><span class="s2">False</span>
        <span class="s1">outer_query.select_related = </span><span class="s2">False</span>
        <span class="s1">compiler = outer_query.get_compiler(using</span><span class="s2">, </span><span class="s1">elide_empty=elide_empty)</span>
        <span class="s1">result = compiler.execute_sql(SINGLE)</span>
        <span class="s2">if </span><span class="s1">result </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">result = empty_set_result</span>

        <span class="s1">converters = compiler.get_converters(outer_query.annotation_select.values())</span>
        <span class="s1">result = next(compiler.apply_converters((result</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">converters))</span>

        <span class="s2">return </span><span class="s1">dict(zip(outer_query.annotation_select</span><span class="s2">, </span><span class="s1">result))</span>

    <span class="s2">def </span><span class="s1">get_count(self</span><span class="s2">, </span><span class="s1">using):</span>
        <span class="s0">&quot;&quot;&quot; 
        Perform a COUNT() query using the current filter constraints. 
        &quot;&quot;&quot;</span>
        <span class="s1">obj = self.clone()</span>
        <span class="s1">obj.add_annotation(Count(</span><span class="s3">'*'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">alias=</span><span class="s3">'__count'</span><span class="s2">, </span><span class="s1">is_summary=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">number = obj.get_aggregation(using</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'__count'</span><span class="s1">])[</span><span class="s3">'__count'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">number </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">number = </span><span class="s5">0</span>
        <span class="s2">return </span><span class="s1">number</span>

    <span class="s2">def </span><span class="s1">has_filters(self):</span>
        <span class="s2">return </span><span class="s1">self.where</span>

    <span class="s2">def </span><span class="s1">exists(self</span><span class="s2">, </span><span class="s1">using</span><span class="s2">, </span><span class="s1">limit=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s1">q = self.clone()</span>
        <span class="s2">if not </span><span class="s1">q.distinct:</span>
            <span class="s2">if </span><span class="s1">q.group_by </span><span class="s2">is True</span><span class="s1">:</span>
                <span class="s1">q.add_fields((f.attname </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.model._meta.concrete_fields)</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s4"># Disable GROUP BY aliases to avoid orphaning references to the</span>
                <span class="s4"># SELECT clause which is about to be cleared.</span>
                <span class="s1">q.set_group_by(allow_aliases=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">q.clear_select_clause()</span>
        <span class="s2">if </span><span class="s1">q.combined_queries </span><span class="s2">and </span><span class="s1">q.combinator == </span><span class="s3">'union'</span><span class="s1">:</span>
            <span class="s1">limit_combined = connections[using].features.supports_slicing_ordering_in_compound</span>
            <span class="s1">q.combined_queries = tuple(</span>
                <span class="s1">combined_query.exists(using</span><span class="s2">, </span><span class="s1">limit=limit_combined)</span>
                <span class="s2">for </span><span class="s1">combined_query </span><span class="s2">in </span><span class="s1">q.combined_queries</span>
            <span class="s1">)</span>
        <span class="s1">q.clear_ordering(force=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">limit:</span>
            <span class="s1">q.set_limits(high=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">q.add_extra({</span><span class="s3">'a'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span><span class="s2">, None, None, None, None, None</span><span class="s1">)</span>
        <span class="s1">q.set_extra_mask([</span><span class="s3">'a'</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">q</span>

    <span class="s2">def </span><span class="s1">has_results(self</span><span class="s2">, </span><span class="s1">using):</span>
        <span class="s1">q = self.exists(using)</span>
        <span class="s1">compiler = q.get_compiler(using=using)</span>
        <span class="s2">return </span><span class="s1">compiler.has_results()</span>

    <span class="s2">def </span><span class="s1">explain(self</span><span class="s2">, </span><span class="s1">using</span><span class="s2">, </span><span class="s1">format=</span><span class="s2">None, </span><span class="s1">**options):</span>
        <span class="s1">q = self.clone()</span>
        <span class="s1">q.explain_info = ExplainInfo(format</span><span class="s2">, </span><span class="s1">options)</span>
        <span class="s1">compiler = q.get_compiler(using=using)</span>
        <span class="s2">return </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">.join(compiler.explain_query())</span>

    <span class="s2">def </span><span class="s1">combine(self</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">, </span><span class="s1">connector):</span>
        <span class="s0">&quot;&quot;&quot; 
        Merge the 'rhs' query into the current one (with any 'rhs' effects 
        being applied *after* (that is, &quot;to the right of&quot;) anything in the 
        current query. 'rhs' is not modified during a call to this function. 
 
        The 'connector' parameter describes how to connect filters from the 
        'rhs' query. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.model != rhs.model:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Cannot combine queries on two different base models.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.is_sliced:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Cannot combine queries once a slice has been taken.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.distinct != rhs.distinct:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Cannot combine a unique query with a non-unique query.'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.distinct_fields != rhs.distinct_fields:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Cannot combine queries with different distinct fields.'</span><span class="s1">)</span>

        <span class="s4"># Work out how to relabel the rhs aliases, if necessary.</span>
        <span class="s1">change_map = {}</span>
        <span class="s1">conjunction = (connector == AND)</span>

        <span class="s4"># Determine which existing joins can be reused. When combining the</span>
        <span class="s4"># query with AND we must recreate all joins for m2m filters. When</span>
        <span class="s4"># combining with OR we can reuse joins. The reason is that in AND</span>
        <span class="s4"># case a single row can't fulfill a condition like:</span>
        <span class="s4">#     revrel__col=1 &amp; revrel__col=2</span>
        <span class="s4"># But, there might be two different related rows matching this</span>
        <span class="s4"># condition. In OR case a single True is enough, so single row is</span>
        <span class="s4"># enough, too.</span>
        <span class="s4">#</span>
        <span class="s4"># Note that we will be creating duplicate joins for non-m2m joins in</span>
        <span class="s4"># the AND case. The results will be correct but this creates too many</span>
        <span class="s4"># joins. This is something that could be fixed later on.</span>
        <span class="s1">reuse = set() </span><span class="s2">if </span><span class="s1">conjunction </span><span class="s2">else </span><span class="s1">set(self.alias_map)</span>
        <span class="s4"># Base table must be present in the query - this is the same</span>
        <span class="s4"># table on both sides.</span>
        <span class="s1">self.get_initial_alias()</span>
        <span class="s1">joinpromoter = JoinPromoter(connector</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">joinpromoter.add_votes(</span>
            <span class="s1">j </span><span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">self.alias_map </span><span class="s2">if </span><span class="s1">self.alias_map[j].join_type == INNER)</span>
        <span class="s1">rhs_votes = set()</span>
        <span class="s4"># Now, add the joins from rhs query into the new query (skipping base</span>
        <span class="s4"># table).</span>
        <span class="s1">rhs_tables = list(rhs.alias_map)[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">for </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">rhs_tables:</span>
            <span class="s1">join = rhs.alias_map[alias]</span>
            <span class="s4"># If the left side of the join was already relabeled, use the</span>
            <span class="s4"># updated alias.</span>
            <span class="s1">join = join.relabeled_clone(change_map)</span>
            <span class="s1">new_alias = self.join(join</span><span class="s2">, </span><span class="s1">reuse=reuse)</span>
            <span class="s2">if </span><span class="s1">join.join_type == INNER:</span>
                <span class="s1">rhs_votes.add(new_alias)</span>
            <span class="s4"># We can't reuse the same join again in the query. If we have two</span>
            <span class="s4"># distinct joins for the same connection in rhs query, then the</span>
            <span class="s4"># combined query must have two joins, too.</span>
            <span class="s1">reuse.discard(new_alias)</span>
            <span class="s2">if </span><span class="s1">alias != new_alias:</span>
                <span class="s1">change_map[alias] = new_alias</span>
            <span class="s2">if not </span><span class="s1">rhs.alias_refcount[alias]:</span>
                <span class="s4"># The alias was unused in the rhs query. Unref it so that it</span>
                <span class="s4"># will be unused in the new query, too. We have to add and</span>
                <span class="s4"># unref the alias so that join promotion has information of</span>
                <span class="s4"># the join type for the unused alias.</span>
                <span class="s1">self.unref_alias(new_alias)</span>
        <span class="s1">joinpromoter.add_votes(rhs_votes)</span>
        <span class="s1">joinpromoter.update_join_types(self)</span>

        <span class="s4"># Combine subqueries aliases to ensure aliases relabelling properly</span>
        <span class="s4"># handle subqueries when combining where and select clauses.</span>
        <span class="s1">self.subq_aliases |= rhs.subq_aliases</span>

        <span class="s4"># Now relabel a copy of the rhs where-clause and add it to the current</span>
        <span class="s4"># one.</span>
        <span class="s1">w = rhs.where.clone()</span>
        <span class="s1">w.relabel_aliases(change_map)</span>
        <span class="s1">self.where.add(w</span><span class="s2">, </span><span class="s1">connector)</span>

        <span class="s4"># Selection columns and extra extensions are those provided by 'rhs'.</span>
        <span class="s2">if </span><span class="s1">rhs.select:</span>
            <span class="s1">self.set_select([col.relabeled_clone(change_map) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">rhs.select])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.select = ()</span>

        <span class="s2">if </span><span class="s1">connector == OR:</span>
            <span class="s4"># It would be nice to be able to handle this, but the queries don't</span>
            <span class="s4"># really make sense (or return consistent value sets). Not worth</span>
            <span class="s4"># the extra complexity when you can write a real query instead.</span>
            <span class="s2">if </span><span class="s1">self.extra </span><span class="s2">and </span><span class="s1">rhs.extra:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;When merging querysets using 'or', you cannot have extra(select=...) on both sides.&quot;</span><span class="s1">)</span>
        <span class="s1">self.extra.update(rhs.extra)</span>
        <span class="s1">extra_select_mask = set()</span>
        <span class="s2">if </span><span class="s1">self.extra_select_mask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">extra_select_mask.update(self.extra_select_mask)</span>
        <span class="s2">if </span><span class="s1">rhs.extra_select_mask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">extra_select_mask.update(rhs.extra_select_mask)</span>
        <span class="s2">if </span><span class="s1">extra_select_mask:</span>
            <span class="s1">self.set_extra_mask(extra_select_mask)</span>
        <span class="s1">self.extra_tables += rhs.extra_tables</span>

        <span class="s4"># Ordering uses the 'rhs' ordering, unless it has none, in which case</span>
        <span class="s4"># the current ordering is used.</span>
        <span class="s1">self.order_by = rhs.order_by </span><span class="s2">or </span><span class="s1">self.order_by</span>
        <span class="s1">self.extra_order_by = rhs.extra_order_by </span><span class="s2">or </span><span class="s1">self.extra_order_by</span>

    <span class="s2">def </span><span class="s1">deferred_to_data(self</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">callback):</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert the self.deferred_loading data structure to an alternate data 
        structure, describing the field that *will* be loaded. This is used to 
        compute the columns to select from the database and also by the 
        QuerySet class to work out which fields are being initialized on each 
        model. Models that have all their fields included aren't mentioned in 
        the result, only those that have field restrictions in place. 
 
        The &quot;target&quot; parameter is the instance that is populated (in place). 
        The &quot;callback&quot; is a function that is called whenever a (model, field) 
        pair need to be added to &quot;target&quot;. It accepts three parameters: 
        &quot;target&quot;, and the model and list of fields being added for that model. 
        &quot;&quot;&quot;</span>
        <span class="s1">field_names</span><span class="s2">, </span><span class="s1">defer = self.deferred_loading</span>
        <span class="s2">if not </span><span class="s1">field_names:</span>
            <span class="s2">return</span>
        <span class="s1">orig_opts = self.get_meta()</span>
        <span class="s1">seen = {}</span>
        <span class="s1">must_include = {orig_opts.concrete_model: {orig_opts.pk}}</span>
        <span class="s2">for </span><span class="s1">field_name </span><span class="s2">in </span><span class="s1">field_names:</span>
            <span class="s1">parts = field_name.split(LOOKUP_SEP)</span>
            <span class="s1">cur_model = self.model._meta.concrete_model</span>
            <span class="s1">opts = orig_opts</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">parts[:-</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s1">old_model = cur_model</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._filtered_relations:</span>
                    <span class="s1">name = self._filtered_relations[name].relation_name</span>
                <span class="s1">source = opts.get_field(name)</span>
                <span class="s2">if </span><span class="s1">is_reverse_o2o(source):</span>
                    <span class="s1">cur_model = source.related_model</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">cur_model = source.remote_field.model</span>
                <span class="s1">opts = cur_model._meta</span>
                <span class="s4"># Even if we're &quot;just passing through&quot; this model, we must add</span>
                <span class="s4"># both the current model's pk and the related reference field</span>
                <span class="s4"># (if it's not a reverse relation) to the things we select.</span>
                <span class="s2">if not </span><span class="s1">is_reverse_o2o(source):</span>
                    <span class="s1">must_include[old_model].add(source)</span>
                <span class="s1">add_to_dict(must_include</span><span class="s2">, </span><span class="s1">cur_model</span><span class="s2">, </span><span class="s1">opts.pk)</span>
            <span class="s1">field = opts.get_field(parts[-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">is_reverse_object = field.auto_created </span><span class="s2">and not </span><span class="s1">field.concrete</span>
            <span class="s1">model = field.related_model </span><span class="s2">if </span><span class="s1">is_reverse_object </span><span class="s2">else </span><span class="s1">field.model</span>
            <span class="s1">model = model._meta.concrete_model</span>
            <span class="s2">if </span><span class="s1">model == opts.model:</span>
                <span class="s1">model = cur_model</span>
            <span class="s2">if not </span><span class="s1">is_reverse_o2o(field):</span>
                <span class="s1">add_to_dict(seen</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">field)</span>

        <span class="s2">if </span><span class="s1">defer:</span>
            <span class="s4"># We need to load all fields for each model, except those that</span>
            <span class="s4"># appear in &quot;seen&quot; (for all models that appear in &quot;seen&quot;). The only</span>
            <span class="s4"># slight complexity here is handling fields that exist on parent</span>
            <span class="s4"># models.</span>
            <span class="s1">workset = {}</span>
            <span class="s2">for </span><span class="s1">model</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">seen.items():</span>
                <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">model._meta.local_fields:</span>
                    <span class="s2">if </span><span class="s1">field </span><span class="s2">not in </span><span class="s1">values:</span>
                        <span class="s1">m = field.model._meta.concrete_model</span>
                        <span class="s1">add_to_dict(workset</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">field)</span>
            <span class="s2">for </span><span class="s1">model</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">must_include.items():</span>
                <span class="s4"># If we haven't included a model in workset, we don't add the</span>
                <span class="s4"># corresponding must_include fields for that model, since an</span>
                <span class="s4"># empty set means &quot;include all fields&quot;. That's why there's no</span>
                <span class="s4"># &quot;else&quot; branch here.</span>
                <span class="s2">if </span><span class="s1">model </span><span class="s2">in </span><span class="s1">workset:</span>
                    <span class="s1">workset[model].update(values)</span>
            <span class="s2">for </span><span class="s1">model</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">workset.items():</span>
                <span class="s1">callback(target</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">values)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">model</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">must_include.items():</span>
                <span class="s2">if </span><span class="s1">model </span><span class="s2">in </span><span class="s1">seen:</span>
                    <span class="s1">seen[model].update(values)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s4"># As we've passed through this model, but not explicitly</span>
                    <span class="s4"># included any fields, we have to make sure it's mentioned</span>
                    <span class="s4"># so that only the &quot;must include&quot; fields are pulled in.</span>
                    <span class="s1">seen[model] = values</span>
            <span class="s4"># Now ensure that every model in the inheritance chain is mentioned</span>
            <span class="s4"># in the parent list. Again, it must be mentioned to ensure that</span>
            <span class="s4"># only &quot;must include&quot; fields are pulled in.</span>
            <span class="s2">for </span><span class="s1">model </span><span class="s2">in </span><span class="s1">orig_opts.get_parent_list():</span>
                <span class="s1">seen.setdefault(model</span><span class="s2">, </span><span class="s1">set())</span>
            <span class="s2">for </span><span class="s1">model</span><span class="s2">, </span><span class="s1">values </span><span class="s2">in </span><span class="s1">seen.items():</span>
                <span class="s1">callback(target</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">values)</span>

    <span class="s2">def </span><span class="s1">table_alias(self</span><span class="s2">, </span><span class="s1">table_name</span><span class="s2">, </span><span class="s1">create=</span><span class="s2">False, </span><span class="s1">filtered_relation=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a table alias for the given table_name and whether this is a 
        new alias or not. 
 
        If 'create' is true, a new alias is always created. Otherwise, the 
        most recently created alias for the table (if one exists) is reused. 
        &quot;&quot;&quot;</span>
        <span class="s1">alias_list = self.table_map.get(table_name)</span>
        <span class="s2">if not </span><span class="s1">create </span><span class="s2">and </span><span class="s1">alias_list:</span>
            <span class="s1">alias = alias_list[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">self.alias_refcount[alias] += </span><span class="s5">1</span>
            <span class="s2">return </span><span class="s1">alias</span><span class="s2">, False</span>

        <span class="s4"># Create a new alias for this table.</span>
        <span class="s2">if </span><span class="s1">alias_list:</span>
            <span class="s1">alias = </span><span class="s3">'%s%d' </span><span class="s1">% (self.alias_prefix</span><span class="s2">, </span><span class="s1">len(self.alias_map) + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">alias_list.append(alias)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># The first occurrence of a table uses the table name directly.</span>
            <span class="s1">alias = filtered_relation.alias </span><span class="s2">if </span><span class="s1">filtered_relation </span><span class="s2">is not None else </span><span class="s1">table_name</span>
            <span class="s1">self.table_map[table_name] = [alias]</span>
        <span class="s1">self.alias_refcount[alias] = </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">alias</span><span class="s2">, True</span>

    <span class="s2">def </span><span class="s1">ref_alias(self</span><span class="s2">, </span><span class="s1">alias):</span>
        <span class="s0">&quot;&quot;&quot;Increases the reference count for this alias.&quot;&quot;&quot;</span>
        <span class="s1">self.alias_refcount[alias] += </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">unref_alias(self</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">amount=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Decreases the reference count for this alias.&quot;&quot;&quot;</span>
        <span class="s1">self.alias_refcount[alias] -= amount</span>

    <span class="s2">def </span><span class="s1">promote_joins(self</span><span class="s2">, </span><span class="s1">aliases):</span>
        <span class="s0">&quot;&quot;&quot; 
        Promote recursively the join type of given aliases and its children to 
        an outer join. If 'unconditional' is False, only promote the join if 
        it is nullable or the parent join is an outer join. 
 
        The children promotion is done to avoid join chains that contain a LOUTER 
        b INNER c. So, if we have currently a INNER b INNER c and a-&gt;b is promoted, 
        then we must also promote b-&gt;c automatically, or otherwise the promotion 
        of a-&gt;b doesn't actually change anything in the query results. 
        &quot;&quot;&quot;</span>
        <span class="s1">aliases = list(aliases)</span>
        <span class="s2">while </span><span class="s1">aliases:</span>
            <span class="s1">alias = aliases.pop(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.alias_map[alias].join_type </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s4"># This is the base table (first FROM entry) - this table</span>
                <span class="s4"># isn't really joined at all in the query, so we should not</span>
                <span class="s4"># alter its join type.</span>
                <span class="s2">continue</span>
            <span class="s4"># Only the first alias (skipped above) should have None join_type</span>
            <span class="s2">assert </span><span class="s1">self.alias_map[alias].join_type </span><span class="s2">is not None</span>
            <span class="s1">parent_alias = self.alias_map[alias].parent_alias</span>
            <span class="s1">parent_louter = parent_alias </span><span class="s2">and </span><span class="s1">self.alias_map[parent_alias].join_type == LOUTER</span>
            <span class="s1">already_louter = self.alias_map[alias].join_type == LOUTER</span>
            <span class="s2">if </span><span class="s1">((self.alias_map[alias].nullable </span><span class="s2">or </span><span class="s1">parent_louter) </span><span class="s2">and</span>
                    <span class="s2">not </span><span class="s1">already_louter):</span>
                <span class="s1">self.alias_map[alias] = self.alias_map[alias].promote()</span>
                <span class="s4"># Join type of 'alias' changed, so re-examine all aliases that</span>
                <span class="s4"># refer to this one.</span>
                <span class="s1">aliases.extend(</span>
                    <span class="s1">join </span><span class="s2">for </span><span class="s1">join </span><span class="s2">in </span><span class="s1">self.alias_map</span>
                    <span class="s2">if </span><span class="s1">self.alias_map[join].parent_alias == alias </span><span class="s2">and </span><span class="s1">join </span><span class="s2">not in </span><span class="s1">aliases</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">demote_joins(self</span><span class="s2">, </span><span class="s1">aliases):</span>
        <span class="s0">&quot;&quot;&quot; 
        Change join type from LOUTER to INNER for all joins in aliases. 
 
        Similarly to promote_joins(), this method must ensure no join chains 
        containing first an outer, then an inner join are generated. If we 
        are demoting b-&gt;c join in chain a LOUTER b LOUTER c then we must 
        demote a-&gt;b automatically, or otherwise the demotion of b-&gt;c doesn't 
        actually change anything in the query results. . 
        &quot;&quot;&quot;</span>
        <span class="s1">aliases = list(aliases)</span>
        <span class="s2">while </span><span class="s1">aliases:</span>
            <span class="s1">alias = aliases.pop(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">self.alias_map[alias].join_type == LOUTER:</span>
                <span class="s1">self.alias_map[alias] = self.alias_map[alias].demote()</span>
                <span class="s1">parent_alias = self.alias_map[alias].parent_alias</span>
                <span class="s2">if </span><span class="s1">self.alias_map[parent_alias].join_type == INNER:</span>
                    <span class="s1">aliases.append(parent_alias)</span>

    <span class="s2">def </span><span class="s1">reset_refcounts(self</span><span class="s2">, </span><span class="s1">to_counts):</span>
        <span class="s0">&quot;&quot;&quot; 
        Reset reference counts for aliases so that they match the value passed 
        in `to_counts`. 
        &quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">cur_refcount </span><span class="s2">in </span><span class="s1">self.alias_refcount.copy().items():</span>
            <span class="s1">unref_amount = cur_refcount - to_counts.get(alias</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">self.unref_alias(alias</span><span class="s2">, </span><span class="s1">unref_amount)</span>

    <span class="s2">def </span><span class="s1">change_aliases(self</span><span class="s2">, </span><span class="s1">change_map):</span>
        <span class="s0">&quot;&quot;&quot; 
        Change the aliases in change_map (which maps old-alias -&gt; new-alias), 
        relabelling any references to them in select columns and the where 
        clause. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">set(change_map).isdisjoint(change_map.values())</span>

        <span class="s4"># 1. Update references in &quot;select&quot; (normal columns plus aliases),</span>
        <span class="s4"># &quot;group by&quot; and &quot;where&quot;.</span>
        <span class="s1">self.where.relabel_aliases(change_map)</span>
        <span class="s2">if </span><span class="s1">isinstance(self.group_by</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s1">self.group_by = tuple([col.relabeled_clone(change_map) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.group_by])</span>
        <span class="s1">self.select = tuple([col.relabeled_clone(change_map) </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.select])</span>
        <span class="s1">self.annotations = self.annotations </span><span class="s2">and </span><span class="s1">{</span>
            <span class="s1">key: col.relabeled_clone(change_map) </span><span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self.annotations.items()</span>
        <span class="s1">}</span>

        <span class="s4"># 2. Rename the alias in the internal table/alias datastructures.</span>
        <span class="s2">for </span><span class="s1">old_alias</span><span class="s2">, </span><span class="s1">new_alias </span><span class="s2">in </span><span class="s1">change_map.items():</span>
            <span class="s2">if </span><span class="s1">old_alias </span><span class="s2">not in </span><span class="s1">self.alias_map:</span>
                <span class="s2">continue</span>
            <span class="s1">alias_data = self.alias_map[old_alias].relabeled_clone(change_map)</span>
            <span class="s1">self.alias_map[new_alias] = alias_data</span>
            <span class="s1">self.alias_refcount[new_alias] = self.alias_refcount[old_alias]</span>
            <span class="s2">del </span><span class="s1">self.alias_refcount[old_alias]</span>
            <span class="s2">del </span><span class="s1">self.alias_map[old_alias]</span>

            <span class="s1">table_aliases = self.table_map[alias_data.table_name]</span>
            <span class="s2">for </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">enumerate(table_aliases):</span>
                <span class="s2">if </span><span class="s1">alias == old_alias:</span>
                    <span class="s1">table_aliases[pos] = new_alias</span>
                    <span class="s2">break</span>
        <span class="s1">self.external_aliases = {</span>
            <span class="s4"># Table is aliased or it's being changed and thus is aliased.</span>
            <span class="s1">change_map.get(alias</span><span class="s2">, </span><span class="s1">alias): (aliased </span><span class="s2">or </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">change_map)</span>
            <span class="s2">for </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">aliased </span><span class="s2">in </span><span class="s1">self.external_aliases.items()</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">bump_prefix(self</span><span class="s2">, </span><span class="s1">outer_query):</span>
        <span class="s0">&quot;&quot;&quot; 
        Change the alias prefix to the next letter in the alphabet in a way 
        that the outer query's aliases and this query's aliases will not 
        conflict. Even tables that previously had no alias will get an alias 
        after this call. 
        &quot;&quot;&quot;</span>
        <span class="s2">def </span><span class="s1">prefix_gen():</span>
            <span class="s0">&quot;&quot;&quot; 
            Generate a sequence of characters in alphabetical order: 
                -&gt; 'A', 'B', 'C', ... 
 
            When the alphabet is finished, the sequence will continue with the 
            Cartesian product: 
                -&gt; 'AA', 'AB', 'AC', ... 
            &quot;&quot;&quot;</span>
            <span class="s1">alphabet = ascii_uppercase</span>
            <span class="s1">prefix = chr(ord(self.alias_prefix) + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">yield </span><span class="s1">prefix</span>
            <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">count(</span><span class="s5">1</span><span class="s1">):</span>
                <span class="s1">seq = alphabet[alphabet.index(prefix):] </span><span class="s2">if </span><span class="s1">prefix </span><span class="s2">else </span><span class="s1">alphabet</span>
                <span class="s2">for </span><span class="s1">s </span><span class="s2">in </span><span class="s1">product(seq</span><span class="s2">, </span><span class="s1">repeat=n):</span>
                    <span class="s2">yield </span><span class="s3">''</span><span class="s1">.join(s)</span>
                <span class="s1">prefix = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">self.alias_prefix != outer_query.alias_prefix:</span>
            <span class="s4"># No clashes between self and outer query should be possible.</span>
            <span class="s2">return</span>

        <span class="s4"># Explicitly avoid infinite loop. The constant divider is based on how</span>
        <span class="s4"># much depth recursive subquery references add to the stack. This value</span>
        <span class="s4"># might need to be adjusted when adding or removing function calls from</span>
        <span class="s4"># the code path in charge of performing these operations.</span>
        <span class="s1">local_recursion_limit = sys.getrecursionlimit() // </span><span class="s5">16</span>
        <span class="s2">for </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">enumerate(prefix_gen()):</span>
            <span class="s2">if </span><span class="s1">prefix </span><span class="s2">not in </span><span class="s1">self.subq_aliases:</span>
                <span class="s1">self.alias_prefix = prefix</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">pos &gt; local_recursion_limit:</span>
                <span class="s2">raise </span><span class="s1">RecursionError(</span>
                    <span class="s3">'Maximum recursion depth exceeded: too many subqueries.'</span>
                <span class="s1">)</span>
        <span class="s1">self.subq_aliases = self.subq_aliases.union([self.alias_prefix])</span>
        <span class="s1">outer_query.subq_aliases = outer_query.subq_aliases.union(self.subq_aliases)</span>
        <span class="s1">self.change_aliases({</span>
            <span class="s1">alias: </span><span class="s3">'%s%d' </span><span class="s1">% (self.alias_prefix</span><span class="s2">, </span><span class="s1">pos)</span>
            <span class="s2">for </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">enumerate(self.alias_map)</span>
        <span class="s1">})</span>

    <span class="s2">def </span><span class="s1">get_initial_alias(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the first alias for this query, after increasing its reference 
        count. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.alias_map:</span>
            <span class="s1">alias = self.base_table</span>
            <span class="s1">self.ref_alias(alias)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">alias = self.join(BaseTable(self.get_meta().db_table</span><span class="s2">, None</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">alias</span>

    <span class="s2">def </span><span class="s1">count_active_tables(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the number of tables in this query with a non-zero reference 
        count. After execution, the reference counts are zeroed, so tables 
        added in compiler will not be seen by this method. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len([</span><span class="s5">1 </span><span class="s2">for </span><span class="s1">count </span><span class="s2">in </span><span class="s1">self.alias_refcount.values() </span><span class="s2">if </span><span class="s1">count])</span>

    <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">join</span><span class="s2">, </span><span class="s1">reuse=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return an alias for the 'join', either reusing an existing alias for 
        that join or creating a new one. 'join' is either a 
        sql.datastructures.BaseTable or Join. 
 
        The 'reuse' parameter can be either None which means all joins are 
        reusable, or it can be a set containing the aliases that can be reused. 
 
        A join is always created as LOUTER if the lhs alias is LOUTER to make 
        sure chains like t1 LOUTER t2 INNER t3 aren't generated. All new 
        joins are created as LOUTER if the join is nullable. 
        &quot;&quot;&quot;</span>
        <span class="s1">reuse_aliases = [</span>
            <span class="s1">a </span><span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">j </span><span class="s2">in </span><span class="s1">self.alias_map.items()</span>
            <span class="s2">if </span><span class="s1">(reuse </span><span class="s2">is None or </span><span class="s1">a </span><span class="s2">in </span><span class="s1">reuse) </span><span class="s2">and </span><span class="s1">j.equals(join)</span>
        <span class="s1">]</span>
        <span class="s2">if </span><span class="s1">reuse_aliases:</span>
            <span class="s2">if </span><span class="s1">join.table_alias </span><span class="s2">in </span><span class="s1">reuse_aliases:</span>
                <span class="s1">reuse_alias = join.table_alias</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Reuse the most recent alias of the joined table</span>
                <span class="s4"># (a many-to-many relation may be joined multiple times).</span>
                <span class="s1">reuse_alias = reuse_aliases[-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.ref_alias(reuse_alias)</span>
            <span class="s2">return </span><span class="s1">reuse_alias</span>

        <span class="s4"># No reuse is possible, so we need a new alias.</span>
        <span class="s1">alias</span><span class="s2">, </span><span class="s1">_ = self.table_alias(join.table_name</span><span class="s2">, </span><span class="s1">create=</span><span class="s2">True, </span><span class="s1">filtered_relation=join.filtered_relation)</span>
        <span class="s2">if </span><span class="s1">join.join_type:</span>
            <span class="s2">if </span><span class="s1">self.alias_map[join.parent_alias].join_type == LOUTER </span><span class="s2">or </span><span class="s1">join.nullable:</span>
                <span class="s1">join_type = LOUTER</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">join_type = INNER</span>
            <span class="s1">join.join_type = join_type</span>
        <span class="s1">join.table_alias = alias</span>
        <span class="s1">self.alias_map[alias] = join</span>
        <span class="s2">return </span><span class="s1">alias</span>

    <span class="s2">def </span><span class="s1">join_parent_model(self</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">seen):</span>
        <span class="s0">&quot;&quot;&quot; 
        Make sure the given 'model' is joined in the query. If 'model' isn't 
        a parent of 'opts' or if it is None this method is a no-op. 
 
        The 'alias' is the root alias for starting the join, 'seen' is a dict 
        of model -&gt; alias of existing joins. It must also contain a mapping 
        of None -&gt; some alias. This will be returned in the no-op case. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">model </span><span class="s2">in </span><span class="s1">seen:</span>
            <span class="s2">return </span><span class="s1">seen[model]</span>
        <span class="s1">chain = opts.get_base_chain(model)</span>
        <span class="s2">if not </span><span class="s1">chain:</span>
            <span class="s2">return </span><span class="s1">alias</span>
        <span class="s1">curr_opts = opts</span>
        <span class="s2">for </span><span class="s1">int_model </span><span class="s2">in </span><span class="s1">chain:</span>
            <span class="s2">if </span><span class="s1">int_model </span><span class="s2">in </span><span class="s1">seen:</span>
                <span class="s1">curr_opts = int_model._meta</span>
                <span class="s1">alias = seen[int_model]</span>
                <span class="s2">continue</span>
            <span class="s4"># Proxy model have elements in base chain</span>
            <span class="s4"># with no parents, assign the new options</span>
            <span class="s4"># object and skip to the next base in that</span>
            <span class="s4"># case</span>
            <span class="s2">if not </span><span class="s1">curr_opts.parents[int_model]:</span>
                <span class="s1">curr_opts = int_model._meta</span>
                <span class="s2">continue</span>
            <span class="s1">link_field = curr_opts.get_ancestor_link(int_model)</span>
            <span class="s1">join_info = self.setup_joins([link_field.name]</span><span class="s2">, </span><span class="s1">curr_opts</span><span class="s2">, </span><span class="s1">alias)</span>
            <span class="s1">curr_opts = int_model._meta</span>
            <span class="s1">alias = seen[int_model] = join_info.joins[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">alias </span><span class="s2">or </span><span class="s1">seen[</span><span class="s2">None</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">add_annotation(self</span><span class="s2">, </span><span class="s1">annotation</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">is_summary=</span><span class="s2">False, </span><span class="s1">select=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Add a single annotation expression to the Query.&quot;&quot;&quot;</span>
        <span class="s1">annotation = annotation.resolve_expression(self</span><span class="s2">, </span><span class="s1">allow_joins=</span><span class="s2">True, </span><span class="s1">reuse=</span><span class="s2">None,</span>
                                                   <span class="s1">summarize=is_summary)</span>
        <span class="s2">if </span><span class="s1">select:</span>
            <span class="s1">self.append_annotation_mask([alias])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.set_annotation_mask(set(self.annotation_select).difference({alias}))</span>
        <span class="s1">self.annotations[alias] = annotation</span>

    <span class="s2">def </span><span class="s1">resolve_expression(self</span><span class="s2">, </span><span class="s1">query</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">clone = self.clone()</span>
        <span class="s4"># Subqueries need to use a different set of aliases than the outer query.</span>
        <span class="s1">clone.bump_prefix(query)</span>
        <span class="s1">clone.subquery = </span><span class="s2">True</span>
        <span class="s1">clone.where.resolve_expression(query</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value </span><span class="s2">in </span><span class="s1">clone.annotations.items():</span>
            <span class="s1">resolved = value.resolve_expression(query</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s2">if </span><span class="s1">hasattr(resolved</span><span class="s2">, </span><span class="s3">'external_aliases'</span><span class="s1">):</span>
                <span class="s1">resolved.external_aliases.update(clone.external_aliases)</span>
            <span class="s1">clone.annotations[key] = resolved</span>
        <span class="s4"># Outer query's aliases are considered external.</span>
        <span class="s2">for </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">table </span><span class="s2">in </span><span class="s1">query.alias_map.items():</span>
            <span class="s1">clone.external_aliases[alias] = (</span>
                <span class="s1">(isinstance(table</span><span class="s2">, </span><span class="s1">Join) </span><span class="s2">and </span><span class="s1">table.join_field.related_model._meta.db_table != alias) </span><span class="s2">or</span>
                <span class="s1">(isinstance(table</span><span class="s2">, </span><span class="s1">BaseTable) </span><span class="s2">and </span><span class="s1">table.table_name != table.table_alias)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">clone</span>

    <span class="s2">def </span><span class="s1">get_external_cols(self):</span>
        <span class="s1">exprs = chain(self.annotations.values()</span><span class="s2">, </span><span class="s1">self.where.children)</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">col </span><span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">self._gen_cols(exprs</span><span class="s2">, </span><span class="s1">include_external=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">col.alias </span><span class="s2">in </span><span class="s1">self.external_aliases</span>
        <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">as_sql(self</span><span class="s2">, </span><span class="s1">compiler</span><span class="s2">, </span><span class="s1">connection):</span>
        <span class="s4"># Some backends (e.g. Oracle) raise an error when a subquery contains</span>
        <span class="s4"># unnecessary ORDER BY clause.</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">self.subquery </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">connection.features.ignores_unnecessary_order_by_in_subqueries</span>
        <span class="s1">):</span>
            <span class="s1">self.clear_ordering(force=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">sql</span><span class="s2">, </span><span class="s1">params = self.get_compiler(connection=connection).as_sql()</span>
        <span class="s2">if </span><span class="s1">self.subquery:</span>
            <span class="s1">sql = </span><span class="s3">'(%s)' </span><span class="s1">% sql</span>
        <span class="s2">return </span><span class="s1">sql</span><span class="s2">, </span><span class="s1">params</span>

    <span class="s2">def </span><span class="s1">resolve_lookup_value(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">can_reuse</span><span class="s2">, </span><span class="s1">allow_joins):</span>
        <span class="s2">if </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s3">'resolve_expression'</span><span class="s1">):</span>
            <span class="s1">value = value.resolve_expression(</span>
                <span class="s1">self</span><span class="s2">, </span><span class="s1">reuse=can_reuse</span><span class="s2">, </span><span class="s1">allow_joins=allow_joins</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">(list</span><span class="s2">, </span><span class="s1">tuple)):</span>
            <span class="s4"># The items of the iterable may be expressions and therefore need</span>
            <span class="s4"># to be resolved independently.</span>
            <span class="s1">values = (</span>
                <span class="s1">self.resolve_lookup_value(sub_value</span><span class="s2">, </span><span class="s1">can_reuse</span><span class="s2">, </span><span class="s1">allow_joins)</span>
                <span class="s2">for </span><span class="s1">sub_value </span><span class="s2">in </span><span class="s1">value</span>
            <span class="s1">)</span>
            <span class="s1">type_ = type(value)</span>
            <span class="s2">if </span><span class="s1">hasattr(type_</span><span class="s2">, </span><span class="s3">'_make'</span><span class="s1">):  </span><span class="s4"># namedtuple</span>
                <span class="s2">return </span><span class="s1">type_(*values)</span>
            <span class="s2">return </span><span class="s1">type_(values)</span>
        <span class="s2">return </span><span class="s1">value</span>

    <span class="s2">def </span><span class="s1">solve_lookup_type(self</span><span class="s2">, </span><span class="s1">lookup):</span>
        <span class="s0">&quot;&quot;&quot; 
        Solve the lookup type from the lookup (e.g.: 'foobar__id__icontains'). 
        &quot;&quot;&quot;</span>
        <span class="s1">lookup_splitted = lookup.split(LOOKUP_SEP)</span>
        <span class="s2">if </span><span class="s1">self.annotations:</span>
            <span class="s1">expression</span><span class="s2">, </span><span class="s1">expression_lookups = refs_expression(lookup_splitted</span><span class="s2">, </span><span class="s1">self.annotations)</span>
            <span class="s2">if </span><span class="s1">expression:</span>
                <span class="s2">return </span><span class="s1">expression_lookups</span><span class="s2">, </span><span class="s1">()</span><span class="s2">, </span><span class="s1">expression</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">lookup_parts = self.names_to_path(lookup_splitted</span><span class="s2">, </span><span class="s1">self.get_meta())</span>
        <span class="s1">field_parts = lookup_splitted[</span><span class="s5">0</span><span class="s1">:len(lookup_splitted) - len(lookup_parts)]</span>
        <span class="s2">if </span><span class="s1">len(lookup_parts) &gt; </span><span class="s5">1 </span><span class="s2">and not </span><span class="s1">field_parts:</span>
            <span class="s2">raise </span><span class="s1">FieldError(</span>
                <span class="s3">'Invalid lookup &quot;%s&quot; for model %s&quot;.' </span><span class="s1">%</span>
                <span class="s1">(lookup</span><span class="s2">, </span><span class="s1">self.get_meta().model.__name__)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">lookup_parts</span><span class="s2">, </span><span class="s1">field_parts</span><span class="s2">, False</span>

    <span class="s2">def </span><span class="s1">check_query_object_type(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">field):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check whether the object passed while querying is of the correct type. 
        If not, raise a ValueError specifying the wrong object. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s3">'_meta'</span><span class="s1">):</span>
            <span class="s2">if not </span><span class="s1">check_rel_lookup_compatibility(value._meta.model</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">field):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">'Cannot query &quot;%s&quot;: Must be &quot;%s&quot; instance.' </span><span class="s1">%</span>
                    <span class="s1">(value</span><span class="s2">, </span><span class="s1">opts.object_name))</span>

    <span class="s2">def </span><span class="s1">check_related_objects(self</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">opts):</span>
        <span class="s0">&quot;&quot;&quot;Check the type of object passed to query relations.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">field.is_relation:</span>
            <span class="s4"># Check that the field and the queryset use the same model in a</span>
            <span class="s4"># query like .filter(author=Author.objects.all()). For example, the</span>
            <span class="s4"># opts would be Author's (from the author field) and value.model</span>
            <span class="s4"># would be Author.objects.all() queryset's .model (Author also).</span>
            <span class="s4"># The field is the related field on the lhs side.</span>
            <span class="s2">if </span><span class="s1">(isinstance(value</span><span class="s2">, </span><span class="s1">Query) </span><span class="s2">and not </span><span class="s1">value.has_select_fields </span><span class="s2">and</span>
                    <span class="s2">not </span><span class="s1">check_rel_lookup_compatibility(value.model</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">field)):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">'Cannot use QuerySet for &quot;%s&quot;: Use a QuerySet for &quot;%s&quot;.' </span><span class="s1">%</span>
                    <span class="s1">(value.model._meta.object_name</span><span class="s2">, </span><span class="s1">opts.object_name)</span>
                <span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s3">'_meta'</span><span class="s1">):</span>
                <span class="s1">self.check_query_object_type(value</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">field)</span>
            <span class="s2">elif </span><span class="s1">hasattr(value</span><span class="s2">, </span><span class="s3">'__iter__'</span><span class="s1">):</span>
                <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">value:</span>
                    <span class="s1">self.check_query_object_type(v</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">field)</span>

    <span class="s2">def </span><span class="s1">check_filterable(self</span><span class="s2">, </span><span class="s1">expression):</span>
        <span class="s0">&quot;&quot;&quot;Raise an error if expression cannot be used in a WHERE clause.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">hasattr(expression</span><span class="s2">, </span><span class="s3">'resolve_expression'</span><span class="s1">) </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">getattr(expression</span><span class="s2">, </span><span class="s3">'filterable'</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">NotSupportedError(</span>
                <span class="s1">expression.__class__.__name__ + </span><span class="s3">' is disallowed in the filter '</span>
                <span class="s3">'clause.'</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">hasattr(expression</span><span class="s2">, </span><span class="s3">'get_source_expressions'</span><span class="s1">):</span>
            <span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">expression.get_source_expressions():</span>
                <span class="s1">self.check_filterable(expr)</span>

    <span class="s2">def </span><span class="s1">build_lookup(self</span><span class="s2">, </span><span class="s1">lookups</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Try to extract transforms and lookup from given lhs. 
 
        The lhs value is something that works like SQLExpression. 
        The rhs value is what the lookup is going to compare against. 
        The lookups is a list of names to extract using get_lookup() 
        and get_transform(). 
        &quot;&quot;&quot;</span>
        <span class="s4"># __exact is the default lookup if one isn't given.</span>
        <span class="s1">*transforms</span><span class="s2">, </span><span class="s1">lookup_name = lookups </span><span class="s2">or </span><span class="s1">[</span><span class="s3">'exact'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">transforms:</span>
            <span class="s1">lhs = self.try_transform(lhs</span><span class="s2">, </span><span class="s1">name)</span>
        <span class="s4"># First try get_lookup() so that the lookup takes precedence if the lhs</span>
        <span class="s4"># supports both transform and lookup for the name.</span>
        <span class="s1">lookup_class = lhs.get_lookup(lookup_name)</span>
        <span class="s2">if not </span><span class="s1">lookup_class:</span>
            <span class="s2">if </span><span class="s1">lhs.field.is_relation:</span>
                <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">'Related Field got invalid lookup: {}'</span><span class="s1">.format(lookup_name))</span>
            <span class="s4"># A lookup wasn't found. Try to interpret the name as a transform</span>
            <span class="s4"># and do an Exact lookup against it.</span>
            <span class="s1">lhs = self.try_transform(lhs</span><span class="s2">, </span><span class="s1">lookup_name)</span>
            <span class="s1">lookup_name = </span><span class="s3">'exact'</span>
            <span class="s1">lookup_class = lhs.get_lookup(lookup_name)</span>
            <span class="s2">if not </span><span class="s1">lookup_class:</span>
                <span class="s2">return</span>

        <span class="s1">lookup = lookup_class(lhs</span><span class="s2">, </span><span class="s1">rhs)</span>
        <span class="s4"># Interpret '__exact=None' as the sql 'is NULL'; otherwise, reject all</span>
        <span class="s4"># uses of None as a query value unless the lookup supports it.</span>
        <span class="s2">if </span><span class="s1">lookup.rhs </span><span class="s2">is None and not </span><span class="s1">lookup.can_use_none_as_rhs:</span>
            <span class="s2">if </span><span class="s1">lookup_name </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">'exact'</span><span class="s2">, </span><span class="s3">'iexact'</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Cannot use None as a query value&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">lhs.get_lookup(</span><span class="s3">'isnull'</span><span class="s1">)(lhs</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s4"># For Oracle '' is equivalent to null. The check must be done at this</span>
        <span class="s4"># stage because join promotion can't be done in the compiler. Using</span>
        <span class="s4"># DEFAULT_DB_ALIAS isn't nice but it's the best that can be done here.</span>
        <span class="s4"># A similar thing is done in is_nullable(), too.</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">lookup_name == </span><span class="s3">'exact' </span><span class="s2">and</span>
            <span class="s1">lookup.rhs == </span><span class="s3">'' </span><span class="s2">and</span>
            <span class="s1">connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">lhs.get_lookup(</span><span class="s3">'isnull'</span><span class="s1">)(lhs</span><span class="s2">, True</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">lookup</span>

    <span class="s2">def </span><span class="s1">try_transform(self</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper method for build_lookup(). Try to fetch and initialize 
        a transform for name parameter from lhs. 
        &quot;&quot;&quot;</span>
        <span class="s1">transform_class = lhs.get_transform(name)</span>
        <span class="s2">if </span><span class="s1">transform_class:</span>
            <span class="s2">return </span><span class="s1">transform_class(lhs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">output_field = lhs.output_field.__class__</span>
            <span class="s1">suggested_lookups = difflib.get_close_matches(name</span><span class="s2">, </span><span class="s1">output_field.get_lookups())</span>
            <span class="s2">if </span><span class="s1">suggested_lookups:</span>
                <span class="s1">suggestion = </span><span class="s3">', perhaps you meant %s?' </span><span class="s1">% </span><span class="s3">' or '</span><span class="s1">.join(suggested_lookups)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">suggestion = </span><span class="s3">'.'</span>
            <span class="s2">raise </span><span class="s1">FieldError(</span>
                <span class="s3">&quot;Unsupported lookup '%s' for %s or join on the field not &quot;</span>
                <span class="s3">&quot;permitted%s&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s1">output_field.__name__</span><span class="s2">, </span><span class="s1">suggestion)</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">build_filter(self</span><span class="s2">, </span><span class="s1">filter_expr</span><span class="s2">, </span><span class="s1">branch_negated=</span><span class="s2">False, </span><span class="s1">current_negated=</span><span class="s2">False,</span>
                     <span class="s1">can_reuse=</span><span class="s2">None, </span><span class="s1">allow_joins=</span><span class="s2">True, </span><span class="s1">split_subq=</span><span class="s2">True,</span>
                     <span class="s1">check_filterable=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Build a WhereNode for a single filter clause but don't add it 
        to this Query. Query.add_q() will then add this filter to the where 
        Node. 
 
        The 'branch_negated' tells us if the current branch contains any 
        negations. This will be used to determine if subqueries are needed. 
 
        The 'current_negated' is used to determine if the current filter is 
        negated or not and this will be used to determine if IS NULL filtering 
        is needed. 
 
        The difference between current_negated and branch_negated is that 
        branch_negated is set on first negation, but current_negated is 
        flipped for each negation. 
 
        Note that add_filter will not do any negating itself, that is done 
        upper in the code by add_q(). 
 
        The 'can_reuse' is a set of reusable joins for multijoins. 
 
        The method will create a filter clause that can be added to the current 
        query. However, if the filter isn't added to the query then the caller 
        is responsible for unreffing the joins used. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(filter_expr</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">&quot;Cannot parse keyword query as dict&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(filter_expr</span><span class="s2">, </span><span class="s1">Q):</span>
            <span class="s2">return </span><span class="s1">self._add_q(</span>
                <span class="s1">filter_expr</span><span class="s2">,</span>
                <span class="s1">branch_negated=branch_negated</span><span class="s2">,</span>
                <span class="s1">current_negated=current_negated</span><span class="s2">,</span>
                <span class="s1">used_aliases=can_reuse</span><span class="s2">,</span>
                <span class="s1">allow_joins=allow_joins</span><span class="s2">,</span>
                <span class="s1">split_subq=split_subq</span><span class="s2">,</span>
                <span class="s1">check_filterable=check_filterable</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">hasattr(filter_expr</span><span class="s2">, </span><span class="s3">'resolve_expression'</span><span class="s1">):</span>
            <span class="s2">if not </span><span class="s1">getattr(filter_expr</span><span class="s2">, </span><span class="s3">'conditional'</span><span class="s2">, False</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">'Cannot filter against a non-conditional expression.'</span><span class="s1">)</span>
            <span class="s1">condition = filter_expr.resolve_expression(self</span><span class="s2">, </span><span class="s1">allow_joins=allow_joins)</span>
            <span class="s2">if not </span><span class="s1">isinstance(condition</span><span class="s2">, </span><span class="s1">Lookup):</span>
                <span class="s1">condition = self.build_lookup([</span><span class="s3">'exact'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">, True</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">WhereNode([condition]</span><span class="s2">, </span><span class="s1">connector=AND)</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s1">arg</span><span class="s2">, </span><span class="s1">value = filter_expr</span>
        <span class="s2">if not </span><span class="s1">arg:</span>
            <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">&quot;Cannot parse keyword query %r&quot; </span><span class="s1">% arg)</span>
        <span class="s1">lookups</span><span class="s2">, </span><span class="s1">parts</span><span class="s2">, </span><span class="s1">reffed_expression = self.solve_lookup_type(arg)</span>

        <span class="s2">if </span><span class="s1">check_filterable:</span>
            <span class="s1">self.check_filterable(reffed_expression)</span>

        <span class="s2">if not </span><span class="s1">allow_joins </span><span class="s2">and </span><span class="s1">len(parts) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">&quot;Joined field references are not permitted in this query&quot;</span><span class="s1">)</span>

        <span class="s1">pre_joins = self.alias_refcount.copy()</span>
        <span class="s1">value = self.resolve_lookup_value(value</span><span class="s2">, </span><span class="s1">can_reuse</span><span class="s2">, </span><span class="s1">allow_joins)</span>
        <span class="s1">used_joins = {k </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.alias_refcount.items() </span><span class="s2">if </span><span class="s1">v &gt; pre_joins.get(k</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)}</span>

        <span class="s2">if </span><span class="s1">check_filterable:</span>
            <span class="s1">self.check_filterable(value)</span>

        <span class="s2">if </span><span class="s1">reffed_expression:</span>
            <span class="s1">condition = self.build_lookup(lookups</span><span class="s2">, </span><span class="s1">reffed_expression</span><span class="s2">, </span><span class="s1">value)</span>
            <span class="s2">return </span><span class="s1">WhereNode([condition]</span><span class="s2">, </span><span class="s1">connector=AND)</span><span class="s2">, </span><span class="s1">[]</span>

        <span class="s1">opts = self.get_meta()</span>
        <span class="s1">alias = self.get_initial_alias()</span>
        <span class="s1">allow_many = </span><span class="s2">not </span><span class="s1">branch_negated </span><span class="s2">or not </span><span class="s1">split_subq</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">join_info = self.setup_joins(</span>
                <span class="s1">parts</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">can_reuse=can_reuse</span><span class="s2">, </span><span class="s1">allow_many=allow_many</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s4"># Prevent iterator from being consumed by check_related_objects()</span>
            <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Iterator):</span>
                <span class="s1">value = list(value)</span>
            <span class="s1">self.check_related_objects(join_info.final_field</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">join_info.opts)</span>

            <span class="s4"># split_exclude() needs to know which joins were generated for the</span>
            <span class="s4"># lookup parts</span>
            <span class="s1">self._lookup_joins = join_info.joins</span>
        <span class="s2">except </span><span class="s1">MultiJoin </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">return </span><span class="s1">self.split_exclude(filter_expr</span><span class="s2">, </span><span class="s1">can_reuse</span><span class="s2">, </span><span class="s1">e.names_with_path)</span>

        <span class="s4"># Update used_joins before trimming since they are reused to determine</span>
        <span class="s4"># which joins could be later promoted to INNER.</span>
        <span class="s1">used_joins.update(join_info.joins)</span>
        <span class="s1">targets</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">join_list = self.trim_joins(join_info.targets</span><span class="s2">, </span><span class="s1">join_info.joins</span><span class="s2">, </span><span class="s1">join_info.path)</span>
        <span class="s2">if </span><span class="s1">can_reuse </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">can_reuse.update(join_list)</span>

        <span class="s2">if </span><span class="s1">join_info.final_field.is_relation:</span>
            <span class="s4"># No support for transforms for relational fields</span>
            <span class="s1">num_lookups = len(lookups)</span>
            <span class="s2">if </span><span class="s1">num_lookups &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">'Related Field got invalid lookup: {}'</span><span class="s1">.format(lookups[</span><span class="s5">0</span><span class="s1">]))</span>
            <span class="s2">if </span><span class="s1">len(targets) == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">col = self._get_col(targets[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">join_info.final_field</span><span class="s2">, </span><span class="s1">alias)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">col = MultiColSource(alias</span><span class="s2">, </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">join_info.targets</span><span class="s2">, </span><span class="s1">join_info.final_field)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">col = self._get_col(targets[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">join_info.final_field</span><span class="s2">, </span><span class="s1">alias)</span>

        <span class="s1">condition = self.build_lookup(lookups</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">value)</span>
        <span class="s1">lookup_type = condition.lookup_name</span>
        <span class="s1">clause = WhereNode([condition]</span><span class="s2">, </span><span class="s1">connector=AND)</span>

        <span class="s1">require_outer = lookup_type == </span><span class="s3">'isnull' </span><span class="s2">and </span><span class="s1">condition.rhs </span><span class="s2">is True and not </span><span class="s1">current_negated</span>
        <span class="s2">if </span><span class="s1">current_negated </span><span class="s2">and </span><span class="s1">(lookup_type != </span><span class="s3">'isnull' </span><span class="s2">or </span><span class="s1">condition.rhs </span><span class="s2">is False</span><span class="s1">) </span><span class="s2">and </span><span class="s1">condition.rhs </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">require_outer = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">lookup_type != </span><span class="s3">'isnull'</span><span class="s1">:</span>
                <span class="s4"># The condition added here will be SQL like this:</span>
                <span class="s4"># NOT (col IS NOT NULL), where the first NOT is added in</span>
                <span class="s4"># upper layers of code. The reason for addition is that if col</span>
                <span class="s4"># is null, then col != someval will result in SQL &quot;unknown&quot;</span>
                <span class="s4"># which isn't the same as in Python. The Python None handling</span>
                <span class="s4"># is wanted, and it can be gotten by</span>
                <span class="s4"># (col IS NULL OR col != someval)</span>
                <span class="s4">#   &lt;=&gt;</span>
                <span class="s4"># NOT (col IS NOT NULL AND col = someval).</span>
                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">self.is_nullable(targets[</span><span class="s5">0</span><span class="s1">]) </span><span class="s2">or</span>
                    <span class="s1">self.alias_map[join_list[-</span><span class="s5">1</span><span class="s1">]].join_type == LOUTER</span>
                <span class="s1">):</span>
                    <span class="s1">lookup_class = targets[</span><span class="s5">0</span><span class="s1">].get_lookup(</span><span class="s3">'isnull'</span><span class="s1">)</span>
                    <span class="s1">col = self._get_col(targets[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">join_info.targets[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alias)</span>
                    <span class="s1">clause.add(lookup_class(col</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">AND)</span>
                <span class="s4"># If someval is a nullable column, someval IS NOT NULL is</span>
                <span class="s4"># added.</span>
                <span class="s2">if </span><span class="s1">isinstance(value</span><span class="s2">, </span><span class="s1">Col) </span><span class="s2">and </span><span class="s1">self.is_nullable(value.target):</span>
                    <span class="s1">lookup_class = value.target.get_lookup(</span><span class="s3">'isnull'</span><span class="s1">)</span>
                    <span class="s1">clause.add(lookup_class(value</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">AND)</span>
        <span class="s2">return </span><span class="s1">clause</span><span class="s2">, </span><span class="s1">used_joins </span><span class="s2">if not </span><span class="s1">require_outer </span><span class="s2">else </span><span class="s1">()</span>

    <span class="s2">def </span><span class="s1">add_filter(self</span><span class="s2">, </span><span class="s1">filter_lhs</span><span class="s2">, </span><span class="s1">filter_rhs):</span>
        <span class="s1">self.add_q(Q((filter_lhs</span><span class="s2">, </span><span class="s1">filter_rhs)))</span>

    <span class="s2">def </span><span class="s1">add_q(self</span><span class="s2">, </span><span class="s1">q_object):</span>
        <span class="s0">&quot;&quot;&quot; 
        A preprocessor for the internal _add_q(). Responsible for doing final 
        join promotion. 
        &quot;&quot;&quot;</span>
        <span class="s4"># For join promotion this case is doing an AND for the added q_object</span>
        <span class="s4"># and existing conditions. So, any existing inner join forces the join</span>
        <span class="s4"># type to remain inner. Existing outer joins can however be demoted.</span>
        <span class="s4"># (Consider case where rel_a is LOUTER and rel_a__col=1 is added - if</span>
        <span class="s4"># rel_a doesn't produce any rows, then the whole condition must fail.</span>
        <span class="s4"># So, demotion is OK.</span>
        <span class="s1">existing_inner = {a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.alias_map </span><span class="s2">if </span><span class="s1">self.alias_map[a].join_type == INNER}</span>
        <span class="s1">clause</span><span class="s2">, </span><span class="s1">_ = self._add_q(q_object</span><span class="s2">, </span><span class="s1">self.used_aliases)</span>
        <span class="s2">if </span><span class="s1">clause:</span>
            <span class="s1">self.where.add(clause</span><span class="s2">, </span><span class="s1">AND)</span>
        <span class="s1">self.demote_joins(existing_inner)</span>

    <span class="s2">def </span><span class="s1">build_where(self</span><span class="s2">, </span><span class="s1">filter_expr):</span>
        <span class="s2">return </span><span class="s1">self.build_filter(filter_expr</span><span class="s2">, </span><span class="s1">allow_joins=</span><span class="s2">False</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">clear_where(self):</span>
        <span class="s1">self.where = WhereNode()</span>

    <span class="s2">def </span><span class="s1">_add_q(self</span><span class="s2">, </span><span class="s1">q_object</span><span class="s2">, </span><span class="s1">used_aliases</span><span class="s2">, </span><span class="s1">branch_negated=</span><span class="s2">False,</span>
               <span class="s1">current_negated=</span><span class="s2">False, </span><span class="s1">allow_joins=</span><span class="s2">True, </span><span class="s1">split_subq=</span><span class="s2">True,</span>
               <span class="s1">check_filterable=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Add a Q-object to the current filter.&quot;&quot;&quot;</span>
        <span class="s1">connector = q_object.connector</span>
        <span class="s1">current_negated = current_negated ^ q_object.negated</span>
        <span class="s1">branch_negated = branch_negated </span><span class="s2">or </span><span class="s1">q_object.negated</span>
        <span class="s1">target_clause = WhereNode(connector=connector</span><span class="s2">, </span><span class="s1">negated=q_object.negated)</span>
        <span class="s1">joinpromoter = JoinPromoter(q_object.connector</span><span class="s2">, </span><span class="s1">len(q_object.children)</span><span class="s2">, </span><span class="s1">current_negated)</span>
        <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">q_object.children:</span>
            <span class="s1">child_clause</span><span class="s2">, </span><span class="s1">needed_inner = self.build_filter(</span>
                <span class="s1">child</span><span class="s2">, </span><span class="s1">can_reuse=used_aliases</span><span class="s2">, </span><span class="s1">branch_negated=branch_negated</span><span class="s2">,</span>
                <span class="s1">current_negated=current_negated</span><span class="s2">, </span><span class="s1">allow_joins=allow_joins</span><span class="s2">,</span>
                <span class="s1">split_subq=split_subq</span><span class="s2">, </span><span class="s1">check_filterable=check_filterable</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">joinpromoter.add_votes(needed_inner)</span>
            <span class="s2">if </span><span class="s1">child_clause:</span>
                <span class="s1">target_clause.add(child_clause</span><span class="s2">, </span><span class="s1">connector)</span>
        <span class="s1">needed_inner = joinpromoter.update_join_types(self)</span>
        <span class="s2">return </span><span class="s1">target_clause</span><span class="s2">, </span><span class="s1">needed_inner</span>

    <span class="s2">def </span><span class="s1">build_filtered_relation_q(self</span><span class="s2">, </span><span class="s1">q_object</span><span class="s2">, </span><span class="s1">reuse</span><span class="s2">, </span><span class="s1">branch_negated=</span><span class="s2">False, </span><span class="s1">current_negated=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Add a FilteredRelation object to the current filter.&quot;&quot;&quot;</span>
        <span class="s1">connector = q_object.connector</span>
        <span class="s1">current_negated ^= q_object.negated</span>
        <span class="s1">branch_negated = branch_negated </span><span class="s2">or </span><span class="s1">q_object.negated</span>
        <span class="s1">target_clause = WhereNode(connector=connector</span><span class="s2">, </span><span class="s1">negated=q_object.negated)</span>
        <span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">q_object.children:</span>
            <span class="s2">if </span><span class="s1">isinstance(child</span><span class="s2">, </span><span class="s1">Node):</span>
                <span class="s1">child_clause = self.build_filtered_relation_q(</span>
                    <span class="s1">child</span><span class="s2">, </span><span class="s1">reuse=reuse</span><span class="s2">, </span><span class="s1">branch_negated=branch_negated</span><span class="s2">,</span>
                    <span class="s1">current_negated=current_negated</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">child_clause</span><span class="s2">, </span><span class="s1">_ = self.build_filter(</span>
                    <span class="s1">child</span><span class="s2">, </span><span class="s1">can_reuse=reuse</span><span class="s2">, </span><span class="s1">branch_negated=branch_negated</span><span class="s2">,</span>
                    <span class="s1">current_negated=current_negated</span><span class="s2">,</span>
                    <span class="s1">allow_joins=</span><span class="s2">True, </span><span class="s1">split_subq=</span><span class="s2">False,</span>
                <span class="s1">)</span>
            <span class="s1">target_clause.add(child_clause</span><span class="s2">, </span><span class="s1">connector)</span>
        <span class="s2">return </span><span class="s1">target_clause</span>

    <span class="s2">def </span><span class="s1">add_filtered_relation(self</span><span class="s2">, </span><span class="s1">filtered_relation</span><span class="s2">, </span><span class="s1">alias):</span>
        <span class="s1">filtered_relation.alias = alias</span>
        <span class="s1">lookups = dict(get_children_from_q(filtered_relation.condition))</span>
        <span class="s1">relation_lookup_parts</span><span class="s2">, </span><span class="s1">relation_field_parts</span><span class="s2">, </span><span class="s1">_ = self.solve_lookup_type(filtered_relation.relation_name)</span>
        <span class="s2">if </span><span class="s1">relation_lookup_parts:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;FilteredRelation's relation_name cannot contain lookups &quot;</span>
                <span class="s3">&quot;(got %r).&quot; </span><span class="s1">% filtered_relation.relation_name</span>
            <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">lookup </span><span class="s2">in </span><span class="s1">chain(lookups):</span>
            <span class="s1">lookup_parts</span><span class="s2">, </span><span class="s1">lookup_field_parts</span><span class="s2">, </span><span class="s1">_ = self.solve_lookup_type(lookup)</span>
            <span class="s1">shift = </span><span class="s5">2 </span><span class="s2">if not </span><span class="s1">lookup_parts </span><span class="s2">else </span><span class="s5">1</span>
            <span class="s1">lookup_field_path = lookup_field_parts[:-shift]</span>
            <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">lookup_field_part </span><span class="s2">in </span><span class="s1">enumerate(lookup_field_path):</span>
                <span class="s2">if </span><span class="s1">len(relation_field_parts) &gt; idx:</span>
                    <span class="s2">if </span><span class="s1">relation_field_parts[idx] != lookup_field_part:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span>
                            <span class="s3">&quot;FilteredRelation's condition doesn't support &quot;</span>
                            <span class="s3">&quot;relations outside the %r (got %r).&quot;</span>
                            <span class="s1">% (filtered_relation.relation_name</span><span class="s2">, </span><span class="s1">lookup)</span>
                        <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;FilteredRelation's condition doesn't support nested &quot;</span>
                        <span class="s3">&quot;relations deeper than the relation_name (got %r for &quot;</span>
                        <span class="s3">&quot;%r).&quot; </span><span class="s1">% (lookup</span><span class="s2">, </span><span class="s1">filtered_relation.relation_name)</span>
                    <span class="s1">)</span>
        <span class="s1">self._filtered_relations[filtered_relation.alias] = filtered_relation</span>

    <span class="s2">def </span><span class="s1">names_to_path(self</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">allow_many=</span><span class="s2">True, </span><span class="s1">fail_on_missing=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Walk the list of names and turns them into PathInfo tuples. A single 
        name in 'names' can generate multiple PathInfos (m2m, for example). 
 
        'names' is the path of names to travel, 'opts' is the model Options we 
        start the name resolving from, 'allow_many' is as for setup_joins(). 
        If fail_on_missing is set to True, then a name that can't be resolved 
        will generate a FieldError. 
 
        Return a list of PathInfo tuples. In addition return the final field 
        (the last used join field) and target (which is a field guaranteed to 
        contain the same value as the final field). Finally, return those names 
        that weren't found (which are likely transforms and the final lookup). 
        &quot;&quot;&quot;</span>
        <span class="s1">path</span><span class="s2">, </span><span class="s1">names_with_path = []</span><span class="s2">, </span><span class="s1">[]</span>
        <span class="s2">for </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(names):</span>
            <span class="s1">cur_names_with_path = (name</span><span class="s2">, </span><span class="s1">[])</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s3">'pk'</span><span class="s1">:</span>
                <span class="s1">name = opts.pk.name</span>

            <span class="s1">field = </span><span class="s2">None</span>
            <span class="s1">filtered_relation = </span><span class="s2">None</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">field = opts.get_field(name)</span>
            <span class="s2">except </span><span class="s1">FieldDoesNotExist:</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.annotation_select:</span>
                    <span class="s1">field = self.annotation_select[name].output_field</span>
                <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._filtered_relations </span><span class="s2">and </span><span class="s1">pos == </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s1">filtered_relation = self._filtered_relations[name]</span>
                    <span class="s2">if </span><span class="s1">LOOKUP_SEP </span><span class="s2">in </span><span class="s1">filtered_relation.relation_name:</span>
                        <span class="s1">parts = filtered_relation.relation_name.split(LOOKUP_SEP)</span>
                        <span class="s1">filtered_relation_path</span><span class="s2">, </span><span class="s1">field</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = self.names_to_path(</span>
                            <span class="s1">parts</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">allow_many</span><span class="s2">, </span><span class="s1">fail_on_missing</span><span class="s2">,</span>
                        <span class="s1">)</span>
                        <span class="s1">path.extend(filtered_relation_path[:-</span><span class="s5">1</span><span class="s1">])</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">field = opts.get_field(filtered_relation.relation_name)</span>
            <span class="s2">if </span><span class="s1">field </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s4"># Fields that contain one-to-many relations with a generic</span>
                <span class="s4"># model (like a GenericForeignKey) cannot generate reverse</span>
                <span class="s4"># relations and therefore cannot be used for reverse querying.</span>
                <span class="s2">if </span><span class="s1">field.is_relation </span><span class="s2">and not </span><span class="s1">field.related_model:</span>
                    <span class="s2">raise </span><span class="s1">FieldError(</span>
                        <span class="s3">&quot;Field %r does not generate an automatic reverse &quot;</span>
                        <span class="s3">&quot;relation and therefore cannot be used for reverse &quot;</span>
                        <span class="s3">&quot;querying. If it is a GenericForeignKey, consider &quot;</span>
                        <span class="s3">&quot;adding a GenericRelation.&quot; </span><span class="s1">% name</span>
                    <span class="s1">)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">model = field.model._meta.concrete_model</span>
                <span class="s2">except </span><span class="s1">AttributeError:</span>
                    <span class="s4"># QuerySet.annotate() may introduce fields that aren't</span>
                    <span class="s4"># attached to a model.</span>
                    <span class="s1">model = </span><span class="s2">None</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># We didn't find the current field, so move position back</span>
                <span class="s4"># one step.</span>
                <span class="s1">pos -= </span><span class="s5">1</span>
                <span class="s2">if </span><span class="s1">pos == -</span><span class="s5">1 </span><span class="s2">or </span><span class="s1">fail_on_missing:</span>
                    <span class="s1">available = sorted([</span>
                        <span class="s1">*get_field_names_from_opts(opts)</span><span class="s2">,</span>
                        <span class="s1">*self.annotation_select</span><span class="s2">,</span>
                        <span class="s1">*self._filtered_relations</span><span class="s2">,</span>
                    <span class="s1">])</span>
                    <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">&quot;Cannot resolve keyword '%s' into field. &quot;</span>
                                     <span class="s3">&quot;Choices are: %s&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(available)))</span>
                <span class="s2">break</span>
            <span class="s4"># Check if we need any joins for concrete inheritance cases (the</span>
            <span class="s4"># field lives in parent, but we are currently in one of its</span>
            <span class="s4"># children)</span>
            <span class="s2">if </span><span class="s1">model </span><span class="s2">is not </span><span class="s1">opts.model:</span>
                <span class="s1">path_to_parent = opts.get_path_to_parent(model)</span>
                <span class="s2">if </span><span class="s1">path_to_parent:</span>
                    <span class="s1">path.extend(path_to_parent)</span>
                    <span class="s1">cur_names_with_path[</span><span class="s5">1</span><span class="s1">].extend(path_to_parent)</span>
                    <span class="s1">opts = path_to_parent[-</span><span class="s5">1</span><span class="s1">].to_opts</span>
            <span class="s2">if </span><span class="s1">hasattr(field</span><span class="s2">, </span><span class="s3">'get_path_info'</span><span class="s1">):</span>
                <span class="s1">pathinfos = field.get_path_info(filtered_relation)</span>
                <span class="s2">if not </span><span class="s1">allow_many:</span>
                    <span class="s2">for </span><span class="s1">inner_pos</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">enumerate(pathinfos):</span>
                        <span class="s2">if </span><span class="s1">p.m2m:</span>
                            <span class="s1">cur_names_with_path[</span><span class="s5">1</span><span class="s1">].extend(pathinfos[</span><span class="s5">0</span><span class="s1">:inner_pos + </span><span class="s5">1</span><span class="s1">])</span>
                            <span class="s1">names_with_path.append(cur_names_with_path)</span>
                            <span class="s2">raise </span><span class="s1">MultiJoin(pos + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">names_with_path)</span>
                <span class="s1">last = pathinfos[-</span><span class="s5">1</span><span class="s1">]</span>
                <span class="s1">path.extend(pathinfos)</span>
                <span class="s1">final_field = last.join_field</span>
                <span class="s1">opts = last.to_opts</span>
                <span class="s1">targets = last.target_fields</span>
                <span class="s1">cur_names_with_path[</span><span class="s5">1</span><span class="s1">].extend(pathinfos)</span>
                <span class="s1">names_with_path.append(cur_names_with_path)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Local non-relational field.</span>
                <span class="s1">final_field = field</span>
                <span class="s1">targets = (field</span><span class="s2">,</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">fail_on_missing </span><span class="s2">and </span><span class="s1">pos + </span><span class="s5">1 </span><span class="s1">!= len(names):</span>
                    <span class="s2">raise </span><span class="s1">FieldError(</span>
                        <span class="s3">&quot;Cannot resolve keyword %r into field. Join on '%s'&quot;</span>
                        <span class="s3">&quot; not permitted.&quot; </span><span class="s1">% (names[pos + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name))</span>
                <span class="s2">break</span>
        <span class="s2">return </span><span class="s1">path</span><span class="s2">, </span><span class="s1">final_field</span><span class="s2">, </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">names[pos + </span><span class="s5">1</span><span class="s1">:]</span>

    <span class="s2">def </span><span class="s1">setup_joins(self</span><span class="s2">, </span><span class="s1">names</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">can_reuse=</span><span class="s2">None, </span><span class="s1">allow_many=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Compute the necessary table joins for the passage through the fields 
        given in 'names'. 'opts' is the Options class for the current model 
        (which gives the table we are starting from), 'alias' is the alias for 
        the table to start the joining from. 
 
        The 'can_reuse' defines the reverse foreign key joins we can reuse. It 
        can be None in which case all joins are reusable or a set of aliases 
        that can be reused. Note that non-reverse foreign keys are always 
        reusable when using setup_joins(). 
 
        If 'allow_many' is False, then any reverse foreign key seen will 
        generate a MultiJoin exception. 
 
        Return the final field involved in the joins, the target field (used 
        for any 'where' constraint), the final 'opts' value, the joins, the 
        field path traveled to generate the joins, and a transform function 
        that takes a field and alias and is equivalent to `field.get_col(alias)` 
        in the simple case but wraps field transforms if they were included in 
        names. 
 
        The target field is the field containing the concrete value. Final 
        field can be something different, for example foreign key pointing to 
        that value. Final field is needed for example in some value 
        conversions (convert 'obj' in fk__id=obj to pk val using the foreign 
        key field for example). 
        &quot;&quot;&quot;</span>
        <span class="s1">joins = [alias]</span>
        <span class="s4"># The transform can't be applied yet, as joins must be trimmed later.</span>
        <span class="s4"># To avoid making every caller of this method look up transforms</span>
        <span class="s4"># directly, compute transforms here and create a partial that converts</span>
        <span class="s4"># fields to the appropriate wrapped version.</span>

        <span class="s2">def </span><span class="s1">final_transformer(field</span><span class="s2">, </span><span class="s1">alias):</span>
            <span class="s2">if not </span><span class="s1">self.alias_cols:</span>
                <span class="s1">alias = </span><span class="s2">None</span>
            <span class="s2">return </span><span class="s1">field.get_col(alias)</span>

        <span class="s4"># Try resolving all the names as fields first. If there's an error,</span>
        <span class="s4"># treat trailing names as lookups until a field can be resolved.</span>
        <span class="s1">last_field_exception = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">pivot </span><span class="s2">in </span><span class="s1">range(len(names)</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">path</span><span class="s2">, </span><span class="s1">final_field</span><span class="s2">, </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">rest = self.names_to_path(</span>
                    <span class="s1">names[:pivot]</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">allow_many</span><span class="s2">, </span><span class="s1">fail_on_missing=</span><span class="s2">True,</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">FieldError </span><span class="s2">as </span><span class="s1">exc:</span>
                <span class="s2">if </span><span class="s1">pivot == </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s4"># The first item cannot be a lookup, so it's safe</span>
                    <span class="s4"># to raise the field error here.</span>
                    <span class="s2">raise</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">last_field_exception = exc</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># The transforms are the remaining items that couldn't be</span>
                <span class="s4"># resolved into fields.</span>
                <span class="s1">transforms = names[pivot:]</span>
                <span class="s2">break</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">transforms:</span>
            <span class="s2">def </span><span class="s1">transform(field</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">previous):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">wrapped = previous(field</span><span class="s2">, </span><span class="s1">alias)</span>
                    <span class="s2">return </span><span class="s1">self.try_transform(wrapped</span><span class="s2">, </span><span class="s1">name)</span>
                <span class="s2">except </span><span class="s1">FieldError:</span>
                    <span class="s4"># FieldError is raised if the transform doesn't exist.</span>
                    <span class="s2">if </span><span class="s1">isinstance(final_field</span><span class="s2">, </span><span class="s1">Field) </span><span class="s2">and </span><span class="s1">last_field_exception:</span>
                        <span class="s2">raise </span><span class="s1">last_field_exception</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">raise</span>
            <span class="s1">final_transformer = functools.partial(transform</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">previous=final_transformer)</span>
        <span class="s4"># Then, add the path to the query's joins. Note that we can't trim</span>
        <span class="s4"># joins at this stage - we will need the information about join type</span>
        <span class="s4"># of the trimmed joins.</span>
        <span class="s2">for </span><span class="s1">join </span><span class="s2">in </span><span class="s1">path:</span>
            <span class="s2">if </span><span class="s1">join.filtered_relation:</span>
                <span class="s1">filtered_relation = join.filtered_relation.clone()</span>
                <span class="s1">table_alias = filtered_relation.alias</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">filtered_relation = </span><span class="s2">None</span>
                <span class="s1">table_alias = </span><span class="s2">None</span>
            <span class="s1">opts = join.to_opts</span>
            <span class="s2">if </span><span class="s1">join.direct:</span>
                <span class="s1">nullable = self.is_nullable(join.join_field)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">nullable = </span><span class="s2">True</span>
            <span class="s1">connection = Join(</span>
                <span class="s1">opts.db_table</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">table_alias</span><span class="s2">, </span><span class="s1">INNER</span><span class="s2">, </span><span class="s1">join.join_field</span><span class="s2">,</span>
                <span class="s1">nullable</span><span class="s2">, </span><span class="s1">filtered_relation=filtered_relation</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">reuse = can_reuse </span><span class="s2">if </span><span class="s1">join.m2m </span><span class="s2">else None</span>
            <span class="s1">alias = self.join(connection</span><span class="s2">, </span><span class="s1">reuse=reuse)</span>
            <span class="s1">joins.append(alias)</span>
            <span class="s2">if </span><span class="s1">filtered_relation:</span>
                <span class="s1">filtered_relation.path = joins[:]</span>
        <span class="s2">return </span><span class="s1">JoinInfo(final_field</span><span class="s2">, </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">joins</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">final_transformer)</span>

    <span class="s2">def </span><span class="s1">trim_joins(self</span><span class="s2">, </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">joins</span><span class="s2">, </span><span class="s1">path):</span>
        <span class="s0">&quot;&quot;&quot; 
        The 'target' parameter is the final field being joined to, 'joins' 
        is the full list of join aliases. The 'path' contain the PathInfos 
        used to create the joins. 
 
        Return the final target field and table alias and the new active 
        joins. 
 
        Always trim any direct join if the target column is already in the 
        previous table. Can't trim reverse joins as it's unknown if there's 
        anything on the other side of the join. 
        &quot;&quot;&quot;</span>
        <span class="s1">joins = joins[:]</span>
        <span class="s2">for </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">info </span><span class="s2">in </span><span class="s1">enumerate(reversed(path)):</span>
            <span class="s2">if </span><span class="s1">len(joins) == </span><span class="s5">1 </span><span class="s2">or not </span><span class="s1">info.direct:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">info.filtered_relation:</span>
                <span class="s2">break</span>
            <span class="s1">join_targets = {t.column </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">info.join_field.foreign_related_fields}</span>
            <span class="s1">cur_targets = {t.column </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">targets}</span>
            <span class="s2">if not </span><span class="s1">cur_targets.issubset(join_targets):</span>
                <span class="s2">break</span>
            <span class="s1">targets_dict = {r[</span><span class="s5">1</span><span class="s1">].column: r[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">info.join_field.related_fields </span><span class="s2">if </span><span class="s1">r[</span><span class="s5">1</span><span class="s1">].column </span><span class="s2">in </span><span class="s1">cur_targets}</span>
            <span class="s1">targets = tuple(targets_dict[t.column] </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">targets)</span>
            <span class="s1">self.unref_alias(joins.pop())</span>
        <span class="s2">return </span><span class="s1">targets</span><span class="s2">, </span><span class="s1">joins[-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">joins</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_gen_cols(cls</span><span class="s2">, </span><span class="s1">exprs</span><span class="s2">, </span><span class="s1">include_external=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">exprs:</span>
            <span class="s2">if </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">Col):</span>
                <span class="s2">yield </span><span class="s1">expr</span>
            <span class="s2">elif </span><span class="s1">include_external </span><span class="s2">and </span><span class="s1">callable(getattr(expr</span><span class="s2">, </span><span class="s3">'get_external_cols'</span><span class="s2">, None</span><span class="s1">)):</span>
                <span class="s2">yield from </span><span class="s1">expr.get_external_cols()</span>
            <span class="s2">elif </span><span class="s1">hasattr(expr</span><span class="s2">, </span><span class="s3">'get_source_expressions'</span><span class="s1">):</span>
                <span class="s2">yield from </span><span class="s1">cls._gen_cols(</span>
                    <span class="s1">expr.get_source_expressions()</span><span class="s2">,</span>
                    <span class="s1">include_external=include_external</span><span class="s2">,</span>
                <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_gen_col_aliases(cls</span><span class="s2">, </span><span class="s1">exprs):</span>
        <span class="s2">yield from </span><span class="s1">(expr.alias </span><span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">cls._gen_cols(exprs))</span>

    <span class="s2">def </span><span class="s1">resolve_ref(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">allow_joins=</span><span class="s2">True, </span><span class="s1">reuse=</span><span class="s2">None, </span><span class="s1">summarize=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">annotation = self.annotations.get(name)</span>
        <span class="s2">if </span><span class="s1">annotation </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">allow_joins:</span>
                <span class="s2">for </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">self._gen_col_aliases([annotation]):</span>
                    <span class="s2">if </span><span class="s1">isinstance(self.alias_map[alias]</span><span class="s2">, </span><span class="s1">Join):</span>
                        <span class="s2">raise </span><span class="s1">FieldError(</span>
                            <span class="s3">'Joined field references are not permitted in '</span>
                            <span class="s3">'this query'</span>
                        <span class="s1">)</span>
            <span class="s2">if </span><span class="s1">summarize:</span>
                <span class="s4"># Summarize currently means we are doing an aggregate() query</span>
                <span class="s4"># which is executed as a wrapped subquery if any of the</span>
                <span class="s4"># aggregate() elements reference an existing annotation. In</span>
                <span class="s4"># that case we need to return a Ref to the subquery's annotation.</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">not in </span><span class="s1">self.annotation_select:</span>
                    <span class="s2">raise </span><span class="s1">FieldError(</span>
                        <span class="s3">&quot;Cannot aggregate over the '%s' alias. Use annotate() &quot;</span>
                        <span class="s3">&quot;to promote it.&quot; </span><span class="s1">% name</span>
                    <span class="s1">)</span>
                <span class="s2">return </span><span class="s1">Ref(name</span><span class="s2">, </span><span class="s1">self.annotation_select[name])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">annotation</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">field_list = name.split(LOOKUP_SEP)</span>
            <span class="s1">annotation = self.annotations.get(field_list[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">annotation </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">for </span><span class="s1">transform </span><span class="s2">in </span><span class="s1">field_list[</span><span class="s5">1</span><span class="s1">:]:</span>
                    <span class="s1">annotation = self.try_transform(annotation</span><span class="s2">, </span><span class="s1">transform)</span>
                <span class="s2">return </span><span class="s1">annotation</span>
            <span class="s1">join_info = self.setup_joins(field_list</span><span class="s2">, </span><span class="s1">self.get_meta()</span><span class="s2">, </span><span class="s1">self.get_initial_alias()</span><span class="s2">, </span><span class="s1">can_reuse=reuse)</span>
            <span class="s1">targets</span><span class="s2">, </span><span class="s1">final_alias</span><span class="s2">, </span><span class="s1">join_list = self.trim_joins(join_info.targets</span><span class="s2">, </span><span class="s1">join_info.joins</span><span class="s2">, </span><span class="s1">join_info.path)</span>
            <span class="s2">if not </span><span class="s1">allow_joins </span><span class="s2">and </span><span class="s1">len(join_list) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">'Joined field references are not permitted in this query'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">len(targets) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">&quot;Referencing multicolumn fields with F() objects &quot;</span>
                                 <span class="s3">&quot;isn't supported&quot;</span><span class="s1">)</span>
            <span class="s4"># Verify that the last lookup in name is a field or a transform:</span>
            <span class="s4"># transform_function() raises FieldError if not.</span>
            <span class="s1">transform = join_info.transform_function(targets[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">final_alias)</span>
            <span class="s2">if </span><span class="s1">reuse </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">reuse.update(join_list)</span>
            <span class="s2">return </span><span class="s1">transform</span>

    <span class="s2">def </span><span class="s1">split_exclude(self</span><span class="s2">, </span><span class="s1">filter_expr</span><span class="s2">, </span><span class="s1">can_reuse</span><span class="s2">, </span><span class="s1">names_with_path):</span>
        <span class="s0">&quot;&quot;&quot; 
        When doing an exclude against any kind of N-to-many relation, we need 
        to use a subquery. This method constructs the nested query, given the 
        original exclude filter (filter_expr) and the portion up to the first 
        N-to-many relation field. 
 
        For example, if the origin filter is ~Q(child__name='foo'), filter_expr 
        is ('child__name', 'foo') and can_reuse is a set of joins usable for 
        filters in the original query. 
 
        We will turn this into equivalent of: 
            WHERE NOT EXISTS( 
                SELECT 1 
                FROM child 
                WHERE name = 'foo' AND child.parent_id = parent.id 
                LIMIT 1 
            ) 
        &quot;&quot;&quot;</span>
        <span class="s4"># Generate the inner query.</span>
        <span class="s1">query = Query(self.model)</span>
        <span class="s1">query._filtered_relations = self._filtered_relations</span>
        <span class="s1">filter_lhs</span><span class="s2">, </span><span class="s1">filter_rhs = filter_expr</span>
        <span class="s2">if </span><span class="s1">isinstance(filter_rhs</span><span class="s2">, </span><span class="s1">OuterRef):</span>
            <span class="s1">filter_rhs = OuterRef(filter_rhs)</span>
        <span class="s2">elif </span><span class="s1">isinstance(filter_rhs</span><span class="s2">, </span><span class="s1">F):</span>
            <span class="s1">filter_rhs = OuterRef(filter_rhs.name)</span>
        <span class="s1">query.add_filter(filter_lhs</span><span class="s2">, </span><span class="s1">filter_rhs)</span>
        <span class="s1">query.clear_ordering(force=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s4"># Try to have as simple as possible subquery -&gt; trim leading joins from</span>
        <span class="s4"># the subquery.</span>
        <span class="s1">trimmed_prefix</span><span class="s2">, </span><span class="s1">contains_louter = query.trim_start(names_with_path)</span>

        <span class="s1">col = query.select[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">select_field = col.target</span>
        <span class="s1">alias = col.alias</span>
        <span class="s2">if </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">can_reuse:</span>
            <span class="s1">pk = select_field.model._meta.pk</span>
            <span class="s4"># Need to add a restriction so that outer query's filters are in effect for</span>
            <span class="s4"># the subquery, too.</span>
            <span class="s1">query.bump_prefix(self)</span>
            <span class="s1">lookup_class = select_field.get_lookup(</span><span class="s3">'exact'</span><span class="s1">)</span>
            <span class="s4"># Note that the query.select[0].alias is different from alias</span>
            <span class="s4"># due to bump_prefix above.</span>
            <span class="s1">lookup = lookup_class(pk.get_col(query.select[</span><span class="s5">0</span><span class="s1">].alias)</span><span class="s2">,</span>
                                  <span class="s1">pk.get_col(alias))</span>
            <span class="s1">query.where.add(lookup</span><span class="s2">, </span><span class="s1">AND)</span>
            <span class="s1">query.external_aliases[alias] = </span><span class="s2">True</span>

        <span class="s1">lookup_class = select_field.get_lookup(</span><span class="s3">'exact'</span><span class="s1">)</span>
        <span class="s1">lookup = lookup_class(col</span><span class="s2">, </span><span class="s1">ResolvedOuterRef(trimmed_prefix))</span>
        <span class="s1">query.where.add(lookup</span><span class="s2">, </span><span class="s1">AND)</span>
        <span class="s1">condition</span><span class="s2">, </span><span class="s1">needed_inner = self.build_filter(Exists(query))</span>

        <span class="s2">if </span><span class="s1">contains_louter:</span>
            <span class="s1">or_null_condition</span><span class="s2">, </span><span class="s1">_ = self.build_filter(</span>
                <span class="s1">(</span><span class="s3">'%s__isnull' </span><span class="s1">% trimmed_prefix</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">current_negated=</span><span class="s2">True, </span><span class="s1">branch_negated=</span><span class="s2">True, </span><span class="s1">can_reuse=can_reuse)</span>
            <span class="s1">condition.add(or_null_condition</span><span class="s2">, </span><span class="s1">OR)</span>
            <span class="s4"># Note that the end result will be:</span>
            <span class="s4"># (outercol NOT IN innerq AND outercol IS NOT NULL) OR outercol IS NULL.</span>
            <span class="s4"># This might look crazy but due to how IN works, this seems to be</span>
            <span class="s4"># correct. If the IS NOT NULL check is removed then outercol NOT</span>
            <span class="s4"># IN will return UNKNOWN. If the IS NULL check is removed, then if</span>
            <span class="s4"># outercol IS NULL we will not match the row.</span>
        <span class="s2">return </span><span class="s1">condition</span><span class="s2">, </span><span class="s1">needed_inner</span>

    <span class="s2">def </span><span class="s1">set_empty(self):</span>
        <span class="s1">self.where.add(NothingNode()</span><span class="s2">, </span><span class="s1">AND)</span>
        <span class="s2">for </span><span class="s1">query </span><span class="s2">in </span><span class="s1">self.combined_queries:</span>
            <span class="s1">query.set_empty()</span>

    <span class="s2">def </span><span class="s1">is_empty(self):</span>
        <span class="s2">return </span><span class="s1">any(isinstance(c</span><span class="s2">, </span><span class="s1">NothingNode) </span><span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">self.where.children)</span>

    <span class="s2">def </span><span class="s1">set_limits(self</span><span class="s2">, </span><span class="s1">low=</span><span class="s2">None, </span><span class="s1">high=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Adjust the limits on the rows retrieved. Use low/high to set these, 
        as it makes it more Pythonic to read and write. When the SQL query is 
        created, convert them to the appropriate offset and limit values. 
 
        Apply any limits passed in here to the existing constraints. Add low 
        to the current low value and clamp both to any existing high value. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">high </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.high_mark </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.high_mark = min(self.high_mark</span><span class="s2">, </span><span class="s1">self.low_mark + high)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.high_mark = self.low_mark + high</span>
        <span class="s2">if </span><span class="s1">low </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.high_mark </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.low_mark = min(self.high_mark</span><span class="s2">, </span><span class="s1">self.low_mark + low)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.low_mark = self.low_mark + low</span>

        <span class="s2">if </span><span class="s1">self.low_mark == self.high_mark:</span>
            <span class="s1">self.set_empty()</span>

    <span class="s2">def </span><span class="s1">clear_limits(self):</span>
        <span class="s0">&quot;&quot;&quot;Clear any existing limits.&quot;&quot;&quot;</span>
        <span class="s1">self.low_mark</span><span class="s2">, </span><span class="s1">self.high_mark = </span><span class="s5">0</span><span class="s2">, None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">is_sliced(self):</span>
        <span class="s2">return </span><span class="s1">self.low_mark != </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">self.high_mark </span><span class="s2">is not None</span>

    <span class="s2">def </span><span class="s1">has_limit_one(self):</span>
        <span class="s2">return </span><span class="s1">self.high_mark </span><span class="s2">is not None and </span><span class="s1">(self.high_mark - self.low_mark) == </span><span class="s5">1</span>

    <span class="s2">def </span><span class="s1">can_filter(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if adding filters to this instance is still possible. 
 
        Typically, this means no limits or offsets have been put on the results. 
        &quot;&quot;&quot;</span>
        <span class="s2">return not </span><span class="s1">self.is_sliced</span>

    <span class="s2">def </span><span class="s1">clear_select_clause(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove all fields from SELECT clause.&quot;&quot;&quot;</span>
        <span class="s1">self.select = ()</span>
        <span class="s1">self.default_cols = </span><span class="s2">False</span>
        <span class="s1">self.select_related = </span><span class="s2">False</span>
        <span class="s1">self.set_extra_mask(())</span>
        <span class="s1">self.set_annotation_mask(())</span>

    <span class="s2">def </span><span class="s1">clear_select_fields(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Clear the list of fields to select (but not extra_select columns). 
        Some queryset types completely replace any existing list of select 
        columns. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.select = ()</span>
        <span class="s1">self.values_select = ()</span>

    <span class="s2">def </span><span class="s1">add_select_col(self</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">self.select += col</span><span class="s2">,</span>
        <span class="s1">self.values_select += name</span><span class="s2">,</span>

    <span class="s2">def </span><span class="s1">set_select(self</span><span class="s2">, </span><span class="s1">cols):</span>
        <span class="s1">self.default_cols = </span><span class="s2">False</span>
        <span class="s1">self.select = tuple(cols)</span>

    <span class="s2">def </span><span class="s1">add_distinct_fields(self</span><span class="s2">, </span><span class="s1">*field_names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add and resolve the given fields to the query's &quot;distinct on&quot; clause. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.distinct_fields = field_names</span>
        <span class="s1">self.distinct = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">add_fields(self</span><span class="s2">, </span><span class="s1">field_names</span><span class="s2">, </span><span class="s1">allow_m2m=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add the given (model) fields to the select set. Add the field names in 
        the order specified. 
        &quot;&quot;&quot;</span>
        <span class="s1">alias = self.get_initial_alias()</span>
        <span class="s1">opts = self.get_meta()</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">cols = []</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">field_names:</span>
                <span class="s4"># Join promotion note - we must not remove any rows here, so</span>
                <span class="s4"># if there is no existing joins, use outer join.</span>
                <span class="s1">join_info = self.setup_joins(name.split(LOOKUP_SEP)</span><span class="s2">, </span><span class="s1">opts</span><span class="s2">, </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">allow_many=allow_m2m)</span>
                <span class="s1">targets</span><span class="s2">, </span><span class="s1">final_alias</span><span class="s2">, </span><span class="s1">joins = self.trim_joins(</span>
                    <span class="s1">join_info.targets</span><span class="s2">,</span>
                    <span class="s1">join_info.joins</span><span class="s2">,</span>
                    <span class="s1">join_info.path</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s2">for </span><span class="s1">target </span><span class="s2">in </span><span class="s1">targets:</span>
                    <span class="s1">cols.append(join_info.transform_function(target</span><span class="s2">, </span><span class="s1">final_alias))</span>
            <span class="s2">if </span><span class="s1">cols:</span>
                <span class="s1">self.set_select(cols)</span>
        <span class="s2">except </span><span class="s1">MultiJoin:</span>
            <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">&quot;Invalid field name: '%s'&quot; </span><span class="s1">% name)</span>
        <span class="s2">except </span><span class="s1">FieldError:</span>
            <span class="s2">if </span><span class="s1">LOOKUP_SEP </span><span class="s2">in </span><span class="s1">name:</span>
                <span class="s4"># For lookups spanning over relationships, show the error</span>
                <span class="s4"># from the model on which the lookup failed.</span>
                <span class="s2">raise</span>
            <span class="s2">elif </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.annotations:</span>
                <span class="s2">raise </span><span class="s1">FieldError(</span>
                    <span class="s3">&quot;Cannot select the '%s' alias. Use annotate() to promote &quot;</span>
                    <span class="s3">&quot;it.&quot; </span><span class="s1">% name</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">names = sorted([</span>
                    <span class="s1">*get_field_names_from_opts(opts)</span><span class="s2">, </span><span class="s1">*self.extra</span><span class="s2">,</span>
                    <span class="s1">*self.annotation_select</span><span class="s2">, </span><span class="s1">*self._filtered_relations</span>
                <span class="s1">])</span>
                <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">&quot;Cannot resolve keyword %r into field. &quot;</span>
                                 <span class="s3">&quot;Choices are: %s&quot; </span><span class="s1">% (name</span><span class="s2">, </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(names)))</span>

    <span class="s2">def </span><span class="s1">add_ordering(self</span><span class="s2">, </span><span class="s1">*ordering):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add items from the 'ordering' sequence to the query's &quot;order by&quot; 
        clause. These items are either field names (not column names) -- 
        possibly with a direction prefix ('-' or '?') -- or OrderBy 
        expressions. 
 
        If 'ordering' is empty, clear all ordering from the query. 
        &quot;&quot;&quot;</span>
        <span class="s1">errors = []</span>
        <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">ordering:</span>
            <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">if </span><span class="s1">item == </span><span class="s3">'?'</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">item.startswith(</span><span class="s3">'-'</span><span class="s1">):</span>
                    <span class="s1">item = item[</span><span class="s5">1</span><span class="s1">:]</span>
                <span class="s2">if </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self.annotations:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">self.extra </span><span class="s2">and </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self.extra:</span>
                    <span class="s2">continue</span>
                <span class="s4"># names_to_path() validates the lookup. A descriptive</span>
                <span class="s4"># FieldError will be raise if it's not.</span>
                <span class="s1">self.names_to_path(item.split(LOOKUP_SEP)</span><span class="s2">, </span><span class="s1">self.model._meta)</span>
            <span class="s2">elif not </span><span class="s1">hasattr(item</span><span class="s2">, </span><span class="s3">'resolve_expression'</span><span class="s1">):</span>
                <span class="s1">errors.append(item)</span>
            <span class="s2">if </span><span class="s1">getattr(item</span><span class="s2">, </span><span class="s3">'contains_aggregate'</span><span class="s2">, False</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">FieldError(</span>
                    <span class="s3">'Using an aggregate in order_by() without also including '</span>
                    <span class="s3">'it in annotate() is not allowed: %s' </span><span class="s1">% item</span>
                <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">errors:</span>
            <span class="s2">raise </span><span class="s1">FieldError(</span><span class="s3">'Invalid order_by arguments: %s' </span><span class="s1">% errors)</span>
        <span class="s2">if </span><span class="s1">ordering:</span>
            <span class="s1">self.order_by += ordering</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.default_ordering = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">clear_ordering(self</span><span class="s2">, </span><span class="s1">force=</span><span class="s2">False, </span><span class="s1">clear_default=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove any ordering settings if the current query allows it without 
        side effects, set 'force' to True to clear the ordering regardless. 
        If 'clear_default' is True, there will be no ordering in the resulting 
        query (not even the model's default). 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">force </span><span class="s2">and </span><span class="s1">(self.is_sliced </span><span class="s2">or </span><span class="s1">self.distinct_fields </span><span class="s2">or </span><span class="s1">self.select_for_update):</span>
            <span class="s2">return</span>
        <span class="s1">self.order_by = ()</span>
        <span class="s1">self.extra_order_by = ()</span>
        <span class="s2">if </span><span class="s1">clear_default:</span>
            <span class="s1">self.default_ordering = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">set_group_by(self</span><span class="s2">, </span><span class="s1">allow_aliases=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Expand the GROUP BY clause required by the query. 
 
        This will usually be the set of all non-aggregate fields in the 
        return data. If the database backend supports grouping by the 
        primary key, and the query would be equivalent, the optimization 
        will be made automatically. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Column names from JOINs to check collisions with aliases.</span>
        <span class="s2">if </span><span class="s1">allow_aliases:</span>
            <span class="s1">column_names = set()</span>
            <span class="s1">seen_models = set()</span>
            <span class="s2">for </span><span class="s1">join </span><span class="s2">in </span><span class="s1">list(self.alias_map.values())[</span><span class="s5">1</span><span class="s1">:]:  </span><span class="s4"># Skip base table.</span>
                <span class="s1">model = join.join_field.related_model</span>
                <span class="s2">if </span><span class="s1">model </span><span class="s2">not in </span><span class="s1">seen_models:</span>
                    <span class="s1">column_names.update({</span>
                        <span class="s1">field.column</span>
                        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">model._meta.local_concrete_fields</span>
                    <span class="s1">})</span>
                    <span class="s1">seen_models.add(model)</span>

        <span class="s1">group_by = list(self.select)</span>
        <span class="s2">if </span><span class="s1">self.annotation_select:</span>
            <span class="s2">for </span><span class="s1">alias</span><span class="s2">, </span><span class="s1">annotation </span><span class="s2">in </span><span class="s1">self.annotation_select.items():</span>
                <span class="s2">if not </span><span class="s1">allow_aliases </span><span class="s2">or </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">column_names:</span>
                    <span class="s1">alias = </span><span class="s2">None</span>
                <span class="s1">group_by_cols = annotation.get_group_by_cols(alias=alias)</span>
                <span class="s1">group_by.extend(group_by_cols)</span>
        <span class="s1">self.group_by = tuple(group_by)</span>

    <span class="s2">def </span><span class="s1">add_select_related(self</span><span class="s2">, </span><span class="s1">fields):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set up the select_related data structure so that we only select 
        certain related models (as opposed to all models, when 
        self.select_related=True). 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self.select_related</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s1">field_dict = {}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">field_dict = self.select_related</span>
        <span class="s2">for </span><span class="s1">field </span><span class="s2">in </span><span class="s1">fields:</span>
            <span class="s1">d = field_dict</span>
            <span class="s2">for </span><span class="s1">part </span><span class="s2">in </span><span class="s1">field.split(LOOKUP_SEP):</span>
                <span class="s1">d = d.setdefault(part</span><span class="s2">, </span><span class="s1">{})</span>
        <span class="s1">self.select_related = field_dict</span>

    <span class="s2">def </span><span class="s1">add_extra(self</span><span class="s2">, </span><span class="s1">select</span><span class="s2">, </span><span class="s1">select_params</span><span class="s2">, </span><span class="s1">where</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">tables</span><span class="s2">, </span><span class="s1">order_by):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add data to the various extra_* attributes for user-created additions 
        to the query. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">select:</span>
            <span class="s4"># We need to pair any placeholder markers in the 'select'</span>
            <span class="s4"># dictionary with their parameters in 'select_params' so that</span>
            <span class="s4"># subsequent updates to the select dictionary also adjust the</span>
            <span class="s4"># parameters appropriately.</span>
            <span class="s1">select_pairs = {}</span>
            <span class="s2">if </span><span class="s1">select_params:</span>
                <span class="s1">param_iter = iter(select_params)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">param_iter = iter([])</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">select.items():</span>
                <span class="s1">entry = str(entry)</span>
                <span class="s1">entry_params = []</span>
                <span class="s1">pos = entry.find(</span><span class="s3">&quot;%s&quot;</span><span class="s1">)</span>
                <span class="s2">while </span><span class="s1">pos != -</span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">pos == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">entry[pos - </span><span class="s5">1</span><span class="s1">] != </span><span class="s3">'%'</span><span class="s1">:</span>
                        <span class="s1">entry_params.append(next(param_iter))</span>
                    <span class="s1">pos = entry.find(</span><span class="s3">&quot;%s&quot;</span><span class="s2">, </span><span class="s1">pos + </span><span class="s5">2</span><span class="s1">)</span>
                <span class="s1">select_pairs[name] = (entry</span><span class="s2">, </span><span class="s1">entry_params)</span>
            <span class="s1">self.extra.update(select_pairs)</span>
        <span class="s2">if </span><span class="s1">where </span><span class="s2">or </span><span class="s1">params:</span>
            <span class="s1">self.where.add(ExtraWhere(where</span><span class="s2">, </span><span class="s1">params)</span><span class="s2">, </span><span class="s1">AND)</span>
        <span class="s2">if </span><span class="s1">tables:</span>
            <span class="s1">self.extra_tables += tuple(tables)</span>
        <span class="s2">if </span><span class="s1">order_by:</span>
            <span class="s1">self.extra_order_by = order_by</span>

    <span class="s2">def </span><span class="s1">clear_deferred_loading(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove any fields from the deferred loading set.&quot;&quot;&quot;</span>
        <span class="s1">self.deferred_loading = (frozenset()</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">add_deferred_loading(self</span><span class="s2">, </span><span class="s1">field_names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add the given list of model field names to the set of fields to 
        exclude from loading from the database when automatic column selection 
        is done. Add the new field names to any existing field names that 
        are deferred (or removed from any existing field names that are marked 
        as the only ones for immediate loading). 
        &quot;&quot;&quot;</span>
        <span class="s4"># Fields on related models are stored in the literal double-underscore</span>
        <span class="s4"># format, so that we can use a set datastructure. We do the foo__bar</span>
        <span class="s4"># splitting and handling when computing the SQL column names (as part of</span>
        <span class="s4"># get_columns()).</span>
        <span class="s1">existing</span><span class="s2">, </span><span class="s1">defer = self.deferred_loading</span>
        <span class="s2">if </span><span class="s1">defer:</span>
            <span class="s4"># Add to existing deferred names.</span>
            <span class="s1">self.deferred_loading = existing.union(field_names)</span><span class="s2">, True</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Remove names from the set of any existing &quot;immediate load&quot; names.</span>
            <span class="s2">if </span><span class="s1">new_existing := existing.difference(field_names):</span>
                <span class="s1">self.deferred_loading = new_existing</span><span class="s2">, False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.clear_deferred_loading()</span>
                <span class="s2">if </span><span class="s1">new_only := set(field_names).difference(existing):</span>
                    <span class="s1">self.deferred_loading = new_only</span><span class="s2">, True</span>

    <span class="s2">def </span><span class="s1">add_immediate_loading(self</span><span class="s2">, </span><span class="s1">field_names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add the given list of model field names to the set of fields to 
        retrieve when the SQL is executed (&quot;immediate loading&quot; fields). The 
        field names replace any existing immediate loading field names. If 
        there are field names already specified for deferred loading, remove 
        those names from the new field_names before storing the new names 
        for immediate loading. (That is, immediate loading overrides any 
        existing immediate values, but respects existing deferrals.) 
        &quot;&quot;&quot;</span>
        <span class="s1">existing</span><span class="s2">, </span><span class="s1">defer = self.deferred_loading</span>
        <span class="s1">field_names = set(field_names)</span>
        <span class="s2">if </span><span class="s3">'pk' </span><span class="s2">in </span><span class="s1">field_names:</span>
            <span class="s1">field_names.remove(</span><span class="s3">'pk'</span><span class="s1">)</span>
            <span class="s1">field_names.add(self.get_meta().pk.name)</span>

        <span class="s2">if </span><span class="s1">defer:</span>
            <span class="s4"># Remove any existing deferred names from the current set before</span>
            <span class="s4"># setting the new names.</span>
            <span class="s1">self.deferred_loading = field_names.difference(existing)</span><span class="s2">, False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Replace any existing &quot;immediate load&quot; field names.</span>
            <span class="s1">self.deferred_loading = frozenset(field_names)</span><span class="s2">, False</span>

    <span class="s2">def </span><span class="s1">get_loaded_field_names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        If any fields are marked to be deferred, return a dictionary mapping 
        models to a set of names in those fields that will be loaded. If a 
        model is not in the returned dictionary, none of its fields are 
        deferred. 
 
        If no fields are marked for deferral, return an empty dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s4"># We cache this because we call this function multiple times</span>
        <span class="s4"># (compiler.fill_related_selections, query.iterator)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._loaded_field_names_cache</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s1">collection = {}</span>
            <span class="s1">self.deferred_to_data(collection</span><span class="s2">, </span><span class="s1">self.get_loaded_field_names_cb)</span>
            <span class="s1">self._loaded_field_names_cache = collection</span>
            <span class="s2">return </span><span class="s1">collection</span>

    <span class="s2">def </span><span class="s1">get_loaded_field_names_cb(self</span><span class="s2">, </span><span class="s1">target</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">fields):</span>
        <span class="s0">&quot;&quot;&quot;Callback used by get_deferred_field_names().&quot;&quot;&quot;</span>
        <span class="s1">target[model] = {f.attname </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fields}</span>

    <span class="s2">def </span><span class="s1">set_annotation_mask(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0">&quot;&quot;&quot;Set the mask of annotations that will be returned by the SELECT.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">names </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.annotation_select_mask = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.annotation_select_mask = set(names)</span>
        <span class="s1">self._annotation_select_cache = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">append_annotation_mask(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s2">if </span><span class="s1">self.annotation_select_mask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.set_annotation_mask(self.annotation_select_mask.union(names))</span>

    <span class="s2">def </span><span class="s1">set_extra_mask(self</span><span class="s2">, </span><span class="s1">names):</span>
        <span class="s0">&quot;&quot;&quot; 
        Set the mask of extra select items that will be returned by SELECT. 
        Don't remove them from the Query since they might be used later. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">names </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.extra_select_mask = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.extra_select_mask = set(names)</span>
        <span class="s1">self._extra_select_cache = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">set_values(self</span><span class="s2">, </span><span class="s1">fields):</span>
        <span class="s1">self.select_related = </span><span class="s2">False</span>
        <span class="s1">self.clear_deferred_loading()</span>
        <span class="s1">self.clear_select_fields()</span>

        <span class="s2">if </span><span class="s1">fields:</span>
            <span class="s1">field_names = []</span>
            <span class="s1">extra_names = []</span>
            <span class="s1">annotation_names = []</span>
            <span class="s2">if not </span><span class="s1">self.extra </span><span class="s2">and not </span><span class="s1">self.annotations:</span>
                <span class="s4"># Shortcut - if there are no extra or annotations, then</span>
                <span class="s4"># the values() clause must be just field names.</span>
                <span class="s1">field_names = list(fields)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.default_cols = </span><span class="s2">False</span>
                <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">fields:</span>
                    <span class="s2">if </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.extra_select:</span>
                        <span class="s1">extra_names.append(f)</span>
                    <span class="s2">elif </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.annotation_select:</span>
                        <span class="s1">annotation_names.append(f)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">field_names.append(f)</span>
            <span class="s1">self.set_extra_mask(extra_names)</span>
            <span class="s1">self.set_annotation_mask(annotation_names)</span>
            <span class="s1">selected = frozenset(field_names + extra_names + annotation_names)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">field_names = [f.attname </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.model._meta.concrete_fields]</span>
            <span class="s1">selected = frozenset(field_names)</span>
        <span class="s4"># Selected annotations must be known before setting the GROUP BY</span>
        <span class="s4"># clause.</span>
        <span class="s2">if </span><span class="s1">self.group_by </span><span class="s2">is True</span><span class="s1">:</span>
            <span class="s1">self.add_fields((f.attname </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">self.model._meta.concrete_fields)</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s4"># Disable GROUP BY aliases to avoid orphaning references to the</span>
            <span class="s4"># SELECT clause which is about to be cleared.</span>
            <span class="s1">self.set_group_by(allow_aliases=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">self.clear_select_fields()</span>
        <span class="s2">elif </span><span class="s1">self.group_by:</span>
            <span class="s4"># Resolve GROUP BY annotation references if they are not part of</span>
            <span class="s4"># the selected fields anymore.</span>
            <span class="s1">group_by = []</span>
            <span class="s2">for </span><span class="s1">expr </span><span class="s2">in </span><span class="s1">self.group_by:</span>
                <span class="s2">if </span><span class="s1">isinstance(expr</span><span class="s2">, </span><span class="s1">Ref) </span><span class="s2">and </span><span class="s1">expr.refs </span><span class="s2">not in </span><span class="s1">selected:</span>
                    <span class="s1">expr = self.annotations[expr.refs]</span>
                <span class="s1">group_by.append(expr)</span>
            <span class="s1">self.group_by = tuple(group_by)</span>

        <span class="s1">self.values_select = tuple(field_names)</span>
        <span class="s1">self.add_fields(field_names</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">annotation_select(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the dictionary of aggregate columns that are not masked and 
        should be used in the SELECT clause. Cache this result for performance. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._annotation_select_cache </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._annotation_select_cache</span>
        <span class="s2">elif not </span><span class="s1">self.annotations:</span>
            <span class="s2">return </span><span class="s1">{}</span>
        <span class="s2">elif </span><span class="s1">self.annotation_select_mask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._annotation_select_cache = {</span>
                <span class="s1">k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.annotations.items()</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.annotation_select_mask</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">self._annotation_select_cache</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.annotations</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">extra_select(self):</span>
        <span class="s2">if </span><span class="s1">self._extra_select_cache </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._extra_select_cache</span>
        <span class="s2">if not </span><span class="s1">self.extra:</span>
            <span class="s2">return </span><span class="s1">{}</span>
        <span class="s2">elif </span><span class="s1">self.extra_select_mask </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._extra_select_cache = {</span>
                <span class="s1">k: v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self.extra.items()</span>
                <span class="s2">if </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self.extra_select_mask</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">self._extra_select_cache</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.extra</span>

    <span class="s2">def </span><span class="s1">trim_start(self</span><span class="s2">, </span><span class="s1">names_with_path):</span>
        <span class="s0">&quot;&quot;&quot; 
        Trim joins from the start of the join path. The candidates for trim 
        are the PathInfos in names_with_path structure that are m2m joins. 
 
        Also set the select column so the start matches the join. 
 
        This method is meant to be used for generating the subquery joins &amp; 
        cols in split_exclude(). 
 
        Return a lookup usable for doing outerq.filter(lookup=self) and a 
        boolean indicating if the joins in the prefix contain a LEFT OUTER join. 
        _&quot;&quot;&quot;</span>
        <span class="s1">all_paths = []</span>
        <span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">paths </span><span class="s2">in </span><span class="s1">names_with_path:</span>
            <span class="s1">all_paths.extend(paths)</span>
        <span class="s1">contains_louter = </span><span class="s2">False</span>
        <span class="s4"># Trim and operate only on tables that were generated for</span>
        <span class="s4"># the lookup part of the query. That is, avoid trimming</span>
        <span class="s4"># joins generated for F() expressions.</span>
        <span class="s1">lookup_tables = [</span>
            <span class="s1">t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self.alias_map</span>
            <span class="s2">if </span><span class="s1">t </span><span class="s2">in </span><span class="s1">self._lookup_joins </span><span class="s2">or </span><span class="s1">t == self.base_table</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">trimmed_paths</span><span class="s2">, </span><span class="s1">path </span><span class="s2">in </span><span class="s1">enumerate(all_paths):</span>
            <span class="s2">if </span><span class="s1">path.m2m:</span>
                <span class="s2">break</span>
            <span class="s2">if </span><span class="s1">self.alias_map[lookup_tables[trimmed_paths + </span><span class="s5">1</span><span class="s1">]].join_type == LOUTER:</span>
                <span class="s1">contains_louter = </span><span class="s2">True</span>
            <span class="s1">alias = lookup_tables[trimmed_paths]</span>
            <span class="s1">self.unref_alias(alias)</span>
        <span class="s4"># The path.join_field is a Rel, lets get the other side's field</span>
        <span class="s1">join_field = path.join_field.field</span>
        <span class="s4"># Build the filter prefix.</span>
        <span class="s1">paths_in_prefix = trimmed_paths</span>
        <span class="s1">trimmed_prefix = []</span>
        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">path </span><span class="s2">in </span><span class="s1">names_with_path:</span>
            <span class="s2">if </span><span class="s1">paths_in_prefix - len(path) &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">break</span>
            <span class="s1">trimmed_prefix.append(name)</span>
            <span class="s1">paths_in_prefix -= len(path)</span>
        <span class="s1">trimmed_prefix.append(</span>
            <span class="s1">join_field.foreign_related_fields[</span><span class="s5">0</span><span class="s1">].name)</span>
        <span class="s1">trimmed_prefix = LOOKUP_SEP.join(trimmed_prefix)</span>
        <span class="s4"># Lets still see if we can trim the first join from the inner query</span>
        <span class="s4"># (that is, self). We can't do this for:</span>
        <span class="s4"># - LEFT JOINs because we would miss those rows that have nothing on</span>
        <span class="s4">#   the outer side,</span>
        <span class="s4"># - INNER JOINs from filtered relations because we would miss their</span>
        <span class="s4">#   filters.</span>
        <span class="s1">first_join = self.alias_map[lookup_tables[trimmed_paths + </span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s2">if </span><span class="s1">first_join.join_type != LOUTER </span><span class="s2">and not </span><span class="s1">first_join.filtered_relation:</span>
            <span class="s1">select_fields = [r[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">join_field.related_fields]</span>
            <span class="s1">select_alias = lookup_tables[trimmed_paths + </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">self.unref_alias(lookup_tables[trimmed_paths])</span>
            <span class="s1">extra_restriction = join_field.get_extra_restriction(</span><span class="s2">None, </span><span class="s1">lookup_tables[trimmed_paths + </span><span class="s5">1</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">extra_restriction:</span>
                <span class="s1">self.where.add(extra_restriction</span><span class="s2">, </span><span class="s1">AND)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># TODO: It might be possible to trim more joins from the start of the</span>
            <span class="s4"># inner query if it happens to have a longer join chain containing the</span>
            <span class="s4"># values in select_fields. Lets punt this one for now.</span>
            <span class="s1">select_fields = [r[</span><span class="s5">1</span><span class="s1">] </span><span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">join_field.related_fields]</span>
            <span class="s1">select_alias = lookup_tables[trimmed_paths]</span>
        <span class="s4"># The found starting point is likely a Join instead of a BaseTable reference.</span>
        <span class="s4"># But the first entry in the query's FROM clause must not be a JOIN.</span>
        <span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">self.alias_map:</span>
            <span class="s2">if </span><span class="s1">self.alias_refcount[table] &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">self.alias_map[table] = BaseTable(self.alias_map[table].table_name</span><span class="s2">, </span><span class="s1">table)</span>
                <span class="s2">break</span>
        <span class="s1">self.set_select([f.get_col(select_alias) </span><span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">select_fields])</span>
        <span class="s2">return </span><span class="s1">trimmed_prefix</span><span class="s2">, </span><span class="s1">contains_louter</span>

    <span class="s2">def </span><span class="s1">is_nullable(self</span><span class="s2">, </span><span class="s1">field):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check if the given field should be treated as nullable. 
 
        Some backends treat '' as null and Django treats such fields as 
        nullable for those backends. In such situations field.null can be 
        False even if we should treat the field as nullable. 
        &quot;&quot;&quot;</span>
        <span class="s4"># We need to use DEFAULT_DB_ALIAS here, as QuerySet does not have</span>
        <span class="s4"># (nor should it have) knowledge of which connection is going to be</span>
        <span class="s4"># used. The proper fix would be to defer all decisions where</span>
        <span class="s4"># is_nullable() is needed to the compiler stage, but that is not easy</span>
        <span class="s4"># to do currently.</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls </span><span class="s2">and</span>
            <span class="s1">field.empty_strings_allowed</span>
        <span class="s1">) </span><span class="s2">or </span><span class="s1">field.null</span>


<span class="s2">def </span><span class="s1">get_order_dir(field</span><span class="s2">, </span><span class="s1">default=</span><span class="s3">'ASC'</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the field name and direction for an order specification. For 
    example, '-foo' is returned as ('foo', 'DESC'). 
 
    The 'default' param is used to indicate which way no prefix (or a '+' 
    prefix) should sort. The '-' prefix always sorts the opposite way. 
    &quot;&quot;&quot;</span>
    <span class="s1">dirn = ORDER_DIR[default]</span>
    <span class="s2">if </span><span class="s1">field[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'-'</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">field[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">dirn[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">field</span><span class="s2">, </span><span class="s1">dirn[</span><span class="s5">0</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">add_to_dict(data</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value):</span>
    <span class="s0">&quot;&quot;&quot; 
    Add &quot;value&quot; to the set of values for &quot;key&quot;, whether or not &quot;key&quot; already 
    exists. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">key </span><span class="s2">in </span><span class="s1">data:</span>
        <span class="s1">data[key].add(value)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">data[key] = {value}</span>


<span class="s2">def </span><span class="s1">is_reverse_o2o(field):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check if the given field is reverse-o2o. The field is expected to be some 
    sort of relation field or related object. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">field.is_relation </span><span class="s2">and </span><span class="s1">field.one_to_one </span><span class="s2">and not </span><span class="s1">field.concrete</span>


<span class="s2">class </span><span class="s1">JoinPromoter:</span>
    <span class="s0">&quot;&quot;&quot; 
    A class to abstract away join promotion problems for complex filter 
    conditions. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">connector</span><span class="s2">, </span><span class="s1">num_children</span><span class="s2">, </span><span class="s1">negated):</span>
        <span class="s1">self.connector = connector</span>
        <span class="s1">self.negated = negated</span>
        <span class="s2">if </span><span class="s1">self.negated:</span>
            <span class="s2">if </span><span class="s1">connector == AND:</span>
                <span class="s1">self.effective_connector = OR</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.effective_connector = AND</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.effective_connector = self.connector</span>
        <span class="s1">self.num_children = num_children</span>
        <span class="s4"># Maps of table alias to how many times it is seen as required for</span>
        <span class="s4"># inner and/or outer joins.</span>
        <span class="s1">self.votes = Counter()</span>

    <span class="s2">def </span><span class="s1">add_votes(self</span><span class="s2">, </span><span class="s1">votes):</span>
        <span class="s0">&quot;&quot;&quot; 
        Add single vote per item to self.votes. Parameter can be any 
        iterable. 
        &quot;&quot;&quot;</span>
        <span class="s1">self.votes.update(votes)</span>

    <span class="s2">def </span><span class="s1">update_join_types(self</span><span class="s2">, </span><span class="s1">query):</span>
        <span class="s0">&quot;&quot;&quot; 
        Change join types so that the generated query is as efficient as 
        possible, but still correct. So, change as many joins as possible 
        to INNER, but don't make OUTER joins INNER if that could remove 
        results from the query. 
        &quot;&quot;&quot;</span>
        <span class="s1">to_promote = set()</span>
        <span class="s1">to_demote = set()</span>
        <span class="s4"># The effective_connector is used so that NOT (a AND b) is treated</span>
        <span class="s4"># similarly to (a OR b) for join promotion.</span>
        <span class="s2">for </span><span class="s1">table</span><span class="s2">, </span><span class="s1">votes </span><span class="s2">in </span><span class="s1">self.votes.items():</span>
            <span class="s4"># We must use outer joins in OR case when the join isn't contained</span>
            <span class="s4"># in all of the joins. Otherwise the INNER JOIN itself could remove</span>
            <span class="s4"># valid results. Consider the case where a model with rel_a and</span>
            <span class="s4"># rel_b relations is queried with rel_a__col=1 | rel_b__col=2. Now,</span>
            <span class="s4"># if rel_a join doesn't produce any results is null (for example</span>
            <span class="s4"># reverse foreign key or null value in direct foreign key), and</span>
            <span class="s4"># there is a matching row in rel_b with col=2, then an INNER join</span>
            <span class="s4"># to rel_a would remove a valid match from the query. So, we need</span>
            <span class="s4"># to promote any existing INNER to LOUTER (it is possible this</span>
            <span class="s4"># promotion in turn will be demoted later on).</span>
            <span class="s2">if </span><span class="s1">self.effective_connector == </span><span class="s3">'OR' </span><span class="s2">and </span><span class="s1">votes &lt; self.num_children:</span>
                <span class="s1">to_promote.add(table)</span>
            <span class="s4"># If connector is AND and there is a filter that can match only</span>
            <span class="s4"># when there is a joinable row, then use INNER. For example, in</span>
            <span class="s4"># rel_a__col=1 &amp; rel_b__col=2, if either of the rels produce NULL</span>
            <span class="s4"># as join output, then the col=1 or col=2 can't match (as</span>
            <span class="s4"># NULL=anything is always false).</span>
            <span class="s4"># For the OR case, if all children voted for a join to be inner,</span>
            <span class="s4"># then we can use INNER for the join. For example:</span>
            <span class="s4">#     (rel_a__col__icontains=Alex | rel_a__col__icontains=Russell)</span>
            <span class="s4"># then if rel_a doesn't produce any rows, the whole condition</span>
            <span class="s4"># can't match. Hence we can safely use INNER join.</span>
            <span class="s2">if </span><span class="s1">self.effective_connector == </span><span class="s3">'AND' </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">self.effective_connector == </span><span class="s3">'OR' </span><span class="s2">and </span><span class="s1">votes == self.num_children):</span>
                <span class="s1">to_demote.add(table)</span>
            <span class="s4"># Finally, what happens in cases where we have:</span>
            <span class="s4">#    (rel_a__col=1|rel_b__col=2) &amp; rel_a__col__gte=0</span>
            <span class="s4"># Now, we first generate the OR clause, and promote joins for it</span>
            <span class="s4"># in the first if branch above. Both rel_a and rel_b are promoted</span>
            <span class="s4"># to LOUTER joins. After that we do the AND case. The OR case</span>
            <span class="s4"># voted no inner joins but the rel_a__col__gte=0 votes inner join</span>
            <span class="s4"># for rel_a. We demote it back to INNER join (in AND case a single</span>
            <span class="s4"># vote is enough). The demotion is OK, if rel_a doesn't produce</span>
            <span class="s4"># rows, then the rel_a__col__gte=0 clause can't be true, and thus</span>
            <span class="s4"># the whole clause must be false. So, it is safe to use INNER</span>
            <span class="s4"># join.</span>
            <span class="s4"># Note that in this example we could just as well have the __gte</span>
            <span class="s4"># clause and the OR clause swapped. Or we could replace the __gte</span>
            <span class="s4"># clause with an OR clause containing rel_a__col=1|rel_a__col=2,</span>
            <span class="s4"># and again we could safely demote to INNER.</span>
        <span class="s1">query.promote_joins(to_promote)</span>
        <span class="s1">query.demote_joins(to_demote)</span>
        <span class="s2">return </span><span class="s1">to_demote</span>
</pre>
</body>
</html>