<html>
<head>
<title>debugger.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
debugger.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: Debugger</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">runtime</span>


<span class="s2">class </span><span class="s1">BreakpointId(str):</span>
    <span class="s3">''' 
    Breakpoint identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; BreakpointId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'BreakpointId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">CallFrameId(str):</span>
    <span class="s3">''' 
    Call frame identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; CallFrameId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'CallFrameId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Location:</span>
    <span class="s3">''' 
    Location in the source code. 
    '''</span>
    <span class="s0">#: Script identifier as reported in the ``Debugger.scriptParsed``.</span>
    <span class="s1">script_id: runtime.ScriptId</span>

    <span class="s0">#: Line number in the script (0-based).</span>
    <span class="s1">line_number: int</span>

    <span class="s0">#: Column number in the script (0-based).</span>
    <span class="s1">column_number: typing.Optional[int] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'scriptId'</span><span class="s1">] = self.script_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'lineNumber'</span><span class="s1">] = self.line_number</span>
        <span class="s2">if </span><span class="s1">self.column_number </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'columnNumber'</span><span class="s1">] = self.column_number</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">script_id=runtime.ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">line_number=int(json[</span><span class="s4">'lineNumber'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">column_number=int(json[</span><span class="s4">'columnNumber'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'columnNumber' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ScriptPosition:</span>
    <span class="s3">''' 
    Location in the source code. 
    '''</span>
    <span class="s1">line_number: int</span>

    <span class="s1">column_number: int</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'lineNumber'</span><span class="s1">] = self.line_number</span>
        <span class="s1">json[</span><span class="s4">'columnNumber'</span><span class="s1">] = self.column_number</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">line_number=int(json[</span><span class="s4">'lineNumber'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">column_number=int(json[</span><span class="s4">'columnNumber'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">LocationRange:</span>
    <span class="s3">''' 
    Location range within one script. 
    '''</span>
    <span class="s1">script_id: runtime.ScriptId</span>

    <span class="s1">start: ScriptPosition</span>

    <span class="s1">end: ScriptPosition</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'scriptId'</span><span class="s1">] = self.script_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'start'</span><span class="s1">] = self.start.to_json()</span>
        <span class="s1">json[</span><span class="s4">'end'</span><span class="s1">] = self.end.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">script_id=runtime.ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">start=ScriptPosition.from_json(json[</span><span class="s4">'start'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">end=ScriptPosition.from_json(json[</span><span class="s4">'end'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CallFrame:</span>
    <span class="s3">''' 
    JavaScript call frame. Array of call frames form the call stack. 
    '''</span>
    <span class="s0">#: Call frame identifier. This identifier is only valid while the virtual machine is paused.</span>
    <span class="s1">call_frame_id: CallFrameId</span>

    <span class="s0">#: Name of the JavaScript function called on this call frame.</span>
    <span class="s1">function_name: str</span>

    <span class="s0">#: Location in the source code.</span>
    <span class="s1">location: Location</span>

    <span class="s0">#: JavaScript script name or url.</span>
    <span class="s1">url: str</span>

    <span class="s0">#: Scope chain for this call frame.</span>
    <span class="s1">scope_chain: typing.List[Scope]</span>

    <span class="s0">#: ``this`` object for this call frame.</span>
    <span class="s1">this: runtime.RemoteObject</span>

    <span class="s0">#: Location in the source code.</span>
    <span class="s1">function_location: typing.Optional[Location] = </span><span class="s2">None</span>

    <span class="s0">#: The value being returned, if the function is at return point.</span>
    <span class="s1">return_value: typing.Optional[runtime.RemoteObject] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'callFrameId'</span><span class="s1">] = self.call_frame_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'functionName'</span><span class="s1">] = self.function_name</span>
        <span class="s1">json[</span><span class="s4">'location'</span><span class="s1">] = self.location.to_json()</span>
        <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s1">json[</span><span class="s4">'scopeChain'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.scope_chain]</span>
        <span class="s1">json[</span><span class="s4">'this'</span><span class="s1">] = self.this.to_json()</span>
        <span class="s2">if </span><span class="s1">self.function_location </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'functionLocation'</span><span class="s1">] = self.function_location.to_json()</span>
        <span class="s2">if </span><span class="s1">self.return_value </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'returnValue'</span><span class="s1">] = self.return_value.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">call_frame_id=CallFrameId.from_json(json[</span><span class="s4">'callFrameId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">function_name=str(json[</span><span class="s4">'functionName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">location=Location.from_json(json[</span><span class="s4">'location'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">scope_chain=[Scope.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'scopeChain'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">this=runtime.RemoteObject.from_json(json[</span><span class="s4">'this'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">function_location=Location.from_json(json[</span><span class="s4">'functionLocation'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'functionLocation' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">return_value=runtime.RemoteObject.from_json(json[</span><span class="s4">'returnValue'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'returnValue' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Scope:</span>
    <span class="s3">''' 
    Scope description. 
    '''</span>
    <span class="s0">#: Scope type.</span>
    <span class="s1">type_: str</span>

    <span class="s0">#: Object representing the scope. For ``global`` and ``with`` scopes it represents the actual</span>
    <span class="s0">#: object; for the rest of the scopes, it is artificial transient object enumerating scope</span>
    <span class="s0">#: variables as its properties.</span>
    <span class="s1">object_: runtime.RemoteObject</span>

    <span class="s1">name: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Location in the source code where scope starts</span>
    <span class="s1">start_location: typing.Optional[Location] = </span><span class="s2">None</span>

    <span class="s0">#: Location in the source code where scope ends</span>
    <span class="s1">end_location: typing.Optional[Location] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s1">json[</span><span class="s4">'object'</span><span class="s1">] = self.object_.to_json()</span>
        <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s2">if </span><span class="s1">self.start_location </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'startLocation'</span><span class="s1">] = self.start_location.to_json()</span>
        <span class="s2">if </span><span class="s1">self.end_location </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'endLocation'</span><span class="s1">] = self.end_location.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">object_=runtime.RemoteObject.from_json(json[</span><span class="s4">'object'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'name' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">start_location=Location.from_json(json[</span><span class="s4">'startLocation'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'startLocation' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">end_location=Location.from_json(json[</span><span class="s4">'endLocation'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'endLocation' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SearchMatch:</span>
    <span class="s3">''' 
    Search match for resource. 
    '''</span>
    <span class="s0">#: Line number in resource content.</span>
    <span class="s1">line_number: float</span>

    <span class="s0">#: Line with match content.</span>
    <span class="s1">line_content: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'lineNumber'</span><span class="s1">] = self.line_number</span>
        <span class="s1">json[</span><span class="s4">'lineContent'</span><span class="s1">] = self.line_content</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">line_number=float(json[</span><span class="s4">'lineNumber'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">line_content=str(json[</span><span class="s4">'lineContent'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">BreakLocation:</span>
    <span class="s0">#: Script identifier as reported in the ``Debugger.scriptParsed``.</span>
    <span class="s1">script_id: runtime.ScriptId</span>

    <span class="s0">#: Line number in the script (0-based).</span>
    <span class="s1">line_number: int</span>

    <span class="s0">#: Column number in the script (0-based).</span>
    <span class="s1">column_number: typing.Optional[int] = </span><span class="s2">None</span>

    <span class="s1">type_: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'scriptId'</span><span class="s1">] = self.script_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'lineNumber'</span><span class="s1">] = self.line_number</span>
        <span class="s2">if </span><span class="s1">self.column_number </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'columnNumber'</span><span class="s1">] = self.column_number</span>
        <span class="s2">if </span><span class="s1">self.type_ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">script_id=runtime.ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">line_number=int(json[</span><span class="s4">'lineNumber'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">column_number=int(json[</span><span class="s4">'columnNumber'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'columnNumber' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'type' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">ScriptLanguage(enum.Enum):</span>
    <span class="s3">''' 
    Enum of possible script languages. 
    '''</span>
    <span class="s1">JAVA_SCRIPT = </span><span class="s4">&quot;JavaScript&quot;</span>
    <span class="s1">WEB_ASSEMBLY = </span><span class="s4">&quot;WebAssembly&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">DebugSymbols:</span>
    <span class="s3">''' 
    Debug symbols available for a wasm script. 
    '''</span>
    <span class="s0">#: Type of the debug symbols.</span>
    <span class="s1">type_: str</span>

    <span class="s0">#: URL of the external symbol source.</span>
    <span class="s1">external_url: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s2">if </span><span class="s1">self.external_url </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'externalURL'</span><span class="s1">] = self.external_url</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">external_url=str(json[</span><span class="s4">'externalURL'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'externalURL' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">continue_to_location(</span>
        <span class="s1">location: Location</span><span class="s2">,</span>
        <span class="s1">target_call_frames: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Continues execution until specific location is reached. 
 
    :param location: Location to continue to. 
    :param target_call_frames: *(Optional)* 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'location'</span><span class="s1">] = location.to_json()</span>
    <span class="s2">if </span><span class="s1">target_call_frames </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'targetCallFrames'</span><span class="s1">] = target_call_frames</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.continueToLocation'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">disable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disables debugger for given page. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.disable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">enable(</span>
        <span class="s1">max_scripts_cache_size: typing.Optional[float] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">runtime.UniqueDebuggerId]:</span>
    <span class="s3">''' 
    Enables debugger for the given page. Clients should not assume that the debugging has been 
    enabled until the result for this command is received. 
 
    :param max_scripts_cache_size: **(EXPERIMENTAL)** *(Optional)* The maximum size in bytes of collected scripts (not referenced by other heap objects) the debugger can hold. Puts no limit if paramter is omitted. 
    :returns: Unique identifier of the debugger. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">max_scripts_cache_size </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'maxScriptsCacheSize'</span><span class="s1">] = max_scripts_cache_size</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.enable'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">runtime.UniqueDebuggerId.from_json(json[</span><span class="s4">'debuggerId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">evaluate_on_call_frame(</span>
        <span class="s1">call_frame_id: CallFrameId</span><span class="s2">,</span>
        <span class="s1">expression: str</span><span class="s2">,</span>
        <span class="s1">object_group: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">include_command_line_api: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">silent: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">return_by_value: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">generate_preview: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">throw_on_side_effect: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">timeout: typing.Optional[runtime.TimeDelta] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[runtime.RemoteObject</span><span class="s2">, </span><span class="s1">typing.Optional[runtime.ExceptionDetails]]]:</span>
    <span class="s3">''' 
    Evaluates expression on a given call frame. 
 
    :param call_frame_id: Call frame identifier to evaluate on. 
    :param expression: Expression to evaluate. 
    :param object_group: *(Optional)* String object group name to put result into (allows rapid releasing resulting object handles using ```releaseObjectGroup````). 
    :param include_command_line_api: *(Optional)* Specifies whether command line API should be available to the evaluated expression, defaults to false. 
    :param silent: *(Optional)* In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides ````setPauseOnException``` state. 
    :param return_by_value: *(Optional)* Whether the result is expected to be a JSON object that should be sent by value. 
    :param generate_preview: **(EXPERIMENTAL)** *(Optional)* Whether preview should be generated for the result. 
    :param throw_on_side_effect: *(Optional)* Whether to throw an exception if side effect cannot be ruled out during evaluation. 
    :param timeout: **(EXPERIMENTAL)** *(Optional)* Terminate execution after timing out (number of milliseconds). 
    :returns: A tuple with the following items: 
 
        0. **result** - Object wrapper for the evaluation result. 
        1. **exceptionDetails** - *(Optional)* Exception details. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'callFrameId'</span><span class="s1">] = call_frame_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'expression'</span><span class="s1">] = expression</span>
    <span class="s2">if </span><span class="s1">object_group </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectGroup'</span><span class="s1">] = object_group</span>
    <span class="s2">if </span><span class="s1">include_command_line_api </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'includeCommandLineAPI'</span><span class="s1">] = include_command_line_api</span>
    <span class="s2">if </span><span class="s1">silent </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'silent'</span><span class="s1">] = silent</span>
    <span class="s2">if </span><span class="s1">return_by_value </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'returnByValue'</span><span class="s1">] = return_by_value</span>
    <span class="s2">if </span><span class="s1">generate_preview </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'generatePreview'</span><span class="s1">] = generate_preview</span>
    <span class="s2">if </span><span class="s1">throw_on_side_effect </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'throwOnSideEffect'</span><span class="s1">] = throw_on_side_effect</span>
    <span class="s2">if </span><span class="s1">timeout </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'timeout'</span><span class="s1">] = timeout.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.evaluateOnCallFrame'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">runtime.RemoteObject.from_json(json[</span><span class="s4">'result'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">runtime.ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exceptionDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_possible_breakpoints(</span>
        <span class="s1">start: Location</span><span class="s2">,</span>
        <span class="s1">end: typing.Optional[Location] = </span><span class="s2">None,</span>
        <span class="s1">restrict_to_function: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[BreakLocation]]:</span>
    <span class="s3">''' 
    Returns possible locations for breakpoint. scriptId in start and end range locations should be 
    the same. 
 
    :param start: Start of range to search possible breakpoint locations in. 
    :param end: *(Optional)* End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range. 
    :param restrict_to_function: *(Optional)* Only consider locations which are in the same (non-nested) function as start. 
    :returns: List of the possible breakpoint locations. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'start'</span><span class="s1">] = start.to_json()</span>
    <span class="s2">if </span><span class="s1">end </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'end'</span><span class="s1">] = end.to_json()</span>
    <span class="s2">if </span><span class="s1">restrict_to_function </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'restrictToFunction'</span><span class="s1">] = restrict_to_function</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.getPossibleBreakpoints'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[BreakLocation.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'locations'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">get_script_source(</span>
        <span class="s1">script_id: runtime.ScriptId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[str</span><span class="s2">, </span><span class="s1">typing.Optional[str]]]:</span>
    <span class="s3">''' 
    Returns source for the script with given id. 
 
    :param script_id: Id of the script to get source for. 
    :returns: A tuple with the following items: 
 
        0. **scriptSource** - Script source (empty in case of Wasm bytecode). 
        1. **bytecode** - *(Optional)* Wasm bytecode. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'scriptId'</span><span class="s1">] = script_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.getScriptSource'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">str(json[</span><span class="s4">'scriptSource'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">str(json[</span><span class="s4">'bytecode'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'bytecode' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_wasm_bytecode(</span>
        <span class="s1">script_id: runtime.ScriptId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">str]:</span>
    <span class="s3">''' 
    This command is deprecated. Use getScriptSource instead. 
 
    :param script_id: Id of the Wasm script to get source for. 
    :returns: Script source. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'scriptId'</span><span class="s1">] = script_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.getWasmBytecode'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">str(json[</span><span class="s4">'bytecode'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_stack_trace(</span>
        <span class="s1">stack_trace_id: runtime.StackTraceId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">runtime.StackTrace]:</span>
    <span class="s3">''' 
    Returns stack trace with given ``stackTraceId``. 
 
    **EXPERIMENTAL** 
 
    :param stack_trace_id: 
    :returns:  
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'stackTraceId'</span><span class="s1">] = stack_trace_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.getStackTrace'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">runtime.StackTrace.from_json(json[</span><span class="s4">'stackTrace'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">pause() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Stops on the next JavaScript statement. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.pause'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">pause_on_async_call(</span>
        <span class="s1">parent_stack_trace_id: runtime.StackTraceId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
 
 
    **EXPERIMENTAL** 
 
    :param parent_stack_trace_id: Debugger will pause when async call with given stack trace is started. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'parentStackTraceId'</span><span class="s1">] = parent_stack_trace_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.pauseOnAsyncCall'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">remove_breakpoint(</span>
        <span class="s1">breakpoint_id: BreakpointId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Removes JavaScript breakpoint. 
 
    :param breakpoint_id: 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'breakpointId'</span><span class="s1">] = breakpoint_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.removeBreakpoint'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">restart_frame(</span>
        <span class="s1">call_frame_id: CallFrameId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[typing.List[CallFrame]</span><span class="s2">, </span><span class="s1">typing.Optional[runtime.StackTrace]</span><span class="s2">, </span><span class="s1">typing.Optional[runtime.StackTraceId]]]:</span>
    <span class="s3">''' 
    Restarts particular call frame from the beginning. 
 
    :param call_frame_id: Call frame identifier to evaluate on. 
    :returns: A tuple with the following items: 
 
        0. **callFrames** - New stack trace. 
        1. **asyncStackTrace** - *(Optional)* Async stack trace, if any. 
        2. **asyncStackTraceId** - *(Optional)* Async stack trace, if any. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'callFrameId'</span><span class="s1">] = call_frame_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.restartFrame'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">[CallFrame.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'callFrames'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">runtime.StackTrace.from_json(json[</span><span class="s4">'asyncStackTrace'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'asyncStackTrace' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">runtime.StackTraceId.from_json(json[</span><span class="s4">'asyncStackTraceId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'asyncStackTraceId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">resume(</span>
        <span class="s1">terminate_on_resume: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Resumes JavaScript execution. 
 
    :param terminate_on_resume: *(Optional)* Set to true to terminate execution upon resuming execution. In contrast to Runtime.terminateExecution, this will allows to execute further JavaScript (i.e. via evaluation) until execution of the paused code is actually resumed, at which point termination is triggered. If execution is currently not paused, this parameter has no effect. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">terminate_on_resume </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'terminateOnResume'</span><span class="s1">] = terminate_on_resume</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.resume'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">search_in_content(</span>
        <span class="s1">script_id: runtime.ScriptId</span><span class="s2">,</span>
        <span class="s1">query: str</span><span class="s2">,</span>
        <span class="s1">case_sensitive: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">is_regex: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[SearchMatch]]:</span>
    <span class="s3">''' 
    Searches for given string in script content. 
 
    :param script_id: Id of the script to search in. 
    :param query: String to search for. 
    :param case_sensitive: *(Optional)* If true, search is case sensitive. 
    :param is_regex: *(Optional)* If true, treats string parameter as regex. 
    :returns: List of search matches. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'scriptId'</span><span class="s1">] = script_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'query'</span><span class="s1">] = query</span>
    <span class="s2">if </span><span class="s1">case_sensitive </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'caseSensitive'</span><span class="s1">] = case_sensitive</span>
    <span class="s2">if </span><span class="s1">is_regex </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'isRegex'</span><span class="s1">] = is_regex</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.searchInContent'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[SearchMatch.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">set_async_call_stack_depth(</span>
        <span class="s1">max_depth: int</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables or disables async call stacks tracking. 
 
    :param max_depth: Maximum depth of async call stacks. Setting to ```0``` will effectively disable collecting async call stacks (default). 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'maxDepth'</span><span class="s1">] = max_depth</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setAsyncCallStackDepth'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_blackbox_patterns(</span>
        <span class="s1">patterns: typing.List[str]</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in 
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by 
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful. 
 
    **EXPERIMENTAL** 
 
    :param patterns: Array of regexps that will be used to check script url for blackbox state. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'patterns'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">patterns]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setBlackboxPatterns'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_blackboxed_ranges(</span>
        <span class="s1">script_id: runtime.ScriptId</span><span class="s2">,</span>
        <span class="s1">positions: typing.List[ScriptPosition]</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted 
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. 
    Positions array contains positions where blackbox state is changed. First interval isn't 
    blackboxed. Array should be sorted. 
 
    **EXPERIMENTAL** 
 
    :param script_id: Id of the script. 
    :param positions: 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'scriptId'</span><span class="s1">] = script_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'positions'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">positions]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setBlackboxedRanges'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_breakpoint(</span>
        <span class="s1">location: Location</span><span class="s2">,</span>
        <span class="s1">condition: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[BreakpointId</span><span class="s2">, </span><span class="s1">Location]]:</span>
    <span class="s3">''' 
    Sets JavaScript breakpoint at a given location. 
 
    :param location: Location to set breakpoint in. 
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true. 
    :returns: A tuple with the following items: 
 
        0. **breakpointId** - Id of the created breakpoint for further reference. 
        1. **actualLocation** - Location this breakpoint resolved into. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'location'</span><span class="s1">] = location.to_json()</span>
    <span class="s2">if </span><span class="s1">condition </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'condition'</span><span class="s1">] = condition</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setBreakpoint'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">BreakpointId.from_json(json[</span><span class="s4">'breakpointId'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">Location.from_json(json[</span><span class="s4">'actualLocation'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">set_instrumentation_breakpoint(</span>
        <span class="s1">instrumentation: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">BreakpointId]:</span>
    <span class="s3">''' 
    Sets instrumentation breakpoint. 
 
    :param instrumentation: Instrumentation name. 
    :returns: Id of the created breakpoint for further reference. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'instrumentation'</span><span class="s1">] = instrumentation</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setInstrumentationBreakpoint'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">BreakpointId.from_json(json[</span><span class="s4">'breakpointId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">set_breakpoint_by_url(</span>
        <span class="s1">line_number: int</span><span class="s2">,</span>
        <span class="s1">url: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">url_regex: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">script_hash: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">column_number: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">condition: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[BreakpointId</span><span class="s2">, </span><span class="s1">typing.List[Location]]]:</span>
    <span class="s3">''' 
    Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this 
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in 
    ``locations`` property. Further matching script parsing will result in subsequent 
    ``breakpointResolved`` events issued. This logical breakpoint will survive page reloads. 
 
    :param line_number: Line number to set breakpoint at. 
    :param url: *(Optional)* URL of the resources to set breakpoint on. 
    :param url_regex: *(Optional)* Regex pattern for the URLs of the resources to set breakpoints on. Either ```url```` or ````urlRegex``` must be specified. 
    :param script_hash: *(Optional)* Script hash of the resources to set breakpoint on. 
    :param column_number: *(Optional)* Offset in the line to set breakpoint at. 
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true. 
    :returns: A tuple with the following items: 
 
        0. **breakpointId** - Id of the created breakpoint for further reference. 
        1. **locations** - List of the locations this breakpoint resolved into upon addition. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'lineNumber'</span><span class="s1">] = line_number</span>
    <span class="s2">if </span><span class="s1">url </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'url'</span><span class="s1">] = url</span>
    <span class="s2">if </span><span class="s1">url_regex </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'urlRegex'</span><span class="s1">] = url_regex</span>
    <span class="s2">if </span><span class="s1">script_hash </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'scriptHash'</span><span class="s1">] = script_hash</span>
    <span class="s2">if </span><span class="s1">column_number </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'columnNumber'</span><span class="s1">] = column_number</span>
    <span class="s2">if </span><span class="s1">condition </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'condition'</span><span class="s1">] = condition</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setBreakpointByUrl'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">BreakpointId.from_json(json[</span><span class="s4">'breakpointId'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">[Location.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'locations'</span><span class="s1">]]</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">set_breakpoint_on_function_call(</span>
        <span class="s1">object_id: runtime.RemoteObjectId</span><span class="s2">,</span>
        <span class="s1">condition: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">BreakpointId]:</span>
    <span class="s3">''' 
    Sets JavaScript breakpoint before each call to the given function. 
    If another function was created from the same source as a given one, 
    calling it will also trigger the breakpoint. 
 
    **EXPERIMENTAL** 
 
    :param object_id: Function object id. 
    :param condition: *(Optional)* Expression to use as a breakpoint condition. When specified, debugger will stop on the breakpoint if this expression evaluates to true. 
    :returns: Id of the created breakpoint for further reference. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s2">if </span><span class="s1">condition </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'condition'</span><span class="s1">] = condition</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setBreakpointOnFunctionCall'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">BreakpointId.from_json(json[</span><span class="s4">'breakpointId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">set_breakpoints_active(</span>
        <span class="s1">active: bool</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Activates / deactivates all breakpoints on the page. 
 
    :param active: New value for breakpoints active state. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'active'</span><span class="s1">] = active</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setBreakpointsActive'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_pause_on_exceptions(</span>
        <span class="s1">state: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or 
    no exceptions. Initial pause on exceptions state is ``none``. 
 
    :param state: Pause on exceptions mode. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'state'</span><span class="s1">] = state</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setPauseOnExceptions'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_return_value(</span>
        <span class="s1">new_value: runtime.CallArgument</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Changes return value in top frame. Available only at return break position. 
 
    **EXPERIMENTAL** 
 
    :param new_value: New return value. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'newValue'</span><span class="s1">] = new_value.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setReturnValue'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_script_source(</span>
        <span class="s1">script_id: runtime.ScriptId</span><span class="s2">,</span>
        <span class="s1">script_source: str</span><span class="s2">,</span>
        <span class="s1">dry_run: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[typing.Optional[typing.List[CallFrame]]</span><span class="s2">, </span><span class="s1">typing.Optional[bool]</span><span class="s2">, </span><span class="s1">typing.Optional[runtime.StackTrace]</span><span class="s2">, </span><span class="s1">typing.Optional[runtime.StackTraceId]</span><span class="s2">, </span><span class="s1">typing.Optional[runtime.ExceptionDetails]]]:</span>
    <span class="s3">''' 
    Edits JavaScript source live. 
 
    :param script_id: Id of the script to edit. 
    :param script_source: New content of the script. 
    :param dry_run: *(Optional)* If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code. 
    :returns: A tuple with the following items: 
 
        0. **callFrames** - *(Optional)* New stack trace in case editing has happened while VM was stopped. 
        1. **stackChanged** - *(Optional)* Whether current call stack  was modified after applying the changes. 
        2. **asyncStackTrace** - *(Optional)* Async stack trace, if any. 
        3. **asyncStackTraceId** - *(Optional)* Async stack trace, if any. 
        4. **exceptionDetails** - *(Optional)* Exception details if any. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'scriptId'</span><span class="s1">] = script_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'scriptSource'</span><span class="s1">] = script_source</span>
    <span class="s2">if </span><span class="s1">dry_run </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'dryRun'</span><span class="s1">] = dry_run</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setScriptSource'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">[CallFrame.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'callFrames'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'callFrames' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">bool(json[</span><span class="s4">'stackChanged'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'stackChanged' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">runtime.StackTrace.from_json(json[</span><span class="s4">'asyncStackTrace'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'asyncStackTrace' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">runtime.StackTraceId.from_json(json[</span><span class="s4">'asyncStackTraceId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'asyncStackTraceId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">runtime.ExceptionDetails.from_json(json[</span><span class="s4">'exceptionDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'exceptionDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">set_skip_all_pauses(</span>
        <span class="s1">skip: bool</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). 
 
    :param skip: New value for skip pauses state. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'skip'</span><span class="s1">] = skip</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setSkipAllPauses'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_variable_value(</span>
        <span class="s1">scope_number: int</span><span class="s2">,</span>
        <span class="s1">variable_name: str</span><span class="s2">,</span>
        <span class="s1">new_value: runtime.CallArgument</span><span class="s2">,</span>
        <span class="s1">call_frame_id: CallFrameId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Changes value of variable in a callframe. Object-based scopes are not supported and must be 
    mutated manually. 
 
    :param scope_number: 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually. 
    :param variable_name: Variable name. 
    :param new_value: New variable value. 
    :param call_frame_id: Id of callframe that holds variable. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'scopeNumber'</span><span class="s1">] = scope_number</span>
    <span class="s1">params[</span><span class="s4">'variableName'</span><span class="s1">] = variable_name</span>
    <span class="s1">params[</span><span class="s4">'newValue'</span><span class="s1">] = new_value.to_json()</span>
    <span class="s1">params[</span><span class="s4">'callFrameId'</span><span class="s1">] = call_frame_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.setVariableValue'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">step_into(</span>
        <span class="s1">break_on_async_call: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">skip_list: typing.Optional[typing.List[LocationRange]] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Steps into the function call. 
 
    :param break_on_async_call: **(EXPERIMENTAL)** *(Optional)* Debugger will pause on the execution of the first async task which was scheduled before next pause. 
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step into. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">break_on_async_call </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'breakOnAsyncCall'</span><span class="s1">] = break_on_async_call</span>
    <span class="s2">if </span><span class="s1">skip_list </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'skipList'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">skip_list]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.stepInto'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">step_out() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Steps out of the function call. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.stepOut'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">step_over(</span>
        <span class="s1">skip_list: typing.Optional[typing.List[LocationRange]] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Steps over the statement. 
 
    :param skip_list: **(EXPERIMENTAL)** *(Optional)* The skipList specifies location ranges that should be skipped on step over. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">skip_list </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'skipList'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">skip_list]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Debugger.stepOver'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s1">@event_class(</span><span class="s4">'Debugger.breakpointResolved'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">BreakpointResolved:</span>
    <span class="s3">''' 
    Fired when breakpoint is resolved to an actual script and location. 
    '''</span>
    <span class="s0">#: Breakpoint unique identifier.</span>
    <span class="s1">breakpoint_id: BreakpointId</span>
    <span class="s0">#: Actual breakpoint location.</span>
    <span class="s1">location: Location</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; BreakpointResolved:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">breakpoint_id=BreakpointId.from_json(json[</span><span class="s4">'breakpointId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">location=Location.from_json(json[</span><span class="s4">'location'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Debugger.paused'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Paused:</span>
    <span class="s3">''' 
    Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. 
    '''</span>
    <span class="s0">#: Call stack the virtual machine stopped on.</span>
    <span class="s1">call_frames: typing.List[CallFrame]</span>
    <span class="s0">#: Pause reason.</span>
    <span class="s1">reason: str</span>
    <span class="s0">#: Object containing break-specific auxiliary properties.</span>
    <span class="s1">data: typing.Optional[dict]</span>
    <span class="s0">#: Hit breakpoints IDs</span>
    <span class="s1">hit_breakpoints: typing.Optional[typing.List[str]]</span>
    <span class="s0">#: Async stack trace, if any.</span>
    <span class="s1">async_stack_trace: typing.Optional[runtime.StackTrace]</span>
    <span class="s0">#: Async stack trace, if any.</span>
    <span class="s1">async_stack_trace_id: typing.Optional[runtime.StackTraceId]</span>
    <span class="s0">#: Never present, will be removed.</span>
    <span class="s1">async_call_stack_trace_id: typing.Optional[runtime.StackTraceId]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; Paused:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">call_frames=[CallFrame.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'callFrames'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">reason=str(json[</span><span class="s4">'reason'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">data=dict(json[</span><span class="s4">'data'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'data' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">hit_breakpoints=[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'hitBreakpoints'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'hitBreakpoints' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">async_stack_trace=runtime.StackTrace.from_json(json[</span><span class="s4">'asyncStackTrace'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'asyncStackTrace' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">async_stack_trace_id=runtime.StackTraceId.from_json(json[</span><span class="s4">'asyncStackTraceId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'asyncStackTraceId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">async_call_stack_trace_id=runtime.StackTraceId.from_json(json[</span><span class="s4">'asyncCallStackTraceId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'asyncCallStackTraceId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Debugger.resumed'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Resumed:</span>
    <span class="s3">''' 
    Fired when the virtual machine resumed execution. 
    '''</span>


    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; Resumed:</span>
        <span class="s2">return </span><span class="s1">cls(</span>

        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Debugger.scriptFailedToParse'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ScriptFailedToParse:</span>
    <span class="s3">''' 
    Fired when virtual machine fails to parse the script. 
    '''</span>
    <span class="s0">#: Identifier of the script parsed.</span>
    <span class="s1">script_id: runtime.ScriptId</span>
    <span class="s0">#: URL or name of the script parsed (if any).</span>
    <span class="s1">url: str</span>
    <span class="s0">#: Line offset of the script within the resource with given URL (for script tags).</span>
    <span class="s1">start_line: int</span>
    <span class="s0">#: Column offset of the script within the resource with given URL.</span>
    <span class="s1">start_column: int</span>
    <span class="s0">#: Last line of the script.</span>
    <span class="s1">end_line: int</span>
    <span class="s0">#: Length of the last line of the script.</span>
    <span class="s1">end_column: int</span>
    <span class="s0">#: Specifies script creation context.</span>
    <span class="s1">execution_context_id: runtime.ExecutionContextId</span>
    <span class="s0">#: Content hash of the script.</span>
    <span class="s1">hash_: str</span>
    <span class="s0">#: Embedder-specific auxiliary data.</span>
    <span class="s1">execution_context_aux_data: typing.Optional[dict]</span>
    <span class="s0">#: URL of source map associated with script (if any).</span>
    <span class="s1">source_map_url: typing.Optional[str]</span>
    <span class="s0">#: True, if this script has sourceURL.</span>
    <span class="s1">has_source_url: typing.Optional[bool]</span>
    <span class="s0">#: True, if this script is ES6 module.</span>
    <span class="s1">is_module: typing.Optional[bool]</span>
    <span class="s0">#: This script length.</span>
    <span class="s1">length: typing.Optional[int]</span>
    <span class="s0">#: JavaScript top stack frame of where the script parsed event was triggered if available.</span>
    <span class="s1">stack_trace: typing.Optional[runtime.StackTrace]</span>
    <span class="s0">#: If the scriptLanguage is WebAssembly, the code section offset in the module.</span>
    <span class="s1">code_offset: typing.Optional[int]</span>
    <span class="s0">#: The language of the script.</span>
    <span class="s1">script_language: typing.Optional[debugger.ScriptLanguage]</span>
    <span class="s0">#: The name the embedder supplied for this script.</span>
    <span class="s1">embedder_name: typing.Optional[str]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ScriptFailedToParse:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">script_id=runtime.ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">start_line=int(json[</span><span class="s4">'startLine'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">start_column=int(json[</span><span class="s4">'startColumn'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">end_line=int(json[</span><span class="s4">'endLine'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">end_column=int(json[</span><span class="s4">'endColumn'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">execution_context_id=runtime.ExecutionContextId.from_json(json[</span><span class="s4">'executionContextId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">hash_=str(json[</span><span class="s4">'hash'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">execution_context_aux_data=dict(json[</span><span class="s4">'executionContextAuxData'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'executionContextAuxData' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">source_map_url=str(json[</span><span class="s4">'sourceMapURL'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'sourceMapURL' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">has_source_url=bool(json[</span><span class="s4">'hasSourceURL'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'hasSourceURL' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">is_module=bool(json[</span><span class="s4">'isModule'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'isModule' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">length=int(json[</span><span class="s4">'length'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'length' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">stack_trace=runtime.StackTrace.from_json(json[</span><span class="s4">'stackTrace'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'stackTrace' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">code_offset=int(json[</span><span class="s4">'codeOffset'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'codeOffset' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">script_language=debugger.ScriptLanguage.from_json(json[</span><span class="s4">'scriptLanguage'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'scriptLanguage' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">embedder_name=str(json[</span><span class="s4">'embedderName'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'embedderName' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Debugger.scriptParsed'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ScriptParsed:</span>
    <span class="s3">''' 
    Fired when virtual machine parses script. This event is also fired for all known and uncollected 
    scripts upon enabling debugger. 
    '''</span>
    <span class="s0">#: Identifier of the script parsed.</span>
    <span class="s1">script_id: runtime.ScriptId</span>
    <span class="s0">#: URL or name of the script parsed (if any).</span>
    <span class="s1">url: str</span>
    <span class="s0">#: Line offset of the script within the resource with given URL (for script tags).</span>
    <span class="s1">start_line: int</span>
    <span class="s0">#: Column offset of the script within the resource with given URL.</span>
    <span class="s1">start_column: int</span>
    <span class="s0">#: Last line of the script.</span>
    <span class="s1">end_line: int</span>
    <span class="s0">#: Length of the last line of the script.</span>
    <span class="s1">end_column: int</span>
    <span class="s0">#: Specifies script creation context.</span>
    <span class="s1">execution_context_id: runtime.ExecutionContextId</span>
    <span class="s0">#: Content hash of the script.</span>
    <span class="s1">hash_: str</span>
    <span class="s0">#: Embedder-specific auxiliary data.</span>
    <span class="s1">execution_context_aux_data: typing.Optional[dict]</span>
    <span class="s0">#: True, if this script is generated as a result of the live edit operation.</span>
    <span class="s1">is_live_edit: typing.Optional[bool]</span>
    <span class="s0">#: URL of source map associated with script (if any).</span>
    <span class="s1">source_map_url: typing.Optional[str]</span>
    <span class="s0">#: True, if this script has sourceURL.</span>
    <span class="s1">has_source_url: typing.Optional[bool]</span>
    <span class="s0">#: True, if this script is ES6 module.</span>
    <span class="s1">is_module: typing.Optional[bool]</span>
    <span class="s0">#: This script length.</span>
    <span class="s1">length: typing.Optional[int]</span>
    <span class="s0">#: JavaScript top stack frame of where the script parsed event was triggered if available.</span>
    <span class="s1">stack_trace: typing.Optional[runtime.StackTrace]</span>
    <span class="s0">#: If the scriptLanguage is WebAssembly, the code section offset in the module.</span>
    <span class="s1">code_offset: typing.Optional[int]</span>
    <span class="s0">#: The language of the script.</span>
    <span class="s1">script_language: typing.Optional[debugger.ScriptLanguage]</span>
    <span class="s0">#: If the scriptLanguage is WebASsembly, the source of debug symbols for the module.</span>
    <span class="s1">debug_symbols: typing.Optional[debugger.DebugSymbols]</span>
    <span class="s0">#: The name the embedder supplied for this script.</span>
    <span class="s1">embedder_name: typing.Optional[str]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ScriptParsed:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">script_id=runtime.ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">start_line=int(json[</span><span class="s4">'startLine'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">start_column=int(json[</span><span class="s4">'startColumn'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">end_line=int(json[</span><span class="s4">'endLine'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">end_column=int(json[</span><span class="s4">'endColumn'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">execution_context_id=runtime.ExecutionContextId.from_json(json[</span><span class="s4">'executionContextId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">hash_=str(json[</span><span class="s4">'hash'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">execution_context_aux_data=dict(json[</span><span class="s4">'executionContextAuxData'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'executionContextAuxData' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">is_live_edit=bool(json[</span><span class="s4">'isLiveEdit'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'isLiveEdit' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">source_map_url=str(json[</span><span class="s4">'sourceMapURL'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'sourceMapURL' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">has_source_url=bool(json[</span><span class="s4">'hasSourceURL'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'hasSourceURL' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">is_module=bool(json[</span><span class="s4">'isModule'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'isModule' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">length=int(json[</span><span class="s4">'length'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'length' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">stack_trace=runtime.StackTrace.from_json(json[</span><span class="s4">'stackTrace'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'stackTrace' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">code_offset=int(json[</span><span class="s4">'codeOffset'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'codeOffset' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">script_language=debugger.ScriptLanguage.from_json(json[</span><span class="s4">'scriptLanguage'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'scriptLanguage' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">debug_symbols=debugger.DebugSymbols.from_json(json[</span><span class="s4">'debugSymbols'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'debugSymbols' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">embedder_name=str(json[</span><span class="s4">'embedderName'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'embedderName' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>
</pre>
</body>
</html>