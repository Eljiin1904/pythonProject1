<html>
<head>
<title>gen_exports.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gen_exports.py</font>
</center></td></tr></table>
<pre><span class="s0">#! /usr/bin/env python3</span>
<span class="s0"># -*- coding: utf-8 -`-</span>
<span class="s2">&quot;&quot;&quot; 
Code generation script for class methods 
to be exported as public API 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">argparse</span>
<span class="s3">import </span><span class="s1">ast</span>
<span class="s3">import </span><span class="s1">astor</span>
<span class="s3">import </span><span class="s1">os</span>
<span class="s3">from </span><span class="s1">pathlib </span><span class="s3">import </span><span class="s1">Path</span>
<span class="s3">import </span><span class="s1">sys</span>

<span class="s3">from </span><span class="s1">textwrap </span><span class="s3">import </span><span class="s1">indent</span>

<span class="s1">PREFIX = </span><span class="s4">&quot;_generated&quot;</span>

<span class="s1">HEADER = </span><span class="s4">&quot;&quot;&quot;# *********************************************************** 
# ******* WARNING: AUTOGENERATED! ALL EDITS WILL BE LOST ****** 
# ************************************************************* 
from ._run import GLOBAL_RUN_CONTEXT, _NO_SEND 
from ._ki import LOCALS_KEY_KI_PROTECTION_ENABLED 
from ._instrumentation import Instrument 
 
# fmt: off 
&quot;&quot;&quot;</span>

<span class="s1">FOOTER = </span><span class="s4">&quot;&quot;&quot;# fmt: on 
&quot;&quot;&quot;</span>

<span class="s1">TEMPLATE = </span><span class="s4">&quot;&quot;&quot;locals()[LOCALS_KEY_KI_PROTECTION_ENABLED] = True 
try: 
    return{}GLOBAL_RUN_CONTEXT.{}.{} 
except AttributeError: 
    raise RuntimeError(&quot;must be called from async context&quot;) 
&quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">is_function(node):</span>
    <span class="s2">&quot;&quot;&quot;Check if the AST node is either a function 
    or an async function 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(node</span><span class="s3">, </span><span class="s1">ast.FunctionDef) </span><span class="s3">or </span><span class="s1">isinstance(node</span><span class="s3">, </span><span class="s1">ast.AsyncFunctionDef):</span>
        <span class="s3">return True</span>
    <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">is_public(node):</span>
    <span class="s2">&quot;&quot;&quot;Check if the AST node has a _public decorator&quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">is_function(node):</span>
        <span class="s3">return False</span>
    <span class="s3">for </span><span class="s1">decorator </span><span class="s3">in </span><span class="s1">node.decorator_list:</span>
        <span class="s3">if </span><span class="s1">isinstance(decorator</span><span class="s3">, </span><span class="s1">ast.Name) </span><span class="s3">and </span><span class="s1">decorator.id == </span><span class="s4">&quot;_public&quot;</span><span class="s1">:</span>
            <span class="s3">return True</span>
    <span class="s3">return False</span>


<span class="s3">def </span><span class="s1">get_public_methods(tree):</span>
    <span class="s2">&quot;&quot;&quot;Return a list of methods marked as public. 
    The function walks the given tree and extracts 
    all objects that are functions which are marked 
    public. 
    &quot;&quot;&quot;</span>
    <span class="s3">for </span><span class="s1">node </span><span class="s3">in </span><span class="s1">ast.walk(tree):</span>
        <span class="s3">if </span><span class="s1">is_public(node):</span>
            <span class="s3">yield </span><span class="s1">node</span>


<span class="s3">def </span><span class="s1">create_passthrough_args(funcdef):</span>
    <span class="s2">&quot;&quot;&quot;Given a function definition, create a string that represents taking all 
    the arguments from the function, and passing them through to another 
    invocation of the same function. 
 
    Example input: ast.parse(&quot;def f(a, *, b): ...&quot;) 
    Example output: &quot;(a, b=b)&quot; 
    &quot;&quot;&quot;</span>
    <span class="s1">call_args = []</span>
    <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">funcdef.args.args:</span>
        <span class="s1">call_args.append(arg.arg)</span>
    <span class="s3">if </span><span class="s1">funcdef.args.vararg:</span>
        <span class="s1">call_args.append(</span><span class="s4">&quot;*&quot; </span><span class="s1">+ funcdef.args.vararg.arg)</span>
    <span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">funcdef.args.kwonlyargs:</span>
        <span class="s1">call_args.append(arg.arg + </span><span class="s4">&quot;=&quot; </span><span class="s1">+ arg.arg)</span>
    <span class="s3">if </span><span class="s1">funcdef.args.kwarg:</span>
        <span class="s1">call_args.append(</span><span class="s4">&quot;**&quot; </span><span class="s1">+ funcdef.args.kwarg.arg)</span>
    <span class="s3">return </span><span class="s4">&quot;({})&quot;</span><span class="s1">.format(</span><span class="s4">&quot;, &quot;</span><span class="s1">.join(call_args))</span>


<span class="s3">def </span><span class="s1">gen_public_wrappers_source(source_path: Path</span><span class="s3">, </span><span class="s1">lookup_path: str) -&gt; str:</span>
    <span class="s2">&quot;&quot;&quot;Scan the given .py file for @_public decorators, and generate wrapper 
    functions. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">generated = [HEADER]</span>
    <span class="s1">source = astor.code_to_ast.parse_file(source_path)</span>
    <span class="s3">for </span><span class="s1">method </span><span class="s3">in </span><span class="s1">get_public_methods(source):</span>
        <span class="s0"># Remove self from arguments</span>
        <span class="s3">assert </span><span class="s1">method.args.args[</span><span class="s5">0</span><span class="s1">].arg == </span><span class="s4">&quot;self&quot;</span>
        <span class="s3">del </span><span class="s1">method.args.args[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s0"># Remove decorators</span>
        <span class="s1">method.decorator_list = []</span>

        <span class="s0"># Create pass through arguments</span>
        <span class="s1">new_args = create_passthrough_args(method)</span>

        <span class="s0"># Remove method body without the docstring</span>
        <span class="s3">if </span><span class="s1">ast.get_docstring(method) </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">del </span><span class="s1">method.body[:]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># The first entry is always the docstring</span>
            <span class="s3">del </span><span class="s1">method.body[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s0"># Create the function definition including the body</span>
        <span class="s1">func = astor.to_source(method</span><span class="s3">, </span><span class="s1">indent_with=</span><span class="s4">&quot; &quot; </span><span class="s1">* </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s0"># Create export function body</span>
        <span class="s1">template = TEMPLATE.format(</span>
            <span class="s4">&quot; await &quot; </span><span class="s3">if </span><span class="s1">isinstance(method</span><span class="s3">, </span><span class="s1">ast.AsyncFunctionDef) </span><span class="s3">else </span><span class="s4">&quot; &quot;</span><span class="s3">,</span>
            <span class="s1">lookup_path</span><span class="s3">,</span>
            <span class="s1">method.name + new_args</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s0"># Assemble function definition arguments and body</span>
        <span class="s1">snippet = func + indent(template</span><span class="s3">, </span><span class="s4">&quot; &quot; </span><span class="s1">* </span><span class="s5">4</span><span class="s1">)</span>

        <span class="s0"># Append the snippet to the corresponding module</span>
        <span class="s1">generated.append(snippet)</span>
    <span class="s1">generated.append(FOOTER)</span>
    <span class="s3">return </span><span class="s4">&quot;</span><span class="s3">\n\n</span><span class="s4">&quot;</span><span class="s1">.join(generated)</span>


<span class="s3">def </span><span class="s1">matches_disk_files(new_files):</span>
    <span class="s3">for </span><span class="s1">new_path</span><span class="s3">, </span><span class="s1">new_source </span><span class="s3">in </span><span class="s1">new_files.items():</span>
        <span class="s3">if not </span><span class="s1">os.path.exists(new_path):</span>
            <span class="s3">return False</span>
        <span class="s3">with </span><span class="s1">open(new_path</span><span class="s3">, </span><span class="s4">&quot;r&quot;</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s3">as </span><span class="s1">old_file:</span>
            <span class="s1">old_source = old_file.read()</span>
        <span class="s3">if </span><span class="s1">old_source != new_source:</span>
            <span class="s3">return False</span>
    <span class="s3">return True</span>


<span class="s3">def </span><span class="s1">process(sources_and_lookups</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">do_test):</span>
    <span class="s1">new_files = {}</span>
    <span class="s3">for </span><span class="s1">source_path</span><span class="s3">, </span><span class="s1">lookup_path </span><span class="s3">in </span><span class="s1">sources_and_lookups:</span>
        <span class="s1">print(</span><span class="s4">&quot;Scanning:&quot;</span><span class="s3">, </span><span class="s1">source_path)</span>
        <span class="s1">new_source = gen_public_wrappers_source(source_path</span><span class="s3">, </span><span class="s1">lookup_path)</span>
        <span class="s1">dirname</span><span class="s3">, </span><span class="s1">basename = os.path.split(source_path)</span>
        <span class="s1">new_path = os.path.join(dirname</span><span class="s3">, </span><span class="s1">PREFIX + basename)</span>
        <span class="s1">new_files[new_path] = new_source</span>
    <span class="s3">if </span><span class="s1">do_test:</span>
        <span class="s3">if not </span><span class="s1">matches_disk_files(new_files):</span>
            <span class="s1">print(</span><span class="s4">&quot;Generated sources are outdated. Please regenerate.&quot;</span><span class="s1">)</span>
            <span class="s1">sys.exit(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;Generated sources are up to date.&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">new_path</span><span class="s3">, </span><span class="s1">new_source </span><span class="s3">in </span><span class="s1">new_files.items():</span>
            <span class="s3">with </span><span class="s1">open(new_path</span><span class="s3">, </span><span class="s4">&quot;w&quot;</span><span class="s3">, </span><span class="s1">encoding=</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
                <span class="s1">f.write(new_source)</span>
        <span class="s1">print(</span><span class="s4">&quot;Regenerated sources successfully.&quot;</span><span class="s1">)</span>


<span class="s0"># This is in fact run in CI, but only in the formatting check job, which</span>
<span class="s0"># doesn't collect coverage.</span>
<span class="s3">def </span><span class="s1">main():  </span><span class="s0"># pragma: no cover</span>
    <span class="s1">parser = argparse.ArgumentParser(</span>
        <span class="s1">description=</span><span class="s4">&quot;Generate python code for public api wrappers&quot;</span>
    <span class="s1">)</span>
    <span class="s1">parser.add_argument(</span>
        <span class="s4">&quot;--test&quot;</span><span class="s3">, </span><span class="s4">&quot;-t&quot;</span><span class="s3">, </span><span class="s1">action=</span><span class="s4">&quot;store_true&quot;</span><span class="s3">, </span><span class="s1">help=</span><span class="s4">&quot;test if code is still up to date&quot;</span>
    <span class="s1">)</span>
    <span class="s1">parsed_args = parser.parse_args()</span>

    <span class="s1">source_root = Path.cwd()</span>
    <span class="s0"># Double-check we found the right directory</span>
    <span class="s3">assert </span><span class="s1">(source_root / </span><span class="s4">&quot;LICENSE&quot;</span><span class="s1">).exists()</span>
    <span class="s1">core = source_root / </span><span class="s4">&quot;trio/_core&quot;</span>
    <span class="s1">to_wrap = [</span>
        <span class="s1">(core / </span><span class="s4">&quot;_run.py&quot;</span><span class="s3">, </span><span class="s4">&quot;runner&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(core / </span><span class="s4">&quot;_instrumentation.py&quot;</span><span class="s3">, </span><span class="s4">&quot;runner.instruments&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(core / </span><span class="s4">&quot;_io_windows.py&quot;</span><span class="s3">, </span><span class="s4">&quot;runner.io_manager&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(core / </span><span class="s4">&quot;_io_epoll.py&quot;</span><span class="s3">, </span><span class="s4">&quot;runner.io_manager&quot;</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">(core / </span><span class="s4">&quot;_io_kqueue.py&quot;</span><span class="s3">, </span><span class="s4">&quot;runner.io_manager&quot;</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">]</span>

    <span class="s1">process(to_wrap</span><span class="s3">, </span><span class="s1">do_test=parsed_args.test)</span>


<span class="s3">if </span><span class="s1">__name__ == </span><span class="s4">&quot;__main__&quot;</span><span class="s1">:  </span><span class="s0"># pragma: no cover</span>
    <span class="s1">main()</span>
</pre>
</body>
</html>