<html>
<head>
<title>network.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
network.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: Network</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">debugger</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">emulation</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">io</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">page</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">runtime</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">security</span>


<span class="s2">class </span><span class="s1">ResourceType(enum.Enum):</span>
    <span class="s3">''' 
    Resource type as it was perceived by the rendering engine. 
    '''</span>
    <span class="s1">DOCUMENT = </span><span class="s4">&quot;Document&quot;</span>
    <span class="s1">STYLESHEET = </span><span class="s4">&quot;Stylesheet&quot;</span>
    <span class="s1">IMAGE = </span><span class="s4">&quot;Image&quot;</span>
    <span class="s1">MEDIA = </span><span class="s4">&quot;Media&quot;</span>
    <span class="s1">FONT = </span><span class="s4">&quot;Font&quot;</span>
    <span class="s1">SCRIPT = </span><span class="s4">&quot;Script&quot;</span>
    <span class="s1">TEXT_TRACK = </span><span class="s4">&quot;TextTrack&quot;</span>
    <span class="s1">XHR = </span><span class="s4">&quot;XHR&quot;</span>
    <span class="s1">FETCH = </span><span class="s4">&quot;Fetch&quot;</span>
    <span class="s1">EVENT_SOURCE = </span><span class="s4">&quot;EventSource&quot;</span>
    <span class="s1">WEB_SOCKET = </span><span class="s4">&quot;WebSocket&quot;</span>
    <span class="s1">MANIFEST = </span><span class="s4">&quot;Manifest&quot;</span>
    <span class="s1">SIGNED_EXCHANGE = </span><span class="s4">&quot;SignedExchange&quot;</span>
    <span class="s1">PING = </span><span class="s4">&quot;Ping&quot;</span>
    <span class="s1">CSP_VIOLATION_REPORT = </span><span class="s4">&quot;CSPViolationReport&quot;</span>
    <span class="s1">PREFLIGHT = </span><span class="s4">&quot;Preflight&quot;</span>
    <span class="s1">OTHER = </span><span class="s4">&quot;Other&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">LoaderId(str):</span>
    <span class="s3">''' 
    Unique loader identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; LoaderId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'LoaderId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">RequestId(str):</span>
    <span class="s3">''' 
    Unique request identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; RequestId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'RequestId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">InterceptionId(str):</span>
    <span class="s3">''' 
    Unique intercepted request identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; InterceptionId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'InterceptionId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">ErrorReason(enum.Enum):</span>
    <span class="s3">''' 
    Network level fetch failure reason. 
    '''</span>
    <span class="s1">FAILED = </span><span class="s4">&quot;Failed&quot;</span>
    <span class="s1">ABORTED = </span><span class="s4">&quot;Aborted&quot;</span>
    <span class="s1">TIMED_OUT = </span><span class="s4">&quot;TimedOut&quot;</span>
    <span class="s1">ACCESS_DENIED = </span><span class="s4">&quot;AccessDenied&quot;</span>
    <span class="s1">CONNECTION_CLOSED = </span><span class="s4">&quot;ConnectionClosed&quot;</span>
    <span class="s1">CONNECTION_RESET = </span><span class="s4">&quot;ConnectionReset&quot;</span>
    <span class="s1">CONNECTION_REFUSED = </span><span class="s4">&quot;ConnectionRefused&quot;</span>
    <span class="s1">CONNECTION_ABORTED = </span><span class="s4">&quot;ConnectionAborted&quot;</span>
    <span class="s1">CONNECTION_FAILED = </span><span class="s4">&quot;ConnectionFailed&quot;</span>
    <span class="s1">NAME_NOT_RESOLVED = </span><span class="s4">&quot;NameNotResolved&quot;</span>
    <span class="s1">INTERNET_DISCONNECTED = </span><span class="s4">&quot;InternetDisconnected&quot;</span>
    <span class="s1">ADDRESS_UNREACHABLE = </span><span class="s4">&quot;AddressUnreachable&quot;</span>
    <span class="s1">BLOCKED_BY_CLIENT = </span><span class="s4">&quot;BlockedByClient&quot;</span>
    <span class="s1">BLOCKED_BY_RESPONSE = </span><span class="s4">&quot;BlockedByResponse&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">TimeSinceEpoch(float):</span>
    <span class="s3">''' 
    UTC time in seconds, counted from January 1, 1970. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; float:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: float) -&gt; TimeSinceEpoch:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'TimeSinceEpoch({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">MonotonicTime(float):</span>
    <span class="s3">''' 
    Monotonically increasing time in seconds since an arbitrary point in the past. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; float:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: float) -&gt; MonotonicTime:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'MonotonicTime({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">Headers(dict):</span>
    <span class="s3">''' 
    Request / response headers as keys / values of JSON object. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; dict:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: dict) -&gt; Headers:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'Headers({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">ConnectionType(enum.Enum):</span>
    <span class="s3">''' 
    The underlying connection technology that the browser is supposedly using. 
    '''</span>
    <span class="s1">NONE = </span><span class="s4">&quot;none&quot;</span>
    <span class="s1">CELLULAR2G = </span><span class="s4">&quot;cellular2g&quot;</span>
    <span class="s1">CELLULAR3G = </span><span class="s4">&quot;cellular3g&quot;</span>
    <span class="s1">CELLULAR4G = </span><span class="s4">&quot;cellular4g&quot;</span>
    <span class="s1">BLUETOOTH = </span><span class="s4">&quot;bluetooth&quot;</span>
    <span class="s1">ETHERNET = </span><span class="s4">&quot;ethernet&quot;</span>
    <span class="s1">WIFI = </span><span class="s4">&quot;wifi&quot;</span>
    <span class="s1">WIMAX = </span><span class="s4">&quot;wimax&quot;</span>
    <span class="s1">OTHER = </span><span class="s4">&quot;other&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">CookieSameSite(enum.Enum):</span>
    <span class="s3">''' 
    Represents the cookie's 'SameSite' status: 
    https://tools.ietf.org/html/draft-west-first-party-cookies 
    '''</span>
    <span class="s1">STRICT = </span><span class="s4">&quot;Strict&quot;</span>
    <span class="s1">LAX = </span><span class="s4">&quot;Lax&quot;</span>
    <span class="s1">NONE = </span><span class="s4">&quot;None&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">CookiePriority(enum.Enum):</span>
    <span class="s3">''' 
    Represents the cookie's 'Priority' status: 
    https://tools.ietf.org/html/draft-west-cookie-priority-00 
    '''</span>
    <span class="s1">LOW = </span><span class="s4">&quot;Low&quot;</span>
    <span class="s1">MEDIUM = </span><span class="s4">&quot;Medium&quot;</span>
    <span class="s1">HIGH = </span><span class="s4">&quot;High&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">CookieSourceScheme(enum.Enum):</span>
    <span class="s3">''' 
    Represents the source scheme of the origin that originally set the cookie. 
    A value of &quot;Unset&quot; allows protocol clients to emulate legacy cookie scope for the scheme. 
    This is a temporary ability and it will be removed in the future. 
    '''</span>
    <span class="s1">UNSET = </span><span class="s4">&quot;Unset&quot;</span>
    <span class="s1">NON_SECURE = </span><span class="s4">&quot;NonSecure&quot;</span>
    <span class="s1">SECURE = </span><span class="s4">&quot;Secure&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ResourceTiming:</span>
    <span class="s3">''' 
    Timing information for the request. 
    '''</span>
    <span class="s0">#: Timing's requestTime is a baseline in seconds, while the other numbers are ticks in</span>
    <span class="s0">#: milliseconds relatively to this requestTime.</span>
    <span class="s1">request_time: float</span>

    <span class="s0">#: Started resolving proxy.</span>
    <span class="s1">proxy_start: float</span>

    <span class="s0">#: Finished resolving proxy.</span>
    <span class="s1">proxy_end: float</span>

    <span class="s0">#: Started DNS address resolve.</span>
    <span class="s1">dns_start: float</span>

    <span class="s0">#: Finished DNS address resolve.</span>
    <span class="s1">dns_end: float</span>

    <span class="s0">#: Started connecting to the remote host.</span>
    <span class="s1">connect_start: float</span>

    <span class="s0">#: Connected to the remote host.</span>
    <span class="s1">connect_end: float</span>

    <span class="s0">#: Started SSL handshake.</span>
    <span class="s1">ssl_start: float</span>

    <span class="s0">#: Finished SSL handshake.</span>
    <span class="s1">ssl_end: float</span>

    <span class="s0">#: Started running ServiceWorker.</span>
    <span class="s1">worker_start: float</span>

    <span class="s0">#: Finished Starting ServiceWorker.</span>
    <span class="s1">worker_ready: float</span>

    <span class="s0">#: Started fetch event.</span>
    <span class="s1">worker_fetch_start: float</span>

    <span class="s0">#: Settled fetch event respondWith promise.</span>
    <span class="s1">worker_respond_with_settled: float</span>

    <span class="s0">#: Started sending request.</span>
    <span class="s1">send_start: float</span>

    <span class="s0">#: Finished sending request.</span>
    <span class="s1">send_end: float</span>

    <span class="s0">#: Time the server started pushing request.</span>
    <span class="s1">push_start: float</span>

    <span class="s0">#: Time the server finished pushing request.</span>
    <span class="s1">push_end: float</span>

    <span class="s0">#: Finished receiving response headers.</span>
    <span class="s1">receive_headers_end: float</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'requestTime'</span><span class="s1">] = self.request_time</span>
        <span class="s1">json[</span><span class="s4">'proxyStart'</span><span class="s1">] = self.proxy_start</span>
        <span class="s1">json[</span><span class="s4">'proxyEnd'</span><span class="s1">] = self.proxy_end</span>
        <span class="s1">json[</span><span class="s4">'dnsStart'</span><span class="s1">] = self.dns_start</span>
        <span class="s1">json[</span><span class="s4">'dnsEnd'</span><span class="s1">] = self.dns_end</span>
        <span class="s1">json[</span><span class="s4">'connectStart'</span><span class="s1">] = self.connect_start</span>
        <span class="s1">json[</span><span class="s4">'connectEnd'</span><span class="s1">] = self.connect_end</span>
        <span class="s1">json[</span><span class="s4">'sslStart'</span><span class="s1">] = self.ssl_start</span>
        <span class="s1">json[</span><span class="s4">'sslEnd'</span><span class="s1">] = self.ssl_end</span>
        <span class="s1">json[</span><span class="s4">'workerStart'</span><span class="s1">] = self.worker_start</span>
        <span class="s1">json[</span><span class="s4">'workerReady'</span><span class="s1">] = self.worker_ready</span>
        <span class="s1">json[</span><span class="s4">'workerFetchStart'</span><span class="s1">] = self.worker_fetch_start</span>
        <span class="s1">json[</span><span class="s4">'workerRespondWithSettled'</span><span class="s1">] = self.worker_respond_with_settled</span>
        <span class="s1">json[</span><span class="s4">'sendStart'</span><span class="s1">] = self.send_start</span>
        <span class="s1">json[</span><span class="s4">'sendEnd'</span><span class="s1">] = self.send_end</span>
        <span class="s1">json[</span><span class="s4">'pushStart'</span><span class="s1">] = self.push_start</span>
        <span class="s1">json[</span><span class="s4">'pushEnd'</span><span class="s1">] = self.push_end</span>
        <span class="s1">json[</span><span class="s4">'receiveHeadersEnd'</span><span class="s1">] = self.receive_headers_end</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_time=float(json[</span><span class="s4">'requestTime'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">proxy_start=float(json[</span><span class="s4">'proxyStart'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">proxy_end=float(json[</span><span class="s4">'proxyEnd'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">dns_start=float(json[</span><span class="s4">'dnsStart'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">dns_end=float(json[</span><span class="s4">'dnsEnd'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">connect_start=float(json[</span><span class="s4">'connectStart'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">connect_end=float(json[</span><span class="s4">'connectEnd'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">ssl_start=float(json[</span><span class="s4">'sslStart'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">ssl_end=float(json[</span><span class="s4">'sslEnd'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">worker_start=float(json[</span><span class="s4">'workerStart'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">worker_ready=float(json[</span><span class="s4">'workerReady'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">worker_fetch_start=float(json[</span><span class="s4">'workerFetchStart'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">worker_respond_with_settled=float(json[</span><span class="s4">'workerRespondWithSettled'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">send_start=float(json[</span><span class="s4">'sendStart'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">send_end=float(json[</span><span class="s4">'sendEnd'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">push_start=float(json[</span><span class="s4">'pushStart'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">push_end=float(json[</span><span class="s4">'pushEnd'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">receive_headers_end=float(json[</span><span class="s4">'receiveHeadersEnd'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">ResourcePriority(enum.Enum):</span>
    <span class="s3">''' 
    Loading priority of a resource request. 
    '''</span>
    <span class="s1">VERY_LOW = </span><span class="s4">&quot;VeryLow&quot;</span>
    <span class="s1">LOW = </span><span class="s4">&quot;Low&quot;</span>
    <span class="s1">MEDIUM = </span><span class="s4">&quot;Medium&quot;</span>
    <span class="s1">HIGH = </span><span class="s4">&quot;High&quot;</span>
    <span class="s1">VERY_HIGH = </span><span class="s4">&quot;VeryHigh&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PostDataEntry:</span>
    <span class="s3">''' 
    Post data entry for HTTP request 
    '''</span>
    <span class="s1">bytes_: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s2">if </span><span class="s1">self.bytes_ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'bytes'</span><span class="s1">] = self.bytes_</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">bytes_=str(json[</span><span class="s4">'bytes'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'bytes' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Request:</span>
    <span class="s3">''' 
    HTTP request data. 
    '''</span>
    <span class="s0">#: Request URL (without fragment).</span>
    <span class="s1">url: str</span>

    <span class="s0">#: HTTP request method.</span>
    <span class="s1">method: str</span>

    <span class="s0">#: HTTP request headers.</span>
    <span class="s1">headers: Headers</span>

    <span class="s0">#: Priority of the resource request at the time request is sent.</span>
    <span class="s1">initial_priority: ResourcePriority</span>

    <span class="s0">#: The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/</span>
    <span class="s1">referrer_policy: str</span>

    <span class="s0">#: Fragment of the requested URL starting with hash, if present.</span>
    <span class="s1">url_fragment: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: HTTP POST request data.</span>
    <span class="s1">post_data: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.</span>
    <span class="s1">has_post_data: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Request body elements. This will be converted from base64 to binary</span>
    <span class="s1">post_data_entries: typing.Optional[typing.List[PostDataEntry]] = </span><span class="s2">None</span>

    <span class="s0">#: The mixed content type of the request.</span>
    <span class="s1">mixed_content_type: typing.Optional[security.MixedContentType] = </span><span class="s2">None</span>

    <span class="s0">#: Whether is loaded via link preload.</span>
    <span class="s1">is_link_preload: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Set for requests when the TrustToken API is used. Contains the parameters</span>
    <span class="s0">#: passed by the developer (e.g. via &quot;fetch&quot;) as understood by the backend.</span>
    <span class="s1">trust_token_params: typing.Optional[TrustTokenParams] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s1">json[</span><span class="s4">'method'</span><span class="s1">] = self.method</span>
        <span class="s1">json[</span><span class="s4">'headers'</span><span class="s1">] = self.headers.to_json()</span>
        <span class="s1">json[</span><span class="s4">'initialPriority'</span><span class="s1">] = self.initial_priority.to_json()</span>
        <span class="s1">json[</span><span class="s4">'referrerPolicy'</span><span class="s1">] = self.referrer_policy</span>
        <span class="s2">if </span><span class="s1">self.url_fragment </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'urlFragment'</span><span class="s1">] = self.url_fragment</span>
        <span class="s2">if </span><span class="s1">self.post_data </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'postData'</span><span class="s1">] = self.post_data</span>
        <span class="s2">if </span><span class="s1">self.has_post_data </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'hasPostData'</span><span class="s1">] = self.has_post_data</span>
        <span class="s2">if </span><span class="s1">self.post_data_entries </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'postDataEntries'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.post_data_entries]</span>
        <span class="s2">if </span><span class="s1">self.mixed_content_type </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'mixedContentType'</span><span class="s1">] = self.mixed_content_type.to_json()</span>
        <span class="s2">if </span><span class="s1">self.is_link_preload </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'isLinkPreload'</span><span class="s1">] = self.is_link_preload</span>
        <span class="s2">if </span><span class="s1">self.trust_token_params </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'trustTokenParams'</span><span class="s1">] = self.trust_token_params.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">method=str(json[</span><span class="s4">'method'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">headers=Headers.from_json(json[</span><span class="s4">'headers'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">initial_priority=ResourcePriority.from_json(json[</span><span class="s4">'initialPriority'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">referrer_policy=str(json[</span><span class="s4">'referrerPolicy'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url_fragment=str(json[</span><span class="s4">'urlFragment'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'urlFragment' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">post_data=str(json[</span><span class="s4">'postData'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'postData' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">has_post_data=bool(json[</span><span class="s4">'hasPostData'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'hasPostData' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">post_data_entries=[PostDataEntry.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'postDataEntries'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'postDataEntries' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">mixed_content_type=security.MixedContentType.from_json(json[</span><span class="s4">'mixedContentType'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'mixedContentType' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">is_link_preload=bool(json[</span><span class="s4">'isLinkPreload'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'isLinkPreload' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">trust_token_params=TrustTokenParams.from_json(json[</span><span class="s4">'trustTokenParams'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'trustTokenParams' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SignedCertificateTimestamp:</span>
    <span class="s3">''' 
    Details of a signed certificate timestamp (SCT). 
    '''</span>
    <span class="s0">#: Validation status.</span>
    <span class="s1">status: str</span>

    <span class="s0">#: Origin.</span>
    <span class="s1">origin: str</span>

    <span class="s0">#: Log name / description.</span>
    <span class="s1">log_description: str</span>

    <span class="s0">#: Log ID.</span>
    <span class="s1">log_id: str</span>

    <span class="s0">#: Issuance date.</span>
    <span class="s1">timestamp: TimeSinceEpoch</span>

    <span class="s0">#: Hash algorithm.</span>
    <span class="s1">hash_algorithm: str</span>

    <span class="s0">#: Signature algorithm.</span>
    <span class="s1">signature_algorithm: str</span>

    <span class="s0">#: Signature data.</span>
    <span class="s1">signature_data: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'status'</span><span class="s1">] = self.status</span>
        <span class="s1">json[</span><span class="s4">'origin'</span><span class="s1">] = self.origin</span>
        <span class="s1">json[</span><span class="s4">'logDescription'</span><span class="s1">] = self.log_description</span>
        <span class="s1">json[</span><span class="s4">'logId'</span><span class="s1">] = self.log_id</span>
        <span class="s1">json[</span><span class="s4">'timestamp'</span><span class="s1">] = self.timestamp.to_json()</span>
        <span class="s1">json[</span><span class="s4">'hashAlgorithm'</span><span class="s1">] = self.hash_algorithm</span>
        <span class="s1">json[</span><span class="s4">'signatureAlgorithm'</span><span class="s1">] = self.signature_algorithm</span>
        <span class="s1">json[</span><span class="s4">'signatureData'</span><span class="s1">] = self.signature_data</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">status=str(json[</span><span class="s4">'status'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">origin=str(json[</span><span class="s4">'origin'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">log_description=str(json[</span><span class="s4">'logDescription'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">log_id=str(json[</span><span class="s4">'logId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=TimeSinceEpoch.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">hash_algorithm=str(json[</span><span class="s4">'hashAlgorithm'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">signature_algorithm=str(json[</span><span class="s4">'signatureAlgorithm'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">signature_data=str(json[</span><span class="s4">'signatureData'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SecurityDetails:</span>
    <span class="s3">''' 
    Security details about a request. 
    '''</span>
    <span class="s0">#: Protocol name (e.g. &quot;TLS 1.2&quot; or &quot;QUIC&quot;).</span>
    <span class="s1">protocol: str</span>

    <span class="s0">#: Key Exchange used by the connection, or the empty string if not applicable.</span>
    <span class="s1">key_exchange: str</span>

    <span class="s0">#: Cipher name.</span>
    <span class="s1">cipher: str</span>

    <span class="s0">#: Certificate ID value.</span>
    <span class="s1">certificate_id: security.CertificateId</span>

    <span class="s0">#: Certificate subject name.</span>
    <span class="s1">subject_name: str</span>

    <span class="s0">#: Subject Alternative Name (SAN) DNS names and IP addresses.</span>
    <span class="s1">san_list: typing.List[str]</span>

    <span class="s0">#: Name of the issuing CA.</span>
    <span class="s1">issuer: str</span>

    <span class="s0">#: Certificate valid from date.</span>
    <span class="s1">valid_from: TimeSinceEpoch</span>

    <span class="s0">#: Certificate valid to (expiration) date</span>
    <span class="s1">valid_to: TimeSinceEpoch</span>

    <span class="s0">#: List of signed certificate timestamps (SCTs).</span>
    <span class="s1">signed_certificate_timestamp_list: typing.List[SignedCertificateTimestamp]</span>

    <span class="s0">#: Whether the request complied with Certificate Transparency policy</span>
    <span class="s1">certificate_transparency_compliance: CertificateTransparencyCompliance</span>

    <span class="s0">#: (EC)DH group used by the connection, if applicable.</span>
    <span class="s1">key_exchange_group: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: TLS MAC. Note that AEAD ciphers do not have separate MACs.</span>
    <span class="s1">mac: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'protocol'</span><span class="s1">] = self.protocol</span>
        <span class="s1">json[</span><span class="s4">'keyExchange'</span><span class="s1">] = self.key_exchange</span>
        <span class="s1">json[</span><span class="s4">'cipher'</span><span class="s1">] = self.cipher</span>
        <span class="s1">json[</span><span class="s4">'certificateId'</span><span class="s1">] = self.certificate_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'subjectName'</span><span class="s1">] = self.subject_name</span>
        <span class="s1">json[</span><span class="s4">'sanList'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.san_list]</span>
        <span class="s1">json[</span><span class="s4">'issuer'</span><span class="s1">] = self.issuer</span>
        <span class="s1">json[</span><span class="s4">'validFrom'</span><span class="s1">] = self.valid_from.to_json()</span>
        <span class="s1">json[</span><span class="s4">'validTo'</span><span class="s1">] = self.valid_to.to_json()</span>
        <span class="s1">json[</span><span class="s4">'signedCertificateTimestampList'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.signed_certificate_timestamp_list]</span>
        <span class="s1">json[</span><span class="s4">'certificateTransparencyCompliance'</span><span class="s1">] = self.certificate_transparency_compliance.to_json()</span>
        <span class="s2">if </span><span class="s1">self.key_exchange_group </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'keyExchangeGroup'</span><span class="s1">] = self.key_exchange_group</span>
        <span class="s2">if </span><span class="s1">self.mac </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'mac'</span><span class="s1">] = self.mac</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">protocol=str(json[</span><span class="s4">'protocol'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">key_exchange=str(json[</span><span class="s4">'keyExchange'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">cipher=str(json[</span><span class="s4">'cipher'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">certificate_id=security.CertificateId.from_json(json[</span><span class="s4">'certificateId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">subject_name=str(json[</span><span class="s4">'subjectName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">san_list=[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'sanList'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">issuer=str(json[</span><span class="s4">'issuer'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">valid_from=TimeSinceEpoch.from_json(json[</span><span class="s4">'validFrom'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">valid_to=TimeSinceEpoch.from_json(json[</span><span class="s4">'validTo'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">signed_certificate_timestamp_list=[SignedCertificateTimestamp.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'signedCertificateTimestampList'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">certificate_transparency_compliance=CertificateTransparencyCompliance.from_json(json[</span><span class="s4">'certificateTransparencyCompliance'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">key_exchange_group=str(json[</span><span class="s4">'keyExchangeGroup'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'keyExchangeGroup' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">mac=str(json[</span><span class="s4">'mac'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'mac' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">CertificateTransparencyCompliance(enum.Enum):</span>
    <span class="s3">''' 
    Whether the request complied with Certificate Transparency policy. 
    '''</span>
    <span class="s1">UNKNOWN = </span><span class="s4">&quot;unknown&quot;</span>
    <span class="s1">NOT_COMPLIANT = </span><span class="s4">&quot;not-compliant&quot;</span>
    <span class="s1">COMPLIANT = </span><span class="s4">&quot;compliant&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">BlockedReason(enum.Enum):</span>
    <span class="s3">''' 
    The reason why request was blocked. 
    '''</span>
    <span class="s1">OTHER = </span><span class="s4">&quot;other&quot;</span>
    <span class="s1">CSP = </span><span class="s4">&quot;csp&quot;</span>
    <span class="s1">MIXED_CONTENT = </span><span class="s4">&quot;mixed-content&quot;</span>
    <span class="s1">ORIGIN = </span><span class="s4">&quot;origin&quot;</span>
    <span class="s1">INSPECTOR = </span><span class="s4">&quot;inspector&quot;</span>
    <span class="s1">SUBRESOURCE_FILTER = </span><span class="s4">&quot;subresource-filter&quot;</span>
    <span class="s1">CONTENT_TYPE = </span><span class="s4">&quot;content-type&quot;</span>
    <span class="s1">COEP_FRAME_RESOURCE_NEEDS_COEP_HEADER = </span><span class="s4">&quot;coep-frame-resource-needs-coep-header&quot;</span>
    <span class="s1">COOP_SANDBOXED_IFRAME_CANNOT_NAVIGATE_TO_COOP_PAGE = </span><span class="s4">&quot;coop-sandboxed-iframe-cannot-navigate-to-coop-page&quot;</span>
    <span class="s1">CORP_NOT_SAME_ORIGIN = </span><span class="s4">&quot;corp-not-same-origin&quot;</span>
    <span class="s1">CORP_NOT_SAME_ORIGIN_AFTER_DEFAULTED_TO_SAME_ORIGIN_BY_COEP = </span><span class="s4">&quot;corp-not-same-origin-after-defaulted-to-same-origin-by-coep&quot;</span>
    <span class="s1">CORP_NOT_SAME_SITE = </span><span class="s4">&quot;corp-not-same-site&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">CorsError(enum.Enum):</span>
    <span class="s3">''' 
    The reason why request was blocked. 
    '''</span>
    <span class="s1">DISALLOWED_BY_MODE = </span><span class="s4">&quot;DisallowedByMode&quot;</span>
    <span class="s1">INVALID_RESPONSE = </span><span class="s4">&quot;InvalidResponse&quot;</span>
    <span class="s1">WILDCARD_ORIGIN_NOT_ALLOWED = </span><span class="s4">&quot;WildcardOriginNotAllowed&quot;</span>
    <span class="s1">MISSING_ALLOW_ORIGIN_HEADER = </span><span class="s4">&quot;MissingAllowOriginHeader&quot;</span>
    <span class="s1">MULTIPLE_ALLOW_ORIGIN_VALUES = </span><span class="s4">&quot;MultipleAllowOriginValues&quot;</span>
    <span class="s1">INVALID_ALLOW_ORIGIN_VALUE = </span><span class="s4">&quot;InvalidAllowOriginValue&quot;</span>
    <span class="s1">ALLOW_ORIGIN_MISMATCH = </span><span class="s4">&quot;AllowOriginMismatch&quot;</span>
    <span class="s1">INVALID_ALLOW_CREDENTIALS = </span><span class="s4">&quot;InvalidAllowCredentials&quot;</span>
    <span class="s1">CORS_DISABLED_SCHEME = </span><span class="s4">&quot;CorsDisabledScheme&quot;</span>
    <span class="s1">PREFLIGHT_INVALID_STATUS = </span><span class="s4">&quot;PreflightInvalidStatus&quot;</span>
    <span class="s1">PREFLIGHT_DISALLOWED_REDIRECT = </span><span class="s4">&quot;PreflightDisallowedRedirect&quot;</span>
    <span class="s1">PREFLIGHT_WILDCARD_ORIGIN_NOT_ALLOWED = </span><span class="s4">&quot;PreflightWildcardOriginNotAllowed&quot;</span>
    <span class="s1">PREFLIGHT_MISSING_ALLOW_ORIGIN_HEADER = </span><span class="s4">&quot;PreflightMissingAllowOriginHeader&quot;</span>
    <span class="s1">PREFLIGHT_MULTIPLE_ALLOW_ORIGIN_VALUES = </span><span class="s4">&quot;PreflightMultipleAllowOriginValues&quot;</span>
    <span class="s1">PREFLIGHT_INVALID_ALLOW_ORIGIN_VALUE = </span><span class="s4">&quot;PreflightInvalidAllowOriginValue&quot;</span>
    <span class="s1">PREFLIGHT_ALLOW_ORIGIN_MISMATCH = </span><span class="s4">&quot;PreflightAllowOriginMismatch&quot;</span>
    <span class="s1">PREFLIGHT_INVALID_ALLOW_CREDENTIALS = </span><span class="s4">&quot;PreflightInvalidAllowCredentials&quot;</span>
    <span class="s1">PREFLIGHT_MISSING_ALLOW_EXTERNAL = </span><span class="s4">&quot;PreflightMissingAllowExternal&quot;</span>
    <span class="s1">PREFLIGHT_INVALID_ALLOW_EXTERNAL = </span><span class="s4">&quot;PreflightInvalidAllowExternal&quot;</span>
    <span class="s1">INVALID_ALLOW_METHODS_PREFLIGHT_RESPONSE = </span><span class="s4">&quot;InvalidAllowMethodsPreflightResponse&quot;</span>
    <span class="s1">INVALID_ALLOW_HEADERS_PREFLIGHT_RESPONSE = </span><span class="s4">&quot;InvalidAllowHeadersPreflightResponse&quot;</span>
    <span class="s1">METHOD_DISALLOWED_BY_PREFLIGHT_RESPONSE = </span><span class="s4">&quot;MethodDisallowedByPreflightResponse&quot;</span>
    <span class="s1">HEADER_DISALLOWED_BY_PREFLIGHT_RESPONSE = </span><span class="s4">&quot;HeaderDisallowedByPreflightResponse&quot;</span>
    <span class="s1">REDIRECT_CONTAINS_CREDENTIALS = </span><span class="s4">&quot;RedirectContainsCredentials&quot;</span>
    <span class="s1">INSECURE_PRIVATE_NETWORK = </span><span class="s4">&quot;InsecurePrivateNetwork&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CorsErrorStatus:</span>
    <span class="s1">cors_error: CorsError</span>

    <span class="s1">failed_parameter: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'corsError'</span><span class="s1">] = self.cors_error.to_json()</span>
        <span class="s1">json[</span><span class="s4">'failedParameter'</span><span class="s1">] = self.failed_parameter</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">cors_error=CorsError.from_json(json[</span><span class="s4">'corsError'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">failed_parameter=str(json[</span><span class="s4">'failedParameter'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">ServiceWorkerResponseSource(enum.Enum):</span>
    <span class="s3">''' 
    Source of serviceworker response. 
    '''</span>
    <span class="s1">CACHE_STORAGE = </span><span class="s4">&quot;cache-storage&quot;</span>
    <span class="s1">HTTP_CACHE = </span><span class="s4">&quot;http-cache&quot;</span>
    <span class="s1">FALLBACK_CODE = </span><span class="s4">&quot;fallback-code&quot;</span>
    <span class="s1">NETWORK = </span><span class="s4">&quot;network&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">TrustTokenParams:</span>
    <span class="s3">''' 
    Determines what type of Trust Token operation is executed and 
    depending on the type, some additional parameters. The values 
    are specified in third_party/blink/renderer/core/fetch/trust_token.idl. 
    '''</span>
    <span class="s1">type_: TrustTokenOperationType</span>

    <span class="s0">#: Only set for &quot;token-redemption&quot; type and determine whether</span>
    <span class="s0">#: to request a fresh SRR or use a still valid cached SRR.</span>
    <span class="s1">refresh_policy: str</span>

    <span class="s0">#: Origins of issuers from whom to request tokens or redemption</span>
    <span class="s0">#: records.</span>
    <span class="s1">issuers: typing.Optional[typing.List[str]] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_.to_json()</span>
        <span class="s1">json[</span><span class="s4">'refreshPolicy'</span><span class="s1">] = self.refresh_policy</span>
        <span class="s2">if </span><span class="s1">self.issuers </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'issuers'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.issuers]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">type_=TrustTokenOperationType.from_json(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">refresh_policy=str(json[</span><span class="s4">'refreshPolicy'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">issuers=[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'issuers'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'issuers' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TrustTokenOperationType(enum.Enum):</span>
    <span class="s1">ISSUANCE = </span><span class="s4">&quot;Issuance&quot;</span>
    <span class="s1">REDEMPTION = </span><span class="s4">&quot;Redemption&quot;</span>
    <span class="s1">SIGNING = </span><span class="s4">&quot;Signing&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Response:</span>
    <span class="s3">''' 
    HTTP response data. 
    '''</span>
    <span class="s0">#: Response URL. This URL can be different from CachedResource.url in case of redirect.</span>
    <span class="s1">url: str</span>

    <span class="s0">#: HTTP response status code.</span>
    <span class="s1">status: int</span>

    <span class="s0">#: HTTP response status text.</span>
    <span class="s1">status_text: str</span>

    <span class="s0">#: HTTP response headers.</span>
    <span class="s1">headers: Headers</span>

    <span class="s0">#: Resource mimeType as determined by the browser.</span>
    <span class="s1">mime_type: str</span>

    <span class="s0">#: Specifies whether physical connection was actually reused for this request.</span>
    <span class="s1">connection_reused: bool</span>

    <span class="s0">#: Physical connection id that was actually used for this request.</span>
    <span class="s1">connection_id: float</span>

    <span class="s0">#: Total number of bytes received for this request so far.</span>
    <span class="s1">encoded_data_length: float</span>

    <span class="s0">#: Security state of the request resource.</span>
    <span class="s1">security_state: security.SecurityState</span>

    <span class="s0">#: HTTP response headers text.</span>
    <span class="s1">headers_text: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Refined HTTP request headers that were actually transmitted over the network.</span>
    <span class="s1">request_headers: typing.Optional[Headers] = </span><span class="s2">None</span>

    <span class="s0">#: HTTP request headers text.</span>
    <span class="s1">request_headers_text: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Remote IP address.</span>
    <span class="s1">remote_ip_address: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Remote port.</span>
    <span class="s1">remote_port: typing.Optional[int] = </span><span class="s2">None</span>

    <span class="s0">#: Specifies that the request was served from the disk cache.</span>
    <span class="s1">from_disk_cache: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Specifies that the request was served from the ServiceWorker.</span>
    <span class="s1">from_service_worker: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Specifies that the request was served from the prefetch cache.</span>
    <span class="s1">from_prefetch_cache: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Timing information for the given request.</span>
    <span class="s1">timing: typing.Optional[ResourceTiming] = </span><span class="s2">None</span>

    <span class="s0">#: Response source of response from ServiceWorker.</span>
    <span class="s1">service_worker_response_source: typing.Optional[ServiceWorkerResponseSource] = </span><span class="s2">None</span>

    <span class="s0">#: The time at which the returned response was generated.</span>
    <span class="s1">response_time: typing.Optional[TimeSinceEpoch] = </span><span class="s2">None</span>

    <span class="s0">#: Cache Storage Cache Name.</span>
    <span class="s1">cache_storage_cache_name: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Protocol used to fetch this request.</span>
    <span class="s1">protocol: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Security details for the request.</span>
    <span class="s1">security_details: typing.Optional[SecurityDetails] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s1">json[</span><span class="s4">'status'</span><span class="s1">] = self.status</span>
        <span class="s1">json[</span><span class="s4">'statusText'</span><span class="s1">] = self.status_text</span>
        <span class="s1">json[</span><span class="s4">'headers'</span><span class="s1">] = self.headers.to_json()</span>
        <span class="s1">json[</span><span class="s4">'mimeType'</span><span class="s1">] = self.mime_type</span>
        <span class="s1">json[</span><span class="s4">'connectionReused'</span><span class="s1">] = self.connection_reused</span>
        <span class="s1">json[</span><span class="s4">'connectionId'</span><span class="s1">] = self.connection_id</span>
        <span class="s1">json[</span><span class="s4">'encodedDataLength'</span><span class="s1">] = self.encoded_data_length</span>
        <span class="s1">json[</span><span class="s4">'securityState'</span><span class="s1">] = self.security_state.to_json()</span>
        <span class="s2">if </span><span class="s1">self.headers_text </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'headersText'</span><span class="s1">] = self.headers_text</span>
        <span class="s2">if </span><span class="s1">self.request_headers </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'requestHeaders'</span><span class="s1">] = self.request_headers.to_json()</span>
        <span class="s2">if </span><span class="s1">self.request_headers_text </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'requestHeadersText'</span><span class="s1">] = self.request_headers_text</span>
        <span class="s2">if </span><span class="s1">self.remote_ip_address </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'remoteIPAddress'</span><span class="s1">] = self.remote_ip_address</span>
        <span class="s2">if </span><span class="s1">self.remote_port </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'remotePort'</span><span class="s1">] = self.remote_port</span>
        <span class="s2">if </span><span class="s1">self.from_disk_cache </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'fromDiskCache'</span><span class="s1">] = self.from_disk_cache</span>
        <span class="s2">if </span><span class="s1">self.from_service_worker </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'fromServiceWorker'</span><span class="s1">] = self.from_service_worker</span>
        <span class="s2">if </span><span class="s1">self.from_prefetch_cache </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'fromPrefetchCache'</span><span class="s1">] = self.from_prefetch_cache</span>
        <span class="s2">if </span><span class="s1">self.timing </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'timing'</span><span class="s1">] = self.timing.to_json()</span>
        <span class="s2">if </span><span class="s1">self.service_worker_response_source </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'serviceWorkerResponseSource'</span><span class="s1">] = self.service_worker_response_source.to_json()</span>
        <span class="s2">if </span><span class="s1">self.response_time </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'responseTime'</span><span class="s1">] = self.response_time.to_json()</span>
        <span class="s2">if </span><span class="s1">self.cache_storage_cache_name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'cacheStorageCacheName'</span><span class="s1">] = self.cache_storage_cache_name</span>
        <span class="s2">if </span><span class="s1">self.protocol </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'protocol'</span><span class="s1">] = self.protocol</span>
        <span class="s2">if </span><span class="s1">self.security_details </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'securityDetails'</span><span class="s1">] = self.security_details.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">status=int(json[</span><span class="s4">'status'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">status_text=str(json[</span><span class="s4">'statusText'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">headers=Headers.from_json(json[</span><span class="s4">'headers'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">mime_type=str(json[</span><span class="s4">'mimeType'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">connection_reused=bool(json[</span><span class="s4">'connectionReused'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">connection_id=float(json[</span><span class="s4">'connectionId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">encoded_data_length=float(json[</span><span class="s4">'encodedDataLength'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">security_state=security.SecurityState.from_json(json[</span><span class="s4">'securityState'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">headers_text=str(json[</span><span class="s4">'headersText'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'headersText' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">request_headers=Headers.from_json(json[</span><span class="s4">'requestHeaders'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'requestHeaders' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">request_headers_text=str(json[</span><span class="s4">'requestHeadersText'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'requestHeadersText' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">remote_ip_address=str(json[</span><span class="s4">'remoteIPAddress'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'remoteIPAddress' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">remote_port=int(json[</span><span class="s4">'remotePort'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'remotePort' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">from_disk_cache=bool(json[</span><span class="s4">'fromDiskCache'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'fromDiskCache' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">from_service_worker=bool(json[</span><span class="s4">'fromServiceWorker'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'fromServiceWorker' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">from_prefetch_cache=bool(json[</span><span class="s4">'fromPrefetchCache'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'fromPrefetchCache' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">timing=ResourceTiming.from_json(json[</span><span class="s4">'timing'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'timing' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">service_worker_response_source=ServiceWorkerResponseSource.from_json(json[</span><span class="s4">'serviceWorkerResponseSource'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'serviceWorkerResponseSource' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">response_time=TimeSinceEpoch.from_json(json[</span><span class="s4">'responseTime'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'responseTime' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">cache_storage_cache_name=str(json[</span><span class="s4">'cacheStorageCacheName'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'cacheStorageCacheName' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">protocol=str(json[</span><span class="s4">'protocol'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'protocol' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">security_details=SecurityDetails.from_json(json[</span><span class="s4">'securityDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'securityDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketRequest:</span>
    <span class="s3">''' 
    WebSocket request data. 
    '''</span>
    <span class="s0">#: HTTP request headers.</span>
    <span class="s1">headers: Headers</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'headers'</span><span class="s1">] = self.headers.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">headers=Headers.from_json(json[</span><span class="s4">'headers'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketResponse:</span>
    <span class="s3">''' 
    WebSocket response data. 
    '''</span>
    <span class="s0">#: HTTP response status code.</span>
    <span class="s1">status: int</span>

    <span class="s0">#: HTTP response status text.</span>
    <span class="s1">status_text: str</span>

    <span class="s0">#: HTTP response headers.</span>
    <span class="s1">headers: Headers</span>

    <span class="s0">#: HTTP response headers text.</span>
    <span class="s1">headers_text: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: HTTP request headers.</span>
    <span class="s1">request_headers: typing.Optional[Headers] = </span><span class="s2">None</span>

    <span class="s0">#: HTTP request headers text.</span>
    <span class="s1">request_headers_text: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'status'</span><span class="s1">] = self.status</span>
        <span class="s1">json[</span><span class="s4">'statusText'</span><span class="s1">] = self.status_text</span>
        <span class="s1">json[</span><span class="s4">'headers'</span><span class="s1">] = self.headers.to_json()</span>
        <span class="s2">if </span><span class="s1">self.headers_text </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'headersText'</span><span class="s1">] = self.headers_text</span>
        <span class="s2">if </span><span class="s1">self.request_headers </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'requestHeaders'</span><span class="s1">] = self.request_headers.to_json()</span>
        <span class="s2">if </span><span class="s1">self.request_headers_text </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'requestHeadersText'</span><span class="s1">] = self.request_headers_text</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">status=int(json[</span><span class="s4">'status'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">status_text=str(json[</span><span class="s4">'statusText'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">headers=Headers.from_json(json[</span><span class="s4">'headers'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">headers_text=str(json[</span><span class="s4">'headersText'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'headersText' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">request_headers=Headers.from_json(json[</span><span class="s4">'requestHeaders'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'requestHeaders' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">request_headers_text=str(json[</span><span class="s4">'requestHeadersText'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'requestHeadersText' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketFrame:</span>
    <span class="s3">''' 
    WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests. 
    '''</span>
    <span class="s0">#: WebSocket message opcode.</span>
    <span class="s1">opcode: float</span>

    <span class="s0">#: WebSocket message mask.</span>
    <span class="s1">mask: bool</span>

    <span class="s0">#: WebSocket message payload data.</span>
    <span class="s0">#: If the opcode is 1, this is a text message and payloadData is a UTF-8 string.</span>
    <span class="s0">#: If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.</span>
    <span class="s1">payload_data: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'opcode'</span><span class="s1">] = self.opcode</span>
        <span class="s1">json[</span><span class="s4">'mask'</span><span class="s1">] = self.mask</span>
        <span class="s1">json[</span><span class="s4">'payloadData'</span><span class="s1">] = self.payload_data</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">opcode=float(json[</span><span class="s4">'opcode'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">mask=bool(json[</span><span class="s4">'mask'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">payload_data=str(json[</span><span class="s4">'payloadData'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CachedResource:</span>
    <span class="s3">''' 
    Information about the cached resource. 
    '''</span>
    <span class="s0">#: Resource URL. This is the url of the original network request.</span>
    <span class="s1">url: str</span>

    <span class="s0">#: Type of this resource.</span>
    <span class="s1">type_: ResourceType</span>

    <span class="s0">#: Cached response body size.</span>
    <span class="s1">body_size: float</span>

    <span class="s0">#: Cached response data.</span>
    <span class="s1">response: typing.Optional[Response] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_.to_json()</span>
        <span class="s1">json[</span><span class="s4">'bodySize'</span><span class="s1">] = self.body_size</span>
        <span class="s2">if </span><span class="s1">self.response </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'response'</span><span class="s1">] = self.response.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">type_=ResourceType.from_json(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">body_size=float(json[</span><span class="s4">'bodySize'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">response=Response.from_json(json[</span><span class="s4">'response'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'response' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Initiator:</span>
    <span class="s3">''' 
    Information about the request initiator. 
    '''</span>
    <span class="s0">#: Type of this initiator.</span>
    <span class="s1">type_: str</span>

    <span class="s0">#: Initiator JavaScript stack trace, set for Script only.</span>
    <span class="s1">stack: typing.Optional[runtime.StackTrace] = </span><span class="s2">None</span>

    <span class="s0">#: Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.</span>
    <span class="s1">url: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Initiator line number, set for Parser type or for Script type (when script is importing</span>
    <span class="s0">#: module) (0-based).</span>
    <span class="s1">line_number: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s0">#: Initiator column number, set for Parser type or for Script type (when script is importing</span>
    <span class="s0">#: module) (0-based).</span>
    <span class="s1">column_number: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s0">#: Set if another request triggered this request (e.g. preflight).</span>
    <span class="s1">request_id: typing.Optional[RequestId] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s2">if </span><span class="s1">self.stack </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'stack'</span><span class="s1">] = self.stack.to_json()</span>
        <span class="s2">if </span><span class="s1">self.url </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s2">if </span><span class="s1">self.line_number </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'lineNumber'</span><span class="s1">] = self.line_number</span>
        <span class="s2">if </span><span class="s1">self.column_number </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'columnNumber'</span><span class="s1">] = self.column_number</span>
        <span class="s2">if </span><span class="s1">self.request_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'requestId'</span><span class="s1">] = self.request_id.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">stack=runtime.StackTrace.from_json(json[</span><span class="s4">'stack'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'stack' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'url' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">line_number=float(json[</span><span class="s4">'lineNumber'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'lineNumber' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">column_number=float(json[</span><span class="s4">'columnNumber'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'columnNumber' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'requestId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Cookie:</span>
    <span class="s3">''' 
    Cookie object 
    '''</span>
    <span class="s0">#: Cookie name.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: Cookie value.</span>
    <span class="s1">value: str</span>

    <span class="s0">#: Cookie domain.</span>
    <span class="s1">domain: str</span>

    <span class="s0">#: Cookie path.</span>
    <span class="s1">path: str</span>

    <span class="s0">#: Cookie expiration date as the number of seconds since the UNIX epoch.</span>
    <span class="s1">expires: float</span>

    <span class="s0">#: Cookie size.</span>
    <span class="s1">size: int</span>

    <span class="s0">#: True if cookie is http-only.</span>
    <span class="s1">http_only: bool</span>

    <span class="s0">#: True if cookie is secure.</span>
    <span class="s1">secure: bool</span>

    <span class="s0">#: True in case of session cookie.</span>
    <span class="s1">session: bool</span>

    <span class="s0">#: Cookie Priority</span>
    <span class="s1">priority: CookiePriority</span>

    <span class="s0">#: True if cookie is SameParty.</span>
    <span class="s1">same_party: bool</span>

    <span class="s0">#: Cookie source scheme type.</span>
    <span class="s1">source_scheme: CookieSourceScheme</span>

    <span class="s0">#: Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.</span>
    <span class="s0">#: An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.</span>
    <span class="s0">#: This is a temporary ability and it will be removed in the future.</span>
    <span class="s1">source_port: int</span>

    <span class="s0">#: Cookie SameSite type.</span>
    <span class="s1">same_site: typing.Optional[CookieSameSite] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s1">json[</span><span class="s4">'domain'</span><span class="s1">] = self.domain</span>
        <span class="s1">json[</span><span class="s4">'path'</span><span class="s1">] = self.path</span>
        <span class="s1">json[</span><span class="s4">'expires'</span><span class="s1">] = self.expires</span>
        <span class="s1">json[</span><span class="s4">'size'</span><span class="s1">] = self.size</span>
        <span class="s1">json[</span><span class="s4">'httpOnly'</span><span class="s1">] = self.http_only</span>
        <span class="s1">json[</span><span class="s4">'secure'</span><span class="s1">] = self.secure</span>
        <span class="s1">json[</span><span class="s4">'session'</span><span class="s1">] = self.session</span>
        <span class="s1">json[</span><span class="s4">'priority'</span><span class="s1">] = self.priority.to_json()</span>
        <span class="s1">json[</span><span class="s4">'sameParty'</span><span class="s1">] = self.same_party</span>
        <span class="s1">json[</span><span class="s4">'sourceScheme'</span><span class="s1">] = self.source_scheme.to_json()</span>
        <span class="s1">json[</span><span class="s4">'sourcePort'</span><span class="s1">] = self.source_port</span>
        <span class="s2">if </span><span class="s1">self.same_site </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'sameSite'</span><span class="s1">] = self.same_site.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=str(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">domain=str(json[</span><span class="s4">'domain'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">path=str(json[</span><span class="s4">'path'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">expires=float(json[</span><span class="s4">'expires'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">size=int(json[</span><span class="s4">'size'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">http_only=bool(json[</span><span class="s4">'httpOnly'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">secure=bool(json[</span><span class="s4">'secure'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">session=bool(json[</span><span class="s4">'session'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">priority=CookiePriority.from_json(json[</span><span class="s4">'priority'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">same_party=bool(json[</span><span class="s4">'sameParty'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">source_scheme=CookieSourceScheme.from_json(json[</span><span class="s4">'sourceScheme'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">source_port=int(json[</span><span class="s4">'sourcePort'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">same_site=CookieSameSite.from_json(json[</span><span class="s4">'sameSite'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'sameSite' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">SetCookieBlockedReason(enum.Enum):</span>
    <span class="s3">''' 
    Types of reasons why a cookie may not be stored from a response. 
    '''</span>
    <span class="s1">SECURE_ONLY = </span><span class="s4">&quot;SecureOnly&quot;</span>
    <span class="s1">SAME_SITE_STRICT = </span><span class="s4">&quot;SameSiteStrict&quot;</span>
    <span class="s1">SAME_SITE_LAX = </span><span class="s4">&quot;SameSiteLax&quot;</span>
    <span class="s1">SAME_SITE_UNSPECIFIED_TREATED_AS_LAX = </span><span class="s4">&quot;SameSiteUnspecifiedTreatedAsLax&quot;</span>
    <span class="s1">SAME_SITE_NONE_INSECURE = </span><span class="s4">&quot;SameSiteNoneInsecure&quot;</span>
    <span class="s1">USER_PREFERENCES = </span><span class="s4">&quot;UserPreferences&quot;</span>
    <span class="s1">SYNTAX_ERROR = </span><span class="s4">&quot;SyntaxError&quot;</span>
    <span class="s1">SCHEME_NOT_SUPPORTED = </span><span class="s4">&quot;SchemeNotSupported&quot;</span>
    <span class="s1">OVERWRITE_SECURE = </span><span class="s4">&quot;OverwriteSecure&quot;</span>
    <span class="s1">INVALID_DOMAIN = </span><span class="s4">&quot;InvalidDomain&quot;</span>
    <span class="s1">INVALID_PREFIX = </span><span class="s4">&quot;InvalidPrefix&quot;</span>
    <span class="s1">UNKNOWN_ERROR = </span><span class="s4">&quot;UnknownError&quot;</span>
    <span class="s1">SCHEMEFUL_SAME_SITE_STRICT = </span><span class="s4">&quot;SchemefulSameSiteStrict&quot;</span>
    <span class="s1">SCHEMEFUL_SAME_SITE_LAX = </span><span class="s4">&quot;SchemefulSameSiteLax&quot;</span>
    <span class="s1">SCHEMEFUL_SAME_SITE_UNSPECIFIED_TREATED_AS_LAX = </span><span class="s4">&quot;SchemefulSameSiteUnspecifiedTreatedAsLax&quot;</span>
    <span class="s1">SAME_PARTY_FROM_CROSS_PARTY_CONTEXT = </span><span class="s4">&quot;SamePartyFromCrossPartyContext&quot;</span>
    <span class="s1">SAME_PARTY_CONFLICTS_WITH_OTHER_ATTRIBUTES = </span><span class="s4">&quot;SamePartyConflictsWithOtherAttributes&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">CookieBlockedReason(enum.Enum):</span>
    <span class="s3">''' 
    Types of reasons why a cookie may not be sent with a request. 
    '''</span>
    <span class="s1">SECURE_ONLY = </span><span class="s4">&quot;SecureOnly&quot;</span>
    <span class="s1">NOT_ON_PATH = </span><span class="s4">&quot;NotOnPath&quot;</span>
    <span class="s1">DOMAIN_MISMATCH = </span><span class="s4">&quot;DomainMismatch&quot;</span>
    <span class="s1">SAME_SITE_STRICT = </span><span class="s4">&quot;SameSiteStrict&quot;</span>
    <span class="s1">SAME_SITE_LAX = </span><span class="s4">&quot;SameSiteLax&quot;</span>
    <span class="s1">SAME_SITE_UNSPECIFIED_TREATED_AS_LAX = </span><span class="s4">&quot;SameSiteUnspecifiedTreatedAsLax&quot;</span>
    <span class="s1">SAME_SITE_NONE_INSECURE = </span><span class="s4">&quot;SameSiteNoneInsecure&quot;</span>
    <span class="s1">USER_PREFERENCES = </span><span class="s4">&quot;UserPreferences&quot;</span>
    <span class="s1">UNKNOWN_ERROR = </span><span class="s4">&quot;UnknownError&quot;</span>
    <span class="s1">SCHEMEFUL_SAME_SITE_STRICT = </span><span class="s4">&quot;SchemefulSameSiteStrict&quot;</span>
    <span class="s1">SCHEMEFUL_SAME_SITE_LAX = </span><span class="s4">&quot;SchemefulSameSiteLax&quot;</span>
    <span class="s1">SCHEMEFUL_SAME_SITE_UNSPECIFIED_TREATED_AS_LAX = </span><span class="s4">&quot;SchemefulSameSiteUnspecifiedTreatedAsLax&quot;</span>
    <span class="s1">SAME_PARTY_FROM_CROSS_PARTY_CONTEXT = </span><span class="s4">&quot;SamePartyFromCrossPartyContext&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">BlockedSetCookieWithReason:</span>
    <span class="s3">''' 
    A cookie which was not stored from a response with the corresponding reason. 
    '''</span>
    <span class="s0">#: The reason(s) this cookie was blocked.</span>
    <span class="s1">blocked_reasons: typing.List[SetCookieBlockedReason]</span>

    <span class="s0">#: The string representing this individual cookie as it would appear in the header.</span>
    <span class="s0">#: This is not the entire &quot;cookie&quot; or &quot;set-cookie&quot; header which could have multiple cookies.</span>
    <span class="s1">cookie_line: str</span>

    <span class="s0">#: The cookie object which represents the cookie which was not stored. It is optional because</span>
    <span class="s0">#: sometimes complete cookie information is not available, such as in the case of parsing</span>
    <span class="s0">#: errors.</span>
    <span class="s1">cookie: typing.Optional[Cookie] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'blockedReasons'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.blocked_reasons]</span>
        <span class="s1">json[</span><span class="s4">'cookieLine'</span><span class="s1">] = self.cookie_line</span>
        <span class="s2">if </span><span class="s1">self.cookie </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'cookie'</span><span class="s1">] = self.cookie.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">blocked_reasons=[SetCookieBlockedReason.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'blockedReasons'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">cookie_line=str(json[</span><span class="s4">'cookieLine'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">cookie=Cookie.from_json(json[</span><span class="s4">'cookie'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'cookie' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">BlockedCookieWithReason:</span>
    <span class="s3">''' 
    A cookie with was not sent with a request with the corresponding reason. 
    '''</span>
    <span class="s0">#: The reason(s) the cookie was blocked.</span>
    <span class="s1">blocked_reasons: typing.List[CookieBlockedReason]</span>

    <span class="s0">#: The cookie object representing the cookie which was not sent.</span>
    <span class="s1">cookie: Cookie</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'blockedReasons'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.blocked_reasons]</span>
        <span class="s1">json[</span><span class="s4">'cookie'</span><span class="s1">] = self.cookie.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">blocked_reasons=[CookieBlockedReason.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'blockedReasons'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">cookie=Cookie.from_json(json[</span><span class="s4">'cookie'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CookieParam:</span>
    <span class="s3">''' 
    Cookie parameter object 
    '''</span>
    <span class="s0">#: Cookie name.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: Cookie value.</span>
    <span class="s1">value: str</span>

    <span class="s0">#: The request-URI to associate with the setting of the cookie. This value can affect the</span>
    <span class="s0">#: default domain, path, source port, and source scheme values of the created cookie.</span>
    <span class="s1">url: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Cookie domain.</span>
    <span class="s1">domain: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: Cookie path.</span>
    <span class="s1">path: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: True if cookie is secure.</span>
    <span class="s1">secure: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: True if cookie is http-only.</span>
    <span class="s1">http_only: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Cookie SameSite type.</span>
    <span class="s1">same_site: typing.Optional[CookieSameSite] = </span><span class="s2">None</span>

    <span class="s0">#: Cookie expiration date, session cookie if not set</span>
    <span class="s1">expires: typing.Optional[TimeSinceEpoch] = </span><span class="s2">None</span>

    <span class="s0">#: Cookie Priority.</span>
    <span class="s1">priority: typing.Optional[CookiePriority] = </span><span class="s2">None</span>

    <span class="s0">#: True if cookie is SameParty.</span>
    <span class="s1">same_party: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Cookie source scheme type.</span>
    <span class="s1">source_scheme: typing.Optional[CookieSourceScheme] = </span><span class="s2">None</span>

    <span class="s0">#: Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.</span>
    <span class="s0">#: An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.</span>
    <span class="s0">#: This is a temporary ability and it will be removed in the future.</span>
    <span class="s1">source_port: typing.Optional[int] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s2">if </span><span class="s1">self.url </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s2">if </span><span class="s1">self.domain </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'domain'</span><span class="s1">] = self.domain</span>
        <span class="s2">if </span><span class="s1">self.path </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'path'</span><span class="s1">] = self.path</span>
        <span class="s2">if </span><span class="s1">self.secure </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'secure'</span><span class="s1">] = self.secure</span>
        <span class="s2">if </span><span class="s1">self.http_only </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'httpOnly'</span><span class="s1">] = self.http_only</span>
        <span class="s2">if </span><span class="s1">self.same_site </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'sameSite'</span><span class="s1">] = self.same_site.to_json()</span>
        <span class="s2">if </span><span class="s1">self.expires </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'expires'</span><span class="s1">] = self.expires.to_json()</span>
        <span class="s2">if </span><span class="s1">self.priority </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'priority'</span><span class="s1">] = self.priority.to_json()</span>
        <span class="s2">if </span><span class="s1">self.same_party </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'sameParty'</span><span class="s1">] = self.same_party</span>
        <span class="s2">if </span><span class="s1">self.source_scheme </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'sourceScheme'</span><span class="s1">] = self.source_scheme.to_json()</span>
        <span class="s2">if </span><span class="s1">self.source_port </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'sourcePort'</span><span class="s1">] = self.source_port</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=str(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'url' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">domain=str(json[</span><span class="s4">'domain'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'domain' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">path=str(json[</span><span class="s4">'path'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'path' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">secure=bool(json[</span><span class="s4">'secure'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'secure' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">http_only=bool(json[</span><span class="s4">'httpOnly'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'httpOnly' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">same_site=CookieSameSite.from_json(json[</span><span class="s4">'sameSite'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'sameSite' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">expires=TimeSinceEpoch.from_json(json[</span><span class="s4">'expires'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'expires' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">priority=CookiePriority.from_json(json[</span><span class="s4">'priority'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'priority' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">same_party=bool(json[</span><span class="s4">'sameParty'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'sameParty' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">source_scheme=CookieSourceScheme.from_json(json[</span><span class="s4">'sourceScheme'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'sourceScheme' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">source_port=int(json[</span><span class="s4">'sourcePort'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'sourcePort' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">AuthChallenge:</span>
    <span class="s3">''' 
    Authorization challenge for HTTP status code 401 or 407. 
    '''</span>
    <span class="s0">#: Origin of the challenger.</span>
    <span class="s1">origin: str</span>

    <span class="s0">#: The authentication scheme used, such as basic or digest</span>
    <span class="s1">scheme: str</span>

    <span class="s0">#: The realm of the challenge. May be empty.</span>
    <span class="s1">realm: str</span>

    <span class="s0">#: Source of the authentication challenge.</span>
    <span class="s1">source: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'origin'</span><span class="s1">] = self.origin</span>
        <span class="s1">json[</span><span class="s4">'scheme'</span><span class="s1">] = self.scheme</span>
        <span class="s1">json[</span><span class="s4">'realm'</span><span class="s1">] = self.realm</span>
        <span class="s2">if </span><span class="s1">self.source </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'source'</span><span class="s1">] = self.source</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">origin=str(json[</span><span class="s4">'origin'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">scheme=str(json[</span><span class="s4">'scheme'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">realm=str(json[</span><span class="s4">'realm'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">source=str(json[</span><span class="s4">'source'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'source' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">AuthChallengeResponse:</span>
    <span class="s3">''' 
    Response to an AuthChallenge. 
    '''</span>
    <span class="s0">#: The decision on what to do in response to the authorization challenge.  Default means</span>
    <span class="s0">#: deferring to the default behavior of the net stack, which will likely either the Cancel</span>
    <span class="s0">#: authentication or display a popup dialog box.</span>
    <span class="s1">response: str</span>

    <span class="s0">#: The username to provide, possibly empty. Should only be set if response is</span>
    <span class="s0">#: ProvideCredentials.</span>
    <span class="s1">username: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: The password to provide, possibly empty. Should only be set if response is</span>
    <span class="s0">#: ProvideCredentials.</span>
    <span class="s1">password: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'response'</span><span class="s1">] = self.response</span>
        <span class="s2">if </span><span class="s1">self.username </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'username'</span><span class="s1">] = self.username</span>
        <span class="s2">if </span><span class="s1">self.password </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'password'</span><span class="s1">] = self.password</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">response=str(json[</span><span class="s4">'response'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">username=str(json[</span><span class="s4">'username'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'username' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">password=str(json[</span><span class="s4">'password'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'password' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">InterceptionStage(enum.Enum):</span>
    <span class="s3">''' 
    Stages of the interception to begin intercepting. Request will intercept before the request is 
    sent. Response will intercept after the response is received. 
    '''</span>
    <span class="s1">REQUEST = </span><span class="s4">&quot;Request&quot;</span>
    <span class="s1">HEADERS_RECEIVED = </span><span class="s4">&quot;HeadersReceived&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RequestPattern:</span>
    <span class="s3">''' 
    Request pattern for interception. 
    '''</span>
    <span class="s0">#: Wildcards ('*' -&gt; zero or more, '?' -&gt; exactly one) are allowed. Escape character is</span>
    <span class="s0">#: backslash. Omitting is equivalent to &quot;*&quot;.</span>
    <span class="s1">url_pattern: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: If set, only requests for matching resource types will be intercepted.</span>
    <span class="s1">resource_type: typing.Optional[ResourceType] = </span><span class="s2">None</span>

    <span class="s0">#: Stage at wich to begin intercepting requests. Default is Request.</span>
    <span class="s1">interception_stage: typing.Optional[InterceptionStage] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s2">if </span><span class="s1">self.url_pattern </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'urlPattern'</span><span class="s1">] = self.url_pattern</span>
        <span class="s2">if </span><span class="s1">self.resource_type </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'resourceType'</span><span class="s1">] = self.resource_type.to_json()</span>
        <span class="s2">if </span><span class="s1">self.interception_stage </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'interceptionStage'</span><span class="s1">] = self.interception_stage.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">url_pattern=str(json[</span><span class="s4">'urlPattern'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'urlPattern' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">resource_type=ResourceType.from_json(json[</span><span class="s4">'resourceType'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'resourceType' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">interception_stage=InterceptionStage.from_json(json[</span><span class="s4">'interceptionStage'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'interceptionStage' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SignedExchangeSignature:</span>
    <span class="s3">''' 
    Information about a signed exchange signature. 
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1 
    '''</span>
    <span class="s0">#: Signed exchange signature label.</span>
    <span class="s1">label: str</span>

    <span class="s0">#: The hex string of signed exchange signature.</span>
    <span class="s1">signature: str</span>

    <span class="s0">#: Signed exchange signature integrity.</span>
    <span class="s1">integrity: str</span>

    <span class="s0">#: Signed exchange signature validity Url.</span>
    <span class="s1">validity_url: str</span>

    <span class="s0">#: Signed exchange signature date.</span>
    <span class="s1">date: int</span>

    <span class="s0">#: Signed exchange signature expires.</span>
    <span class="s1">expires: int</span>

    <span class="s0">#: Signed exchange signature cert Url.</span>
    <span class="s1">cert_url: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: The hex string of signed exchange signature cert sha256.</span>
    <span class="s1">cert_sha256: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: The encoded certificates.</span>
    <span class="s1">certificates: typing.Optional[typing.List[str]] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'label'</span><span class="s1">] = self.label</span>
        <span class="s1">json[</span><span class="s4">'signature'</span><span class="s1">] = self.signature</span>
        <span class="s1">json[</span><span class="s4">'integrity'</span><span class="s1">] = self.integrity</span>
        <span class="s1">json[</span><span class="s4">'validityUrl'</span><span class="s1">] = self.validity_url</span>
        <span class="s1">json[</span><span class="s4">'date'</span><span class="s1">] = self.date</span>
        <span class="s1">json[</span><span class="s4">'expires'</span><span class="s1">] = self.expires</span>
        <span class="s2">if </span><span class="s1">self.cert_url </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'certUrl'</span><span class="s1">] = self.cert_url</span>
        <span class="s2">if </span><span class="s1">self.cert_sha256 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'certSha256'</span><span class="s1">] = self.cert_sha256</span>
        <span class="s2">if </span><span class="s1">self.certificates </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'certificates'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.certificates]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">label=str(json[</span><span class="s4">'label'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">signature=str(json[</span><span class="s4">'signature'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">integrity=str(json[</span><span class="s4">'integrity'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">validity_url=str(json[</span><span class="s4">'validityUrl'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">date=int(json[</span><span class="s4">'date'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">expires=int(json[</span><span class="s4">'expires'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">cert_url=str(json[</span><span class="s4">'certUrl'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'certUrl' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">cert_sha256=str(json[</span><span class="s4">'certSha256'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'certSha256' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">certificates=[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'certificates'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'certificates' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SignedExchangeHeader:</span>
    <span class="s3">''' 
    Information about a signed exchange header. 
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation 
    '''</span>
    <span class="s0">#: Signed exchange request URL.</span>
    <span class="s1">request_url: str</span>

    <span class="s0">#: Signed exchange response code.</span>
    <span class="s1">response_code: int</span>

    <span class="s0">#: Signed exchange response headers.</span>
    <span class="s1">response_headers: Headers</span>

    <span class="s0">#: Signed exchange response signature.</span>
    <span class="s1">signatures: typing.List[SignedExchangeSignature]</span>

    <span class="s0">#: Signed exchange header integrity hash in the form of &quot;sha256-&lt;base64-hash-value&gt;&quot;.</span>
    <span class="s1">header_integrity: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'requestUrl'</span><span class="s1">] = self.request_url</span>
        <span class="s1">json[</span><span class="s4">'responseCode'</span><span class="s1">] = self.response_code</span>
        <span class="s1">json[</span><span class="s4">'responseHeaders'</span><span class="s1">] = self.response_headers.to_json()</span>
        <span class="s1">json[</span><span class="s4">'signatures'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.signatures]</span>
        <span class="s1">json[</span><span class="s4">'headerIntegrity'</span><span class="s1">] = self.header_integrity</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_url=str(json[</span><span class="s4">'requestUrl'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">response_code=int(json[</span><span class="s4">'responseCode'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">response_headers=Headers.from_json(json[</span><span class="s4">'responseHeaders'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">signatures=[SignedExchangeSignature.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'signatures'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">header_integrity=str(json[</span><span class="s4">'headerIntegrity'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">SignedExchangeErrorField(enum.Enum):</span>
    <span class="s3">''' 
    Field type for a signed exchange related error. 
    '''</span>
    <span class="s1">SIGNATURE_SIG = </span><span class="s4">&quot;signatureSig&quot;</span>
    <span class="s1">SIGNATURE_INTEGRITY = </span><span class="s4">&quot;signatureIntegrity&quot;</span>
    <span class="s1">SIGNATURE_CERT_URL = </span><span class="s4">&quot;signatureCertUrl&quot;</span>
    <span class="s1">SIGNATURE_CERT_SHA256 = </span><span class="s4">&quot;signatureCertSha256&quot;</span>
    <span class="s1">SIGNATURE_VALIDITY_URL = </span><span class="s4">&quot;signatureValidityUrl&quot;</span>
    <span class="s1">SIGNATURE_TIMESTAMPS = </span><span class="s4">&quot;signatureTimestamps&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SignedExchangeError:</span>
    <span class="s3">''' 
    Information about a signed exchange response. 
    '''</span>
    <span class="s0">#: Error message.</span>
    <span class="s1">message: str</span>

    <span class="s0">#: The index of the signature which caused the error.</span>
    <span class="s1">signature_index: typing.Optional[int] = </span><span class="s2">None</span>

    <span class="s0">#: The field which caused the error.</span>
    <span class="s1">error_field: typing.Optional[SignedExchangeErrorField] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'message'</span><span class="s1">] = self.message</span>
        <span class="s2">if </span><span class="s1">self.signature_index </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'signatureIndex'</span><span class="s1">] = self.signature_index</span>
        <span class="s2">if </span><span class="s1">self.error_field </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'errorField'</span><span class="s1">] = self.error_field.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">message=str(json[</span><span class="s4">'message'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">signature_index=int(json[</span><span class="s4">'signatureIndex'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'signatureIndex' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">error_field=SignedExchangeErrorField.from_json(json[</span><span class="s4">'errorField'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'errorField' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SignedExchangeInfo:</span>
    <span class="s3">''' 
    Information about a signed exchange response. 
    '''</span>
    <span class="s0">#: The outer response of signed HTTP exchange which was received from network.</span>
    <span class="s1">outer_response: Response</span>

    <span class="s0">#: Information about the signed exchange header.</span>
    <span class="s1">header: typing.Optional[SignedExchangeHeader] = </span><span class="s2">None</span>

    <span class="s0">#: Security details for the signed exchange header.</span>
    <span class="s1">security_details: typing.Optional[SecurityDetails] = </span><span class="s2">None</span>

    <span class="s0">#: Errors occurred while handling the signed exchagne.</span>
    <span class="s1">errors: typing.Optional[typing.List[SignedExchangeError]] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'outerResponse'</span><span class="s1">] = self.outer_response.to_json()</span>
        <span class="s2">if </span><span class="s1">self.header </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'header'</span><span class="s1">] = self.header.to_json()</span>
        <span class="s2">if </span><span class="s1">self.security_details </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'securityDetails'</span><span class="s1">] = self.security_details.to_json()</span>
        <span class="s2">if </span><span class="s1">self.errors </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'errors'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.errors]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">outer_response=Response.from_json(json[</span><span class="s4">'outerResponse'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">header=SignedExchangeHeader.from_json(json[</span><span class="s4">'header'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'header' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">security_details=SecurityDetails.from_json(json[</span><span class="s4">'securityDetails'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'securityDetails' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">errors=[SignedExchangeError.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'errors'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'errors' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">ContentEncoding(enum.Enum):</span>
    <span class="s3">''' 
    List of content encodings supported by the backend. 
    '''</span>
    <span class="s1">DEFLATE = </span><span class="s4">&quot;deflate&quot;</span>
    <span class="s1">GZIP = </span><span class="s4">&quot;gzip&quot;</span>
    <span class="s1">BR = </span><span class="s4">&quot;br&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">PrivateNetworkRequestPolicy(enum.Enum):</span>
    <span class="s1">ALLOW = </span><span class="s4">&quot;Allow&quot;</span>
    <span class="s1">BLOCK_FROM_INSECURE_TO_MORE_PRIVATE = </span><span class="s4">&quot;BlockFromInsecureToMorePrivate&quot;</span>
    <span class="s1">WARN_FROM_INSECURE_TO_MORE_PRIVATE = </span><span class="s4">&quot;WarnFromInsecureToMorePrivate&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s2">class </span><span class="s1">IPAddressSpace(enum.Enum):</span>
    <span class="s1">LOCAL = </span><span class="s4">&quot;Local&quot;</span>
    <span class="s1">PRIVATE = </span><span class="s4">&quot;Private&quot;</span>
    <span class="s1">PUBLIC = </span><span class="s4">&quot;Public&quot;</span>
    <span class="s1">UNKNOWN = </span><span class="s4">&quot;Unknown&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ClientSecurityState:</span>
    <span class="s1">initiator_is_secure_context: bool</span>

    <span class="s1">initiator_ip_address_space: IPAddressSpace</span>

    <span class="s1">private_network_request_policy: PrivateNetworkRequestPolicy</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'initiatorIsSecureContext'</span><span class="s1">] = self.initiator_is_secure_context</span>
        <span class="s1">json[</span><span class="s4">'initiatorIPAddressSpace'</span><span class="s1">] = self.initiator_ip_address_space.to_json()</span>
        <span class="s1">json[</span><span class="s4">'privateNetworkRequestPolicy'</span><span class="s1">] = self.private_network_request_policy.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">initiator_is_secure_context=bool(json[</span><span class="s4">'initiatorIsSecureContext'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">initiator_ip_address_space=IPAddressSpace.from_json(json[</span><span class="s4">'initiatorIPAddressSpace'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">private_network_request_policy=PrivateNetworkRequestPolicy.from_json(json[</span><span class="s4">'privateNetworkRequestPolicy'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">CrossOriginOpenerPolicyValue(enum.Enum):</span>
    <span class="s1">SAME_ORIGIN = </span><span class="s4">&quot;SameOrigin&quot;</span>
    <span class="s1">SAME_ORIGIN_ALLOW_POPUPS = </span><span class="s4">&quot;SameOriginAllowPopups&quot;</span>
    <span class="s1">UNSAFE_NONE = </span><span class="s4">&quot;UnsafeNone&quot;</span>
    <span class="s1">SAME_ORIGIN_PLUS_COEP = </span><span class="s4">&quot;SameOriginPlusCoep&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CrossOriginOpenerPolicyStatus:</span>
    <span class="s1">value: CrossOriginOpenerPolicyValue</span>

    <span class="s1">report_only_value: CrossOriginOpenerPolicyValue</span>

    <span class="s1">reporting_endpoint: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s1">report_only_reporting_endpoint: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value.to_json()</span>
        <span class="s1">json[</span><span class="s4">'reportOnlyValue'</span><span class="s1">] = self.report_only_value.to_json()</span>
        <span class="s2">if </span><span class="s1">self.reporting_endpoint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'reportingEndpoint'</span><span class="s1">] = self.reporting_endpoint</span>
        <span class="s2">if </span><span class="s1">self.report_only_reporting_endpoint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'reportOnlyReportingEndpoint'</span><span class="s1">] = self.report_only_reporting_endpoint</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">value=CrossOriginOpenerPolicyValue.from_json(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">report_only_value=CrossOriginOpenerPolicyValue.from_json(json[</span><span class="s4">'reportOnlyValue'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">reporting_endpoint=str(json[</span><span class="s4">'reportingEndpoint'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'reportingEndpoint' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">report_only_reporting_endpoint=str(json[</span><span class="s4">'reportOnlyReportingEndpoint'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'reportOnlyReportingEndpoint' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">CrossOriginEmbedderPolicyValue(enum.Enum):</span>
    <span class="s1">NONE = </span><span class="s4">&quot;None&quot;</span>
    <span class="s1">CORS_OR_CREDENTIALLESS = </span><span class="s4">&quot;CorsOrCredentialless&quot;</span>
    <span class="s1">REQUIRE_CORP = </span><span class="s4">&quot;RequireCorp&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CrossOriginEmbedderPolicyStatus:</span>
    <span class="s1">value: CrossOriginEmbedderPolicyValue</span>

    <span class="s1">report_only_value: CrossOriginEmbedderPolicyValue</span>

    <span class="s1">reporting_endpoint: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s1">report_only_reporting_endpoint: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value.to_json()</span>
        <span class="s1">json[</span><span class="s4">'reportOnlyValue'</span><span class="s1">] = self.report_only_value.to_json()</span>
        <span class="s2">if </span><span class="s1">self.reporting_endpoint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'reportingEndpoint'</span><span class="s1">] = self.reporting_endpoint</span>
        <span class="s2">if </span><span class="s1">self.report_only_reporting_endpoint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'reportOnlyReportingEndpoint'</span><span class="s1">] = self.report_only_reporting_endpoint</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">value=CrossOriginEmbedderPolicyValue.from_json(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">report_only_value=CrossOriginEmbedderPolicyValue.from_json(json[</span><span class="s4">'reportOnlyValue'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">reporting_endpoint=str(json[</span><span class="s4">'reportingEndpoint'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'reportingEndpoint' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">report_only_reporting_endpoint=str(json[</span><span class="s4">'reportOnlyReportingEndpoint'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'reportOnlyReportingEndpoint' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SecurityIsolationStatus:</span>
    <span class="s1">coop: typing.Optional[CrossOriginOpenerPolicyStatus] = </span><span class="s2">None</span>

    <span class="s1">coep: typing.Optional[CrossOriginEmbedderPolicyStatus] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s2">if </span><span class="s1">self.coop </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'coop'</span><span class="s1">] = self.coop.to_json()</span>
        <span class="s2">if </span><span class="s1">self.coep </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'coep'</span><span class="s1">] = self.coep.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">coop=CrossOriginOpenerPolicyStatus.from_json(json[</span><span class="s4">'coop'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'coop' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">coep=CrossOriginEmbedderPolicyStatus.from_json(json[</span><span class="s4">'coep'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'coep' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">LoadNetworkResourcePageResult:</span>
    <span class="s3">''' 
    An object providing the result of a network resource load. 
    '''</span>
    <span class="s1">success: bool</span>

    <span class="s0">#: Optional values used for error reporting.</span>
    <span class="s1">net_error: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s1">net_error_name: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s1">http_status_code: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s0">#: If successful, one of the following two fields holds the result.</span>
    <span class="s1">stream: typing.Optional[io.StreamHandle] = </span><span class="s2">None</span>

    <span class="s0">#: Response headers.</span>
    <span class="s1">headers: typing.Optional[network.Headers] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'success'</span><span class="s1">] = self.success</span>
        <span class="s2">if </span><span class="s1">self.net_error </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'netError'</span><span class="s1">] = self.net_error</span>
        <span class="s2">if </span><span class="s1">self.net_error_name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'netErrorName'</span><span class="s1">] = self.net_error_name</span>
        <span class="s2">if </span><span class="s1">self.http_status_code </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'httpStatusCode'</span><span class="s1">] = self.http_status_code</span>
        <span class="s2">if </span><span class="s1">self.stream </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'stream'</span><span class="s1">] = self.stream.to_json()</span>
        <span class="s2">if </span><span class="s1">self.headers </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'headers'</span><span class="s1">] = self.headers.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">success=bool(json[</span><span class="s4">'success'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">net_error=float(json[</span><span class="s4">'netError'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'netError' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">net_error_name=str(json[</span><span class="s4">'netErrorName'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'netErrorName' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">http_status_code=float(json[</span><span class="s4">'httpStatusCode'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'httpStatusCode' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">stream=io.StreamHandle.from_json(json[</span><span class="s4">'stream'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'stream' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">headers=network.Headers.from_json(json[</span><span class="s4">'headers'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'headers' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">LoadNetworkResourceOptions:</span>
    <span class="s3">''' 
    An options object that may be extended later to better support CORS, 
    CORB and streaming. 
    '''</span>
    <span class="s1">disable_cache: bool</span>

    <span class="s1">include_credentials: bool</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'disableCache'</span><span class="s1">] = self.disable_cache</span>
        <span class="s1">json[</span><span class="s4">'includeCredentials'</span><span class="s1">] = self.include_credentials</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">disable_cache=bool(json[</span><span class="s4">'disableCache'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">include_credentials=bool(json[</span><span class="s4">'includeCredentials'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">set_accepted_encodings(</span>
        <span class="s1">encodings: typing.List[ContentEncoding]</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted. 
 
    **EXPERIMENTAL** 
 
    :param encodings: List of accepted content encodings. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'encodings'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">encodings]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setAcceptedEncodings'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">clear_accepted_encodings_override() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Clears accepted encodings set by setAcceptedEncodings 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.clearAcceptedEncodingsOverride'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">can_clear_browser_cache() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">bool]:</span>
    <span class="s3">''' 
    Tells whether clearing browser cache is supported. 
 
    :returns: True if browser cache can be cleared. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.canClearBrowserCache'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">bool(json[</span><span class="s4">'result'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">can_clear_browser_cookies() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">bool]:</span>
    <span class="s3">''' 
    Tells whether clearing browser cookies is supported. 
 
    :returns: True if browser cookies can be cleared. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.canClearBrowserCookies'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">bool(json[</span><span class="s4">'result'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">can_emulate_network_conditions() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">bool]:</span>
    <span class="s3">''' 
    Tells whether emulation of network conditions is supported. 
 
    :returns: True if emulation of network conditions is supported. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.canEmulateNetworkConditions'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">bool(json[</span><span class="s4">'result'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">clear_browser_cache() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Clears browser cache. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.clearBrowserCache'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">clear_browser_cookies() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Clears browser cookies. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.clearBrowserCookies'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">continue_intercepted_request(</span>
        <span class="s1">interception_id: InterceptionId</span><span class="s2">,</span>
        <span class="s1">error_reason: typing.Optional[ErrorReason] = </span><span class="s2">None,</span>
        <span class="s1">raw_response: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">url: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">method: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">post_data: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">headers: typing.Optional[Headers] = </span><span class="s2">None,</span>
        <span class="s1">auth_challenge_response: typing.Optional[AuthChallengeResponse] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Response to Network.requestIntercepted which either modifies the request to continue with any 
    modifications, or blocks it, or completes it with the provided response bytes. If a network 
    fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted 
    event will be sent with the same InterceptionId. 
    Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead. 
 
    **EXPERIMENTAL** 
 
    :param interception_id: 
    :param error_reason: *(Optional)* If set this causes the request to fail with the given reason. Passing ```Aborted```` for requests marked with ````isNavigationRequest``` also cancels the navigation. Must not be set in response to an authChallenge. 
    :param raw_response: *(Optional)* If set the requests completes using with the provided base64 encoded raw response, including HTTP status line and headers etc... Must not be set in response to an authChallenge. 
    :param url: *(Optional)* If set the request url will be modified in a way that's not observable by page. Must not be set in response to an authChallenge. 
    :param method: *(Optional)* If set this allows the request method to be overridden. Must not be set in response to an authChallenge. 
    :param post_data: *(Optional)* If set this allows postData to be set. Must not be set in response to an authChallenge. 
    :param headers: *(Optional)* If set this allows the request headers to be changed. Must not be set in response to an authChallenge. 
    :param auth_challenge_response: *(Optional)* Response to a requestIntercepted with an authChallenge. Must not be set otherwise. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'interceptionId'</span><span class="s1">] = interception_id.to_json()</span>
    <span class="s2">if </span><span class="s1">error_reason </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'errorReason'</span><span class="s1">] = error_reason.to_json()</span>
    <span class="s2">if </span><span class="s1">raw_response </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'rawResponse'</span><span class="s1">] = raw_response</span>
    <span class="s2">if </span><span class="s1">url </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'url'</span><span class="s1">] = url</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'method'</span><span class="s1">] = method</span>
    <span class="s2">if </span><span class="s1">post_data </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'postData'</span><span class="s1">] = post_data</span>
    <span class="s2">if </span><span class="s1">headers </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'headers'</span><span class="s1">] = headers.to_json()</span>
    <span class="s2">if </span><span class="s1">auth_challenge_response </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'authChallengeResponse'</span><span class="s1">] = auth_challenge_response.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.continueInterceptedRequest'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">delete_cookies(</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">url: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">domain: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">path: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Deletes browser cookies with matching name and url or domain/path pair. 
 
    :param name: Name of the cookies to remove. 
    :param url: *(Optional)* If specified, deletes all the cookies with the given name where domain and path match provided URL. 
    :param domain: *(Optional)* If specified, deletes only cookies with the exact domain. 
    :param path: *(Optional)* If specified, deletes only cookies with the exact path. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'name'</span><span class="s1">] = name</span>
    <span class="s2">if </span><span class="s1">url </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'url'</span><span class="s1">] = url</span>
    <span class="s2">if </span><span class="s1">domain </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'domain'</span><span class="s1">] = domain</span>
    <span class="s2">if </span><span class="s1">path </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'path'</span><span class="s1">] = path</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.deleteCookies'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">disable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disables network tracking, prevents network events from being sent to the client. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.disable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">emulate_network_conditions(</span>
        <span class="s1">offline: bool</span><span class="s2">,</span>
        <span class="s1">latency: float</span><span class="s2">,</span>
        <span class="s1">download_throughput: float</span><span class="s2">,</span>
        <span class="s1">upload_throughput: float</span><span class="s2">,</span>
        <span class="s1">connection_type: typing.Optional[ConnectionType] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Activates emulation of network conditions. 
 
    :param offline: True to emulate internet disconnection. 
    :param latency: Minimum latency from request sent to response headers received (ms). 
    :param download_throughput: Maximal aggregated download throughput (bytes/sec). -1 disables download throttling. 
    :param upload_throughput: Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling. 
    :param connection_type: *(Optional)* Connection type if known. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'offline'</span><span class="s1">] = offline</span>
    <span class="s1">params[</span><span class="s4">'latency'</span><span class="s1">] = latency</span>
    <span class="s1">params[</span><span class="s4">'downloadThroughput'</span><span class="s1">] = download_throughput</span>
    <span class="s1">params[</span><span class="s4">'uploadThroughput'</span><span class="s1">] = upload_throughput</span>
    <span class="s2">if </span><span class="s1">connection_type </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'connectionType'</span><span class="s1">] = connection_type.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.emulateNetworkConditions'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">enable(</span>
        <span class="s1">max_total_buffer_size: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">max_resource_buffer_size: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">max_post_data_size: typing.Optional[int] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables network tracking, network events will now be delivered to the client. 
 
    :param max_total_buffer_size: **(EXPERIMENTAL)** *(Optional)* Buffer size in bytes to use when preserving network payloads (XHRs, etc). 
    :param max_resource_buffer_size: **(EXPERIMENTAL)** *(Optional)* Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc). 
    :param max_post_data_size: *(Optional)* Longest post body size (in bytes) that would be included in requestWillBeSent notification 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">max_total_buffer_size </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'maxTotalBufferSize'</span><span class="s1">] = max_total_buffer_size</span>
    <span class="s2">if </span><span class="s1">max_resource_buffer_size </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'maxResourceBufferSize'</span><span class="s1">] = max_resource_buffer_size</span>
    <span class="s2">if </span><span class="s1">max_post_data_size </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'maxPostDataSize'</span><span class="s1">] = max_post_data_size</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.enable'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_all_cookies() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[Cookie]]:</span>
    <span class="s3">''' 
    Returns all browser cookies. Depending on the backend support, will return detailed cookie 
    information in the ``cookies`` field. 
 
    :returns: Array of cookie objects. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.getAllCookies'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[Cookie.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'cookies'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">get_certificate(</span>
        <span class="s1">origin: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[str]]:</span>
    <span class="s3">''' 
    Returns the DER-encoded certificate. 
 
    **EXPERIMENTAL** 
 
    :param origin: Origin to get certificate for. 
    :returns:  
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'origin'</span><span class="s1">] = origin</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.getCertificate'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'tableNames'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">get_cookies(</span>
        <span class="s1">urls: typing.Optional[typing.List[str]] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[Cookie]]:</span>
    <span class="s3">''' 
    Returns all browser cookies for the current URL. Depending on the backend support, will return 
    detailed cookie information in the ``cookies`` field. 
 
    :param urls: *(Optional)* The list of URLs for which applicable cookies will be fetched. If not specified, it's assumed to be set to the list containing the URLs of the page and all of its subframes. 
    :returns: Array of cookie objects. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">urls </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'urls'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">urls]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.getCookies'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[Cookie.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'cookies'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">get_response_body(</span>
        <span class="s1">request_id: RequestId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[str</span><span class="s2">, </span><span class="s1">bool]]:</span>
    <span class="s3">''' 
    Returns content served for the given request. 
 
    :param request_id: Identifier of the network request to get content for. 
    :returns: A tuple with the following items: 
 
        0. **body** - Response body. 
        1. **base64Encoded** - True, if content was sent as base64. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.getResponseBody'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">str(json[</span><span class="s4">'body'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">bool(json[</span><span class="s4">'base64Encoded'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_request_post_data(</span>
        <span class="s1">request_id: RequestId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">str]:</span>
    <span class="s3">''' 
    Returns post data sent with the request. Returns an error when no data was sent with the request. 
 
    :param request_id: Identifier of the network request to get content for. 
    :returns: Request body string, omitting files from multipart requests 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.getRequestPostData'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">str(json[</span><span class="s4">'postData'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_response_body_for_interception(</span>
        <span class="s1">interception_id: InterceptionId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[str</span><span class="s2">, </span><span class="s1">bool]]:</span>
    <span class="s3">''' 
    Returns content served for the given currently intercepted request. 
 
    **EXPERIMENTAL** 
 
    :param interception_id: Identifier for the intercepted request to get body for. 
    :returns: A tuple with the following items: 
 
        0. **body** - Response body. 
        1. **base64Encoded** - True, if content was sent as base64. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'interceptionId'</span><span class="s1">] = interception_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.getResponseBodyForInterception'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">str(json[</span><span class="s4">'body'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">bool(json[</span><span class="s4">'base64Encoded'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">take_response_body_for_interception_as_stream(</span>
        <span class="s1">interception_id: InterceptionId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">io.StreamHandle]:</span>
    <span class="s3">''' 
    Returns a handle to the stream representing the response body. Note that after this command, 
    the intercepted request can't be continued as is -- you either need to cancel it or to provide 
    the response body. The stream only supports sequential read, IO.read will fail if the position 
    is specified. 
 
    **EXPERIMENTAL** 
 
    :param interception_id: 
    :returns:  
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'interceptionId'</span><span class="s1">] = interception_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.takeResponseBodyForInterceptionAsStream'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">io.StreamHandle.from_json(json[</span><span class="s4">'stream'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">replay_xhr(</span>
        <span class="s1">request_id: RequestId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    This method sends a new XMLHttpRequest which is identical to the original one. The following 
    parameters should be identical: method, url, async, request body, extra headers, withCredentials 
    attribute, user, password. 
 
    **EXPERIMENTAL** 
 
    :param request_id: Identifier of XHR to replay. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.replayXHR'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">search_in_response_body(</span>
        <span class="s1">request_id: RequestId</span><span class="s2">,</span>
        <span class="s1">query: str</span><span class="s2">,</span>
        <span class="s1">case_sensitive: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">is_regex: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[debugger.SearchMatch]]:</span>
    <span class="s3">''' 
    Searches for given string in response content. 
 
    **EXPERIMENTAL** 
 
    :param request_id: Identifier of the network response to search. 
    :param query: String to search for. 
    :param case_sensitive: *(Optional)* If true, search is case sensitive. 
    :param is_regex: *(Optional)* If true, treats string parameter as regex. 
    :returns: List of search matches. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'requestId'</span><span class="s1">] = request_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'query'</span><span class="s1">] = query</span>
    <span class="s2">if </span><span class="s1">case_sensitive </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'caseSensitive'</span><span class="s1">] = case_sensitive</span>
    <span class="s2">if </span><span class="s1">is_regex </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'isRegex'</span><span class="s1">] = is_regex</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.searchInResponseBody'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[debugger.SearchMatch.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">set_blocked_ur_ls(</span>
        <span class="s1">urls: typing.List[str]</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Blocks URLs from loading. 
 
    **EXPERIMENTAL** 
 
    :param urls: URL patterns to block. Wildcards ('*') are allowed. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'urls'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">urls]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setBlockedURLs'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_bypass_service_worker(</span>
        <span class="s1">bypass: bool</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Toggles ignoring of service worker for each request. 
 
    **EXPERIMENTAL** 
 
    :param bypass: Bypass service worker and load from network. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'bypass'</span><span class="s1">] = bypass</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setBypassServiceWorker'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_cache_disabled(</span>
        <span class="s1">cache_disabled: bool</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Toggles ignoring cache for each request. If ``true``, cache will not be used. 
 
    :param cache_disabled: Cache disabled state. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'cacheDisabled'</span><span class="s1">] = cache_disabled</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setCacheDisabled'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_cookie(</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">value: str</span><span class="s2">,</span>
        <span class="s1">url: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">domain: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">path: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">secure: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">http_only: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">same_site: typing.Optional[CookieSameSite] = </span><span class="s2">None,</span>
        <span class="s1">expires: typing.Optional[TimeSinceEpoch] = </span><span class="s2">None,</span>
        <span class="s1">priority: typing.Optional[CookiePriority] = </span><span class="s2">None,</span>
        <span class="s1">same_party: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">source_scheme: typing.Optional[CookieSourceScheme] = </span><span class="s2">None,</span>
        <span class="s1">source_port: typing.Optional[int] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">bool]:</span>
    <span class="s3">''' 
    Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist. 
 
    :param name: Cookie name. 
    :param value: Cookie value. 
    :param url: *(Optional)* The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie. 
    :param domain: *(Optional)* Cookie domain. 
    :param path: *(Optional)* Cookie path. 
    :param secure: *(Optional)* True if cookie is secure. 
    :param http_only: *(Optional)* True if cookie is http-only. 
    :param same_site: *(Optional)* Cookie SameSite type. 
    :param expires: *(Optional)* Cookie expiration date, session cookie if not set 
    :param priority: **(EXPERIMENTAL)** *(Optional)* Cookie Priority type. 
    :param same_party: **(EXPERIMENTAL)** *(Optional)* True if cookie is SameParty. 
    :param source_scheme: **(EXPERIMENTAL)** *(Optional)* Cookie source scheme type. 
    :param source_port: **(EXPERIMENTAL)** *(Optional)* Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port. An unspecified port value allows protocol clients to emulate legacy cookie scope for the port. This is a temporary ability and it will be removed in the future. 
    :returns: Always set to true. If an error occurs, the response indicates protocol error. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'name'</span><span class="s1">] = name</span>
    <span class="s1">params[</span><span class="s4">'value'</span><span class="s1">] = value</span>
    <span class="s2">if </span><span class="s1">url </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'url'</span><span class="s1">] = url</span>
    <span class="s2">if </span><span class="s1">domain </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'domain'</span><span class="s1">] = domain</span>
    <span class="s2">if </span><span class="s1">path </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'path'</span><span class="s1">] = path</span>
    <span class="s2">if </span><span class="s1">secure </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'secure'</span><span class="s1">] = secure</span>
    <span class="s2">if </span><span class="s1">http_only </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'httpOnly'</span><span class="s1">] = http_only</span>
    <span class="s2">if </span><span class="s1">same_site </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'sameSite'</span><span class="s1">] = same_site.to_json()</span>
    <span class="s2">if </span><span class="s1">expires </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'expires'</span><span class="s1">] = expires.to_json()</span>
    <span class="s2">if </span><span class="s1">priority </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'priority'</span><span class="s1">] = priority.to_json()</span>
    <span class="s2">if </span><span class="s1">same_party </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'sameParty'</span><span class="s1">] = same_party</span>
    <span class="s2">if </span><span class="s1">source_scheme </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'sourceScheme'</span><span class="s1">] = source_scheme.to_json()</span>
    <span class="s2">if </span><span class="s1">source_port </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'sourcePort'</span><span class="s1">] = source_port</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setCookie'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">bool(json[</span><span class="s4">'success'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">set_cookies(</span>
        <span class="s1">cookies: typing.List[CookieParam]</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets given cookies. 
 
    :param cookies: Cookies to be set. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'cookies'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">cookies]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setCookies'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_data_size_limits_for_test(</span>
        <span class="s1">max_total_size: int</span><span class="s2">,</span>
        <span class="s1">max_resource_size: int</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    For testing. 
 
    **EXPERIMENTAL** 
 
    :param max_total_size: Maximum total buffer size. 
    :param max_resource_size: Maximum per-resource size. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'maxTotalSize'</span><span class="s1">] = max_total_size</span>
    <span class="s1">params[</span><span class="s4">'maxResourceSize'</span><span class="s1">] = max_resource_size</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setDataSizeLimitsForTest'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_extra_http_headers(</span>
        <span class="s1">headers: Headers</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Specifies whether to always send extra HTTP headers with the requests from this page. 
 
    :param headers: Map with extra HTTP headers. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'headers'</span><span class="s1">] = headers.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setExtraHTTPHeaders'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_attach_debug_stack(</span>
        <span class="s1">enabled: bool</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Specifies whether to attach a page script stack id in requests 
 
    **EXPERIMENTAL** 
 
    :param enabled: Whether to attach a page script stack for debugging purpose. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'enabled'</span><span class="s1">] = enabled</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setAttachDebugStack'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_request_interception(</span>
        <span class="s1">patterns: typing.List[RequestPattern]</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets the requests to intercept that match the provided patterns and optionally resource types. 
    Deprecated, please use Fetch.enable instead. 
 
    **EXPERIMENTAL** 
 
    :param patterns: Requests matching any of these patterns will be forwarded and wait for the corresponding continueInterceptedRequest call. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'patterns'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">patterns]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setRequestInterception'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_user_agent_override(</span>
        <span class="s1">user_agent: str</span><span class="s2">,</span>
        <span class="s1">accept_language: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">platform: typing.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">user_agent_metadata: typing.Optional[emulation.UserAgentMetadata] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Allows overriding user agent with the given string. 
 
    :param user_agent: User agent to use. 
    :param accept_language: *(Optional)* Browser langugage to emulate. 
    :param platform: *(Optional)* The platform navigator.platform should return. 
    :param user_agent_metadata: **(EXPERIMENTAL)** *(Optional)* To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'userAgent'</span><span class="s1">] = user_agent</span>
    <span class="s2">if </span><span class="s1">accept_language </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'acceptLanguage'</span><span class="s1">] = accept_language</span>
    <span class="s2">if </span><span class="s1">platform </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'platform'</span><span class="s1">] = platform</span>
    <span class="s2">if </span><span class="s1">user_agent_metadata </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'userAgentMetadata'</span><span class="s1">] = user_agent_metadata.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.setUserAgentOverride'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_security_isolation_status(</span>
        <span class="s1">frame_id: typing.Optional[page.FrameId] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">SecurityIsolationStatus]:</span>
    <span class="s3">''' 
    Returns information about the COEP/COOP isolation status. 
 
    **EXPERIMENTAL** 
 
    :param frame_id: *(Optional)* If no frameId is provided, the status of the target is provided. 
    :returns:  
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">frame_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'frameId'</span><span class="s1">] = frame_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.getSecurityIsolationStatus'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">SecurityIsolationStatus.from_json(json[</span><span class="s4">'status'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">load_network_resource(</span>
        <span class="s1">frame_id: page.FrameId</span><span class="s2">,</span>
        <span class="s1">url: str</span><span class="s2">,</span>
        <span class="s1">options: LoadNetworkResourceOptions</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">LoadNetworkResourcePageResult]:</span>
    <span class="s3">''' 
    Fetches the resource and returns the content. 
 
    **EXPERIMENTAL** 
 
    :param frame_id: Frame id to get the resource for. 
    :param url: URL of the resource to get content for. 
    :param options: Options for the request. 
    :returns:  
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'frameId'</span><span class="s1">] = frame_id.to_json()</span>
    <span class="s1">params[</span><span class="s4">'url'</span><span class="s1">] = url</span>
    <span class="s1">params[</span><span class="s4">'options'</span><span class="s1">] = options.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Network.loadNetworkResource'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">LoadNetworkResourcePageResult.from_json(json[</span><span class="s4">'resource'</span><span class="s1">])</span>


<span class="s1">@event_class(</span><span class="s4">'Network.dataReceived'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">DataReceived:</span>
    <span class="s3">''' 
    Fired when data chunk was received over the network. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: Data chunk length.</span>
    <span class="s1">data_length: int</span>
    <span class="s0">#: Actual bytes received (might be less than dataLength for compressed encodings).</span>
    <span class="s1">encoded_data_length: int</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; DataReceived:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">data_length=int(json[</span><span class="s4">'dataLength'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">encoded_data_length=int(json[</span><span class="s4">'encodedDataLength'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.eventSourceMessageReceived'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">EventSourceMessageReceived:</span>
    <span class="s3">''' 
    Fired when EventSource message is received. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: Message type.</span>
    <span class="s1">event_name: str</span>
    <span class="s0">#: Message identifier.</span>
    <span class="s1">event_id: str</span>
    <span class="s0">#: Message content.</span>
    <span class="s1">data: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; EventSourceMessageReceived:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">event_name=str(json[</span><span class="s4">'eventName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">event_id=str(json[</span><span class="s4">'eventId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">data=str(json[</span><span class="s4">'data'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.loadingFailed'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">LoadingFailed:</span>
    <span class="s3">''' 
    Fired when HTTP request has failed to load. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: Resource type.</span>
    <span class="s1">type_: ResourceType</span>
    <span class="s0">#: User friendly error message.</span>
    <span class="s1">error_text: str</span>
    <span class="s0">#: True if loading was canceled.</span>
    <span class="s1">canceled: typing.Optional[bool]</span>
    <span class="s0">#: The reason why loading was blocked, if any.</span>
    <span class="s1">blocked_reason: typing.Optional[BlockedReason]</span>
    <span class="s0">#: The reason why loading was blocked by CORS, if any.</span>
    <span class="s1">cors_error_status: typing.Optional[CorsErrorStatus]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; LoadingFailed:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">type_=ResourceType.from_json(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">error_text=str(json[</span><span class="s4">'errorText'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">canceled=bool(json[</span><span class="s4">'canceled'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'canceled' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">blocked_reason=BlockedReason.from_json(json[</span><span class="s4">'blockedReason'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'blockedReason' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">cors_error_status=CorsErrorStatus.from_json(json[</span><span class="s4">'corsErrorStatus'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'corsErrorStatus' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.loadingFinished'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">LoadingFinished:</span>
    <span class="s3">''' 
    Fired when HTTP request has finished loading. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: Total number of bytes received for this request.</span>
    <span class="s1">encoded_data_length: float</span>
    <span class="s0">#: Set when 1) response was blocked by Cross-Origin Read Blocking and also</span>
    <span class="s0">#: 2) this needs to be reported to the DevTools console.</span>
    <span class="s1">should_report_corb_blocking: typing.Optional[bool]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; LoadingFinished:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">encoded_data_length=float(json[</span><span class="s4">'encodedDataLength'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">should_report_corb_blocking=bool(json[</span><span class="s4">'shouldReportCorbBlocking'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'shouldReportCorbBlocking' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.requestIntercepted'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RequestIntercepted:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Details of an intercepted HTTP request, which must be either allowed, blocked, modified or 
    mocked. 
    Deprecated, use Fetch.requestPaused instead. 
    '''</span>
    <span class="s0">#: Each request the page makes will have a unique id, however if any redirects are encountered</span>
    <span class="s0">#: while processing that fetch, they will be reported with the same id as the original fetch.</span>
    <span class="s0">#: Likewise if HTTP authentication is needed then the same fetch id will be used.</span>
    <span class="s1">interception_id: InterceptionId</span>
    <span class="s1">request: Request</span>
    <span class="s0">#: The id of the frame that initiated the request.</span>
    <span class="s1">frame_id: page.FrameId</span>
    <span class="s0">#: How the requested resource will be used.</span>
    <span class="s1">resource_type: ResourceType</span>
    <span class="s0">#: Whether this is a navigation request, which can abort the navigation completely.</span>
    <span class="s1">is_navigation_request: bool</span>
    <span class="s0">#: Set if the request is a navigation that will result in a download.</span>
    <span class="s0">#: Only present after response is received from the server (i.e. HeadersReceived stage).</span>
    <span class="s1">is_download: typing.Optional[bool]</span>
    <span class="s0">#: Redirect location, only sent if a redirect was intercepted.</span>
    <span class="s1">redirect_url: typing.Optional[str]</span>
    <span class="s0">#: Details of the Authorization Challenge encountered. If this is set then</span>
    <span class="s0">#: continueInterceptedRequest must contain an authChallengeResponse.</span>
    <span class="s1">auth_challenge: typing.Optional[AuthChallenge]</span>
    <span class="s0">#: Response error if intercepted at response stage or if redirect occurred while intercepting</span>
    <span class="s0">#: request.</span>
    <span class="s1">response_error_reason: typing.Optional[ErrorReason]</span>
    <span class="s0">#: Response code if intercepted at response stage or if redirect occurred while intercepting</span>
    <span class="s0">#: request or auth retry occurred.</span>
    <span class="s1">response_status_code: typing.Optional[int]</span>
    <span class="s0">#: Response headers if intercepted at the response stage or if redirect occurred while</span>
    <span class="s0">#: intercepting request or auth retry occurred.</span>
    <span class="s1">response_headers: typing.Optional[Headers]</span>
    <span class="s0">#: If the intercepted request had a corresponding requestWillBeSent event fired for it, then</span>
    <span class="s0">#: this requestId will be the same as the requestId present in the requestWillBeSent event.</span>
    <span class="s1">request_id: typing.Optional[RequestId]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; RequestIntercepted:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">interception_id=InterceptionId.from_json(json[</span><span class="s4">'interceptionId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">request=Request.from_json(json[</span><span class="s4">'request'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">frame_id=page.FrameId.from_json(json[</span><span class="s4">'frameId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">resource_type=ResourceType.from_json(json[</span><span class="s4">'resourceType'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">is_navigation_request=bool(json[</span><span class="s4">'isNavigationRequest'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">is_download=bool(json[</span><span class="s4">'isDownload'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'isDownload' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">redirect_url=str(json[</span><span class="s4">'redirectUrl'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'redirectUrl' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">auth_challenge=AuthChallenge.from_json(json[</span><span class="s4">'authChallenge'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'authChallenge' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">response_error_reason=ErrorReason.from_json(json[</span><span class="s4">'responseErrorReason'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'responseErrorReason' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">response_status_code=int(json[</span><span class="s4">'responseStatusCode'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'responseStatusCode' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">response_headers=Headers.from_json(json[</span><span class="s4">'responseHeaders'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'responseHeaders' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'requestId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.requestServedFromCache'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RequestServedFromCache:</span>
    <span class="s3">''' 
    Fired if request ended up loading from cache. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; RequestServedFromCache:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.requestWillBeSent'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RequestWillBeSent:</span>
    <span class="s3">''' 
    Fired when page is about to send HTTP request. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Loader identifier. Empty string if the request is fetched from worker.</span>
    <span class="s1">loader_id: LoaderId</span>
    <span class="s0">#: URL of the document this request is loaded for.</span>
    <span class="s1">document_url: str</span>
    <span class="s0">#: Request data.</span>
    <span class="s1">request: Request</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">wall_time: TimeSinceEpoch</span>
    <span class="s0">#: Request initiator.</span>
    <span class="s1">initiator: Initiator</span>
    <span class="s0">#: Redirect response data.</span>
    <span class="s1">redirect_response: typing.Optional[Response]</span>
    <span class="s0">#: Type of this resource.</span>
    <span class="s1">type_: typing.Optional[ResourceType]</span>
    <span class="s0">#: Frame identifier.</span>
    <span class="s1">frame_id: typing.Optional[page.FrameId]</span>
    <span class="s0">#: Whether the request is initiated by a user gesture. Defaults to false.</span>
    <span class="s1">has_user_gesture: typing.Optional[bool]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; RequestWillBeSent:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">loader_id=LoaderId.from_json(json[</span><span class="s4">'loaderId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">document_url=str(json[</span><span class="s4">'documentURL'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">request=Request.from_json(json[</span><span class="s4">'request'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">wall_time=TimeSinceEpoch.from_json(json[</span><span class="s4">'wallTime'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">initiator=Initiator.from_json(json[</span><span class="s4">'initiator'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">redirect_response=Response.from_json(json[</span><span class="s4">'redirectResponse'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'redirectResponse' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">type_=ResourceType.from_json(json[</span><span class="s4">'type'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'type' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">frame_id=page.FrameId.from_json(json[</span><span class="s4">'frameId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'frameId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">has_user_gesture=bool(json[</span><span class="s4">'hasUserGesture'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'hasUserGesture' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.resourceChangedPriority'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ResourceChangedPriority:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Fired when resource loading priority is changed 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: New priority</span>
    <span class="s1">new_priority: ResourcePriority</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ResourceChangedPriority:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">new_priority=ResourcePriority.from_json(json[</span><span class="s4">'newPriority'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.signedExchangeReceived'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SignedExchangeReceived:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Fired when a signed exchange was received over the network 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Information about the signed exchange response.</span>
    <span class="s1">info: SignedExchangeInfo</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; SignedExchangeReceived:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">info=SignedExchangeInfo.from_json(json[</span><span class="s4">'info'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.responseReceived'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ResponseReceived:</span>
    <span class="s3">''' 
    Fired when HTTP response is available. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Loader identifier. Empty string if the request is fetched from worker.</span>
    <span class="s1">loader_id: LoaderId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: Resource type.</span>
    <span class="s1">type_: ResourceType</span>
    <span class="s0">#: Response data.</span>
    <span class="s1">response: Response</span>
    <span class="s0">#: Frame identifier.</span>
    <span class="s1">frame_id: typing.Optional[page.FrameId]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ResponseReceived:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">loader_id=LoaderId.from_json(json[</span><span class="s4">'loaderId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">type_=ResourceType.from_json(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">response=Response.from_json(json[</span><span class="s4">'response'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">frame_id=page.FrameId.from_json(json[</span><span class="s4">'frameId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'frameId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webSocketClosed'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketClosed:</span>
    <span class="s3">''' 
    Fired when WebSocket is closed. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebSocketClosed:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webSocketCreated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketCreated:</span>
    <span class="s3">''' 
    Fired upon WebSocket creation. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: WebSocket request URL.</span>
    <span class="s1">url: str</span>
    <span class="s0">#: Request initiator.</span>
    <span class="s1">initiator: typing.Optional[Initiator]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebSocketCreated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">initiator=Initiator.from_json(json[</span><span class="s4">'initiator'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'initiator' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webSocketFrameError'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketFrameError:</span>
    <span class="s3">''' 
    Fired when WebSocket message error occurs. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: WebSocket error message.</span>
    <span class="s1">error_message: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebSocketFrameError:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">error_message=str(json[</span><span class="s4">'errorMessage'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webSocketFrameReceived'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketFrameReceived:</span>
    <span class="s3">''' 
    Fired when WebSocket message is received. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: WebSocket response data.</span>
    <span class="s1">response: WebSocketFrame</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebSocketFrameReceived:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">response=WebSocketFrame.from_json(json[</span><span class="s4">'response'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webSocketFrameSent'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketFrameSent:</span>
    <span class="s3">''' 
    Fired when WebSocket message is sent. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: WebSocket response data.</span>
    <span class="s1">response: WebSocketFrame</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebSocketFrameSent:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">response=WebSocketFrame.from_json(json[</span><span class="s4">'response'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webSocketHandshakeResponseReceived'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketHandshakeResponseReceived:</span>
    <span class="s3">''' 
    Fired when WebSocket handshake response becomes available. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: WebSocket response data.</span>
    <span class="s1">response: WebSocketResponse</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebSocketHandshakeResponseReceived:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">response=WebSocketResponse.from_json(json[</span><span class="s4">'response'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webSocketWillSendHandshakeRequest'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebSocketWillSendHandshakeRequest:</span>
    <span class="s3">''' 
    Fired when WebSocket is about to initiate handshake. 
    '''</span>
    <span class="s0">#: Request identifier.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: UTC Timestamp.</span>
    <span class="s1">wall_time: TimeSinceEpoch</span>
    <span class="s0">#: WebSocket request data.</span>
    <span class="s1">request: WebSocketRequest</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebSocketWillSendHandshakeRequest:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">wall_time=TimeSinceEpoch.from_json(json[</span><span class="s4">'wallTime'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">request=WebSocketRequest.from_json(json[</span><span class="s4">'request'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webTransportCreated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebTransportCreated:</span>
    <span class="s3">''' 
    Fired upon WebTransport creation. 
    '''</span>
    <span class="s0">#: WebTransport identifier.</span>
    <span class="s1">transport_id: RequestId</span>
    <span class="s0">#: WebTransport request URL.</span>
    <span class="s1">url: str</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>
    <span class="s0">#: Request initiator.</span>
    <span class="s1">initiator: typing.Optional[Initiator]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebTransportCreated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">transport_id=RequestId.from_json(json[</span><span class="s4">'transportId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">initiator=Initiator.from_json(json[</span><span class="s4">'initiator'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'initiator' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webTransportConnectionEstablished'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebTransportConnectionEstablished:</span>
    <span class="s3">''' 
    Fired when WebTransport handshake is finished. 
    '''</span>
    <span class="s0">#: WebTransport identifier.</span>
    <span class="s1">transport_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebTransportConnectionEstablished:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">transport_id=RequestId.from_json(json[</span><span class="s4">'transportId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.webTransportClosed'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">WebTransportClosed:</span>
    <span class="s3">''' 
    Fired when WebTransport is disposed. 
    '''</span>
    <span class="s0">#: WebTransport identifier.</span>
    <span class="s1">transport_id: RequestId</span>
    <span class="s0">#: Timestamp.</span>
    <span class="s1">timestamp: MonotonicTime</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; WebTransportClosed:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">transport_id=RequestId.from_json(json[</span><span class="s4">'transportId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=MonotonicTime.from_json(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.requestWillBeSentExtraInfo'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RequestWillBeSentExtraInfo:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Fired when additional information about a requestWillBeSent event is available from the 
    network stack. Not every requestWillBeSent event will have an additional 
    requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent 
    or requestWillBeSentExtraInfo will be fired first for the same request. 
    '''</span>
    <span class="s0">#: Request identifier. Used to match this information to an existing requestWillBeSent event.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: A list of cookies potentially associated to the requested URL. This includes both cookies sent with</span>
    <span class="s0">#: the request and the ones not sent; the latter are distinguished by having blockedReason field set.</span>
    <span class="s1">associated_cookies: typing.List[BlockedCookieWithReason]</span>
    <span class="s0">#: Raw request headers as they will be sent over the wire.</span>
    <span class="s1">headers: Headers</span>
    <span class="s0">#: The client security state set for the request.</span>
    <span class="s1">client_security_state: typing.Optional[ClientSecurityState]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; RequestWillBeSentExtraInfo:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">associated_cookies=[BlockedCookieWithReason.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'associatedCookies'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">headers=Headers.from_json(json[</span><span class="s4">'headers'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">client_security_state=ClientSecurityState.from_json(json[</span><span class="s4">'clientSecurityState'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'clientSecurityState' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.responseReceivedExtraInfo'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ResponseReceivedExtraInfo:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Fired when additional information about a responseReceived event is available from the network 
    stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for 
    it, and responseReceivedExtraInfo may be fired before or after responseReceived. 
    '''</span>
    <span class="s0">#: Request identifier. Used to match this information to another responseReceived event.</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: A list of cookies which were not stored from the response along with the corresponding</span>
    <span class="s0">#: reasons for blocking. The cookies here may not be valid due to syntax errors, which</span>
    <span class="s0">#: are represented by the invalid cookie line string instead of a proper cookie.</span>
    <span class="s1">blocked_cookies: typing.List[BlockedSetCookieWithReason]</span>
    <span class="s0">#: Raw response headers as they were received over the wire.</span>
    <span class="s1">headers: Headers</span>
    <span class="s0">#: The IP address space of the resource. The address space can only be determined once the transport</span>
    <span class="s0">#: established the connection, so we can't send it in ``requestWillBeSentExtraInfo``.</span>
    <span class="s1">resource_ip_address_space: IPAddressSpace</span>
    <span class="s0">#: Raw response header text as it was received over the wire. The raw text may not always be</span>
    <span class="s0">#: available, such as in the case of HTTP/2 or QUIC.</span>
    <span class="s1">headers_text: typing.Optional[str]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ResponseReceivedExtraInfo:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">blocked_cookies=[BlockedSetCookieWithReason.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'blockedCookies'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">headers=Headers.from_json(json[</span><span class="s4">'headers'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">resource_ip_address_space=IPAddressSpace.from_json(json[</span><span class="s4">'resourceIPAddressSpace'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">headers_text=str(json[</span><span class="s4">'headersText'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'headersText' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Network.trustTokenOperationDone'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">TrustTokenOperationDone:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Fired exactly once for each Trust Token operation. Depending on 
    the type of the operation and whether the operation succeeded or 
    failed, the event is fired before the corresponding request was sent 
    or after the response was received. 
    '''</span>
    <span class="s0">#: Detailed success or error status of the operation.</span>
    <span class="s0">#: 'AlreadyExists' also signifies a successful operation, as the result</span>
    <span class="s0">#: of the operation already exists und thus, the operation was abort</span>
    <span class="s0">#: preemptively (e.g. a cache hit).</span>
    <span class="s1">status: str</span>
    <span class="s1">type_: TrustTokenOperationType</span>
    <span class="s1">request_id: RequestId</span>
    <span class="s0">#: Top level origin. The context in which the operation was attempted.</span>
    <span class="s1">top_level_origin: typing.Optional[str]</span>
    <span class="s0">#: Origin of the issuer in case of a &quot;Issuance&quot; or &quot;Redemption&quot; operation.</span>
    <span class="s1">issuer_origin: typing.Optional[str]</span>
    <span class="s0">#: The number of obtained Trust Tokens on a successful &quot;Issuance&quot; operation.</span>
    <span class="s1">issued_token_count: typing.Optional[int]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; TrustTokenOperationDone:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">status=str(json[</span><span class="s4">'status'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">type_=TrustTokenOperationType.from_json(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">request_id=RequestId.from_json(json[</span><span class="s4">'requestId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">top_level_origin=str(json[</span><span class="s4">'topLevelOrigin'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'topLevelOrigin' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">issuer_origin=str(json[</span><span class="s4">'issuerOrigin'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'issuerOrigin' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">issued_token_count=int(json[</span><span class="s4">'issuedTokenCount'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'issuedTokenCount' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>
</pre>
</body>
</html>