<html>
<head>
<title>test_socket.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_socket.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">errno</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">attr</span>

<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">socket </span><span class="s0">as </span><span class="s1">stdlib_socket</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">tempfile</span>
<span class="s0">import </span><span class="s1">sys </span><span class="s0">as </span><span class="s1">_sys</span>
<span class="s0">from </span><span class="s1">.._core.tests.tutil </span><span class="s0">import </span><span class="s1">creates_ipv6</span><span class="s0">, </span><span class="s1">binds_ipv6</span>
<span class="s0">from </span><span class="s1">.. </span><span class="s0">import </span><span class="s1">_core</span>
<span class="s0">from </span><span class="s1">.. </span><span class="s0">import </span><span class="s1">_socket </span><span class="s0">as </span><span class="s1">_tsocket</span>
<span class="s0">from </span><span class="s1">.. </span><span class="s0">import </span><span class="s1">socket </span><span class="s0">as </span><span class="s1">tsocket</span>
<span class="s0">from </span><span class="s1">.._socket </span><span class="s0">import </span><span class="s1">_NUMERIC_ONLY</span><span class="s0">, </span><span class="s1">_try_sync</span>
<span class="s0">from </span><span class="s1">..testing </span><span class="s0">import </span><span class="s1">assert_checkpoints</span><span class="s0">, </span><span class="s1">wait_all_tasks_blocked</span>

<span class="s2">################################################################</span>
<span class="s2"># utils</span>
<span class="s2">################################################################</span>


<span class="s0">class </span><span class="s1">MonkeypatchedGAI:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">orig_getaddrinfo):</span>
        <span class="s1">self._orig_getaddrinfo = orig_getaddrinfo</span>
        <span class="s1">self._responses = {}</span>
        <span class="s1">self.record = []</span>

    <span class="s2"># get a normalized getaddrinfo argument tuple</span>
    <span class="s0">def </span><span class="s1">_frozenbind(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">sig = inspect.signature(self._orig_getaddrinfo)</span>
        <span class="s1">bound = sig.bind(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">bound.apply_defaults()</span>
        <span class="s1">frozenbound = bound.args</span>
        <span class="s0">assert not </span><span class="s1">bound.kwargs</span>
        <span class="s0">return </span><span class="s1">frozenbound</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s0">, </span><span class="s1">response</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._responses[self._frozenbind(*args</span><span class="s0">, </span><span class="s1">**kwargs)] = response</span>

    <span class="s0">def </span><span class="s1">getaddrinfo(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">bound = self._frozenbind(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">self.record.append(bound)</span>
        <span class="s0">if </span><span class="s1">bound </span><span class="s0">in </span><span class="s1">self._responses:</span>
            <span class="s0">return </span><span class="s1">self._responses[bound]</span>
        <span class="s0">elif </span><span class="s1">bound[-</span><span class="s3">1</span><span class="s1">] &amp; stdlib_socket.AI_NUMERICHOST:</span>
            <span class="s0">return </span><span class="s1">self._orig_getaddrinfo(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;gai called with unexpected arguments {}&quot;</span><span class="s1">.format(bound))</span>


<span class="s1">@pytest.fixture</span>
<span class="s0">def </span><span class="s1">monkeygai(monkeypatch):</span>
    <span class="s1">controller = MonkeypatchedGAI(stdlib_socket.getaddrinfo)</span>
    <span class="s1">monkeypatch.setattr(stdlib_socket</span><span class="s0">, </span><span class="s4">&quot;getaddrinfo&quot;</span><span class="s0">, </span><span class="s1">controller.getaddrinfo)</span>
    <span class="s0">return </span><span class="s1">controller</span>


<span class="s0">async def </span><span class="s1">test__try_sync():</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">async with </span><span class="s1">_try_sync():</span>
            <span class="s0">pass</span>

    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
            <span class="s0">async with </span><span class="s1">_try_sync():</span>
                <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">async with </span><span class="s1">_try_sync():</span>
        <span class="s0">raise </span><span class="s1">BlockingIOError</span>

    <span class="s0">def </span><span class="s1">_is_ValueError(exc):</span>
        <span class="s0">return </span><span class="s1">isinstance(exc</span><span class="s0">, </span><span class="s1">ValueError)</span>

    <span class="s0">async with </span><span class="s1">_try_sync(_is_ValueError):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(BlockingIOError):</span>
            <span class="s0">async with </span><span class="s1">_try_sync(_is_ValueError):</span>
                <span class="s0">raise </span><span class="s1">BlockingIOError</span>


<span class="s2">################################################################</span>
<span class="s2"># basic re-exports</span>
<span class="s2">################################################################</span>


<span class="s0">def </span><span class="s1">test_socket_has_some_reexports():</span>
    <span class="s0">assert </span><span class="s1">tsocket.SOL_SOCKET == stdlib_socket.SOL_SOCKET</span>
    <span class="s0">assert </span><span class="s1">tsocket.TCP_NODELAY == stdlib_socket.TCP_NODELAY</span>
    <span class="s0">assert </span><span class="s1">tsocket.gaierror == stdlib_socket.gaierror</span>
    <span class="s0">assert </span><span class="s1">tsocket.ntohs == stdlib_socket.ntohs</span>


<span class="s2">################################################################</span>
<span class="s2"># name resolution</span>
<span class="s2">################################################################</span>


<span class="s0">async def </span><span class="s1">test_getaddrinfo(monkeygai):</span>
    <span class="s0">def </span><span class="s1">check(got</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s2"># win32 returns 0 for the proto field</span>
        <span class="s2"># musl and glibc have inconsistent handling of the canonical name</span>
        <span class="s2"># field (https://github.com/python-trio/trio/issues/1499)</span>
        <span class="s2"># Neither field gets used much and there isn't much opportunity for us</span>
        <span class="s2"># to mess them up, so we don't bother checking them here</span>
        <span class="s0">def </span><span class="s1">interesting_fields(gai_tup):</span>
            <span class="s2"># (family, type, proto, canonname, sockaddr)</span>
            <span class="s1">family</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">proto</span><span class="s0">, </span><span class="s1">canonname</span><span class="s0">, </span><span class="s1">sockaddr = gai_tup</span>
            <span class="s0">return </span><span class="s1">(family</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">sockaddr)</span>

        <span class="s0">def </span><span class="s1">filtered(gai_list):</span>
            <span class="s0">return </span><span class="s1">[interesting_fields(gai_tup) </span><span class="s0">for </span><span class="s1">gai_tup </span><span class="s0">in </span><span class="s1">gai_list]</span>

        <span class="s0">assert </span><span class="s1">filtered(got) == filtered(expected)</span>

    <span class="s2"># Simple non-blocking non-error cases, ipv4 and ipv6:</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s1">res = </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s4">&quot;12345&quot;</span><span class="s0">, </span><span class="s1">type=tsocket.SOCK_STREAM)</span>

    <span class="s1">check(</span>
        <span class="s1">res</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">tsocket.AF_INET</span><span class="s0">,  </span><span class="s2"># 127.0.0.1 is ipv4</span>
                <span class="s1">tsocket.SOCK_STREAM</span><span class="s0">,</span>
                <span class="s1">tsocket.IPPROTO_TCP</span><span class="s0">,</span>
                <span class="s4">&quot;&quot;</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">12345</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s1">res = </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;::1&quot;</span><span class="s0">, </span><span class="s4">&quot;12345&quot;</span><span class="s0">, </span><span class="s1">type=tsocket.SOCK_DGRAM)</span>
    <span class="s1">check(</span>
        <span class="s1">res</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">tsocket.AF_INET6</span><span class="s0">,</span>
                <span class="s1">tsocket.SOCK_DGRAM</span><span class="s0">,</span>
                <span class="s1">tsocket.IPPROTO_UDP</span><span class="s0">,</span>
                <span class="s4">&quot;&quot;</span><span class="s0">,</span>
                <span class="s1">(</span><span class="s4">&quot;::1&quot;</span><span class="s0">, </span><span class="s3">12345</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">monkeygai.set(</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s5">b&quot;host&quot;</span><span class="s0">, </span><span class="s4">&quot;port&quot;</span><span class="s0">, </span><span class="s1">family=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">type=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">proto=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">flags=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s1">res = </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;host&quot;</span><span class="s0">, </span><span class="s4">&quot;port&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">res == </span><span class="s4">&quot;x&quot;</span>
    <span class="s0">assert </span><span class="s1">monkeygai.record[-</span><span class="s3">1</span><span class="s1">] == (</span><span class="s5">b&quot;host&quot;</span><span class="s0">, </span><span class="s4">&quot;port&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2"># check raising an error from a non-blocking getaddrinfo</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(tsocket.gaierror) </span><span class="s0">as </span><span class="s1">excinfo:</span>
            <span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;::1&quot;</span><span class="s0">, </span><span class="s4">&quot;12345&quot;</span><span class="s0">, </span><span class="s1">type=-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2"># Linux + glibc, Windows</span>
    <span class="s1">expected_errnos = {tsocket.EAI_SOCKTYPE}</span>
    <span class="s2"># Linux + musl</span>
    <span class="s1">expected_errnos.add(tsocket.EAI_SERVICE)</span>
    <span class="s2"># macOS</span>
    <span class="s0">if </span><span class="s1">hasattr(tsocket</span><span class="s0">, </span><span class="s4">&quot;EAI_BADHINTS&quot;</span><span class="s1">):</span>
        <span class="s1">expected_errnos.add(tsocket.EAI_BADHINTS)</span>
    <span class="s0">assert </span><span class="s1">excinfo.value.errno </span><span class="s0">in </span><span class="s1">expected_errnos</span>

    <span class="s2"># check raising an error from a blocking getaddrinfo (exploits the fact</span>
    <span class="s2"># that monkeygai raises if it gets a non-numeric request it hasn't been</span>
    <span class="s2"># given an answer for)</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
            <span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;asdf&quot;</span><span class="s0">, </span><span class="s4">&quot;12345&quot;</span><span class="s1">)</span>


<span class="s0">async def </span><span class="s1">test_getnameinfo():</span>
    <span class="s2"># Trivial test:</span>
    <span class="s1">ni_numeric = stdlib_socket.NI_NUMERICHOST | stdlib_socket.NI_NUMERICSERV</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s1">got = </span><span class="s0">await </span><span class="s1">tsocket.getnameinfo((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">1234</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ni_numeric)</span>
    <span class="s0">assert </span><span class="s1">got == (</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s4">&quot;1234&quot;</span><span class="s1">)</span>

    <span class="s2"># getnameinfo requires a numeric address as input:</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(tsocket.gaierror):</span>
            <span class="s0">await </span><span class="s1">tsocket.getnameinfo((</span><span class="s4">&quot;google.com&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(tsocket.gaierror):</span>
            <span class="s0">await </span><span class="s1">tsocket.getnameinfo((</span><span class="s4">&quot;localhost&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2"># Blocking call to get expected values:</span>
    <span class="s1">host</span><span class="s0">, </span><span class="s1">service = stdlib_socket.getnameinfo((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2"># Some working calls:</span>
    <span class="s1">got = </span><span class="s0">await </span><span class="s1">tsocket.getnameinfo((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">got == (host</span><span class="s0">, </span><span class="s1">service)</span>

    <span class="s1">got = </span><span class="s0">await </span><span class="s1">tsocket.getnameinfo((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span><span class="s0">, </span><span class="s1">tsocket.NI_NUMERICHOST)</span>
    <span class="s0">assert </span><span class="s1">got == (</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s1">service)</span>

    <span class="s1">got = </span><span class="s0">await </span><span class="s1">tsocket.getnameinfo((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span><span class="s0">, </span><span class="s1">tsocket.NI_NUMERICSERV)</span>
    <span class="s0">assert </span><span class="s1">got == (host</span><span class="s0">, </span><span class="s4">&quot;80&quot;</span><span class="s1">)</span>


<span class="s2">################################################################</span>
<span class="s2"># constructors</span>
<span class="s2">################################################################</span>


<span class="s0">async def </span><span class="s1">test_from_stdlib_socket():</span>
    <span class="s1">sa</span><span class="s0">, </span><span class="s1">sb = stdlib_socket.socketpair()</span>
    <span class="s0">assert not </span><span class="s1">isinstance(sa</span><span class="s0">, </span><span class="s1">tsocket.SocketType)</span>
    <span class="s0">with </span><span class="s1">sa</span><span class="s0">, </span><span class="s1">sb:</span>
        <span class="s1">ta = tsocket.from_stdlib_socket(sa)</span>
        <span class="s0">assert </span><span class="s1">isinstance(ta</span><span class="s0">, </span><span class="s1">tsocket.SocketType)</span>
        <span class="s0">assert </span><span class="s1">sa.fileno() == ta.fileno()</span>
        <span class="s0">await </span><span class="s1">ta.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">sb.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>

    <span class="s2"># rejects other types</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">tsocket.from_stdlib_socket(</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">class </span><span class="s1">MySocket(stdlib_socket.socket):</span>
        <span class="s0">pass</span>

    <span class="s0">with </span><span class="s1">MySocket() </span><span class="s0">as </span><span class="s1">mysock:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s1">tsocket.from_stdlib_socket(mysock)</span>


<span class="s0">async def </span><span class="s1">test_from_fd():</span>
    <span class="s1">sa</span><span class="s0">, </span><span class="s1">sb = stdlib_socket.socketpair()</span>
    <span class="s1">ta = tsocket.fromfd(sa.fileno()</span><span class="s0">, </span><span class="s1">sa.family</span><span class="s0">, </span><span class="s1">sa.type</span><span class="s0">, </span><span class="s1">sa.proto)</span>
    <span class="s0">with </span><span class="s1">sa</span><span class="s0">, </span><span class="s1">sb</span><span class="s0">, </span><span class="s1">ta:</span>
        <span class="s0">assert </span><span class="s1">ta.fileno() != sa.fileno()</span>
        <span class="s0">await </span><span class="s1">ta.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">sb.recv(</span><span class="s3">3</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>


<span class="s0">async def </span><span class="s1">test_socketpair_simple():</span>
    <span class="s0">async def </span><span class="s1">child(sock):</span>
        <span class="s1">print(</span><span class="s4">&quot;sending hello&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">sock.send(</span><span class="s5">b&quot;h&quot;</span><span class="s1">)</span>
        <span class="s0">assert await </span><span class="s1">sock.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;h&quot;</span>

    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(child</span><span class="s0">, </span><span class="s1">a)</span>
            <span class="s1">nursery.start_soon(child</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">hasattr(tsocket</span><span class="s0">, </span><span class="s4">&quot;fromshare&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;windows only&quot;</span><span class="s1">)</span>
<span class="s0">async def </span><span class="s1">test_fromshare():</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s2"># share with ourselves</span>
        <span class="s1">shared = a.share(os.getpid())</span>
        <span class="s1">a2 = tsocket.fromshare(shared)</span>
        <span class="s0">with </span><span class="s1">a2:</span>
            <span class="s0">assert </span><span class="s1">a.fileno() != a2.fileno()</span>
            <span class="s0">await </span><span class="s1">a2.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
            <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>


<span class="s0">async def </span><span class="s1">test_socket():</span>
    <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">s:</span>
        <span class="s0">assert </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">tsocket.SocketType)</span>
        <span class="s0">assert </span><span class="s1">s.family == tsocket.AF_INET</span>


<span class="s1">@creates_ipv6</span>
<span class="s0">async def </span><span class="s1">test_socket_v6():</span>
    <span class="s0">with </span><span class="s1">tsocket.socket(tsocket.AF_INET6</span><span class="s0">, </span><span class="s1">tsocket.SOCK_DGRAM) </span><span class="s0">as </span><span class="s1">s:</span>
        <span class="s0">assert </span><span class="s1">isinstance(s</span><span class="s0">, </span><span class="s1">tsocket.SocketType)</span>
        <span class="s0">assert </span><span class="s1">s.family == tsocket.AF_INET6</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">_sys.platform == </span><span class="s4">&quot;linux&quot;</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;linux only&quot;</span><span class="s1">)</span>
<span class="s0">async def </span><span class="s1">test_sniff_sockopts():</span>
    <span class="s0">from </span><span class="s1">socket </span><span class="s0">import </span><span class="s1">AF_INET</span><span class="s0">, </span><span class="s1">AF_INET6</span><span class="s0">, </span><span class="s1">SOCK_DGRAM</span><span class="s0">, </span><span class="s1">SOCK_STREAM</span>

    <span class="s2"># generate the combinations of families/types we're testing:</span>
    <span class="s1">sockets = []</span>
    <span class="s0">for </span><span class="s1">family </span><span class="s0">in </span><span class="s1">[AF_INET</span><span class="s0">, </span><span class="s1">AF_INET6]:</span>
        <span class="s0">for </span><span class="s1">type </span><span class="s0">in </span><span class="s1">[SOCK_DGRAM</span><span class="s0">, </span><span class="s1">SOCK_STREAM]:</span>
            <span class="s1">sockets.append(stdlib_socket.socket(family</span><span class="s0">, </span><span class="s1">type))</span>
    <span class="s0">for </span><span class="s1">socket </span><span class="s0">in </span><span class="s1">sockets:</span>
        <span class="s2"># regular Trio socket constructor</span>
        <span class="s1">tsocket_socket = tsocket.socket(fileno=socket.fileno())</span>
        <span class="s2"># check family / type for correctness:</span>
        <span class="s0">assert </span><span class="s1">tsocket_socket.family == socket.family</span>
        <span class="s0">assert </span><span class="s1">tsocket_socket.type == socket.type</span>
        <span class="s1">tsocket_socket.detach()</span>

        <span class="s2"># fromfd constructor</span>
        <span class="s1">tsocket_from_fd = tsocket.fromfd(socket.fileno()</span><span class="s0">, </span><span class="s1">AF_INET</span><span class="s0">, </span><span class="s1">SOCK_STREAM)</span>
        <span class="s2"># check family / type for correctness:</span>
        <span class="s0">assert </span><span class="s1">tsocket_from_fd.family == socket.family</span>
        <span class="s0">assert </span><span class="s1">tsocket_from_fd.type == socket.type</span>
        <span class="s1">tsocket_from_fd.close()</span>

        <span class="s1">socket.close()</span>


<span class="s2">################################################################</span>
<span class="s2"># _SocketType</span>
<span class="s2">################################################################</span>


<span class="s0">async def </span><span class="s1">test_SocketType_basics():</span>
    <span class="s1">sock = tsocket.socket()</span>
    <span class="s0">with </span><span class="s1">sock </span><span class="s0">as </span><span class="s1">cm_enter_value:</span>
        <span class="s0">assert </span><span class="s1">cm_enter_value </span><span class="s0">is </span><span class="s1">sock</span>
        <span class="s0">assert </span><span class="s1">isinstance(sock.fileno()</span><span class="s0">, </span><span class="s1">int)</span>
        <span class="s0">assert not </span><span class="s1">sock.get_inheritable()</span>
        <span class="s1">sock.set_inheritable(</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">sock.get_inheritable()</span>

        <span class="s1">sock.setsockopt(tsocket.IPPROTO_TCP</span><span class="s0">, </span><span class="s1">tsocket.TCP_NODELAY</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">sock.getsockopt(tsocket.IPPROTO_TCP</span><span class="s0">, </span><span class="s1">tsocket.TCP_NODELAY)</span>
        <span class="s1">sock.setsockopt(tsocket.IPPROTO_TCP</span><span class="s0">, </span><span class="s1">tsocket.TCP_NODELAY</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">sock.getsockopt(tsocket.IPPROTO_TCP</span><span class="s0">, </span><span class="s1">tsocket.TCP_NODELAY)</span>
    <span class="s2"># closed sockets have fileno() == -1</span>
    <span class="s0">assert </span><span class="s1">sock.fileno() == -</span><span class="s3">1</span>

    <span class="s2"># smoke test</span>
    <span class="s1">repr(sock)</span>

    <span class="s2"># detach</span>
    <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock:</span>
        <span class="s1">fd = sock.fileno()</span>
        <span class="s0">assert </span><span class="s1">sock.detach() == fd</span>
        <span class="s0">assert </span><span class="s1">sock.fileno() == -</span><span class="s3">1</span>

    <span class="s2"># close</span>
    <span class="s1">sock = tsocket.socket()</span>
    <span class="s0">assert </span><span class="s1">sock.fileno() &gt;= </span><span class="s3">0</span>
    <span class="s1">sock.close()</span>
    <span class="s0">assert </span><span class="s1">sock.fileno() == -</span><span class="s3">1</span>

    <span class="s2"># share was tested above together with fromshare</span>

    <span class="s2"># check __dir__</span>
    <span class="s0">assert </span><span class="s4">&quot;family&quot; </span><span class="s0">in </span><span class="s1">dir(sock)</span>
    <span class="s0">assert </span><span class="s4">&quot;recv&quot; </span><span class="s0">in </span><span class="s1">dir(sock)</span>
    <span class="s0">assert </span><span class="s4">&quot;setsockopt&quot; </span><span class="s0">in </span><span class="s1">dir(sock)</span>

    <span class="s2"># our __getattr__ handles unknown names</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AttributeError):</span>
        <span class="s1">sock.asdf</span>

    <span class="s2"># type family proto</span>
    <span class="s1">stdlib_sock = stdlib_socket.socket()</span>
    <span class="s1">sock = tsocket.from_stdlib_socket(stdlib_sock)</span>
    <span class="s0">assert </span><span class="s1">sock.type == _tsocket.real_socket_type(stdlib_sock.type)</span>
    <span class="s0">assert </span><span class="s1">sock.family == stdlib_sock.family</span>
    <span class="s0">assert </span><span class="s1">sock.proto == stdlib_sock.proto</span>
    <span class="s1">sock.close()</span>


<span class="s0">async def </span><span class="s1">test_SocketType_dup():</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s1">a2 = a.dup()</span>
        <span class="s0">with </span><span class="s1">a2:</span>
            <span class="s0">assert </span><span class="s1">isinstance(a2</span><span class="s0">, </span><span class="s1">tsocket.SocketType)</span>
            <span class="s0">assert </span><span class="s1">a2.fileno() != a.fileno()</span>
            <span class="s1">a.close()</span>
            <span class="s0">await </span><span class="s1">a2.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
            <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>


<span class="s0">async def </span><span class="s1">test_SocketType_shutdown():</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s0">await </span><span class="s1">a.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
        <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>
        <span class="s0">assert not </span><span class="s1">a.did_shutdown_SHUT_WR</span>
        <span class="s0">assert not </span><span class="s1">b.did_shutdown_SHUT_WR</span>
        <span class="s1">a.shutdown(tsocket.SHUT_WR)</span>
        <span class="s0">assert </span><span class="s1">a.did_shutdown_SHUT_WR</span>
        <span class="s0">assert not </span><span class="s1">b.did_shutdown_SHUT_WR</span>
        <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;&quot;</span>
        <span class="s0">await </span><span class="s1">b.send(</span><span class="s5">b&quot;y&quot;</span><span class="s1">)</span>
        <span class="s0">assert await </span><span class="s1">a.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;y&quot;</span>

    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s0">assert not </span><span class="s1">a.did_shutdown_SHUT_WR</span>
        <span class="s1">a.shutdown(tsocket.SHUT_RD)</span>
        <span class="s0">assert not </span><span class="s1">a.did_shutdown_SHUT_WR</span>

    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s0">assert not </span><span class="s1">a.did_shutdown_SHUT_WR</span>
        <span class="s1">a.shutdown(tsocket.SHUT_RDWR)</span>
        <span class="s0">assert </span><span class="s1">a.did_shutdown_SHUT_WR</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;address, socket_type&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s1">tsocket.AF_INET)</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span><span class="s4">&quot;::1&quot;</span><span class="s0">, </span><span class="s1">tsocket.AF_INET6</span><span class="s0">, </span><span class="s1">marks=binds_ipv6)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">async def </span><span class="s1">test_SocketType_simple_server(address</span><span class="s0">, </span><span class="s1">socket_type):</span>
    <span class="s2"># listen, bind, accept, connect, getpeername, getsockname</span>
    <span class="s1">listener = tsocket.socket(socket_type)</span>
    <span class="s1">client = tsocket.socket(socket_type)</span>
    <span class="s0">with </span><span class="s1">listener</span><span class="s0">, </span><span class="s1">client:</span>
        <span class="s0">await </span><span class="s1">listener.bind((address</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">listener.listen(</span><span class="s3">20</span><span class="s1">)</span>
        <span class="s1">addr = listener.getsockname()[:</span><span class="s3">2</span><span class="s1">]</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(client.connect</span><span class="s0">, </span><span class="s1">addr)</span>
            <span class="s1">server</span><span class="s0">, </span><span class="s1">client_addr = </span><span class="s0">await </span><span class="s1">listener.accept()</span>
        <span class="s0">with </span><span class="s1">server:</span>
            <span class="s0">assert </span><span class="s1">client_addr == server.getpeername() == client.getsockname()</span>
            <span class="s0">await </span><span class="s1">server.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
            <span class="s0">assert await </span><span class="s1">client.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>


<span class="s0">async def </span><span class="s1">test_SocketType_is_readable():</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s0">assert not </span><span class="s1">a.is_readable()</span>
        <span class="s0">await </span><span class="s1">b.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">_core.wait_readable(a)</span>
        <span class="s0">assert </span><span class="s1">a.is_readable()</span>
        <span class="s0">assert await </span><span class="s1">a.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>
        <span class="s0">assert not </span><span class="s1">a.is_readable()</span>


<span class="s2"># On some macOS systems, getaddrinfo likes to return V4-mapped addresses even</span>
<span class="s2"># when we *don't* pass AI_V4MAPPED.</span>
<span class="s2"># https://github.com/python-trio/trio/issues/580</span>
<span class="s0">def </span><span class="s1">gai_without_v4mapped_is_buggy():  </span><span class="s2"># pragma: no cover</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">stdlib_socket.getaddrinfo(</span><span class="s4">&quot;1.2.3.4&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">family=stdlib_socket.AF_INET6)</span>
    <span class="s0">except </span><span class="s1">stdlib_socket.gaierror:</span>
        <span class="s0">return False</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return True</span>


<span class="s1">@attr.s</span>
<span class="s0">class </span><span class="s1">Addresses:</span>
    <span class="s1">bind_all = attr.ib()</span>
    <span class="s1">localhost = attr.ib()</span>
    <span class="s1">arbitrary = attr.ib()</span>
    <span class="s1">broadcast = attr.ib()</span>


<span class="s2"># Direct thorough tests of the implicit resolver helpers</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;socket_type, addrs&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">tsocket.AF_INET</span><span class="s0">,</span>
            <span class="s1">Addresses(</span>
                <span class="s1">bind_all=</span><span class="s4">&quot;0.0.0.0&quot;</span><span class="s0">,</span>
                <span class="s1">localhost=</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">,</span>
                <span class="s1">arbitrary=</span><span class="s4">&quot;1.2.3.4&quot;</span><span class="s0">,</span>
                <span class="s1">broadcast=</span><span class="s4">&quot;255.255.255.255&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span>
            <span class="s1">tsocket.AF_INET6</span><span class="s0">,</span>
            <span class="s1">Addresses(</span>
                <span class="s1">bind_all=</span><span class="s4">&quot;::&quot;</span><span class="s0">,</span>
                <span class="s1">localhost=</span><span class="s4">&quot;::1&quot;</span><span class="s0">,</span>
                <span class="s1">arbitrary=</span><span class="s4">&quot;1::2&quot;</span><span class="s0">,</span>
                <span class="s1">broadcast=</span><span class="s4">&quot;::ffff:255.255.255.255&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">marks=creates_ipv6</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">async def </span><span class="s1">test_SocketType_resolve(socket_type</span><span class="s0">, </span><span class="s1">addrs):</span>
    <span class="s1">v6 = socket_type == tsocket.AF_INET6</span>

    <span class="s0">def </span><span class="s1">pad(addr):</span>
        <span class="s0">if </span><span class="s1">v6:</span>
            <span class="s0">while </span><span class="s1">len(addr) &lt; </span><span class="s3">4</span><span class="s1">:</span>
                <span class="s1">addr += (</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">addr</span>

    <span class="s0">def </span><span class="s1">assert_eq(actual</span><span class="s0">, </span><span class="s1">expected):</span>
        <span class="s0">assert </span><span class="s1">pad(expected) == pad(actual)</span>

    <span class="s0">with </span><span class="s1">tsocket.socket(family=socket_type) </span><span class="s0">as </span><span class="s1">sock:</span>
        <span class="s2"># For some reason the stdlib special-cases &quot;&quot; to pass NULL to</span>
        <span class="s2"># getaddrinfo They also error out on None, but whatever, None is much</span>
        <span class="s2"># more consistent, so we accept it too.</span>
        <span class="s0">for </span><span class="s1">null </span><span class="s0">in </span><span class="s1">[</span><span class="s0">None, </span><span class="s4">&quot;&quot;</span><span class="s1">]:</span>
            <span class="s1">got = </span><span class="s0">await </span><span class="s1">sock._resolve_local_address_nocp((null</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span>
            <span class="s1">assert_eq(got</span><span class="s0">, </span><span class="s1">(addrs.bind_all</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span>
            <span class="s1">got = </span><span class="s0">await </span><span class="s1">sock._resolve_remote_address_nocp((null</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span>
            <span class="s1">assert_eq(got</span><span class="s0">, </span><span class="s1">(addrs.localhost</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span>

        <span class="s2"># AI_PASSIVE only affects the wildcard address, so for everything else</span>
        <span class="s2"># _resolve_local_address_nocp and _resolve_remote_address_nocp should</span>
        <span class="s2"># work the same:</span>
        <span class="s0">for </span><span class="s1">resolver </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;_resolve_local_address_nocp&quot;</span><span class="s0">, </span><span class="s4">&quot;_resolve_remote_address_nocp&quot;</span><span class="s1">]:</span>

            <span class="s0">async def </span><span class="s1">res(*args):</span>
                <span class="s0">return await </span><span class="s1">getattr(sock</span><span class="s0">, </span><span class="s1">resolver)(*args)</span>

            <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((addrs.arbitrary</span><span class="s0">, </span><span class="s4">&quot;http&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(addrs.arbitrary</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">v6:</span>
                <span class="s2"># Check handling of different length ipv6 address tuples</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s2"># Non-zero flowinfo/scopeid get passed through</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

                <span class="s2"># And again with a string port, as a trick to avoid the</span>
                <span class="s2"># already-resolved address fastpath and make sure we call</span>
                <span class="s2"># getaddrinfo</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s4">&quot;80&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s4">&quot;80&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s4">&quot;80&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s4">&quot;80&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s4">&quot;80&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;1::2&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

                <span class="s2"># V4 mapped addresses resolved if V6ONLY is False</span>
                <span class="s1">sock.setsockopt(tsocket.IPPROTO_IPV6</span><span class="s0">, </span><span class="s1">tsocket.IPV6_V6ONLY</span><span class="s0">, False</span><span class="s1">)</span>
                <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1.2.3.4&quot;</span><span class="s0">, </span><span class="s4">&quot;http&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;::ffff:1.2.3.4&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span>

            <span class="s2"># Check the &lt;broadcast&gt; special case, because why not</span>
            <span class="s1">assert_eq(</span><span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;&lt;broadcast&gt;&quot;</span><span class="s0">, </span><span class="s3">123</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(addrs.broadcast</span><span class="s0">, </span><span class="s3">123</span><span class="s1">))</span>

            <span class="s2"># But not if it's true (at least on systems where getaddrinfo works</span>
            <span class="s2"># correctly)</span>
            <span class="s0">if </span><span class="s1">v6 </span><span class="s0">and not </span><span class="s1">gai_without_v4mapped_is_buggy():</span>
                <span class="s1">sock.setsockopt(tsocket.IPPROTO_IPV6</span><span class="s0">, </span><span class="s1">tsocket.IPV6_V6ONLY</span><span class="s0">, True</span><span class="s1">)</span>
                <span class="s0">with </span><span class="s1">pytest.raises(tsocket.gaierror) </span><span class="s0">as </span><span class="s1">excinfo:</span>
                    <span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1.2.3.4&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span>
                <span class="s2"># Windows, macOS</span>
                <span class="s1">expected_errnos = {tsocket.EAI_NONAME}</span>
                <span class="s2"># Linux</span>
                <span class="s0">if </span><span class="s1">hasattr(tsocket</span><span class="s0">, </span><span class="s4">&quot;EAI_ADDRFAMILY&quot;</span><span class="s1">):</span>
                    <span class="s1">expected_errnos.add(tsocket.EAI_ADDRFAMILY)</span>
                <span class="s0">assert </span><span class="s1">excinfo.value.errno </span><span class="s0">in </span><span class="s1">expected_errnos</span>

            <span class="s2"># A family where we know nothing about the addresses, so should just</span>
            <span class="s2"># pass them through. This should work on Linux, which is enough to</span>
            <span class="s2"># smoke test the basic functionality...</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">netlink_sock = tsocket.socket(</span>
                    <span class="s1">family=tsocket.AF_NETLINK</span><span class="s0">, </span><span class="s1">type=tsocket.SOCK_DGRAM</span>
                <span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">OSError):</span>
                <span class="s0">pass</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert await </span><span class="s1">getattr(netlink_sock</span><span class="s0">, </span><span class="s1">resolver)(</span><span class="s4">&quot;asdf&quot;</span><span class="s1">) == </span><span class="s4">&quot;asdf&quot;</span>
                <span class="s1">netlink_sock.close()</span>

            <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                <span class="s0">await </span><span class="s1">res(</span><span class="s4">&quot;1.2.3.4&quot;</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                <span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1.2.3.4&quot;</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                <span class="s0">if </span><span class="s1">v6:</span>
                    <span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1.2.3.4&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">await </span><span class="s1">res((</span><span class="s4">&quot;1.2.3.4&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>


<span class="s0">async def </span><span class="s1">test_SocketType_unresolved_names():</span>
    <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock:</span>
        <span class="s0">await </span><span class="s1">sock.bind((</span><span class="s4">&quot;localhost&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">sock.getsockname()[</span><span class="s3">0</span><span class="s1">] == </span><span class="s4">&quot;127.0.0.1&quot;</span>
        <span class="s1">sock.listen(</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock2:</span>
            <span class="s0">await </span><span class="s1">sock2.connect((</span><span class="s4">&quot;localhost&quot;</span><span class="s0">, </span><span class="s1">sock.getsockname()[</span><span class="s3">1</span><span class="s1">]))</span>
            <span class="s0">assert </span><span class="s1">sock2.getpeername() == sock.getsockname()</span>

    <span class="s2"># check gaierror propagates out</span>
    <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(tsocket.gaierror):</span>
            <span class="s2"># definitely not a valid request</span>
            <span class="s0">await </span><span class="s1">sock.bind((</span><span class="s4">&quot;1.2:3&quot;</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">))</span>


<span class="s2"># This tests all the complicated paths through _nonblocking_helper, using recv</span>
<span class="s2"># as a stand-in for all the methods that use _nonblocking_helper.</span>
<span class="s0">async def </span><span class="s1">test_SocketType_non_blocking_paths():</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = stdlib_socket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s1">ta = tsocket.from_stdlib_socket(a)</span>
        <span class="s1">b.setblocking(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s2"># cancel before even calling</span>
        <span class="s1">b.send(</span><span class="s5">b&quot;1&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cscope:</span>
            <span class="s1">cscope.cancel()</span>
            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                    <span class="s0">await </span><span class="s1">ta.recv(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s2"># immediate success (also checks that the previous attempt didn't</span>
        <span class="s2"># actually read anything)</span>
        <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
            <span class="s0">await </span><span class="s1">ta.recv(</span><span class="s3">10</span><span class="s1">) == </span><span class="s5">b&quot;1&quot;</span>
        <span class="s2"># immediate failure</span>
        <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
                <span class="s0">await </span><span class="s1">ta.recv(</span><span class="s4">&quot;haha&quot;</span><span class="s1">)</span>
        <span class="s2"># block then succeed</span>

        <span class="s0">async def </span><span class="s1">do_successful_blocking_recv():</span>
            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">assert await </span><span class="s1">ta.recv(</span><span class="s3">10</span><span class="s1">) == </span><span class="s5">b&quot;2&quot;</span>

        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(do_successful_blocking_recv)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s1">b.send(</span><span class="s5">b&quot;2&quot;</span><span class="s1">)</span>
        <span class="s2"># block then cancelled</span>

        <span class="s0">async def </span><span class="s1">do_cancelled_blocking_recv():</span>
            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                    <span class="s0">await </span><span class="s1">ta.recv(</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(do_cancelled_blocking_recv)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s1">nursery.cancel_scope.cancel()</span>
        <span class="s2"># Okay, here's the trickiest one: we want to exercise the path where</span>
        <span class="s2"># the task is signaled to wake, goes to recv, but then the recv fails,</span>
        <span class="s2"># so it has to go back to sleep and try again. Strategy: have two</span>
        <span class="s2"># tasks waiting on two sockets (to work around the rule against having</span>
        <span class="s2"># two tasks waiting on the same socket), wake them both up at the same</span>
        <span class="s2"># time, and whichever one runs first &quot;steals&quot; the data from the</span>
        <span class="s2"># other:</span>
        <span class="s1">tb = tsocket.from_stdlib_socket(b)</span>

        <span class="s0">async def </span><span class="s1">t1():</span>
            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">assert await </span><span class="s1">ta.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;a&quot;</span>
            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">assert await </span><span class="s1">tb.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;b&quot;</span>

        <span class="s0">async def </span><span class="s1">t2():</span>
            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">assert await </span><span class="s1">tb.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;b&quot;</span>
            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">assert await </span><span class="s1">ta.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;a&quot;</span>

        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(t1)</span>
            <span class="s1">nursery.start_soon(t2)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s1">a.send(</span><span class="s5">b&quot;b&quot;</span><span class="s1">)</span>
            <span class="s1">b.send(</span><span class="s5">b&quot;a&quot;</span><span class="s1">)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s1">a.send(</span><span class="s5">b&quot;b&quot;</span><span class="s1">)</span>
            <span class="s1">b.send(</span><span class="s5">b&quot;a&quot;</span><span class="s1">)</span>


<span class="s2"># This tests the complicated paths through connect</span>
<span class="s0">async def </span><span class="s1">test_SocketType_connect_paths():</span>
    <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s2"># Should be a tuple</span>
            <span class="s0">await </span><span class="s1">sock.connect(</span><span class="s4">&quot;localhost&quot;</span><span class="s1">)</span>

    <span class="s2"># cancelled before we start</span>
    <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cancel_scope:</span>
            <span class="s1">cancel_scope.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">sock.connect((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">))</span>

    <span class="s2"># Cancelled in between the connect() call and the connect completing</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cancel_scope:</span>
        <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock</span><span class="s0">, </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">listener:</span>
            <span class="s0">await </span><span class="s1">listener.bind((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
            <span class="s1">listener.listen()</span>

            <span class="s2"># Swap in our weird subclass under the trio.socket._SocketType's</span>
            <span class="s2"># nose -- and then swap it back out again before we hit</span>
            <span class="s2"># wait_socket_writable, which insists on a real socket.</span>
            <span class="s0">class </span><span class="s1">CancelSocket(stdlib_socket.socket):</span>
                <span class="s0">def </span><span class="s1">connect(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                    <span class="s1">cancel_scope.cancel()</span>
                    <span class="s1">sock._sock = stdlib_socket.fromfd(</span>
                        <span class="s1">self.detach()</span><span class="s0">, </span><span class="s1">self.family</span><span class="s0">, </span><span class="s1">self.type</span>
                    <span class="s1">)</span>
                    <span class="s1">sock._sock.connect(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
                    <span class="s2"># If connect *doesn't* raise, then pretend it did</span>
                    <span class="s0">raise </span><span class="s1">BlockingIOError  </span><span class="s2"># pragma: no cover</span>

            <span class="s1">sock._sock.close()</span>
            <span class="s1">sock._sock = CancelSocket()</span>

            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                    <span class="s0">await </span><span class="s1">sock.connect(listener.getsockname())</span>
            <span class="s0">assert </span><span class="s1">sock.fileno() == -</span><span class="s3">1</span>

    <span class="s2"># Failed connect (hopefully after raising BlockingIOError)</span>
    <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(OSError):</span>
            <span class="s2"># TCP port 2 is not assigned. Pretty sure nothing will be</span>
            <span class="s2"># listening there. (We used to bind a port and then *not* call</span>
            <span class="s2"># listen() to ensure nothing was listening there, but it turns</span>
            <span class="s2"># out on macOS if you do this it takes 30 seconds for the</span>
            <span class="s2"># connect to fail. Really. Also if you use a non-routable</span>
            <span class="s2"># address. This way fails instantly though. As long as nothing</span>
            <span class="s2"># is listening on port 2.)</span>
            <span class="s0">await </span><span class="s1">sock.connect((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>


<span class="s0">async def </span><span class="s1">test_resolve_remote_address_exception_closes_socket():</span>
    <span class="s2"># Here we are testing issue 247, any cancellation will leave the socket closed</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cancel_scope:</span>
        <span class="s0">with </span><span class="s1">tsocket.socket() </span><span class="s0">as </span><span class="s1">sock:</span>

            <span class="s0">async def </span><span class="s1">_resolve_remote_address_nocp(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
                <span class="s1">cancel_scope.cancel()</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

            <span class="s1">sock._resolve_remote_address_nocp = _resolve_remote_address_nocp</span>
            <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
                <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                    <span class="s0">await </span><span class="s1">sock.connect(</span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">sock.fileno() == -</span><span class="s3">1</span>


<span class="s0">async def </span><span class="s1">test_send_recv_variants():</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s2"># recv, including with flags</span>
        <span class="s0">assert await </span><span class="s1">a.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">) == </span><span class="s3">1</span>
        <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">tsocket.MSG_PEEK) == </span><span class="s5">b&quot;x&quot;</span>
        <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">10</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>

        <span class="s2"># recv_into</span>
        <span class="s0">await </span><span class="s1">a.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">buf = bytearray(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">b.recv_into(buf)</span>
        <span class="s0">assert </span><span class="s1">buf == </span><span class="s5">b&quot;x&quot; </span><span class="s1">+ </span><span class="s5">b&quot;</span><span class="s0">\x00</span><span class="s5">&quot; </span><span class="s1">* </span><span class="s3">9</span>

        <span class="s0">if </span><span class="s1">hasattr(a</span><span class="s0">, </span><span class="s4">&quot;sendmsg&quot;</span><span class="s1">):</span>
            <span class="s0">assert await </span><span class="s1">a.sendmsg([</span><span class="s5">b&quot;xxx&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]) == </span><span class="s3">3</span>
            <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">10</span><span class="s1">) == </span><span class="s5">b&quot;xxx&quot;</span>

    <span class="s1">a = tsocket.socket(type=tsocket.SOCK_DGRAM)</span>
    <span class="s1">b = tsocket.socket(type=tsocket.SOCK_DGRAM)</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s0">await </span><span class="s1">a.bind((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s0">await </span><span class="s1">b.bind((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>

        <span class="s1">targets = [b.getsockname()</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;localhost&quot;</span><span class="s0">, </span><span class="s1">b.getsockname()[</span><span class="s3">1</span><span class="s1">])]</span>

        <span class="s2"># recvfrom + sendto, with and without names</span>
        <span class="s0">for </span><span class="s1">target </span><span class="s0">in </span><span class="s1">targets:</span>
            <span class="s0">assert await </span><span class="s1">a.sendto(</span><span class="s5">b&quot;xxx&quot;</span><span class="s0">, </span><span class="s1">target) == </span><span class="s3">3</span>
            <span class="s1">(data</span><span class="s0">, </span><span class="s1">addr) = </span><span class="s0">await </span><span class="s1">b.recvfrom(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">data == </span><span class="s5">b&quot;xxx&quot;</span>
            <span class="s0">assert </span><span class="s1">addr == a.getsockname()</span>

        <span class="s2"># sendto + flags</span>
        <span class="s2">#</span>
        <span class="s2"># I can't find any flags that send() accepts... on Linux at least</span>
        <span class="s2"># passing MSG_MORE to send_some on a connected UDP socket seems to</span>
        <span class="s2"># just be ignored.</span>
        <span class="s2">#</span>
        <span class="s2"># But there's no MSG_MORE on Windows or macOS. I guess send_some flags</span>
        <span class="s2"># are really not very useful, but at least this tests them a bit.</span>
        <span class="s0">if </span><span class="s1">hasattr(tsocket</span><span class="s0">, </span><span class="s4">&quot;MSG_MORE&quot;</span><span class="s1">):</span>
            <span class="s0">await </span><span class="s1">a.sendto(</span><span class="s5">b&quot;xxx&quot;</span><span class="s0">, </span><span class="s1">tsocket.MSG_MORE</span><span class="s0">, </span><span class="s1">b.getsockname())</span>
            <span class="s0">await </span><span class="s1">a.sendto(</span><span class="s5">b&quot;yyy&quot;</span><span class="s0">, </span><span class="s1">tsocket.MSG_MORE</span><span class="s0">, </span><span class="s1">b.getsockname())</span>
            <span class="s0">await </span><span class="s1">a.sendto(</span><span class="s5">b&quot;zzz&quot;</span><span class="s0">, </span><span class="s1">b.getsockname())</span>
            <span class="s1">(data</span><span class="s0">, </span><span class="s1">addr) = </span><span class="s0">await </span><span class="s1">b.recvfrom(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">data == </span><span class="s5">b&quot;xxxyyyzzz&quot;</span>
            <span class="s0">assert </span><span class="s1">addr == a.getsockname()</span>

        <span class="s2"># recvfrom_into</span>
        <span class="s0">assert await </span><span class="s1">a.sendto(</span><span class="s5">b&quot;xxx&quot;</span><span class="s0">, </span><span class="s1">b.getsockname()) == </span><span class="s3">3</span>
        <span class="s1">buf = bytearray(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">(nbytes</span><span class="s0">, </span><span class="s1">addr) = </span><span class="s0">await </span><span class="s1">b.recvfrom_into(buf)</span>
        <span class="s0">assert </span><span class="s1">nbytes == </span><span class="s3">3</span>
        <span class="s0">assert </span><span class="s1">buf == </span><span class="s5">b&quot;xxx&quot; </span><span class="s1">+ </span><span class="s5">b&quot;</span><span class="s0">\x00</span><span class="s5">&quot; </span><span class="s1">* </span><span class="s3">7</span>
        <span class="s0">assert </span><span class="s1">addr == a.getsockname()</span>

        <span class="s0">if </span><span class="s1">hasattr(b</span><span class="s0">, </span><span class="s4">&quot;recvmsg&quot;</span><span class="s1">):</span>
            <span class="s0">assert await </span><span class="s1">a.sendto(</span><span class="s5">b&quot;xxx&quot;</span><span class="s0">, </span><span class="s1">b.getsockname()) == </span><span class="s3">3</span>
            <span class="s1">(data</span><span class="s0">, </span><span class="s1">ancdata</span><span class="s0">, </span><span class="s1">msg_flags</span><span class="s0">, </span><span class="s1">addr) = </span><span class="s0">await </span><span class="s1">b.recvmsg(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">data == </span><span class="s5">b&quot;xxx&quot;</span>
            <span class="s0">assert </span><span class="s1">ancdata == []</span>
            <span class="s0">assert </span><span class="s1">msg_flags == </span><span class="s3">0</span>
            <span class="s0">assert </span><span class="s1">addr == a.getsockname()</span>

        <span class="s0">if </span><span class="s1">hasattr(b</span><span class="s0">, </span><span class="s4">&quot;recvmsg_into&quot;</span><span class="s1">):</span>
            <span class="s0">assert await </span><span class="s1">a.sendto(</span><span class="s5">b&quot;xyzw&quot;</span><span class="s0">, </span><span class="s1">b.getsockname()) == </span><span class="s3">4</span>
            <span class="s1">buf1 = bytearray(</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">buf2 = bytearray(</span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">ret = </span><span class="s0">await </span><span class="s1">b.recvmsg_into([buf1</span><span class="s0">, </span><span class="s1">buf2])</span>
            <span class="s1">(nbytes</span><span class="s0">, </span><span class="s1">ancdata</span><span class="s0">, </span><span class="s1">msg_flags</span><span class="s0">, </span><span class="s1">addr) = ret</span>
            <span class="s0">assert </span><span class="s1">nbytes == </span><span class="s3">4</span>
            <span class="s0">assert </span><span class="s1">buf1 == </span><span class="s5">b&quot;xy&quot;</span>
            <span class="s0">assert </span><span class="s1">buf2 == </span><span class="s5">b&quot;zw&quot; </span><span class="s1">+ </span><span class="s5">b&quot;</span><span class="s0">\x00</span><span class="s5">&quot;</span>
            <span class="s0">assert </span><span class="s1">ancdata == []</span>
            <span class="s0">assert </span><span class="s1">msg_flags == </span><span class="s3">0</span>
            <span class="s0">assert </span><span class="s1">addr == a.getsockname()</span>

        <span class="s0">if </span><span class="s1">hasattr(a</span><span class="s0">, </span><span class="s4">&quot;sendmsg&quot;</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">target </span><span class="s0">in </span><span class="s1">targets:</span>
                <span class="s0">assert await </span><span class="s1">a.sendmsg([</span><span class="s5">b&quot;x&quot;</span><span class="s0">, </span><span class="s5">b&quot;yz&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">target) == </span><span class="s3">3</span>
                <span class="s0">assert await </span><span class="s1">b.recvfrom(</span><span class="s3">10</span><span class="s1">) == (</span><span class="s5">b&quot;xyz&quot;</span><span class="s0">, </span><span class="s1">a.getsockname())</span>

    <span class="s1">a = tsocket.socket(type=tsocket.SOCK_DGRAM)</span>
    <span class="s1">b = tsocket.socket(type=tsocket.SOCK_DGRAM)</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s0">await </span><span class="s1">b.bind((</span><span class="s4">&quot;127.0.0.1&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s0">await </span><span class="s1">a.connect(b.getsockname())</span>
        <span class="s2"># send on a connected udp socket; each call creates a separate</span>
        <span class="s2"># datagram</span>
        <span class="s0">await </span><span class="s1">a.send(</span><span class="s5">b&quot;xxx&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">a.send(</span><span class="s5">b&quot;yyy&quot;</span><span class="s1">)</span>
        <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">10</span><span class="s1">) == </span><span class="s5">b&quot;xxx&quot;</span>
        <span class="s0">assert await </span><span class="s1">b.recv(</span><span class="s3">10</span><span class="s1">) == </span><span class="s5">b&quot;yyy&quot;</span>


<span class="s0">async def </span><span class="s1">test_idna(monkeygai):</span>
    <span class="s2"># This is the encoding for &quot;faß.de&quot;, which uses one of the characters that</span>
    <span class="s2"># IDNA 2003 handles incorrectly:</span>
    <span class="s1">monkeygai.set(</span><span class="s4">&quot;ok faß.de&quot;</span><span class="s0">, </span><span class="s5">b&quot;xn--fa-hia.de&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>
    <span class="s1">monkeygai.set(</span><span class="s4">&quot;ok ::1&quot;</span><span class="s0">, </span><span class="s4">&quot;::1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s1">flags=_NUMERIC_ONLY)</span>
    <span class="s1">monkeygai.set(</span><span class="s4">&quot;ok ::1&quot;</span><span class="s0">, </span><span class="s5">b&quot;::1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s0">, </span><span class="s1">flags=_NUMERIC_ONLY)</span>
    <span class="s2"># Some things that should not reach the underlying socket.getaddrinfo:</span>
    <span class="s1">monkeygai.set(</span><span class="s4">&quot;bad&quot;</span><span class="s0">, </span><span class="s4">&quot;fass.de&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>
    <span class="s2"># We always call socket.getaddrinfo with bytes objects:</span>
    <span class="s1">monkeygai.set(</span><span class="s4">&quot;bad&quot;</span><span class="s0">, </span><span class="s4">&quot;xn--fa-hia.de&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s4">&quot;ok ::1&quot; </span><span class="s1">== </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;::1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s4">&quot;ok ::1&quot; </span><span class="s1">== </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s5">b&quot;::1&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s4">&quot;ok faß.de&quot; </span><span class="s1">== </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;faß.de&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s4">&quot;ok faß.de&quot; </span><span class="s1">== </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;xn--fa-hia.de&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s4">&quot;ok faß.de&quot; </span><span class="s1">== </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s5">b&quot;xn--fa-hia.de&quot;</span><span class="s0">, </span><span class="s3">80</span><span class="s1">)</span>


<span class="s0">async def </span><span class="s1">test_getprotobyname():</span>
    <span class="s2"># These are the constants used in IP header fields, so the numeric values</span>
    <span class="s2"># had *better* be stable across systems...</span>
    <span class="s0">assert await </span><span class="s1">tsocket.getprotobyname(</span><span class="s4">&quot;udp&quot;</span><span class="s1">) == </span><span class="s3">17</span>
    <span class="s0">assert await </span><span class="s1">tsocket.getprotobyname(</span><span class="s4">&quot;tcp&quot;</span><span class="s1">) == </span><span class="s3">6</span>


<span class="s0">async def </span><span class="s1">test_custom_hostname_resolver(monkeygai):</span>
    <span class="s0">class </span><span class="s1">CustomResolver:</span>
        <span class="s0">async def </span><span class="s1">getaddrinfo(self</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">family</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">proto</span><span class="s0">, </span><span class="s1">flags):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s4">&quot;custom_gai&quot;</span><span class="s0">, </span><span class="s1">host</span><span class="s0">, </span><span class="s1">port</span><span class="s0">, </span><span class="s1">family</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">proto</span><span class="s0">, </span><span class="s1">flags)</span>

        <span class="s0">async def </span><span class="s1">getnameinfo(self</span><span class="s0">, </span><span class="s1">sockaddr</span><span class="s0">, </span><span class="s1">flags):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s4">&quot;custom_gni&quot;</span><span class="s0">, </span><span class="s1">sockaddr</span><span class="s0">, </span><span class="s1">flags)</span>

    <span class="s1">cr = CustomResolver()</span>

    <span class="s0">assert </span><span class="s1">tsocket.set_custom_hostname_resolver(cr) </span><span class="s0">is None</span>

    <span class="s2"># Check that the arguments are all getting passed through.</span>
    <span class="s2"># We have to use valid calls to avoid making the underlying system</span>
    <span class="s2"># getaddrinfo cranky when it's used for NUMERIC checks.</span>
    <span class="s0">for </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">[</span>
        <span class="s1">(tsocket.AF_INET</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">tsocket.SOCK_STREAM</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">tsocket.IPPROTO_TCP</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">tsocket.AI_CANONNAME)</span><span class="s0">,</span>
    <span class="s1">]:</span>
        <span class="s0">assert await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;localhost&quot;</span><span class="s0">, </span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">*vals) == (</span>
            <span class="s4">&quot;custom_gai&quot;</span><span class="s0">,</span>
            <span class="s5">b&quot;localhost&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;foo&quot;</span><span class="s0">,</span>
            <span class="s1">*vals</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s2"># IDNA encoding is handled before calling the special object</span>
    <span class="s1">got = </span><span class="s0">await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;föö&quot;</span><span class="s0">, </span><span class="s4">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">expected = (</span><span class="s4">&quot;custom_gai&quot;</span><span class="s0">, </span><span class="s5">b&quot;xn--f-1gaa&quot;</span><span class="s0">, </span><span class="s4">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">got == expected</span>

    <span class="s0">assert await </span><span class="s1">tsocket.getnameinfo(</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) == (</span><span class="s4">&quot;custom_gni&quot;</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2"># We can set it back to None</span>
    <span class="s0">assert </span><span class="s1">tsocket.set_custom_hostname_resolver(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">is </span><span class="s1">cr</span>

    <span class="s2"># And now Trio switches back to calling socket.getaddrinfo (specifically</span>
    <span class="s2"># our monkeypatched version of socket.getaddrinfo)</span>
    <span class="s1">monkeygai.set(</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s5">b&quot;host&quot;</span><span class="s0">, </span><span class="s4">&quot;port&quot;</span><span class="s0">, </span><span class="s1">family=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">type=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">proto=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">flags=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">assert await </span><span class="s1">tsocket.getaddrinfo(</span><span class="s4">&quot;host&quot;</span><span class="s0">, </span><span class="s4">&quot;port&quot;</span><span class="s1">) == </span><span class="s4">&quot;x&quot;</span>


<span class="s0">async def </span><span class="s1">test_custom_socket_factory():</span>
    <span class="s0">class </span><span class="s1">CustomSocketFactory:</span>
        <span class="s0">def </span><span class="s1">socket(self</span><span class="s0">, </span><span class="s1">family</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">proto):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s4">&quot;hi&quot;</span><span class="s0">, </span><span class="s1">family</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">proto)</span>

    <span class="s1">csf = CustomSocketFactory()</span>

    <span class="s0">assert </span><span class="s1">tsocket.set_custom_socket_factory(csf) </span><span class="s0">is None</span>

    <span class="s0">assert </span><span class="s1">tsocket.socket() == (</span><span class="s4">&quot;hi&quot;</span><span class="s0">, </span><span class="s1">tsocket.AF_INET</span><span class="s0">, </span><span class="s1">tsocket.SOCK_STREAM</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">tsocket.socket(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">) == (</span><span class="s4">&quot;hi&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>

    <span class="s2"># socket with fileno= doesn't call our custom method</span>
    <span class="s1">fd = stdlib_socket.socket().detach()</span>
    <span class="s1">wrapped = tsocket.socket(fileno=fd)</span>
    <span class="s0">assert </span><span class="s1">hasattr(wrapped</span><span class="s0">, </span><span class="s4">&quot;bind&quot;</span><span class="s1">)</span>
    <span class="s1">wrapped.close()</span>

    <span class="s2"># Likewise for socketpair</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = tsocket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s0">assert </span><span class="s1">hasattr(a</span><span class="s0">, </span><span class="s4">&quot;bind&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">hasattr(b</span><span class="s0">, </span><span class="s4">&quot;bind&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">tsocket.set_custom_socket_factory(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">is </span><span class="s1">csf</span>


<span class="s0">async def </span><span class="s1">test_SocketType_is_abstract():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">tsocket.SocketType()</span>


<span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">hasattr(tsocket</span><span class="s0">, </span><span class="s4">&quot;AF_UNIX&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;no unix domain sockets&quot;</span><span class="s1">)</span>
<span class="s0">async def </span><span class="s1">test_unix_domain_socket():</span>
    <span class="s2"># Bind has a special branch to use a thread, since it has to do filesystem</span>
    <span class="s2"># traversal. Maybe connect should too? Not sure.</span>

    <span class="s0">async def </span><span class="s1">check_AF_UNIX(path):</span>
        <span class="s0">with </span><span class="s1">tsocket.socket(family=tsocket.AF_UNIX) </span><span class="s0">as </span><span class="s1">lsock:</span>
            <span class="s0">await </span><span class="s1">lsock.bind(path)</span>
            <span class="s1">lsock.listen(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s0">with </span><span class="s1">tsocket.socket(family=tsocket.AF_UNIX) </span><span class="s0">as </span><span class="s1">csock:</span>
                <span class="s0">await </span><span class="s1">csock.connect(path)</span>
                <span class="s1">ssock</span><span class="s0">, </span><span class="s1">_ = </span><span class="s0">await </span><span class="s1">lsock.accept()</span>
                <span class="s0">with </span><span class="s1">ssock:</span>
                    <span class="s0">await </span><span class="s1">csock.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>
                    <span class="s0">assert await </span><span class="s1">ssock.recv(</span><span class="s3">1</span><span class="s1">) == </span><span class="s5">b&quot;x&quot;</span>

    <span class="s2"># Can't use tmpdir fixture, because we can exceed the maximum AF_UNIX path</span>
    <span class="s2"># length on macOS.</span>
    <span class="s0">with </span><span class="s1">tempfile.TemporaryDirectory() </span><span class="s0">as </span><span class="s1">tmpdir:</span>
        <span class="s1">path = </span><span class="s4">&quot;{}/sock&quot;</span><span class="s1">.format(tmpdir)</span>
        <span class="s0">await </span><span class="s1">check_AF_UNIX(path)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">cookie = os.urandom(</span><span class="s3">20</span><span class="s1">).hex().encode(</span><span class="s4">&quot;ascii&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">check_AF_UNIX(</span><span class="s5">b&quot;</span><span class="s0">\x00</span><span class="s5">trio-test-&quot; </span><span class="s1">+ cookie)</span>
    <span class="s0">except </span><span class="s1">FileNotFoundError:</span>
        <span class="s2"># macOS doesn't support abstract filenames with the leading NUL byte</span>
        <span class="s0">pass</span>


<span class="s0">async def </span><span class="s1">test_interrupted_by_close():</span>
    <span class="s1">a_stdlib</span><span class="s0">, </span><span class="s1">b_stdlib = stdlib_socket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a_stdlib</span><span class="s0">, </span><span class="s1">b_stdlib:</span>
        <span class="s1">a_stdlib.setblocking(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">data = </span><span class="s5">b&quot;x&quot; </span><span class="s1">* </span><span class="s3">99999</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s1">a_stdlib.send(data)</span>
        <span class="s0">except </span><span class="s1">BlockingIOError:</span>
            <span class="s0">pass</span>

        <span class="s1">a = tsocket.from_stdlib_socket(a_stdlib)</span>

        <span class="s0">async def </span><span class="s1">sender():</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.ClosedResourceError):</span>
                <span class="s0">await </span><span class="s1">a.send(data)</span>

        <span class="s0">async def </span><span class="s1">receiver():</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.ClosedResourceError):</span>
                <span class="s0">await </span><span class="s1">a.recv(</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(sender)</span>
            <span class="s1">nursery.start_soon(receiver)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s1">a.close()</span>


<span class="s0">async def </span><span class="s1">test_many_sockets():</span>
    <span class="s1">total = </span><span class="s3">5000  </span><span class="s2"># Must be more than MAX_AFD_GROUP_SIZE</span>
    <span class="s1">sockets = []</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(total // </span><span class="s3">2</span><span class="s1">):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">a</span><span class="s0">, </span><span class="s1">b = stdlib_socket.socketpair()</span>
        <span class="s0">except </span><span class="s1">OSError </span><span class="s0">as </span><span class="s1">e:  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">assert </span><span class="s1">e.errno </span><span class="s0">in </span><span class="s1">(errno.EMFILE</span><span class="s0">, </span><span class="s1">errno.ENFILE)</span>
            <span class="s0">break</span>
        <span class="s1">sockets += [a</span><span class="s0">, </span><span class="s1">b]</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">sockets:</span>
            <span class="s1">nursery.start_soon(_core.wait_readable</span><span class="s0">, </span><span class="s1">s)</span>
        <span class="s0">await </span><span class="s1">_core.wait_all_tasks_blocked()</span>
        <span class="s1">nursery.cancel_scope.cancel()</span>
    <span class="s0">for </span><span class="s1">sock </span><span class="s0">in </span><span class="s1">sockets:</span>
        <span class="s1">sock.close()</span>
    <span class="s0">if </span><span class="s1">x != total // </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
        <span class="s1">print(</span><span class="s4">f&quot;Unable to open more than </span><span class="s0">{</span><span class="s1">(x-</span><span class="s3">1</span><span class="s1">)*</span><span class="s3">2</span><span class="s0">} </span><span class="s4">sockets.&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>