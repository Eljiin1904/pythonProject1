<html>
<head>
<title>trans_real.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
trans_real.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Translation helper functions.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">gettext </span><span class="s2">as </span><span class="s1">gettext_module</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">from </span><span class="s1">asgiref.local </span><span class="s2">import </span><span class="s1">Local</span>

<span class="s2">from </span><span class="s1">django.apps </span><span class="s2">import </span><span class="s1">apps</span>
<span class="s2">from </span><span class="s1">django.conf </span><span class="s2">import </span><span class="s1">settings</span>
<span class="s2">from </span><span class="s1">django.conf.locale </span><span class="s2">import </span><span class="s1">LANG_INFO</span>
<span class="s2">from </span><span class="s1">django.core.exceptions </span><span class="s2">import </span><span class="s1">AppRegistryNotReady</span>
<span class="s2">from </span><span class="s1">django.core.signals </span><span class="s2">import </span><span class="s1">setting_changed</span>
<span class="s2">from </span><span class="s1">django.dispatch </span><span class="s2">import </span><span class="s1">receiver</span>
<span class="s2">from </span><span class="s1">django.utils.regex_helper </span><span class="s2">import </span><span class="s1">_lazy_re_compile</span>
<span class="s2">from </span><span class="s1">django.utils.safestring </span><span class="s2">import </span><span class="s1">SafeData</span><span class="s2">, </span><span class="s1">mark_safe</span>

<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">to_language</span><span class="s2">, </span><span class="s1">to_locale</span>

<span class="s3"># Translations are cached in a dictionary for every language.</span>
<span class="s3"># The active translations are stored by threadid to make them thread local.</span>
<span class="s1">_translations = {}</span>
<span class="s1">_active = Local()</span>

<span class="s3"># The default translation is based on the settings file.</span>
<span class="s1">_default = </span><span class="s2">None</span>

<span class="s3"># magic gettext number to separate context from message</span>
<span class="s1">CONTEXT_SEPARATOR = </span><span class="s4">&quot;</span><span class="s2">\x04</span><span class="s4">&quot;</span>

<span class="s3"># Format of Accept-Language header values. From RFC 2616, section 14.4 and 3.9</span>
<span class="s3"># and RFC 3066, section 2.1</span>
<span class="s1">accept_language_re = _lazy_re_compile(</span><span class="s4">r''' 
        ([A-Za-z]{1,8}(?:-[A-Za-z0-9]{1,8})*|\*)      # &quot;en&quot;, &quot;en-au&quot;, &quot;x-y-z&quot;, &quot;es-419&quot;, &quot;*&quot; 
        (?:\s*;\s*q=(0(?:\.\d{,3})?|1(?:\.0{,3})?))?  # Optional &quot;q=1.00&quot;, &quot;q=0.8&quot; 
        (?:\s*,\s*|$)                                 # Multiple accepts per header. 
        '''</span><span class="s2">, </span><span class="s1">re.VERBOSE)</span>

<span class="s1">language_code_re = _lazy_re_compile(</span>
    <span class="s4">r'^[a-z]{1,8}(?:-[a-z0-9]{1,8})*(?:@[a-z0-9]{1,20})?$'</span><span class="s2">,</span>
    <span class="s1">re.IGNORECASE</span>
<span class="s1">)</span>

<span class="s1">language_code_prefix_re = _lazy_re_compile(</span><span class="s4">r'^/(\w+([@-]\w+)?)(/|$)'</span><span class="s1">)</span>


<span class="s1">@receiver(setting_changed)</span>
<span class="s2">def </span><span class="s1">reset_cache(**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Reset global state when LANGUAGES setting has been changed, as some 
    languages should no longer be accepted. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">kwargs[</span><span class="s4">'setting'</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s4">'LANGUAGES'</span><span class="s2">, </span><span class="s4">'LANGUAGE_CODE'</span><span class="s1">):</span>
        <span class="s1">check_for_language.cache_clear()</span>
        <span class="s1">get_languages.cache_clear()</span>
        <span class="s1">get_supported_language_variant.cache_clear()</span>


<span class="s2">class </span><span class="s1">TranslationCatalog:</span>
    <span class="s0">&quot;&quot;&quot; 
    Simulate a dict for DjangoTranslation._catalog so as multiple catalogs 
    with different plural equations are kept separate. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">trans=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._catalogs = [trans._catalog.copy()] </span><span class="s2">if </span><span class="s1">trans </span><span class="s2">else </span><span class="s1">[{}]</span>
        <span class="s1">self._plurals = [trans.plural] </span><span class="s2">if </span><span class="s1">trans </span><span class="s2">else </span><span class="s1">[</span><span class="s2">lambda </span><span class="s1">n: int(n != </span><span class="s5">1</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s2">for </span><span class="s1">cat </span><span class="s2">in </span><span class="s1">self._catalogs:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">cat[key]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">pass</span>
        <span class="s2">raise </span><span class="s1">KeyError(key)</span>

    <span class="s2">def </span><span class="s1">__setitem__(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self._catalogs[</span><span class="s5">0</span><span class="s1">][key] = value</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s2">return </span><span class="s1">any(key </span><span class="s2">in </span><span class="s1">cat </span><span class="s2">for </span><span class="s1">cat </span><span class="s2">in </span><span class="s1">self._catalogs)</span>

    <span class="s2">def </span><span class="s1">items(self):</span>
        <span class="s2">for </span><span class="s1">cat </span><span class="s2">in </span><span class="s1">self._catalogs:</span>
            <span class="s2">yield from </span><span class="s1">cat.items()</span>

    <span class="s2">def </span><span class="s1">keys(self):</span>
        <span class="s2">for </span><span class="s1">cat </span><span class="s2">in </span><span class="s1">self._catalogs:</span>
            <span class="s2">yield from </span><span class="s1">cat.keys()</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">trans):</span>
        <span class="s3"># Merge if plural function is the same, else prepend.</span>
        <span class="s2">for </span><span class="s1">cat</span><span class="s2">, </span><span class="s1">plural </span><span class="s2">in </span><span class="s1">zip(self._catalogs</span><span class="s2">, </span><span class="s1">self._plurals):</span>
            <span class="s2">if </span><span class="s1">trans.plural.__code__ == plural.__code__:</span>
                <span class="s1">cat.update(trans._catalog)</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._catalogs.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">trans._catalog.copy())</span>
            <span class="s1">self._plurals.insert(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">trans.plural)</span>

    <span class="s2">def </span><span class="s1">get(self</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">default=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">missing = object()</span>
        <span class="s2">for </span><span class="s1">cat </span><span class="s2">in </span><span class="s1">self._catalogs:</span>
            <span class="s1">result = cat.get(key</span><span class="s2">, </span><span class="s1">missing)</span>
            <span class="s2">if </span><span class="s1">result </span><span class="s2">is not </span><span class="s1">missing:</span>
                <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">return </span><span class="s1">default</span>

    <span class="s2">def </span><span class="s1">plural(self</span><span class="s2">, </span><span class="s1">msgid</span><span class="s2">, </span><span class="s1">num):</span>
        <span class="s2">for </span><span class="s1">cat</span><span class="s2">, </span><span class="s1">plural </span><span class="s2">in </span><span class="s1">zip(self._catalogs</span><span class="s2">, </span><span class="s1">self._plurals):</span>
            <span class="s1">tmsg = cat.get((msgid</span><span class="s2">, </span><span class="s1">plural(num)))</span>
            <span class="s2">if </span><span class="s1">tmsg </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">tmsg</span>
        <span class="s2">raise </span><span class="s1">KeyError</span>


<span class="s2">class </span><span class="s1">DjangoTranslation(gettext_module.GNUTranslations):</span>
    <span class="s0">&quot;&quot;&quot; 
    Set up the GNUTranslations context with regard to output charset. 
 
    This translation object will be constructed out of multiple GNUTranslations 
    objects by merging their catalogs. It will construct an object for the 
    requested language and add a fallback to the default language, if it's 
    different from the requested language. 
    &quot;&quot;&quot;</span>
    <span class="s1">domain = </span><span class="s4">'django'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">language</span><span class="s2">, </span><span class="s1">domain=</span><span class="s2">None, </span><span class="s1">localedirs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create a GNUTranslations() using many locale directories&quot;&quot;&quot;</span>
        <span class="s1">gettext_module.GNUTranslations.__init__(self)</span>
        <span class="s2">if </span><span class="s1">domain </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.domain = domain</span>

        <span class="s1">self.__language = language</span>
        <span class="s1">self.__to_language = to_language(language)</span>
        <span class="s1">self.__locale = to_locale(language)</span>
        <span class="s1">self._catalog = </span><span class="s2">None</span>
        <span class="s3"># If a language doesn't have a catalog, use the Germanic default for</span>
        <span class="s3"># pluralization: anything except one is pluralized.</span>
        <span class="s1">self.plural = </span><span class="s2">lambda </span><span class="s1">n: int(n != </span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">self.domain == </span><span class="s4">'django'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">localedirs </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s3"># A module-level cache is used for caching 'django' translations</span>
                <span class="s1">warnings.warn(</span><span class="s4">&quot;localedirs is ignored when domain is 'django'.&quot;</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
                <span class="s1">localedirs = </span><span class="s2">None</span>
            <span class="s1">self._init_translation_catalog()</span>

        <span class="s2">if </span><span class="s1">localedirs:</span>
            <span class="s2">for </span><span class="s1">localedir </span><span class="s2">in </span><span class="s1">localedirs:</span>
                <span class="s1">translation = self._new_gnu_trans(localedir)</span>
                <span class="s1">self.merge(translation)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._add_installed_apps_translations()</span>

        <span class="s1">self._add_local_translations()</span>
        <span class="s2">if </span><span class="s1">self.__language == settings.LANGUAGE_CODE </span><span class="s2">and </span><span class="s1">self.domain == </span><span class="s4">'django' </span><span class="s2">and </span><span class="s1">self._catalog </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># default lang should have at least one translation file available.</span>
            <span class="s2">raise </span><span class="s1">OSError(</span><span class="s4">'No translation files found for default language %s.' </span><span class="s1">% settings.LANGUAGE_CODE)</span>
        <span class="s1">self._add_fallback(localedirs)</span>
        <span class="s2">if </span><span class="s1">self._catalog </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># No catalogs found for this language, set an empty catalog.</span>
            <span class="s1">self._catalog = TranslationCatalog()</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">&quot;&lt;DjangoTranslation lang:%s&gt;&quot; </span><span class="s1">% self.__language</span>

    <span class="s2">def </span><span class="s1">_new_gnu_trans(self</span><span class="s2">, </span><span class="s1">localedir</span><span class="s2">, </span><span class="s1">use_null_fallback=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a mergeable gettext.GNUTranslations instance. 
 
        A convenience wrapper. By default gettext uses 'fallback=False'. 
        Using param `use_null_fallback` to avoid confusion with any other 
        references to 'fallback'. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">gettext_module.translation(</span>
            <span class="s1">domain=self.domain</span><span class="s2">,</span>
            <span class="s1">localedir=localedir</span><span class="s2">,</span>
            <span class="s1">languages=[self.__locale]</span><span class="s2">,</span>
            <span class="s1">fallback=use_null_fallback</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_init_translation_catalog(self):</span>
        <span class="s0">&quot;&quot;&quot;Create a base catalog using global django translations.&quot;&quot;&quot;</span>
        <span class="s1">settingsfile = sys.modules[settings.__module__].__file__</span>
        <span class="s1">localedir = os.path.join(os.path.dirname(settingsfile)</span><span class="s2">, </span><span class="s4">'locale'</span><span class="s1">)</span>
        <span class="s1">translation = self._new_gnu_trans(localedir)</span>
        <span class="s1">self.merge(translation)</span>

    <span class="s2">def </span><span class="s1">_add_installed_apps_translations(self):</span>
        <span class="s0">&quot;&quot;&quot;Merge translations from each installed app.&quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">app_configs = reversed(list(apps.get_app_configs()))</span>
        <span class="s2">except </span><span class="s1">AppRegistryNotReady:</span>
            <span class="s2">raise </span><span class="s1">AppRegistryNotReady(</span>
                <span class="s4">&quot;The translation infrastructure cannot be initialized before the &quot;</span>
                <span class="s4">&quot;apps registry is ready. Check that you don't make non-lazy &quot;</span>
                <span class="s4">&quot;gettext calls at import time.&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">app_config </span><span class="s2">in </span><span class="s1">app_configs:</span>
            <span class="s1">localedir = os.path.join(app_config.path</span><span class="s2">, </span><span class="s4">'locale'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">os.path.exists(localedir):</span>
                <span class="s1">translation = self._new_gnu_trans(localedir)</span>
                <span class="s1">self.merge(translation)</span>

    <span class="s2">def </span><span class="s1">_add_local_translations(self):</span>
        <span class="s0">&quot;&quot;&quot;Merge translations defined in LOCALE_PATHS.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">localedir </span><span class="s2">in </span><span class="s1">reversed(settings.LOCALE_PATHS):</span>
            <span class="s1">translation = self._new_gnu_trans(localedir)</span>
            <span class="s1">self.merge(translation)</span>

    <span class="s2">def </span><span class="s1">_add_fallback(self</span><span class="s2">, </span><span class="s1">localedirs=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Set the GNUTranslations() fallback with the default language.&quot;&quot;&quot;</span>
        <span class="s3"># Don't set a fallback for the default language or any English variant</span>
        <span class="s3"># (as it's empty, so it'll ALWAYS fall back to the default language)</span>
        <span class="s2">if </span><span class="s1">self.__language == settings.LANGUAGE_CODE </span><span class="s2">or </span><span class="s1">self.__language.startswith(</span><span class="s4">'en'</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s2">if </span><span class="s1">self.domain == </span><span class="s4">'django'</span><span class="s1">:</span>
            <span class="s3"># Get from cache</span>
            <span class="s1">default_translation = translation(settings.LANGUAGE_CODE)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">default_translation = DjangoTranslation(</span>
                <span class="s1">settings.LANGUAGE_CODE</span><span class="s2">, </span><span class="s1">domain=self.domain</span><span class="s2">, </span><span class="s1">localedirs=localedirs</span>
            <span class="s1">)</span>
        <span class="s1">self.add_fallback(default_translation)</span>

    <span class="s2">def </span><span class="s1">merge(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot;Merge another translation into this catalog.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">getattr(other</span><span class="s2">, </span><span class="s4">'_catalog'</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s2">return  </span><span class="s3"># NullTranslations() has no _catalog</span>
        <span class="s2">if </span><span class="s1">self._catalog </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># Take plural and _info from first catalog found (generally Django's).</span>
            <span class="s1">self.plural = other.plural</span>
            <span class="s1">self._info = other._info.copy()</span>
            <span class="s1">self._catalog = TranslationCatalog(other)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._catalog.update(other)</span>
        <span class="s2">if </span><span class="s1">other._fallback:</span>
            <span class="s1">self.add_fallback(other._fallback)</span>

    <span class="s2">def </span><span class="s1">language(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the translation language.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.__language</span>

    <span class="s2">def </span><span class="s1">to_language(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the translation language name.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.__to_language</span>

    <span class="s2">def </span><span class="s1">ngettext(self</span><span class="s2">, </span><span class="s1">msgid1</span><span class="s2">, </span><span class="s1">msgid2</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">tmsg = self._catalog.plural(msgid1</span><span class="s2">, </span><span class="s1">n)</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">if </span><span class="s1">self._fallback:</span>
                <span class="s2">return </span><span class="s1">self._fallback.ngettext(msgid1</span><span class="s2">, </span><span class="s1">msgid2</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s2">if </span><span class="s1">n == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">tmsg = msgid1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">tmsg = msgid2</span>
        <span class="s2">return </span><span class="s1">tmsg</span>


<span class="s2">def </span><span class="s1">translation(language):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a translation object in the default 'django' domain. 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_translations</span>
    <span class="s2">if </span><span class="s1">language </span><span class="s2">not in </span><span class="s1">_translations:</span>
        <span class="s1">_translations[language] = DjangoTranslation(language)</span>
    <span class="s2">return </span><span class="s1">_translations[language]</span>


<span class="s2">def </span><span class="s1">activate(language):</span>
    <span class="s0">&quot;&quot;&quot; 
    Fetch the translation object for a given language and install it as the 
    current translation object for the current thread. 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">language:</span>
        <span class="s2">return</span>
    <span class="s1">_active.value = translation(language)</span>


<span class="s2">def </span><span class="s1">deactivate():</span>
    <span class="s0">&quot;&quot;&quot; 
    Uninstall the active translation object so that further _() calls resolve 
    to the default translation object. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">hasattr(_active</span><span class="s2">, </span><span class="s4">&quot;value&quot;</span><span class="s1">):</span>
        <span class="s2">del </span><span class="s1">_active.value</span>


<span class="s2">def </span><span class="s1">deactivate_all():</span>
    <span class="s0">&quot;&quot;&quot; 
    Make the active translation object a NullTranslations() instance. This is 
    useful when we want delayed translations to appear as the original string 
    for some reason. 
    &quot;&quot;&quot;</span>
    <span class="s1">_active.value = gettext_module.NullTranslations()</span>
    <span class="s1">_active.value.to_language = </span><span class="s2">lambda </span><span class="s1">*args: </span><span class="s2">None</span>


<span class="s2">def </span><span class="s1">get_language():</span>
    <span class="s0">&quot;&quot;&quot;Return the currently selected language.&quot;&quot;&quot;</span>
    <span class="s1">t = getattr(_active</span><span class="s2">, </span><span class="s4">&quot;value&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">t.to_language()</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">pass</span>
    <span class="s3"># If we don't have a real translation object, assume it's the default language.</span>
    <span class="s2">return </span><span class="s1">settings.LANGUAGE_CODE</span>


<span class="s2">def </span><span class="s1">get_language_bidi():</span>
    <span class="s0">&quot;&quot;&quot; 
    Return selected language's BiDi layout. 
 
    * False = left-to-right layout 
    * True = right-to-left layout 
    &quot;&quot;&quot;</span>
    <span class="s1">lang = get_language()</span>
    <span class="s2">if </span><span class="s1">lang </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">base_lang = get_language().split(</span><span class="s4">'-'</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">base_lang </span><span class="s2">in </span><span class="s1">settings.LANGUAGES_BIDI</span>


<span class="s2">def </span><span class="s1">catalog():</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the current active catalog for further processing. 
    This can be used if you need to modify the catalog or want to access the 
    whole message catalog instead of just translating one string. 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_default</span>

    <span class="s1">t = getattr(_active</span><span class="s2">, </span><span class="s4">&quot;value&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">t</span>
    <span class="s2">if </span><span class="s1">_default </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">_default = translation(settings.LANGUAGE_CODE)</span>
    <span class="s2">return </span><span class="s1">_default</span>


<span class="s2">def </span><span class="s1">gettext(message):</span>
    <span class="s0">&quot;&quot;&quot; 
    Translate the 'message' string. It uses the current thread to find the 
    translation object to use. If no current translation is activated, the 
    message will be run through the default translation object. 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_default</span>

    <span class="s1">eol_message = message.replace(</span><span class="s4">'</span><span class="s2">\r\n</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">).replace(</span><span class="s4">'</span><span class="s2">\r</span><span class="s4">'</span><span class="s2">, </span><span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">eol_message:</span>
        <span class="s1">_default = _default </span><span class="s2">or </span><span class="s1">translation(settings.LANGUAGE_CODE)</span>
        <span class="s1">translation_object = getattr(_active</span><span class="s2">, </span><span class="s4">&quot;value&quot;</span><span class="s2">, </span><span class="s1">_default)</span>

        <span class="s1">result = translation_object.gettext(eol_message)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># Return an empty value of the corresponding type if an empty message</span>
        <span class="s3"># is given, instead of metadata, which is the default gettext behavior.</span>
        <span class="s1">result = type(message)(</span><span class="s4">''</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">isinstance(message</span><span class="s2">, </span><span class="s1">SafeData):</span>
        <span class="s2">return </span><span class="s1">mark_safe(result)</span>

    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">pgettext(context</span><span class="s2">, </span><span class="s1">message):</span>
    <span class="s1">msg_with_ctxt = </span><span class="s4">&quot;%s%s%s&quot; </span><span class="s1">% (context</span><span class="s2">, </span><span class="s1">CONTEXT_SEPARATOR</span><span class="s2">, </span><span class="s1">message)</span>
    <span class="s1">result = gettext(msg_with_ctxt)</span>
    <span class="s2">if </span><span class="s1">CONTEXT_SEPARATOR </span><span class="s2">in </span><span class="s1">result:</span>
        <span class="s3"># Translation not found</span>
        <span class="s1">result = message</span>
    <span class="s2">elif </span><span class="s1">isinstance(message</span><span class="s2">, </span><span class="s1">SafeData):</span>
        <span class="s1">result = mark_safe(result)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">gettext_noop(message):</span>
    <span class="s0">&quot;&quot;&quot; 
    Mark strings for translation but don't translate them now. This can be 
    used to store strings in global variables that should stay in the base 
    language (because they might be used externally) and will be translated 
    later. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">message</span>


<span class="s2">def </span><span class="s1">do_ntranslate(singular</span><span class="s2">, </span><span class="s1">plural</span><span class="s2">, </span><span class="s1">number</span><span class="s2">, </span><span class="s1">translation_function):</span>
    <span class="s2">global </span><span class="s1">_default</span>

    <span class="s1">t = getattr(_active</span><span class="s2">, </span><span class="s4">&quot;value&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">t </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">getattr(t</span><span class="s2">, </span><span class="s1">translation_function)(singular</span><span class="s2">, </span><span class="s1">plural</span><span class="s2">, </span><span class="s1">number)</span>
    <span class="s2">if </span><span class="s1">_default </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">_default = translation(settings.LANGUAGE_CODE)</span>
    <span class="s2">return </span><span class="s1">getattr(_default</span><span class="s2">, </span><span class="s1">translation_function)(singular</span><span class="s2">, </span><span class="s1">plural</span><span class="s2">, </span><span class="s1">number)</span>


<span class="s2">def </span><span class="s1">ngettext(singular</span><span class="s2">, </span><span class="s1">plural</span><span class="s2">, </span><span class="s1">number):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a string of the translation of either the singular or plural, 
    based on the number. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">do_ntranslate(singular</span><span class="s2">, </span><span class="s1">plural</span><span class="s2">, </span><span class="s1">number</span><span class="s2">, </span><span class="s4">'ngettext'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">npgettext(context</span><span class="s2">, </span><span class="s1">singular</span><span class="s2">, </span><span class="s1">plural</span><span class="s2">, </span><span class="s1">number):</span>
    <span class="s1">msgs_with_ctxt = (</span><span class="s4">&quot;%s%s%s&quot; </span><span class="s1">% (context</span><span class="s2">, </span><span class="s1">CONTEXT_SEPARATOR</span><span class="s2">, </span><span class="s1">singular)</span><span class="s2">,</span>
                      <span class="s4">&quot;%s%s%s&quot; </span><span class="s1">% (context</span><span class="s2">, </span><span class="s1">CONTEXT_SEPARATOR</span><span class="s2">, </span><span class="s1">plural)</span><span class="s2">,</span>
                      <span class="s1">number)</span>
    <span class="s1">result = ngettext(*msgs_with_ctxt)</span>
    <span class="s2">if </span><span class="s1">CONTEXT_SEPARATOR </span><span class="s2">in </span><span class="s1">result:</span>
        <span class="s3"># Translation not found</span>
        <span class="s1">result = ngettext(singular</span><span class="s2">, </span><span class="s1">plural</span><span class="s2">, </span><span class="s1">number)</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">all_locale_paths():</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a list of paths to user-provides languages files. 
    &quot;&quot;&quot;</span>
    <span class="s1">globalpath = os.path.join(</span>
        <span class="s1">os.path.dirname(sys.modules[settings.__module__].__file__)</span><span class="s2">, </span><span class="s4">'locale'</span><span class="s1">)</span>
    <span class="s1">app_paths = []</span>
    <span class="s2">for </span><span class="s1">app_config </span><span class="s2">in </span><span class="s1">apps.get_app_configs():</span>
        <span class="s1">locale_path = os.path.join(app_config.path</span><span class="s2">, </span><span class="s4">'locale'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">os.path.exists(locale_path):</span>
            <span class="s1">app_paths.append(locale_path)</span>
    <span class="s2">return </span><span class="s1">[globalpath</span><span class="s2">, </span><span class="s1">*settings.LOCALE_PATHS</span><span class="s2">, </span><span class="s1">*app_paths]</span>


<span class="s1">@functools.lru_cache(maxsize=</span><span class="s5">1000</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">check_for_language(lang_code):</span>
    <span class="s0">&quot;&quot;&quot; 
    Check whether there is a global language file for the given language 
    code. This is used to decide whether a user-provided language is 
    available. 
 
    lru_cache should have a maxsize to prevent from memory exhaustion attacks, 
    as the provided language codes are taken from the HTTP request. See also 
    &lt;https://www.djangoproject.com/weblog/2007/oct/26/security-fix/&gt;. 
    &quot;&quot;&quot;</span>
    <span class="s3"># First, a quick check to make sure lang_code is well-formed (#21458)</span>
    <span class="s2">if </span><span class="s1">lang_code </span><span class="s2">is None or not </span><span class="s1">language_code_re.search(lang_code):</span>
        <span class="s2">return False</span>
    <span class="s2">return </span><span class="s1">any(</span>
        <span class="s1">gettext_module.find(</span><span class="s4">'django'</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">[to_locale(lang_code)]) </span><span class="s2">is not None</span>
        <span class="s2">for </span><span class="s1">path </span><span class="s2">in </span><span class="s1">all_locale_paths()</span>
    <span class="s1">)</span>


<span class="s1">@functools.lru_cache()</span>
<span class="s2">def </span><span class="s1">get_languages():</span>
    <span class="s0">&quot;&quot;&quot; 
    Cache of settings.LANGUAGES in a dictionary for easy lookups by key. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">dict(settings.LANGUAGES)</span>


<span class="s1">@functools.lru_cache(maxsize=</span><span class="s5">1000</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">get_supported_language_variant(lang_code</span><span class="s2">, </span><span class="s1">strict=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the language code that's listed in supported languages, possibly 
    selecting a more generic variant. Raise LookupError if nothing is found. 
 
    If `strict` is False (the default), look for a country-specific variant 
    when neither the language code nor its generic variant is found. 
 
    lru_cache should have a maxsize to prevent from memory exhaustion attacks, 
    as the provided language codes are taken from the HTTP request. See also 
    &lt;https://www.djangoproject.com/weblog/2007/oct/26/security-fix/&gt;. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">lang_code:</span>
        <span class="s3"># If 'zh-hant-tw' is not supported, try special fallback or subsequent</span>
        <span class="s3"># language codes i.e. 'zh-hant' and 'zh'.</span>
        <span class="s1">possible_lang_codes = [lang_code]</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">possible_lang_codes.extend(LANG_INFO[lang_code][</span><span class="s4">'fallback'</span><span class="s1">])</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s2">pass</span>
        <span class="s1">i = </span><span class="s2">None</span>
        <span class="s2">while </span><span class="s1">(i := lang_code.rfind(</span><span class="s4">'-'</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">i)) &gt; -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">possible_lang_codes.append(lang_code[:i])</span>
        <span class="s1">generic_lang_code = possible_lang_codes[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">supported_lang_codes = get_languages()</span>

        <span class="s2">for </span><span class="s1">code </span><span class="s2">in </span><span class="s1">possible_lang_codes:</span>
            <span class="s2">if </span><span class="s1">code </span><span class="s2">in </span><span class="s1">supported_lang_codes </span><span class="s2">and </span><span class="s1">check_for_language(code):</span>
                <span class="s2">return </span><span class="s1">code</span>
        <span class="s2">if not </span><span class="s1">strict:</span>
            <span class="s3"># if fr-fr is not supported, try fr-ca.</span>
            <span class="s2">for </span><span class="s1">supported_code </span><span class="s2">in </span><span class="s1">supported_lang_codes:</span>
                <span class="s2">if </span><span class="s1">supported_code.startswith(generic_lang_code + </span><span class="s4">'-'</span><span class="s1">):</span>
                    <span class="s2">return </span><span class="s1">supported_code</span>
    <span class="s2">raise </span><span class="s1">LookupError(lang_code)</span>


<span class="s2">def </span><span class="s1">get_language_from_path(path</span><span class="s2">, </span><span class="s1">strict=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the language code if there's a valid language code found in `path`. 
 
    If `strict` is False (the default), look for a country-specific variant 
    when neither the language code nor its generic variant is found. 
    &quot;&quot;&quot;</span>
    <span class="s1">regex_match = language_code_prefix_re.match(path)</span>
    <span class="s2">if not </span><span class="s1">regex_match:</span>
        <span class="s2">return None</span>
    <span class="s1">lang_code = regex_match[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">get_supported_language_variant(lang_code</span><span class="s2">, </span><span class="s1">strict=strict)</span>
    <span class="s2">except </span><span class="s1">LookupError:</span>
        <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">get_language_from_request(request</span><span class="s2">, </span><span class="s1">check_path=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Analyze the request to find what language the user wants the system to 
    show. Only languages listed in settings.LANGUAGES are taken into account. 
    If the user requests a sublanguage where we have a main language, we send 
    out the main language. 
 
    If check_path is True, the URL path prefix will be checked for a language 
    code, otherwise this is skipped for backwards compatibility. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">check_path:</span>
        <span class="s1">lang_code = get_language_from_path(request.path_info)</span>
        <span class="s2">if </span><span class="s1">lang_code </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">lang_code</span>

    <span class="s1">lang_code = request.COOKIES.get(settings.LANGUAGE_COOKIE_NAME)</span>
    <span class="s2">if </span><span class="s1">lang_code </span><span class="s2">is not None and </span><span class="s1">lang_code </span><span class="s2">in </span><span class="s1">get_languages() </span><span class="s2">and </span><span class="s1">check_for_language(lang_code):</span>
        <span class="s2">return </span><span class="s1">lang_code</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">get_supported_language_variant(lang_code)</span>
    <span class="s2">except </span><span class="s1">LookupError:</span>
        <span class="s2">pass</span>

    <span class="s1">accept = request.META.get(</span><span class="s4">'HTTP_ACCEPT_LANGUAGE'</span><span class="s2">, </span><span class="s4">''</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">accept_lang</span><span class="s2">, </span><span class="s1">unused </span><span class="s2">in </span><span class="s1">parse_accept_lang_header(accept):</span>
        <span class="s2">if </span><span class="s1">accept_lang == </span><span class="s4">'*'</span><span class="s1">:</span>
            <span class="s2">break</span>

        <span class="s2">if not </span><span class="s1">language_code_re.search(accept_lang):</span>
            <span class="s2">continue</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">get_supported_language_variant(accept_lang)</span>
        <span class="s2">except </span><span class="s1">LookupError:</span>
            <span class="s2">continue</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">get_supported_language_variant(settings.LANGUAGE_CODE)</span>
    <span class="s2">except </span><span class="s1">LookupError:</span>
        <span class="s2">return </span><span class="s1">settings.LANGUAGE_CODE</span>


<span class="s1">@functools.lru_cache(maxsize=</span><span class="s5">1000</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">parse_accept_lang_header(lang_string):</span>
    <span class="s0">&quot;&quot;&quot; 
    Parse the lang_string, which is the body of an HTTP Accept-Language 
    header, and return a tuple of (lang, q-value), ordered by 'q' values. 
 
    Return an empty tuple if there are any format errors in lang_string. 
    &quot;&quot;&quot;</span>
    <span class="s1">result = []</span>
    <span class="s1">pieces = accept_language_re.split(lang_string.lower())</span>
    <span class="s2">if </span><span class="s1">pieces[-</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s2">return </span><span class="s1">()</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">len(pieces) - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">):</span>
        <span class="s1">first</span><span class="s2">, </span><span class="s1">lang</span><span class="s2">, </span><span class="s1">priority = pieces[i:i + </span><span class="s5">3</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">first:</span>
            <span class="s2">return </span><span class="s1">()</span>
        <span class="s2">if </span><span class="s1">priority:</span>
            <span class="s1">priority = float(priority)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">priority = </span><span class="s5">1.0</span>
        <span class="s1">result.append((lang</span><span class="s2">, </span><span class="s1">priority))</span>
    <span class="s1">result.sort(key=</span><span class="s2">lambda </span><span class="s1">k: k[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">tuple(result)</span>
</pre>
</body>
</html>