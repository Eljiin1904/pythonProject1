<html>
<head>
<title>test_run.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_run.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">contextvars</span>
<span class="s0">import </span><span class="s1">functools</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">time</span>
<span class="s0">import </span><span class="s1">types</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">from </span><span class="s1">contextlib </span><span class="s0">import </span><span class="s1">contextmanager</span><span class="s0">, </span><span class="s1">ExitStack</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">inf</span>
<span class="s0">from </span><span class="s1">textwrap </span><span class="s0">import </span><span class="s1">dedent</span>
<span class="s0">import </span><span class="s1">gc</span>

<span class="s0">import </span><span class="s1">attr</span>
<span class="s0">import </span><span class="s1">outcome</span>
<span class="s0">import </span><span class="s1">sniffio</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">.tutil </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">slow</span><span class="s0">,</span>
    <span class="s1">check_sequence_matches</span><span class="s0">,</span>
    <span class="s1">gc_collect_harder</span><span class="s0">,</span>
    <span class="s1">ignore_coroutine_never_awaited_warnings</span><span class="s0">,</span>
    <span class="s1">buggy_pypy_asyncgens</span><span class="s0">,</span>
    <span class="s1">restore_unraisablehook</span><span class="s0">,</span>
    <span class="s1">create_asyncio_future_in_new_loop</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">... </span><span class="s0">import </span><span class="s1">_core</span>
<span class="s0">from </span><span class="s1">.._run </span><span class="s0">import </span><span class="s1">DEADLINE_HEAP_MIN_PRUNE_THRESHOLD</span>
<span class="s0">from </span><span class="s1">..._threads </span><span class="s0">import </span><span class="s1">to_thread_run_sync</span>
<span class="s0">from </span><span class="s1">..._timeouts </span><span class="s0">import </span><span class="s1">sleep</span><span class="s0">, </span><span class="s1">fail_after</span>
<span class="s0">from </span><span class="s1">...testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">wait_all_tasks_blocked</span><span class="s0">,</span>
    <span class="s1">Sequencer</span><span class="s0">,</span>
    <span class="s1">assert_checkpoints</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s2"># slightly different from _timeouts.sleep_forever because it returns the value</span>
<span class="s2"># its rescheduled with, which is really only useful for tests of</span>
<span class="s2"># rescheduling...</span>
<span class="s0">async def </span><span class="s1">sleep_forever():</span>
    <span class="s0">return await </span><span class="s1">_core.wait_task_rescheduled(</span><span class="s0">lambda </span><span class="s1">_: _core.Abort.SUCCEEDED)</span>


<span class="s0">def </span><span class="s1">test_basic():</span>
    <span class="s0">async def </span><span class="s1">trivial(x):</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">assert </span><span class="s1">_core.run(trivial</span><span class="s0">, </span><span class="s3">8</span><span class="s1">) == </span><span class="s3">8</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s2"># Missing an argument</span>
        <span class="s1">_core.run(trivial)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s2"># Not an async function</span>
        <span class="s1">_core.run(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">trivial2(x):</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">assert </span><span class="s1">_core.run(trivial2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">) == </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">test_initial_task_error():</span>
    <span class="s0">async def </span><span class="s1">main(x):</span>
        <span class="s0">raise </span><span class="s1">ValueError(x)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main</span><span class="s0">, </span><span class="s3">17</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">excinfo.value.args == (</span><span class="s3">17</span><span class="s0">,</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_run_nesting():</span>
    <span class="s0">async def </span><span class="s1">inception():</span>
        <span class="s0">async def </span><span class="s1">main():  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">pass</span>

        <span class="s0">return </span><span class="s1">_core.run(main)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(inception)</span>
    <span class="s0">assert </span><span class="s4">&quot;from inside&quot; </span><span class="s0">in </span><span class="s1">str(excinfo.value)</span>


<span class="s0">async def </span><span class="s1">test_nursery_warn_use_async_with():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">on = _core.open_nursery()</span>
        <span class="s0">with </span><span class="s1">on:</span>
            <span class="s0">pass  </span><span class="s2"># pragma: no cover</span>
    <span class="s1">excinfo.match(</span>
        <span class="s4">r&quot;use 'async with open_nursery\(...\)', not 'with open_nursery\(...\)'&quot;</span>
    <span class="s1">)</span>

    <span class="s2"># avoid unawaited coro.</span>
    <span class="s0">async with </span><span class="s1">on:</span>
        <span class="s0">pass</span>


<span class="s0">async def </span><span class="s1">test_nursery_main_block_error_basic():</span>
    <span class="s1">exc = ValueError(</span><span class="s4">&quot;whoops&quot;</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery():</span>
            <span class="s0">raise </span><span class="s1">exc</span>
    <span class="s0">assert </span><span class="s1">excinfo.value </span><span class="s0">is </span><span class="s1">exc</span>


<span class="s0">async def </span><span class="s1">test_child_crash_basic():</span>
    <span class="s1">exc = ValueError(</span><span class="s4">&quot;uh oh&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">erroring():</span>
        <span class="s0">raise </span><span class="s1">exc</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># nursery.__aexit__ propagates exception from child back to parent</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(erroring)</span>
    <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">assert </span><span class="s1">e </span><span class="s0">is </span><span class="s1">exc</span>


<span class="s0">async def </span><span class="s1">test_basic_interleave():</span>
    <span class="s0">async def </span><span class="s1">looper(whoami</span><span class="s0">, </span><span class="s1">record):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
            <span class="s1">record.append((whoami</span><span class="s0">, </span><span class="s1">i))</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">record = []</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(looper</span><span class="s0">, </span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s1">record)</span>
        <span class="s1">nursery.start_soon(looper</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s1">record)</span>

    <span class="s1">check_sequence_matches(</span>
        <span class="s1">record</span><span class="s0">, </span><span class="s1">[{(</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">{(</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">{(</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)}]</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_task_crash_propagation():</span>
    <span class="s1">looper_record = []</span>

    <span class="s0">async def </span><span class="s1">looper():</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
            <span class="s1">print(</span><span class="s4">&quot;looper cancelled&quot;</span><span class="s1">)</span>
            <span class="s1">looper_record.append(</span><span class="s4">&quot;cancelled&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">crasher():</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;argh&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(looper)</span>
            <span class="s1">nursery.start_soon(crasher)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main)</span>

    <span class="s0">assert </span><span class="s1">looper_record == [</span><span class="s4">&quot;cancelled&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">excinfo.value.args == (</span><span class="s4">&quot;argh&quot;</span><span class="s0">,</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_main_and_task_both_crash():</span>
    <span class="s2"># If main crashes and there's also a task crash, then we get both in a</span>
    <span class="s2"># MultiError</span>
    <span class="s0">async def </span><span class="s1">crasher():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(crasher)</span>
            <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.MultiError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main)</span>
    <span class="s1">print(excinfo.value)</span>
    <span class="s0">assert </span><span class="s1">{type(exc) </span><span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">excinfo.value.exceptions} == {</span>
        <span class="s1">ValueError</span><span class="s0">,</span>
        <span class="s1">KeyError</span><span class="s0">,</span>
    <span class="s1">}</span>


<span class="s0">def </span><span class="s1">test_two_child_crashes():</span>
    <span class="s0">async def </span><span class="s1">crasher(etype):</span>
        <span class="s0">raise </span><span class="s1">etype</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(crasher</span><span class="s0">, </span><span class="s1">KeyError)</span>
            <span class="s1">nursery.start_soon(crasher</span><span class="s0">, </span><span class="s1">ValueError)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.MultiError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main)</span>
    <span class="s0">assert </span><span class="s1">{type(exc) </span><span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">excinfo.value.exceptions} == {</span>
        <span class="s1">ValueError</span><span class="s0">,</span>
        <span class="s1">KeyError</span><span class="s0">,</span>
    <span class="s1">}</span>


<span class="s0">async def </span><span class="s1">test_child_crash_wakes_parent():</span>
    <span class="s0">async def </span><span class="s1">crasher():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(crasher)</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>


<span class="s0">async def </span><span class="s1">test_reschedule():</span>
    <span class="s1">t1 = </span><span class="s0">None</span>
    <span class="s1">t2 = </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">child1():</span>
        <span class="s0">nonlocal </span><span class="s1">t1</span><span class="s0">, </span><span class="s1">t2</span>
        <span class="s1">t1 = _core.current_task()</span>
        <span class="s1">print(</span><span class="s4">&quot;child1 start&quot;</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s0">await </span><span class="s1">sleep_forever()</span>
        <span class="s1">print(</span><span class="s4">&quot;child1 woke&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">x == </span><span class="s3">0</span>
        <span class="s1">print(</span><span class="s4">&quot;child1 rescheduling t2&quot;</span><span class="s1">)</span>
        <span class="s1">_core.reschedule(t2</span><span class="s0">, </span><span class="s1">outcome.Error(ValueError()))</span>
        <span class="s1">print(</span><span class="s4">&quot;child1 exit&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">child2():</span>
        <span class="s0">nonlocal </span><span class="s1">t1</span><span class="s0">, </span><span class="s1">t2</span>
        <span class="s1">print(</span><span class="s4">&quot;child2 start&quot;</span><span class="s1">)</span>
        <span class="s1">t2 = _core.current_task()</span>
        <span class="s1">_core.reschedule(t1</span><span class="s0">, </span><span class="s1">outcome.Value(</span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">print(</span><span class="s4">&quot;child2 sleep&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>
        <span class="s1">print(</span><span class="s4">&quot;child2 successful exit&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(child1)</span>
        <span class="s2"># let t1 run and fall asleep</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s1">nursery.start_soon(child2)</span>


<span class="s0">async def </span><span class="s1">test_current_time():</span>
    <span class="s1">t1 = _core.current_time()</span>
    <span class="s2"># Windows clock is pretty low-resolution -- appveyor tests fail unless we</span>
    <span class="s2"># sleep for a bit here.</span>
    <span class="s1">time.sleep(time.get_clock_info(</span><span class="s4">&quot;perf_counter&quot;</span><span class="s1">).resolution)</span>
    <span class="s1">t2 = _core.current_time()</span>
    <span class="s0">assert </span><span class="s1">t1 &lt; t2</span>


<span class="s0">async def </span><span class="s1">test_current_time_with_mock_clock(mock_clock):</span>
    <span class="s1">start = mock_clock.current_time()</span>
    <span class="s0">assert </span><span class="s1">mock_clock.current_time() == _core.current_time()</span>
    <span class="s0">assert </span><span class="s1">mock_clock.current_time() == _core.current_time()</span>
    <span class="s1">mock_clock.jump(</span><span class="s3">3.14</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">start + </span><span class="s3">3.14 </span><span class="s1">== mock_clock.current_time() == _core.current_time()</span>


<span class="s0">async def </span><span class="s1">test_current_clock(mock_clock):</span>
    <span class="s0">assert </span><span class="s1">mock_clock </span><span class="s0">is </span><span class="s1">_core.current_clock()</span>


<span class="s0">async def </span><span class="s1">test_current_task():</span>
    <span class="s1">parent_task = _core.current_task()</span>

    <span class="s0">async def </span><span class="s1">child():</span>
        <span class="s0">assert </span><span class="s1">_core.current_task().parent_nursery.parent_task </span><span class="s0">is </span><span class="s1">parent_task</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(child)</span>


<span class="s0">async def </span><span class="s1">test_root_task():</span>
    <span class="s1">root = _core.current_root_task()</span>
    <span class="s0">assert </span><span class="s1">root.parent_nursery </span><span class="s0">is </span><span class="s1">root.eventual_parent_nursery </span><span class="s0">is None</span>


<span class="s0">def </span><span class="s1">test_out_of_context():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">_core.current_task()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">_core.current_time()</span>


<span class="s0">async def </span><span class="s1">test_current_statistics(mock_clock):</span>
    <span class="s2"># Make sure all the early startup stuff has settled down</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>

    <span class="s2"># A child that sticks around to make some interesting stats:</span>
    <span class="s0">async def </span><span class="s1">child():</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>
        <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
            <span class="s0">pass</span>

    <span class="s1">stats = _core.current_statistics()</span>
    <span class="s1">print(stats)</span>
    <span class="s2"># 2 system tasks + us</span>
    <span class="s0">assert </span><span class="s1">stats.tasks_living == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">stats.run_sync_soon_queue_size == </span><span class="s3">0</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(child)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s1">token = _core.current_trio_token()</span>
        <span class="s1">token.run_sync_soon(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">token.run_sync_soon(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">stats = _core.current_statistics()</span>
        <span class="s1">print(stats)</span>
        <span class="s2"># 2 system tasks + us + child</span>
        <span class="s0">assert </span><span class="s1">stats.tasks_living == </span><span class="s3">4</span>
        <span class="s2"># the exact value here might shift if we change how we do accounting</span>
        <span class="s2"># (currently it only counts tasks that we already know will be</span>
        <span class="s2"># runnable on the next pass), but still useful to at least test the</span>
        <span class="s2"># difference between now and after we wake up the child:</span>
        <span class="s0">assert </span><span class="s1">stats.tasks_runnable == </span><span class="s3">0</span>
        <span class="s0">assert </span><span class="s1">stats.run_sync_soon_queue_size == </span><span class="s3">2</span>

        <span class="s1">nursery.cancel_scope.cancel()</span>
        <span class="s1">stats = _core.current_statistics()</span>
        <span class="s1">print(stats)</span>
        <span class="s0">assert </span><span class="s1">stats.tasks_runnable == </span><span class="s3">1</span>

    <span class="s2"># Give the child a chance to die and the run_sync_soon a chance to clear</span>
    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s0">with </span><span class="s1">_core.CancelScope(deadline=_core.current_time() + </span><span class="s3">5</span><span class="s1">):</span>
        <span class="s1">stats = _core.current_statistics()</span>
        <span class="s1">print(stats)</span>
        <span class="s0">assert </span><span class="s1">stats.seconds_to_next_deadline == </span><span class="s3">5</span>
    <span class="s1">stats = _core.current_statistics()</span>
    <span class="s1">print(stats)</span>
    <span class="s0">assert </span><span class="s1">stats.seconds_to_next_deadline == inf</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_repr(mock_clock):</span>
    <span class="s1">scope = _core.CancelScope()</span>
    <span class="s0">assert </span><span class="s4">&quot;unbound&quot; </span><span class="s0">in </span><span class="s1">repr(scope)</span>
    <span class="s0">with </span><span class="s1">scope:</span>
        <span class="s0">assert </span><span class="s4">&quot;active&quot; </span><span class="s0">in </span><span class="s1">repr(scope)</span>
        <span class="s1">scope.deadline = _core.current_time() - </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s4">&quot;deadline is 1.00 seconds ago&quot; </span><span class="s0">in </span><span class="s1">repr(scope)</span>
        <span class="s1">scope.deadline = _core.current_time() + </span><span class="s3">10</span>
        <span class="s0">assert </span><span class="s4">&quot;deadline is 10.00 seconds from now&quot; </span><span class="s0">in </span><span class="s1">repr(scope)</span>
        <span class="s2"># when not in async context, can't get the current time</span>
        <span class="s0">assert </span><span class="s4">&quot;deadline&quot; </span><span class="s0">not in await </span><span class="s1">to_thread_run_sync(repr</span><span class="s0">, </span><span class="s1">scope)</span>
        <span class="s1">scope.cancel()</span>
        <span class="s0">assert </span><span class="s4">&quot;cancelled&quot; </span><span class="s0">in </span><span class="s1">repr(scope)</span>
    <span class="s0">assert </span><span class="s4">&quot;exited&quot; </span><span class="s0">in </span><span class="s1">repr(scope)</span>


<span class="s0">def </span><span class="s1">test_cancel_points():</span>
    <span class="s0">async def </span><span class="s1">main1():</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint_if_cancelled()</span>
            <span class="s1">scope.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint_if_cancelled()</span>

    <span class="s1">_core.run(main1)</span>

    <span class="s0">async def </span><span class="s1">main2():</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s1">scope.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.run(main2)</span>

    <span class="s0">async def </span><span class="s1">main3():</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
            <span class="s1">scope.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s1">_core.run(main3)</span>

    <span class="s0">async def </span><span class="s1">main4():</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
            <span class="s1">scope.cancel()</span>
            <span class="s0">await </span><span class="s1">_core.cancel_shielded_checkpoint()</span>
            <span class="s0">await </span><span class="s1">_core.cancel_shielded_checkpoint()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.run(main4)</span>


<span class="s0">async def </span><span class="s1">test_cancel_edge_cases():</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s2"># Two cancels in a row -- idempotent</span>
        <span class="s1">scope.cancel()</span>
        <span class="s1">scope.cancel()</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s0">assert </span><span class="s1">scope.cancel_called</span>
    <span class="s0">assert </span><span class="s1">scope.cancelled_caught</span>

    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s2"># Check level-triggering</span>
        <span class="s1">scope.cancel()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_multierror_filtering():</span>
    <span class="s0">async def </span><span class="s1">crasher():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">outer:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
                    <span class="s2"># Two children that get cancelled by the nursery scope</span>
                    <span class="s1">nursery.start_soon(sleep_forever)  </span><span class="s2"># t1</span>
                    <span class="s1">nursery.start_soon(sleep_forever)  </span><span class="s2"># t2</span>
                    <span class="s1">nursery.cancel_scope.cancel()</span>
                    <span class="s0">with </span><span class="s1">_core.CancelScope(shield=</span><span class="s0">True</span><span class="s1">):</span>
                        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
                    <span class="s2"># One child that gets cancelled by the outer scope</span>
                    <span class="s1">nursery.start_soon(sleep_forever)  </span><span class="s2"># t3</span>
                    <span class="s1">outer.cancel()</span>
                    <span class="s2"># And one that raises a different error</span>
                    <span class="s1">nursery.start_soon(crasher)  </span><span class="s2"># t4</span>
                <span class="s2"># and then our __aexit__ also receives an outer Cancelled</span>
            <span class="s0">except </span><span class="s1">_core.MultiError </span><span class="s0">as </span><span class="s1">multi_exc:</span>
                <span class="s2"># Since the outer scope became cancelled before the</span>
                <span class="s2"># nursery block exited, all cancellations inside the</span>
                <span class="s2"># nursery block continue propagating to reach the</span>
                <span class="s2"># outer scope.</span>
                <span class="s0">assert </span><span class="s1">len(multi_exc.exceptions) == </span><span class="s3">5</span>
                <span class="s1">summary = {}</span>
                <span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">multi_exc.exceptions:</span>
                    <span class="s1">summary.setdefault(type(exc)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
                    <span class="s1">summary[type(exc)] += </span><span class="s3">1</span>
                <span class="s0">assert </span><span class="s1">summary == {_core.Cancelled: </span><span class="s3">4</span><span class="s0">, </span><span class="s1">KeyError: </span><span class="s3">1</span><span class="s1">}</span>
                <span class="s0">raise</span>
    <span class="s0">except </span><span class="s1">AssertionError:  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">raise</span>
    <span class="s0">except </span><span class="s1">BaseException </span><span class="s0">as </span><span class="s1">exc:</span>
        <span class="s2"># This is outside the outer scope, so all the Cancelled</span>
        <span class="s2"># exceptions should have been absorbed, leaving just a regular</span>
        <span class="s2"># KeyError from crasher()</span>
        <span class="s0">assert </span><span class="s1">type(exc) </span><span class="s0">is </span><span class="s1">KeyError</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">assert False</span>


<span class="s0">async def </span><span class="s1">test_precancelled_task():</span>
    <span class="s2"># a task that gets spawned into an already-cancelled nursery should begin</span>
    <span class="s2"># execution (https://github.com/python-trio/trio/issues/41), but get a</span>
    <span class="s2"># cancelled error at its first blocking call.</span>
    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">blocker():</span>
        <span class="s1">record.append(</span><span class="s4">&quot;started&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.cancel_scope.cancel()</span>
        <span class="s1">nursery.start_soon(blocker)</span>
    <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;started&quot;</span><span class="s1">]</span>


<span class="s0">async def </span><span class="s1">test_cancel_shielding():</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">outer:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">inner:</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s1">outer.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

            <span class="s0">assert </span><span class="s1">inner.shield </span><span class="s0">is False</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
                <span class="s1">inner.shield = </span><span class="s4">&quot;hello&quot;</span>
            <span class="s0">assert </span><span class="s1">inner.shield </span><span class="s0">is False</span>

            <span class="s1">inner.shield = </span><span class="s0">True</span>
            <span class="s0">assert </span><span class="s1">inner.shield </span><span class="s0">is True</span>
            <span class="s2"># shield protects us from 'outer'</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

            <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">innerest:</span>
                <span class="s1">innerest.cancel()</span>
                <span class="s2"># but it doesn't protect us from scope inside inner</span>
                <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

            <span class="s1">inner.shield = </span><span class="s0">False</span>
            <span class="s2"># can disable shield again</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

            <span class="s2"># re-enable shield</span>
            <span class="s1">inner.shield = </span><span class="s0">True</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s2"># shield doesn't protect us from inner itself</span>
            <span class="s1">inner.cancel()</span>
            <span class="s2"># This should now raise, but be absorbed by the inner scope</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">assert </span><span class="s1">inner.cancelled_caught</span>


<span class="s2"># make sure that cancellation propagates immediately to all children</span>
<span class="s0">async def </span><span class="s1">test_cancel_inheritance():</span>
    <span class="s1">record = set()</span>

    <span class="s0">async def </span><span class="s1">leaf(ident):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>
        <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
            <span class="s1">record.add(ident)</span>

    <span class="s0">async def </span><span class="s1">worker(ident):</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(leaf</span><span class="s0">, </span><span class="s1">ident + </span><span class="s4">&quot;-l1&quot;</span><span class="s1">)</span>
            <span class="s1">nursery.start_soon(leaf</span><span class="s0">, </span><span class="s1">ident + </span><span class="s4">&quot;-l2&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(worker</span><span class="s0">, </span><span class="s4">&quot;w1&quot;</span><span class="s1">)</span>
        <span class="s1">nursery.start_soon(worker</span><span class="s0">, </span><span class="s4">&quot;w2&quot;</span><span class="s1">)</span>
        <span class="s1">nursery.cancel_scope.cancel()</span>

    <span class="s0">assert </span><span class="s1">record == {</span><span class="s4">&quot;w1-l1&quot;</span><span class="s0">, </span><span class="s4">&quot;w1-l2&quot;</span><span class="s0">, </span><span class="s4">&quot;w2-l1&quot;</span><span class="s0">, </span><span class="s4">&quot;w2-l2&quot;</span><span class="s1">}</span>


<span class="s0">async def </span><span class="s1">test_cancel_shield_abort():</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">outer:</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">outer.cancel()</span>
            <span class="s1">nursery.cancel_scope.shield = </span><span class="s0">True</span>
            <span class="s2"># The outer scope is cancelled, but this task is protected by the</span>
            <span class="s2"># shield, so it manages to get to sleep</span>
            <span class="s1">record = []</span>

            <span class="s0">async def </span><span class="s1">sleeper():</span>
                <span class="s1">record.append(</span><span class="s4">&quot;sleeping&quot;</span><span class="s1">)</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s0">await </span><span class="s1">sleep_forever()</span>
                <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
                    <span class="s1">record.append(</span><span class="s4">&quot;cancelled&quot;</span><span class="s1">)</span>

            <span class="s1">nursery.start_soon(sleeper)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleeping&quot;</span><span class="s1">]</span>
            <span class="s2"># now when we unshield, it should abort the sleep.</span>
            <span class="s1">nursery.cancel_scope.shield = </span><span class="s0">False</span>
            <span class="s2"># wait for the task to finish before entering the nursery</span>
            <span class="s2"># __aexit__, because __aexit__ could make it spuriously look like</span>
            <span class="s2"># this worked by cancelling the nursery scope. (When originally</span>
            <span class="s2"># written, without these last few lines, the test spuriously</span>
            <span class="s2"># passed, even though shield assignment was buggy.)</span>
            <span class="s0">with </span><span class="s1">_core.CancelScope(shield=</span><span class="s0">True</span><span class="s1">):</span>
                <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
                <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleeping&quot;</span><span class="s0">, </span><span class="s4">&quot;cancelled&quot;</span><span class="s1">]</span>


<span class="s0">async def </span><span class="s1">test_basic_timeout(mock_clock):</span>
    <span class="s1">start = _core.current_time()</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s0">assert </span><span class="s1">scope.deadline == inf</span>
        <span class="s1">scope.deadline = start + </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">scope.deadline == start + </span><span class="s3">1</span>
    <span class="s0">assert not </span><span class="s1">scope.cancel_called</span>
    <span class="s1">mock_clock.jump(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s0">assert not </span><span class="s1">scope.cancel_called</span>

    <span class="s1">start = _core.current_time()</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope(deadline=start + </span><span class="s3">1</span><span class="s1">) </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s1">mock_clock.jump(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">sleep_forever()</span>
    <span class="s2"># But then the scope swallowed the exception... but we can still see it</span>
    <span class="s2"># here:</span>
    <span class="s0">assert </span><span class="s1">scope.cancel_called</span>
    <span class="s0">assert </span><span class="s1">scope.cancelled_caught</span>

    <span class="s2"># changing deadline</span>
    <span class="s1">start = _core.current_time()</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s1">scope.deadline = start + </span><span class="s3">10</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s1">mock_clock.jump(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s1">scope.deadline = start + </span><span class="s3">1</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_nesting():</span>
    <span class="s2"># Nested scopes: if two triggering at once, the outer one wins</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope1:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope2:</span>
            <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope3:</span>
                <span class="s1">scope3.cancel()</span>
                <span class="s1">scope2.cancel()</span>
                <span class="s0">await </span><span class="s1">sleep_forever()</span>
    <span class="s0">assert </span><span class="s1">scope3.cancel_called</span>
    <span class="s0">assert not </span><span class="s1">scope3.cancelled_caught</span>
    <span class="s0">assert </span><span class="s1">scope2.cancel_called</span>
    <span class="s0">assert </span><span class="s1">scope2.cancelled_caught</span>
    <span class="s0">assert not </span><span class="s1">scope1.cancel_called</span>
    <span class="s0">assert not </span><span class="s1">scope1.cancelled_caught</span>

    <span class="s2"># shielding</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope1:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope2:</span>
            <span class="s1">scope1.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s1">scope2.shield = </span><span class="s0">True</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s1">scope2.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s2"># if a scope is pending, but then gets popped off the stack, then it</span>
    <span class="s2"># isn't delivered</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s1">scope.cancel()</span>
        <span class="s0">await </span><span class="s1">_core.cancel_shielded_checkpoint()</span>
    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s0">assert not </span><span class="s1">scope.cancelled_caught</span>


<span class="s2"># Regression test for https://github.com/python-trio/trio/issues/1175</span>
<span class="s0">async def </span><span class="s1">test_unshield_while_cancel_propagating():</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">outer:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">inner:</span>
            <span class="s1">outer.cancel()</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
            <span class="s0">finally</span><span class="s1">:</span>
                <span class="s1">inner.shield = </span><span class="s0">True</span>
    <span class="s0">assert </span><span class="s1">outer.cancelled_caught </span><span class="s0">and not </span><span class="s1">inner.cancelled_caught</span>


<span class="s0">async def </span><span class="s1">test_cancel_unbound():</span>
    <span class="s0">async def </span><span class="s1">sleep_until_cancelled(scope):</span>
        <span class="s0">with </span><span class="s1">scope</span><span class="s0">, </span><span class="s1">fail_after(</span><span class="s3">1</span><span class="s1">):</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s2"># Cancel before entry</span>
    <span class="s1">scope = _core.CancelScope()</span>
    <span class="s1">scope.cancel()</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(sleep_until_cancelled</span><span class="s0">, </span><span class="s1">scope)</span>

    <span class="s2"># Cancel after entry</span>
    <span class="s1">scope = _core.CancelScope()</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(sleep_until_cancelled</span><span class="s0">, </span><span class="s1">scope)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s1">scope.cancel()</span>

    <span class="s2"># Shield before entry</span>
    <span class="s1">scope = _core.CancelScope()</span>
    <span class="s1">scope.shield = </span><span class="s0">True</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">outer</span><span class="s0">, </span><span class="s1">scope:</span>
        <span class="s1">outer.cancel()</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s1">scope.shield = </span><span class="s0">False</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s2"># Can't reuse</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s1">scope.cancel()</span>
    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s0">assert </span><span class="s1">scope.cancel_called</span>
    <span class="s0">assert not </span><span class="s1">scope.cancelled_caught</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
        <span class="s0">with </span><span class="s1">scope:</span>
            <span class="s0">pass  </span><span class="s2"># pragma: no cover</span>
    <span class="s0">assert </span><span class="s4">&quot;single 'with' block&quot; </span><span class="s0">in </span><span class="s1">str(exc_info.value)</span>

    <span class="s2"># Can't reenter</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s0">with </span><span class="s1">scope:</span>
                <span class="s0">pass  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">assert </span><span class="s4">&quot;single 'with' block&quot; </span><span class="s0">in </span><span class="s1">str(exc_info.value)</span>

    <span class="s2"># Can't enter from multiple tasks simultaneously</span>
    <span class="s1">scope = _core.CancelScope()</span>

    <span class="s0">async def </span><span class="s1">enter_scope():</span>
        <span class="s0">with </span><span class="s1">scope:</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(enter_scope</span><span class="s0">, </span><span class="s1">name=</span><span class="s4">&quot;this one&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>

        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s0">with </span><span class="s1">scope:</span>
                <span class="s0">pass  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">assert </span><span class="s4">&quot;single 'with' block&quot; </span><span class="s0">in </span><span class="s1">str(exc_info.value)</span>
        <span class="s1">nursery.cancel_scope.cancel()</span>

    <span class="s2"># If not yet entered, cancel_called is true when the deadline has passed</span>
    <span class="s2"># even if cancel() hasn't been called yet</span>
    <span class="s1">scope = _core.CancelScope(deadline=_core.current_time() + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">scope.cancel_called</span>
    <span class="s1">scope.deadline -= </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">scope.cancel_called</span>
    <span class="s1">scope.deadline += </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">scope.cancel_called  </span><span class="s2"># never become un-cancelled</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_misnesting():</span>
    <span class="s1">outer = _core.CancelScope()</span>
    <span class="s1">inner = _core.CancelScope()</span>
    <span class="s0">with </span><span class="s1">ExitStack() </span><span class="s0">as </span><span class="s1">stack:</span>
        <span class="s1">stack.enter_context(outer)</span>
        <span class="s0">with </span><span class="s1">inner:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;still within its child&quot;</span><span class="s1">):</span>
                <span class="s1">stack.close()</span>
        <span class="s2"># No further error is raised when exiting the inner context</span>

    <span class="s2"># If there are other tasks inside the abandoned part of the cancel tree,</span>
    <span class="s2"># they get cancelled when the misnesting is detected</span>
    <span class="s0">async def </span><span class="s1">task1():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s2"># Even if inside another cancel scope</span>
    <span class="s0">async def </span><span class="s1">task2():</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope():</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">with </span><span class="s1">ExitStack() </span><span class="s0">as </span><span class="s1">stack:</span>
        <span class="s1">stack.enter_context(_core.CancelScope())</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(task1)</span>
            <span class="s1">nursery.start_soon(task2)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;still within its child&quot;</span><span class="s1">):</span>
                <span class="s1">stack.close()</span>

    <span class="s2"># Variant that makes the child tasks direct children of the scope</span>
    <span class="s2"># that noticed the misnesting:</span>
    <span class="s1">nursery_mgr = _core.open_nursery()</span>
    <span class="s1">nursery = </span><span class="s0">await </span><span class="s1">nursery_mgr.__aenter__()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">nursery.start_soon(task1)</span>
        <span class="s1">nursery.start_soon(task2)</span>
        <span class="s1">nursery.start_soon(sleep_forever)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s1">nursery.cancel_scope.__exit__(</span><span class="s0">None, None, None</span><span class="s1">)</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">exc_info:</span>
            <span class="s0">await </span><span class="s1">nursery_mgr.__aexit__(*sys.exc_info())</span>
        <span class="s0">assert </span><span class="s4">&quot;which had already been exited&quot; </span><span class="s0">in </span><span class="s1">str(exc_info.value)</span>
        <span class="s0">assert </span><span class="s1">type(exc_info.value.__context__) </span><span class="s0">is </span><span class="s1">_core.MultiError</span>
        <span class="s0">assert </span><span class="s1">len(exc_info.value.__context__.exceptions) == </span><span class="s3">3</span>
        <span class="s1">cancelled_in_context = </span><span class="s0">False</span>
        <span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">exc_info.value.__context__.exceptions:</span>
            <span class="s0">assert </span><span class="s1">isinstance(exc</span><span class="s0">, </span><span class="s1">RuntimeError)</span>
            <span class="s0">assert </span><span class="s4">&quot;closed before the task exited&quot; </span><span class="s0">in </span><span class="s1">str(exc)</span>
            <span class="s1">cancelled_in_context |= isinstance(exc.__context__</span><span class="s0">, </span><span class="s1">_core.Cancelled)</span>
        <span class="s0">assert </span><span class="s1">cancelled_in_context  </span><span class="s2"># for the sleep_forever</span>

    <span class="s2"># Trying to exit a cancel scope from an unrelated task raises an error</span>
    <span class="s2"># without affecting any state</span>
    <span class="s0">async def </span><span class="s1">task3(task_status):</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
            <span class="s1">task_status.started(scope)</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">scope = </span><span class="s0">await </span><span class="s1">nursery.start(task3)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;from unrelated&quot;</span><span class="s1">):</span>
            <span class="s1">scope.__exit__(</span><span class="s0">None, None, None</span><span class="s1">)</span>
        <span class="s1">scope.cancel()</span>


<span class="s1">@slow</span>
<span class="s0">async def </span><span class="s1">test_timekeeping():</span>
    <span class="s2"># probably a good idea to use a real clock for *one* test anyway...</span>
    <span class="s1">TARGET = </span><span class="s3">1.0</span>
    <span class="s2"># give it a few tries in case of random CI server flakiness</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">):</span>
        <span class="s1">real_start = time.perf_counter()</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
            <span class="s1">scope.deadline = _core.current_time() + TARGET</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>
        <span class="s1">real_duration = time.perf_counter() - real_start</span>
        <span class="s1">accuracy = real_duration / TARGET</span>
        <span class="s1">print(accuracy)</span>
        <span class="s2"># Actual time elapsed should always be &gt;= target time</span>
        <span class="s2"># (== is possible depending on system behavior for time.perf_counter resolution</span>
        <span class="s0">if </span><span class="s3">1.0 </span><span class="s1">&lt;= accuracy &lt; </span><span class="s3">2</span><span class="s1">:  </span><span class="s2"># pragma: no branch</span>
            <span class="s0">break</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">assert False</span>


<span class="s0">async def </span><span class="s1">test_failed_abort():</span>
    <span class="s1">stubborn_task = [</span><span class="s0">None</span><span class="s1">]</span>
    <span class="s1">stubborn_scope = [</span><span class="s0">None</span><span class="s1">]</span>
    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">stubborn_sleeper():</span>
        <span class="s1">stubborn_task[</span><span class="s3">0</span><span class="s1">] = _core.current_task()</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
            <span class="s1">stubborn_scope[</span><span class="s3">0</span><span class="s1">] = scope</span>
            <span class="s1">record.append(</span><span class="s4">&quot;sleep&quot;</span><span class="s1">)</span>
            <span class="s1">x = </span><span class="s0">await </span><span class="s1">_core.wait_task_rescheduled(</span><span class="s0">lambda </span><span class="s1">_: _core.Abort.FAILED)</span>
            <span class="s0">assert </span><span class="s1">x == </span><span class="s3">1</span>
            <span class="s1">record.append(</span><span class="s4">&quot;woke&quot;</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">_core.checkpoint_if_cancelled()</span>
            <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
                <span class="s1">record.append(</span><span class="s4">&quot;cancelled&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(stubborn_sleeper)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleep&quot;</span><span class="s1">]</span>
        <span class="s1">stubborn_scope[</span><span class="s3">0</span><span class="s1">].cancel()</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s2"># cancel didn't wake it up</span>
        <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleep&quot;</span><span class="s1">]</span>
        <span class="s2"># wake it up again by hand</span>
        <span class="s1">_core.reschedule(stubborn_task[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">outcome.Value(</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleep&quot;</span><span class="s0">, </span><span class="s4">&quot;woke&quot;</span><span class="s0">, </span><span class="s4">&quot;cancelled&quot;</span><span class="s1">]</span>


<span class="s1">@restore_unraisablehook()</span>
<span class="s0">def </span><span class="s1">test_broken_abort():</span>
    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s2"># These yields are here to work around an annoying warning -- we're</span>
        <span class="s2"># going to crash the main loop, and if we (by chance) do this before</span>
        <span class="s2"># the run_sync_soon task runs for the first time, then Python gives us</span>
        <span class="s2"># a spurious warning about it not being awaited. (I mean, the warning</span>
        <span class="s2"># is correct, but here we're testing our ability to deliver a</span>
        <span class="s2"># semi-meaningful error after things have gone totally pear-shaped, so</span>
        <span class="s2"># it's not relevant.) By letting the run_sync_soon_task run first, we</span>
        <span class="s2"># avoid the warning.</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
            <span class="s1">scope.cancel()</span>
            <span class="s2"># None is not a legal return value here</span>
            <span class="s0">await </span><span class="s1">_core.wait_task_rescheduled(</span><span class="s0">lambda </span><span class="s1">_: </span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.TrioInternalError):</span>
        <span class="s1">_core.run(main)</span>

    <span class="s2"># Because this crashes, various __del__ methods print complaints on</span>
    <span class="s2"># stderr. Make sure that they get run now, so the output is attached to</span>
    <span class="s2"># this test.</span>
    <span class="s1">gc_collect_harder()</span>


<span class="s1">@restore_unraisablehook()</span>
<span class="s0">def </span><span class="s1">test_error_in_run_loop():</span>
    <span class="s2"># Blow stuff up real good to check we at least get a TrioInternalError</span>
    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">task = _core.current_task()</span>
        <span class="s1">task._schedule_points = </span><span class="s4">&quot;hello!&quot;</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s0">with </span><span class="s1">ignore_coroutine_never_awaited_warnings():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.TrioInternalError):</span>
            <span class="s1">_core.run(main)</span>


<span class="s0">async def </span><span class="s1">test_spawn_system_task():</span>
    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">system_task(x):</span>
        <span class="s1">record.append((</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s1">x))</span>
        <span class="s1">record.append((</span><span class="s4">&quot;ki&quot;</span><span class="s0">, </span><span class="s1">_core.currently_ki_protected()))</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.spawn_system_task(system_task</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
    <span class="s0">assert </span><span class="s1">record == [(</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;ki&quot;</span><span class="s0">, True</span><span class="s1">)]</span>


<span class="s2"># intentionally make a system task crash</span>
<span class="s0">def </span><span class="s1">test_system_task_crash():</span>
    <span class="s0">async def </span><span class="s1">crasher():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">_core.spawn_system_task(crasher)</span>
        <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.TrioInternalError):</span>
        <span class="s1">_core.run(main)</span>


<span class="s0">def </span><span class="s1">test_system_task_crash_MultiError():</span>
    <span class="s0">async def </span><span class="s1">crasher1():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">async def </span><span class="s1">crasher2():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">async def </span><span class="s1">system_task():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(crasher1)</span>
            <span class="s1">nursery.start_soon(crasher2)</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">_core.spawn_system_task(system_task)</span>
        <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.TrioInternalError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main)</span>

    <span class="s1">me = excinfo.value.__cause__</span>
    <span class="s0">assert </span><span class="s1">isinstance(me</span><span class="s0">, </span><span class="s1">_core.MultiError)</span>
    <span class="s0">assert </span><span class="s1">len(me.exceptions) == </span><span class="s3">2</span>
    <span class="s0">for </span><span class="s1">exc </span><span class="s0">in </span><span class="s1">me.exceptions:</span>
        <span class="s0">assert </span><span class="s1">isinstance(exc</span><span class="s0">, </span><span class="s1">(KeyError</span><span class="s0">, </span><span class="s1">ValueError))</span>


<span class="s0">def </span><span class="s1">test_system_task_crash_plus_Cancelled():</span>
    <span class="s2"># Set up a situation where a system task crashes with a</span>
    <span class="s2"># MultiError([Cancelled, ValueError])</span>
    <span class="s0">async def </span><span class="s1">crasher():</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>
        <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
            <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">async def </span><span class="s1">cancelme():</span>
        <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">async def </span><span class="s1">system_task():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(crasher)</span>
            <span class="s1">nursery.start_soon(cancelme)</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">_core.spawn_system_task(system_task)</span>
        <span class="s2"># then we exit, triggering a cancellation</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.TrioInternalError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main)</span>
    <span class="s0">assert </span><span class="s1">type(excinfo.value.__cause__) </span><span class="s0">is </span><span class="s1">ValueError</span>


<span class="s0">def </span><span class="s1">test_system_task_crash_KeyboardInterrupt():</span>
    <span class="s0">async def </span><span class="s1">ki():</span>
        <span class="s0">raise </span><span class="s1">KeyboardInterrupt</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">_core.spawn_system_task(ki)</span>
        <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.TrioInternalError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main)</span>
    <span class="s0">assert </span><span class="s1">isinstance(excinfo.value.__cause__</span><span class="s0">, </span><span class="s1">KeyboardInterrupt)</span>


<span class="s2"># This used to fail because checkpoint was a yield followed by an immediate</span>
<span class="s2"># reschedule. So we had:</span>
<span class="s2"># 1) this task yields</span>
<span class="s2"># 2) this task is rescheduled</span>
<span class="s2"># ...</span>
<span class="s2"># 3) next iteration of event loop starts, runs timeouts</span>
<span class="s2"># 4) this task has timed out</span>
<span class="s2"># 5) ...but it's on the run queue, so the timeout is queued to be delivered</span>
<span class="s2">#    the next time that it's blocked.</span>
<span class="s0">async def </span><span class="s1">test_yield_briefly_checks_for_timeout(mock_clock):</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope(deadline=_core.current_time() + </span><span class="s3">5</span><span class="s1">):</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s1">mock_clock.jump(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>


<span class="s2"># This tests that sys.exc_info is properly saved/restored as we swap between</span>
<span class="s2"># tasks. It turns out that the interpreter automagically handles this for us</span>
<span class="s2"># so there's no special code in Trio required to pass this test, but it's</span>
<span class="s2"># still nice to know that it works :-).</span>
<span class="s2">#</span>
<span class="s2"># Update: it turns out I was right to be nervous! see the next test...</span>
<span class="s0">async def </span><span class="s1">test_exc_info():</span>
    <span class="s1">record = []</span>
    <span class="s1">seq = Sequencer()</span>

    <span class="s0">async def </span><span class="s1">child1():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">async with </span><span class="s1">seq(</span><span class="s3">0</span><span class="s1">):</span>
                    <span class="s0">pass  </span><span class="s2"># we don't yield until seq(2) below</span>
                <span class="s1">record.append(</span><span class="s4">&quot;child1 raise&quot;</span><span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;child1&quot;</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">record.append(</span><span class="s4">&quot;child1 sleep&quot;</span><span class="s1">)</span>
                <span class="s0">async with </span><span class="s1">seq(</span><span class="s3">2</span><span class="s1">):</span>
                    <span class="s0">pass</span>
                <span class="s0">assert </span><span class="s4">&quot;child2 wake&quot; </span><span class="s0">in </span><span class="s1">record</span>
                <span class="s1">record.append(</span><span class="s4">&quot;child1 re-raise&quot;</span><span class="s1">)</span>
                <span class="s0">raise</span>
        <span class="s0">assert </span><span class="s1">excinfo.value.__context__ </span><span class="s0">is None</span>
        <span class="s1">record.append(</span><span class="s4">&quot;child1 success&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">child2():</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
            <span class="s0">async with </span><span class="s1">seq(</span><span class="s3">1</span><span class="s1">):</span>
                <span class="s0">pass  </span><span class="s2"># we don't yield until seq(3) below</span>
            <span class="s0">assert </span><span class="s4">&quot;child1 sleep&quot; </span><span class="s0">in </span><span class="s1">record</span>
            <span class="s1">record.append(</span><span class="s4">&quot;child2 wake&quot;</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">sys.exc_info() == (</span><span class="s0">None, None, None</span><span class="s1">)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s4">&quot;child2&quot;</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">KeyError:</span>
                <span class="s1">record.append(</span><span class="s4">&quot;child2 sleep again&quot;</span><span class="s1">)</span>
                <span class="s0">async with </span><span class="s1">seq(</span><span class="s3">3</span><span class="s1">):</span>
                    <span class="s0">pass</span>
                <span class="s0">assert </span><span class="s4">&quot;child1 re-raise&quot; </span><span class="s0">in </span><span class="s1">record</span>
                <span class="s1">record.append(</span><span class="s4">&quot;child2 re-raise&quot;</span><span class="s1">)</span>
                <span class="s0">raise</span>
        <span class="s0">assert </span><span class="s1">excinfo.value.__context__ </span><span class="s0">is None</span>
        <span class="s1">record.append(</span><span class="s4">&quot;child2 success&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(child1)</span>
        <span class="s1">nursery.start_soon(child2)</span>

    <span class="s0">assert </span><span class="s1">record == [</span>
        <span class="s4">&quot;child1 raise&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;child1 sleep&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;child2 wake&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;child2 sleep again&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;child1 re-raise&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;child1 success&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;child2 re-raise&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;child2 success&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>


<span class="s2"># At least as of CPython 3.6, using .throw() to raise an exception inside a</span>
<span class="s2"># coroutine/generator causes the original exc_info state to be lost, so things</span>
<span class="s2"># like re-raising and exception chaining are broken.</span>
<span class="s2">#</span>
<span class="s2"># https://bugs.python.org/issue29587</span>
<span class="s0">async def </span><span class="s1">test_exc_info_after_yield_error():</span>
    <span class="s1">child_task = </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">child():</span>
        <span class="s0">nonlocal </span><span class="s1">child_task</span>
        <span class="s1">child_task = _core.current_task()</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">sleep_forever()</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">pass</span>
            <span class="s0">raise</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(child)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s1">_core.reschedule(child_task</span><span class="s0">, </span><span class="s1">outcome.Error(ValueError()))</span>


<span class="s2"># Similar to previous test -- if the ValueError() gets sent in via 'throw',</span>
<span class="s2"># then Python's normal implicit chaining stuff is broken.</span>
<span class="s0">async def </span><span class="s1">test_exception_chaining_after_yield_error():</span>
    <span class="s1">child_task = </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">child():</span>
        <span class="s0">nonlocal </span><span class="s1">child_task</span>
        <span class="s1">child_task = _core.current_task()</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(child)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s1">_core.reschedule(child_task</span><span class="s0">, </span><span class="s1">outcome.Error(ValueError()))</span>

    <span class="s0">assert </span><span class="s1">isinstance(excinfo.value.__context__</span><span class="s0">, </span><span class="s1">KeyError)</span>


<span class="s0">async def </span><span class="s1">test_nursery_exception_chaining_doesnt_make_context_loops():</span>
    <span class="s0">async def </span><span class="s1">crasher():</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.MultiError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(crasher)</span>
            <span class="s0">raise </span><span class="s1">ValueError</span>
    <span class="s2"># the MultiError should not have the KeyError or ValueError as context</span>
    <span class="s0">assert </span><span class="s1">excinfo.value.__context__ </span><span class="s0">is None</span>


<span class="s0">def </span><span class="s1">test_TrioToken_identity():</span>
    <span class="s0">async def </span><span class="s1">get_and_check_token():</span>
        <span class="s1">token = _core.current_trio_token()</span>
        <span class="s2"># Two calls in the same run give the same object</span>
        <span class="s0">assert </span><span class="s1">token </span><span class="s0">is </span><span class="s1">_core.current_trio_token()</span>
        <span class="s0">return </span><span class="s1">token</span>

    <span class="s1">t1 = _core.run(get_and_check_token)</span>
    <span class="s1">t2 = _core.run(get_and_check_token)</span>
    <span class="s0">assert </span><span class="s1">t1 </span><span class="s0">is not </span><span class="s1">t2</span>
    <span class="s0">assert </span><span class="s1">t1 != t2</span>
    <span class="s0">assert </span><span class="s1">hash(t1) != hash(t2)</span>


<span class="s0">async def </span><span class="s1">test_TrioToken_run_sync_soon_basic():</span>
    <span class="s1">record = []</span>

    <span class="s0">def </span><span class="s1">cb(x):</span>
        <span class="s1">record.append((</span><span class="s4">&quot;cb&quot;</span><span class="s0">, </span><span class="s1">x))</span>

    <span class="s1">token = _core.current_trio_token()</span>
    <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">record</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
    <span class="s0">assert </span><span class="s1">record == [(</span><span class="s4">&quot;cb&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_too_late():</span>
    <span class="s1">token = </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">nonlocal </span><span class="s1">token</span>
        <span class="s1">token = _core.current_trio_token()</span>

    <span class="s1">_core.run(main)</span>
    <span class="s0">assert </span><span class="s1">token </span><span class="s0">is not None</span>
    <span class="s0">with </span><span class="s1">pytest.raises(_core.RunFinishedError):</span>
        <span class="s1">token.run_sync_soon(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)  </span><span class="s2"># pragma: no branch</span>


<span class="s0">async def </span><span class="s1">test_TrioToken_run_sync_soon_idempotent():</span>
    <span class="s1">record = []</span>

    <span class="s0">def </span><span class="s1">cb(x):</span>
        <span class="s1">record.append(x)</span>

    <span class="s1">token = _core.current_trio_token()</span>
    <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
    <span class="s0">assert </span><span class="s1">len(record) == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">sorted(record) == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span>

    <span class="s2"># ordering test</span>
    <span class="s1">record = []</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">100</span><span class="s1">):</span>
            <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
    <span class="s2"># We guarantee FIFO</span>
    <span class="s0">assert </span><span class="s1">record == list(range(</span><span class="s3">100</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_idempotent_requeue():</span>
    <span class="s2"># We guarantee that if a call has finished, queueing it again will call it</span>
    <span class="s2"># again. Due to the lack of synchronization, this effectively means that</span>
    <span class="s2"># we have to guarantee that once a call has *started*, queueing it again</span>
    <span class="s2"># will call it again. Also this is much easier to test :-)</span>
    <span class="s1">record = []</span>

    <span class="s0">def </span><span class="s1">redo(token):</span>
        <span class="s1">record.append(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">token.run_sync_soon(redo</span><span class="s0">, </span><span class="s1">token</span><span class="s0">, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">_core.RunFinishedError:</span>
            <span class="s0">pass</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">token = _core.current_trio_token()</span>
        <span class="s1">token.run_sync_soon(redo</span><span class="s0">, </span><span class="s1">token</span><span class="s0">, </span><span class="s1">idempotent=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.run(main)</span>

    <span class="s0">assert </span><span class="s1">len(record) &gt;= </span><span class="s3">2</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_after_main_crash():</span>
    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">token = _core.current_trio_token()</span>
        <span class="s2"># After main exits but before finally cleaning up, callback processed</span>
        <span class="s2"># normally</span>
        <span class="s1">token.run_sync_soon(</span><span class="s0">lambda</span><span class="s1">: record.append(</span><span class="s4">&quot;sync-cb&quot;</span><span class="s1">))</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">_core.run(main)</span>

    <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sync-cb&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_crashes():</span>
    <span class="s1">record = set()</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">token = _core.current_trio_token()</span>
        <span class="s1">token.run_sync_soon(</span><span class="s0">lambda</span><span class="s1">: dict()[</span><span class="s4">&quot;nope&quot;</span><span class="s1">])</span>
        <span class="s2"># check that a crashing run_sync_soon callback doesn't stop further</span>
        <span class="s2"># calls to run_sync_soon</span>
        <span class="s1">token.run_sync_soon(</span><span class="s0">lambda</span><span class="s1">: record.add(</span><span class="s4">&quot;2nd run_sync_soon ran&quot;</span><span class="s1">))</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>
        <span class="s0">except </span><span class="s1">_core.Cancelled:</span>
            <span class="s1">record.add(</span><span class="s4">&quot;cancelled!&quot;</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.TrioInternalError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main)</span>

    <span class="s0">assert </span><span class="s1">type(excinfo.value.__cause__) </span><span class="s0">is </span><span class="s1">KeyError</span>
    <span class="s0">assert </span><span class="s1">record == {</span><span class="s4">&quot;2nd run_sync_soon ran&quot;</span><span class="s0">, </span><span class="s4">&quot;cancelled!&quot;</span><span class="s1">}</span>


<span class="s0">async def </span><span class="s1">test_TrioToken_run_sync_soon_FIFO():</span>
    <span class="s1">N = </span><span class="s3">100</span>
    <span class="s1">record = []</span>
    <span class="s1">token = _core.current_trio_token()</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(N):</span>
        <span class="s1">token.run_sync_soon(</span><span class="s0">lambda </span><span class="s1">j: record.append(j)</span><span class="s0">, </span><span class="s1">i)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
    <span class="s0">assert </span><span class="s1">record == list(range(N))</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_starvation_resistance():</span>
    <span class="s2"># Even if we push callbacks in from callbacks, so that the callback queue</span>
    <span class="s2"># never empties out, then we still can't starve out other tasks from</span>
    <span class="s2"># running.</span>
    <span class="s1">token = </span><span class="s0">None</span>
    <span class="s1">record = []</span>

    <span class="s0">def </span><span class="s1">naughty_cb(i):</span>
        <span class="s0">nonlocal </span><span class="s1">token</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">token.run_sync_soon(naughty_cb</span><span class="s0">, </span><span class="s1">i + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">_core.RunFinishedError:</span>
            <span class="s1">record.append((</span><span class="s4">&quot;run finished&quot;</span><span class="s0">, </span><span class="s1">i))</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s0">nonlocal </span><span class="s1">token</span>
        <span class="s1">token = _core.current_trio_token()</span>
        <span class="s1">token.run_sync_soon(naughty_cb</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">record.append(</span><span class="s4">&quot;starting&quot;</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">20</span><span class="s1">):</span>
            <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s1">_core.run(main)</span>
    <span class="s0">assert </span><span class="s1">len(record) == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">record[</span><span class="s3">0</span><span class="s1">] == </span><span class="s4">&quot;starting&quot;</span>
    <span class="s0">assert </span><span class="s1">record[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == </span><span class="s4">&quot;run finished&quot;</span>
    <span class="s0">assert </span><span class="s1">record[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">1</span><span class="s1">] &gt;= </span><span class="s3">19</span>


<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_threaded_stress_test():</span>
    <span class="s1">cb_counter = </span><span class="s3">0</span>

    <span class="s0">def </span><span class="s1">cb():</span>
        <span class="s0">nonlocal </span><span class="s1">cb_counter</span>
        <span class="s1">cb_counter += </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">stress_thread(token):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s1">token.run_sync_soon(cb)</span>
                <span class="s1">time.sleep(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">_core.RunFinishedError:</span>
            <span class="s0">pass</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">token = _core.current_trio_token()</span>
        <span class="s1">thread = threading.Thread(target=stress_thread</span><span class="s0">, </span><span class="s1">args=(token</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">thread.start()</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">):</span>
            <span class="s1">start_value = cb_counter</span>
            <span class="s0">while </span><span class="s1">cb_counter == start_value:</span>
                <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">0.01</span><span class="s1">)</span>

    <span class="s1">_core.run(main)</span>
    <span class="s1">print(cb_counter)</span>


<span class="s0">async def </span><span class="s1">test_TrioToken_run_sync_soon_massive_queue():</span>
    <span class="s2"># There are edge cases in the wakeup fd code when the wakeup fd overflows,</span>
    <span class="s2"># so let's try to make that happen. This is also just a good stress test</span>
    <span class="s2"># in general. (With the current-as-of-2017-02-14 code using a socketpair</span>
    <span class="s2"># with minimal buffer, Linux takes 6 wakeups to fill the buffer and macOS</span>
    <span class="s2"># takes 1 wakeup. So 1000 is overkill if anything. Windows OTOH takes</span>
    <span class="s2"># ~600,000 wakeups, but has the same code paths...)</span>
    <span class="s1">COUNT = </span><span class="s3">1000</span>
    <span class="s1">token = _core.current_trio_token()</span>
    <span class="s1">counter = [</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">cb(i):</span>
        <span class="s2"># This also tests FIFO ordering of callbacks</span>
        <span class="s0">assert </span><span class="s1">counter[</span><span class="s3">0</span><span class="s1">] == i</span>
        <span class="s1">counter[</span><span class="s3">0</span><span class="s1">] += </span><span class="s3">1</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(COUNT):</span>
        <span class="s1">token.run_sync_soon(cb</span><span class="s0">, </span><span class="s1">i)</span>
    <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
    <span class="s0">assert </span><span class="s1">counter[</span><span class="s3">0</span><span class="s1">] == COUNT</span>


<span class="s1">@pytest.mark.skipif(buggy_pypy_asyncgens</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;PyPy 7.2 is buggy&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_TrioToken_run_sync_soon_late_crash():</span>
    <span class="s2"># Crash after system nursery is closed -- easiest way to do that is</span>
    <span class="s2"># from an async generator finalizer.</span>
    <span class="s1">record = []</span>
    <span class="s1">saved = []</span>

    <span class="s0">async def </span><span class="s1">agen():</span>
        <span class="s1">token = _core.current_trio_token()</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s3">1</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">token.run_sync_soon(</span><span class="s0">lambda</span><span class="s1">: {}[</span><span class="s4">&quot;nope&quot;</span><span class="s1">])</span>
            <span class="s1">token.run_sync_soon(</span><span class="s0">lambda</span><span class="s1">: record.append(</span><span class="s4">&quot;2nd ran&quot;</span><span class="s1">))</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">saved.append(agen())</span>
        <span class="s0">await </span><span class="s1">saved[-</span><span class="s3">1</span><span class="s1">].asend(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">record.append(</span><span class="s4">&quot;main exiting&quot;</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(_core.TrioInternalError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(main)</span>

    <span class="s0">assert </span><span class="s1">type(excinfo.value.__cause__) </span><span class="s0">is </span><span class="s1">KeyError</span>
    <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;main exiting&quot;</span><span class="s0">, </span><span class="s4">&quot;2nd ran&quot;</span><span class="s1">]</span>


<span class="s0">async def </span><span class="s1">test_slow_abort_basic():</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">scope:</span>
        <span class="s1">scope.cancel()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s1">task = _core.current_task()</span>
            <span class="s1">token = _core.current_trio_token()</span>

            <span class="s0">def </span><span class="s1">slow_abort(raise_cancel):</span>
                <span class="s1">result = outcome.capture(raise_cancel)</span>
                <span class="s1">token.run_sync_soon(_core.reschedule</span><span class="s0">, </span><span class="s1">task</span><span class="s0">, </span><span class="s1">result)</span>
                <span class="s0">return </span><span class="s1">_core.Abort.FAILED</span>

            <span class="s0">await </span><span class="s1">_core.wait_task_rescheduled(slow_abort)</span>


<span class="s0">async def </span><span class="s1">test_slow_abort_edge_cases():</span>
    <span class="s1">record = []</span>

    <span class="s0">async def </span><span class="s1">slow_aborter():</span>
        <span class="s1">task = _core.current_task()</span>
        <span class="s1">token = _core.current_trio_token()</span>

        <span class="s0">def </span><span class="s1">slow_abort(raise_cancel):</span>
            <span class="s1">record.append(</span><span class="s4">&quot;abort-called&quot;</span><span class="s1">)</span>
            <span class="s1">result = outcome.capture(raise_cancel)</span>
            <span class="s1">token.run_sync_soon(_core.reschedule</span><span class="s0">, </span><span class="s1">task</span><span class="s0">, </span><span class="s1">result)</span>
            <span class="s0">return </span><span class="s1">_core.Abort.FAILED</span>

        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s1">record.append(</span><span class="s4">&quot;sleeping&quot;</span><span class="s1">)</span>
            <span class="s0">await </span><span class="s1">_core.wait_task_rescheduled(slow_abort)</span>
        <span class="s1">record.append(</span><span class="s4">&quot;cancelled&quot;</span><span class="s1">)</span>
        <span class="s2"># blocking again, this time it's okay, because we're shielded</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
        <span class="s1">record.append(</span><span class="s4">&quot;done&quot;</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">outer1:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">outer2:</span>
            <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
                <span class="s2"># So we have a task blocked on an operation that can't be</span>
                <span class="s2"># aborted immediately</span>
                <span class="s1">nursery.start_soon(slow_aborter)</span>
                <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
                <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleeping&quot;</span><span class="s1">]</span>
                <span class="s2"># And then we cancel it, so the abort callback gets run</span>
                <span class="s1">outer1.cancel()</span>
                <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleeping&quot;</span><span class="s0">, </span><span class="s4">&quot;abort-called&quot;</span><span class="s1">]</span>
                <span class="s2"># In fact that happens twice! (This used to cause the abort</span>
                <span class="s2"># callback to be run twice)</span>
                <span class="s1">outer2.cancel()</span>
                <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleeping&quot;</span><span class="s0">, </span><span class="s4">&quot;abort-called&quot;</span><span class="s1">]</span>
                <span class="s2"># But then before the abort finishes, the task gets shielded!</span>
                <span class="s1">nursery.cancel_scope.shield = </span><span class="s0">True</span>
                <span class="s2"># Now we wait for the task to finish...</span>
            <span class="s2"># The cancellation was delivered, even though it was shielded</span>
            <span class="s0">assert </span><span class="s1">record == [</span><span class="s4">&quot;sleeping&quot;</span><span class="s0">, </span><span class="s4">&quot;abort-called&quot;</span><span class="s0">, </span><span class="s4">&quot;cancelled&quot;</span><span class="s0">, </span><span class="s4">&quot;done&quot;</span><span class="s1">]</span>


<span class="s0">async def </span><span class="s1">test_task_tree_introspection():</span>
    <span class="s1">tasks = {}</span>
    <span class="s1">nurseries = {}</span>

    <span class="s0">async def </span><span class="s1">parent(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s1">tasks[</span><span class="s4">&quot;parent&quot;</span><span class="s1">] = _core.current_task()</span>

        <span class="s0">assert </span><span class="s1">tasks[</span><span class="s4">&quot;parent&quot;</span><span class="s1">].child_nurseries == []</span>

        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery1:</span>
            <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery2:</span>
                <span class="s0">assert </span><span class="s1">tasks[</span><span class="s4">&quot;parent&quot;</span><span class="s1">].child_nurseries == [nursery1</span><span class="s0">, </span><span class="s1">nursery2]</span>

        <span class="s0">assert </span><span class="s1">tasks[</span><span class="s4">&quot;parent&quot;</span><span class="s1">].child_nurseries == []</span>

        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nurseries[</span><span class="s4">&quot;parent&quot;</span><span class="s1">] = nursery</span>
            <span class="s0">await </span><span class="s1">nursery.start(child1)</span>

        <span class="s2"># Upward links survive after tasks/nurseries exit</span>
        <span class="s0">assert </span><span class="s1">nurseries[</span><span class="s4">&quot;parent&quot;</span><span class="s1">].parent_task </span><span class="s0">is </span><span class="s1">tasks[</span><span class="s4">&quot;parent&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">tasks[</span><span class="s4">&quot;child1&quot;</span><span class="s1">].parent_nursery </span><span class="s0">is </span><span class="s1">nurseries[</span><span class="s4">&quot;parent&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">nurseries[</span><span class="s4">&quot;child1&quot;</span><span class="s1">].parent_task </span><span class="s0">is </span><span class="s1">tasks[</span><span class="s4">&quot;child1&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">tasks[</span><span class="s4">&quot;child2&quot;</span><span class="s1">].parent_nursery </span><span class="s0">is </span><span class="s1">nurseries[</span><span class="s4">&quot;child1&quot;</span><span class="s1">]</span>

        <span class="s1">nursery = _core.current_task().parent_nursery</span>
        <span class="s2"># Make sure that chaining eventually gives a nursery of None (and not,</span>
        <span class="s2"># for example, an error)</span>
        <span class="s0">while </span><span class="s1">nursery </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">t = nursery.parent_task</span>
            <span class="s1">nursery = t.parent_nursery</span>

    <span class="s0">async def </span><span class="s1">child2():</span>
        <span class="s1">tasks[</span><span class="s4">&quot;child2&quot;</span><span class="s1">] = _core.current_task()</span>
        <span class="s0">assert </span><span class="s1">tasks[</span><span class="s4">&quot;parent&quot;</span><span class="s1">].child_nurseries == [nurseries[</span><span class="s4">&quot;parent&quot;</span><span class="s1">]]</span>
        <span class="s0">assert </span><span class="s1">nurseries[</span><span class="s4">&quot;parent&quot;</span><span class="s1">].child_tasks == frozenset({tasks[</span><span class="s4">&quot;child1&quot;</span><span class="s1">]})</span>
        <span class="s0">assert </span><span class="s1">tasks[</span><span class="s4">&quot;child1&quot;</span><span class="s1">].child_nurseries == [nurseries[</span><span class="s4">&quot;child1&quot;</span><span class="s1">]]</span>
        <span class="s0">assert </span><span class="s1">nurseries[</span><span class="s4">&quot;child1&quot;</span><span class="s1">].child_tasks == frozenset({tasks[</span><span class="s4">&quot;child2&quot;</span><span class="s1">]})</span>
        <span class="s0">assert </span><span class="s1">tasks[</span><span class="s4">&quot;child2&quot;</span><span class="s1">].child_nurseries == []</span>

    <span class="s0">async def </span><span class="s1">child1(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s1">me = tasks[</span><span class="s4">&quot;child1&quot;</span><span class="s1">] = _core.current_task()</span>
        <span class="s0">assert </span><span class="s1">me.parent_nursery.parent_task </span><span class="s0">is </span><span class="s1">tasks[</span><span class="s4">&quot;parent&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">me.parent_nursery </span><span class="s0">is not </span><span class="s1">nurseries[</span><span class="s4">&quot;parent&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">me.eventual_parent_nursery </span><span class="s0">is </span><span class="s1">nurseries[</span><span class="s4">&quot;parent&quot;</span><span class="s1">]</span>
        <span class="s1">task_status.started()</span>
        <span class="s0">assert </span><span class="s1">me.parent_nursery </span><span class="s0">is </span><span class="s1">nurseries[</span><span class="s4">&quot;parent&quot;</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">me.eventual_parent_nursery </span><span class="s0">is None</span>

        <span class="s2"># Wait for the start() call to return and close its internal nursery, to</span>
        <span class="s2"># ensure consistent results in child2:</span>
        <span class="s0">await </span><span class="s1">_core.wait_all_tasks_blocked()</span>

        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nurseries[</span><span class="s4">&quot;child1&quot;</span><span class="s1">] = nursery</span>
            <span class="s1">nursery.start_soon(child2)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(parent)</span>

    <span class="s2"># There are no pending starts, so no one should have a non-None</span>
    <span class="s2"># eventual_parent_nursery</span>
    <span class="s0">for </span><span class="s1">task </span><span class="s0">in </span><span class="s1">tasks.values():</span>
        <span class="s0">assert </span><span class="s1">task.eventual_parent_nursery </span><span class="s0">is None</span>


<span class="s0">async def </span><span class="s1">test_nursery_closure():</span>
    <span class="s0">async def </span><span class="s1">child1(nursery):</span>
        <span class="s2"># We can add new tasks to the nursery even after entering __aexit__,</span>
        <span class="s2"># so long as there are still tasks running</span>
        <span class="s1">nursery.start_soon(child2)</span>

    <span class="s0">async def </span><span class="s1">child2():</span>
        <span class="s0">pass</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(child1</span><span class="s0">, </span><span class="s1">nursery)</span>

    <span class="s2"># But once we've left __aexit__, the nursery is closed</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">nursery.start_soon(child2)</span>


<span class="s0">async def </span><span class="s1">test_spawn_name():</span>
    <span class="s0">async def </span><span class="s1">func1(expected):</span>
        <span class="s1">task = _core.current_task()</span>
        <span class="s0">assert </span><span class="s1">expected </span><span class="s0">in </span><span class="s1">task.name</span>

    <span class="s0">async def </span><span class="s1">func2():  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">pass</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">for </span><span class="s1">spawn_fn </span><span class="s0">in </span><span class="s1">[nursery.start_soon</span><span class="s0">, </span><span class="s1">_core.spawn_system_task]:</span>
            <span class="s1">spawn_fn(func1</span><span class="s0">, </span><span class="s4">&quot;func1&quot;</span><span class="s1">)</span>
            <span class="s1">spawn_fn(func1</span><span class="s0">, </span><span class="s4">&quot;func2&quot;</span><span class="s0">, </span><span class="s1">name=func2)</span>
            <span class="s1">spawn_fn(func1</span><span class="s0">, </span><span class="s4">&quot;func3&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s4">&quot;func3&quot;</span><span class="s1">)</span>
            <span class="s1">spawn_fn(functools.partial(func1</span><span class="s0">, </span><span class="s4">&quot;func1&quot;</span><span class="s1">))</span>
            <span class="s1">spawn_fn(func1</span><span class="s0">, </span><span class="s4">&quot;object&quot;</span><span class="s0">, </span><span class="s1">name=object())</span>


<span class="s0">async def </span><span class="s1">test_current_effective_deadline(mock_clock):</span>
    <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == inf</span>

    <span class="s0">with </span><span class="s1">_core.CancelScope(deadline=</span><span class="s3">5</span><span class="s1">) </span><span class="s0">as </span><span class="s1">scope1:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope(deadline=</span><span class="s3">10</span><span class="s1">) </span><span class="s0">as </span><span class="s1">scope2:</span>
            <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == </span><span class="s3">5</span>
            <span class="s1">scope2.deadline = </span><span class="s3">3</span>
            <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == </span><span class="s3">3</span>
            <span class="s1">scope2.deadline = </span><span class="s3">10</span>
            <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == </span><span class="s3">5</span>
            <span class="s1">scope2.shield = </span><span class="s0">True</span>
            <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == </span><span class="s3">10</span>
            <span class="s1">scope2.shield = </span><span class="s0">False</span>
            <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == </span><span class="s3">5</span>
            <span class="s1">scope1.cancel()</span>
            <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == -inf</span>
            <span class="s1">scope2.shield = </span><span class="s0">True</span>
            <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == </span><span class="s3">10</span>
        <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == -inf</span>
    <span class="s0">assert </span><span class="s1">_core.current_effective_deadline() == inf</span>


<span class="s0">def </span><span class="s1">test_nice_error_on_bad_calls_to_run_or_spawn():</span>
    <span class="s0">def </span><span class="s1">bad_call_run(*args):</span>
        <span class="s1">_core.run(*args)</span>

    <span class="s0">def </span><span class="s1">bad_call_spawn(*args):</span>
        <span class="s0">async def </span><span class="s1">main():</span>
            <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
                <span class="s1">nursery.start_soon(*args)</span>

        <span class="s1">_core.run(main)</span>

    <span class="s0">for </span><span class="s1">bad_call </span><span class="s0">in </span><span class="s1">bad_call_run</span><span class="s0">, </span><span class="s1">bad_call_spawn:</span>

        <span class="s0">async def </span><span class="s1">f():  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">pass</span>

        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;expecting an async function&quot;</span><span class="s1">):</span>
            <span class="s1">bad_call(f())</span>

        <span class="s0">async def </span><span class="s1">async_gen(arg):  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">yield </span><span class="s1">arg</span>

        <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;expected an async function but got an async generator&quot;</span>
        <span class="s1">):</span>
            <span class="s1">bad_call(async_gen</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_calling_asyncio_function_gives_nice_error():</span>
    <span class="s0">async def </span><span class="s1">child_xyzzy():</span>
        <span class="s0">await </span><span class="s1">create_asyncio_future_in_new_loop()</span>

    <span class="s0">async def </span><span class="s1">misguided():</span>
        <span class="s0">await </span><span class="s1">child_xyzzy()</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">_core.run(misguided)</span>

    <span class="s0">assert </span><span class="s4">&quot;asyncio&quot; </span><span class="s0">in </span><span class="s1">str(excinfo.value)</span>
    <span class="s2"># The traceback should point to the location of the foreign await</span>
    <span class="s0">assert </span><span class="s1">any(  </span><span class="s2"># pragma: no branch</span>
        <span class="s1">entry.name == </span><span class="s4">&quot;child_xyzzy&quot; </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">excinfo.traceback</span>
    <span class="s1">)</span>


<span class="s0">async def </span><span class="s1">test_asyncio_function_inside_nursery_does_not_explode():</span>
    <span class="s2"># Regression test for https://github.com/python-trio/trio/issues/552</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s0">import </span><span class="s1">asyncio</span>

            <span class="s1">nursery.start_soon(sleep_forever)</span>
            <span class="s0">await </span><span class="s1">create_asyncio_future_in_new_loop()</span>
    <span class="s0">assert </span><span class="s4">&quot;asyncio&quot; </span><span class="s0">in </span><span class="s1">str(excinfo.value)</span>


<span class="s0">async def </span><span class="s1">test_trivial_yields():</span>
    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint_if_cancelled()</span>
        <span class="s0">await </span><span class="s1">_core.cancel_shielded_checkpoint()</span>

    <span class="s0">with </span><span class="s1">assert_checkpoints():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery():</span>
            <span class="s0">pass</span>

    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cancel_scope:</span>
        <span class="s1">cancel_scope.cancel()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.MultiError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
            <span class="s0">async with </span><span class="s1">_core.open_nursery():</span>
                <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">assert </span><span class="s1">len(excinfo.value.exceptions) == </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s1">{type(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">excinfo.value.exceptions} == {</span>
            <span class="s1">KeyError</span><span class="s0">,</span>
            <span class="s1">_core.Cancelled</span><span class="s0">,</span>
        <span class="s1">}</span>


<span class="s0">async def </span><span class="s1">test_nursery_start(autojump_clock):</span>
    <span class="s0">async def </span><span class="s1">no_args():  </span><span class="s2"># pragma: no cover</span>
        <span class="s0">pass</span>

    <span class="s2"># Errors in calling convention get raised immediately from start</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
            <span class="s0">await </span><span class="s1">nursery.start(no_args)</span>

    <span class="s0">async def </span><span class="s1">sleep_then_start(seconds</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s1">repr(task_status)  </span><span class="s2"># smoke test</span>
        <span class="s0">await </span><span class="s1">sleep(seconds)</span>
        <span class="s1">task_status.started(seconds)</span>
        <span class="s0">await </span><span class="s1">sleep(seconds)</span>

    <span class="s2"># Basic happy-path check: start waits for the task to call started(), then</span>
    <span class="s2"># returns, passes back the value, and the given nursery then waits for it</span>
    <span class="s2"># to exit.</span>
    <span class="s0">for </span><span class="s1">seconds </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]:</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s0">assert </span><span class="s1">len(nursery.child_tasks) == </span><span class="s3">0</span>
            <span class="s1">t0 = _core.current_time()</span>
            <span class="s0">assert await </span><span class="s1">nursery.start(sleep_then_start</span><span class="s0">, </span><span class="s1">seconds) == seconds</span>
            <span class="s0">assert </span><span class="s1">_core.current_time() - t0 == seconds</span>
            <span class="s0">assert </span><span class="s1">len(nursery.child_tasks) == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">_core.current_time() - t0 == </span><span class="s3">2 </span><span class="s1">* seconds</span>

    <span class="s2"># Make sure TASK_STATUS_IGNORED works so task function can be called</span>
    <span class="s2"># directly</span>
    <span class="s1">t0 = _core.current_time()</span>
    <span class="s0">await </span><span class="s1">sleep_then_start(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">_core.current_time() - t0 == </span><span class="s3">2 </span><span class="s1">* </span><span class="s3">3</span>

    <span class="s2"># calling started twice</span>
    <span class="s0">async def </span><span class="s1">double_started(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s1">task_status.started()</span>
        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
            <span class="s1">task_status.started()</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">await </span><span class="s1">nursery.start(double_started)</span>

    <span class="s2"># child crashes before calling started -&gt; error comes out of .start()</span>
    <span class="s0">async def </span><span class="s1">raise_keyerror(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s4">&quot;oops&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
            <span class="s0">await </span><span class="s1">nursery.start(raise_keyerror)</span>

    <span class="s2"># child exiting cleanly before calling started -&gt; triggers a RuntimeError</span>
    <span class="s0">async def </span><span class="s1">nothing(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s0">return</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
            <span class="s0">await </span><span class="s1">nursery.start(nothing)</span>
        <span class="s0">assert </span><span class="s4">&quot;exited without calling&quot; </span><span class="s0">in </span><span class="s1">str(excinfo.value)</span>

    <span class="s2"># if the call to start() is cancelled, then the call to started() does</span>
    <span class="s2"># nothing -- the child keeps executing under start(). The value it passed</span>
    <span class="s2"># is ignored; start() raises Cancelled.</span>
    <span class="s0">async def </span><span class="s1">just_started(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s1">task_status.started(</span><span class="s4">&quot;hi&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cs:</span>
            <span class="s1">cs.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
                <span class="s0">await </span><span class="s1">nursery.start(just_started)</span>

    <span class="s2"># and if after the no-op started(), the child crashes, the error comes out</span>
    <span class="s2"># of start()</span>
    <span class="s0">async def </span><span class="s1">raise_keyerror_after_started(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s1">task_status.started()</span>
        <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s4">&quot;whoopsiedaisy&quot;</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cs:</span>
            <span class="s1">cs.cancel()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(_core.MultiError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
                <span class="s0">await </span><span class="s1">nursery.start(raise_keyerror_after_started)</span>
    <span class="s0">assert </span><span class="s1">{type(e) </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">excinfo.value.exceptions} == {</span>
        <span class="s1">_core.Cancelled</span><span class="s0">,</span>
        <span class="s1">KeyError</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s2"># trying to start in a closed nursery raises an error immediately</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">closed_nursery:</span>
        <span class="s0">pass</span>
    <span class="s1">t0 = _core.current_time()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s0">await </span><span class="s1">closed_nursery.start(sleep_then_start</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">_core.current_time() == t0</span>


<span class="s0">async def </span><span class="s1">test_task_nursery_stack():</span>
    <span class="s1">task = _core.current_task()</span>
    <span class="s0">assert </span><span class="s1">task._child_nurseries == []</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery1:</span>
        <span class="s0">assert </span><span class="s1">task._child_nurseries == [nursery1]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
            <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery2:</span>
                <span class="s0">assert </span><span class="s1">task._child_nurseries == [nursery1</span><span class="s0">, </span><span class="s1">nursery2]</span>
                <span class="s0">raise </span><span class="s1">KeyError</span>
        <span class="s0">assert </span><span class="s1">task._child_nurseries == [nursery1]</span>
    <span class="s0">assert </span><span class="s1">task._child_nurseries == []</span>


<span class="s0">async def </span><span class="s1">test_nursery_start_with_cancelled_nursery():</span>
    <span class="s2"># This function isn't testing task_status, it's using task_status as a</span>
    <span class="s2"># convenient way to get a nursery that we can test spawning stuff into.</span>
    <span class="s0">async def </span><span class="s1">setup_nursery(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">task_status.started(nursery)</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s2"># Calls started() while children are asleep, so we can make sure</span>
    <span class="s2"># that the cancellation machinery notices and aborts when a sleeping task</span>
    <span class="s2"># is moved into a cancelled scope.</span>
    <span class="s0">async def </span><span class="s1">sleeping_children(fn</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(sleep_forever)</span>
            <span class="s1">nursery.start_soon(sleep_forever)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
            <span class="s1">fn()</span>
            <span class="s1">task_status.started()</span>

    <span class="s2"># Cancelling the setup_nursery just *before* calling started()</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">target_nursery = </span><span class="s0">await </span><span class="s1">nursery.start(setup_nursery)</span>
        <span class="s0">await </span><span class="s1">target_nursery.start(</span>
            <span class="s1">sleeping_children</span><span class="s0">, </span><span class="s1">target_nursery.cancel_scope.cancel</span>
        <span class="s1">)</span>

    <span class="s2"># Cancelling the setup_nursery just *after* calling started()</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">target_nursery = </span><span class="s0">await </span><span class="s1">nursery.start(setup_nursery)</span>
        <span class="s0">await </span><span class="s1">target_nursery.start(sleeping_children</span><span class="s0">, lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">target_nursery.cancel_scope.cancel()</span>


<span class="s0">async def </span><span class="s1">test_nursery_start_keeps_nursery_open(autojump_clock):</span>
    <span class="s0">async def </span><span class="s1">sleep_a_bit(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">task_status.started()</span>
        <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery1:</span>
        <span class="s1">t0 = _core.current_time()</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery2:</span>
            <span class="s2"># Start the 'start' call running in the background</span>
            <span class="s1">nursery1.start_soon(nursery2.start</span><span class="s0">, </span><span class="s1">sleep_a_bit)</span>
            <span class="s2"># Sleep a bit</span>
            <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s2"># Start another one.</span>
            <span class="s1">nursery1.start_soon(nursery2.start</span><span class="s0">, </span><span class="s1">sleep_a_bit)</span>
            <span class="s2"># Then exit this nursery. At this point, there are no tasks</span>
            <span class="s2"># present in this nursery -- the only thing keeping it open is</span>
            <span class="s2"># that the tasks will be placed into it soon, when they call</span>
            <span class="s2"># started().</span>
        <span class="s0">assert </span><span class="s1">_core.current_time() - t0 == </span><span class="s3">6</span>

    <span class="s2"># Check that it still works even if the task that the nursery is waiting</span>
    <span class="s2"># for ends up crashing, and never actually enters the nursery.</span>
    <span class="s0">async def </span><span class="s1">sleep_then_crash(task_status=_core.TASK_STATUS_IGNORED):</span>
        <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">7</span><span class="s1">)</span>
        <span class="s0">raise </span><span class="s1">KeyError</span>

    <span class="s0">async def </span><span class="s1">start_sleep_then_crash(nursery):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
            <span class="s0">await </span><span class="s1">nursery.start(sleep_then_crash)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery1:</span>
        <span class="s1">t0 = _core.current_time()</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery2:</span>
            <span class="s1">nursery1.start_soon(start_sleep_then_crash</span><span class="s0">, </span><span class="s1">nursery2)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">_core.current_time() - t0 == </span><span class="s3">7</span>


<span class="s0">async def </span><span class="s1">test_nursery_explicit_exception():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery():</span>
            <span class="s0">raise </span><span class="s1">KeyError()</span>


<span class="s0">async def </span><span class="s1">test_nursery_stop_iteration():</span>
    <span class="s0">async def </span><span class="s1">fail():</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(fail)</span>
            <span class="s0">raise </span><span class="s1">StopIteration</span>
    <span class="s0">except </span><span class="s1">_core.MultiError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">assert </span><span class="s1">tuple(map(type</span><span class="s0">, </span><span class="s1">e.exceptions)) == (StopIteration</span><span class="s0">, </span><span class="s1">ValueError)</span>


<span class="s0">async def </span><span class="s1">test_nursery_stop_async_iteration():</span>
    <span class="s0">class </span><span class="s1">it:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">count):</span>
            <span class="s1">self.count = count</span>
            <span class="s1">self.val = </span><span class="s3">0</span>

        <span class="s0">async def </span><span class="s1">__anext__(self):</span>
            <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s1">val = self.val</span>
            <span class="s0">if </span><span class="s1">val &gt;= self.count:</span>
                <span class="s0">raise </span><span class="s1">StopAsyncIteration</span>
            <span class="s1">self.val += </span><span class="s3">1</span>
            <span class="s0">return </span><span class="s1">val</span>

    <span class="s0">class </span><span class="s1">async_zip:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*largs):</span>
            <span class="s1">self.nexts = [obj.__anext__ </span><span class="s0">for </span><span class="s1">obj </span><span class="s0">in </span><span class="s1">largs]</span>

        <span class="s0">async def </span><span class="s1">_accumulate(self</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">items</span><span class="s0">, </span><span class="s1">i):</span>
            <span class="s1">items[i] = </span><span class="s0">await </span><span class="s1">f()</span>

        <span class="s0">def </span><span class="s1">__aiter__(self):</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">async def </span><span class="s1">__anext__(self):</span>
            <span class="s1">nexts = self.nexts</span>
            <span class="s1">items = [</span><span class="s0">None</span><span class="s1">] * len(nexts)</span>
            <span class="s1">got_stop = </span><span class="s0">False</span>

            <span class="s0">def </span><span class="s1">handle(exc):</span>
                <span class="s0">nonlocal </span><span class="s1">got_stop</span>
                <span class="s0">if </span><span class="s1">isinstance(exc</span><span class="s0">, </span><span class="s1">StopAsyncIteration):</span>
                    <span class="s1">got_stop = </span><span class="s0">True</span>
                    <span class="s0">return None</span>
                <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
                    <span class="s0">return </span><span class="s1">exc</span>

            <span class="s0">with </span><span class="s1">_core.MultiError.catch(handle):</span>
                <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
                    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">f </span><span class="s0">in </span><span class="s1">enumerate(nexts):</span>
                        <span class="s1">nursery.start_soon(self._accumulate</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">items</span><span class="s0">, </span><span class="s1">i)</span>

            <span class="s0">if </span><span class="s1">got_stop:</span>
                <span class="s0">raise </span><span class="s1">StopAsyncIteration</span>
            <span class="s0">return </span><span class="s1">items</span>

    <span class="s1">result = []</span>
    <span class="s0">async for </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">async_zip(it(</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">it(</span><span class="s3">2</span><span class="s1">)):</span>
        <span class="s1">result.append(vals)</span>
    <span class="s0">assert </span><span class="s1">result == [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span>


<span class="s0">async def </span><span class="s1">test_traceback_frame_removal():</span>
    <span class="s0">async def </span><span class="s1">my_child_task():</span>
        <span class="s0">raise </span><span class="s1">KeyError()</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s2"># Trick: For now cancel/nursery scopes still leave a bunch of tb gunk</span>
        <span class="s2"># behind. But if there's a MultiError, they leave it on the MultiError,</span>
        <span class="s2"># which lets us get a clean look at the KeyError itself. Someday I</span>
        <span class="s2"># guess this will always be a MultiError (#611), but for now we can</span>
        <span class="s2"># force it by raising two exceptions.</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(my_child_task)</span>
            <span class="s1">nursery.start_soon(my_child_task)</span>
    <span class="s0">except </span><span class="s1">_core.MultiError </span><span class="s0">as </span><span class="s1">exc:</span>
        <span class="s1">first_exc = exc.exceptions[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">isinstance(first_exc</span><span class="s0">, </span><span class="s1">KeyError)</span>
        <span class="s2"># The top frame in the exception traceback should be inside the child</span>
        <span class="s2"># task, not trio/contextvars internals. And there's only one frame</span>
        <span class="s2"># inside the child task, so this will also detect if our frame-removal</span>
        <span class="s2"># is too eager.</span>
        <span class="s1">frame = first_exc.__traceback__.tb_frame</span>
        <span class="s0">assert </span><span class="s1">frame.f_code </span><span class="s0">is </span><span class="s1">my_child_task.__code__</span>


<span class="s0">def </span><span class="s1">test_contextvar_support():</span>
    <span class="s1">var = contextvars.ContextVar(</span><span class="s4">&quot;test&quot;</span><span class="s1">)</span>
    <span class="s1">var.set(</span><span class="s4">&quot;before&quot;</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">var.get() == </span><span class="s4">&quot;before&quot;</span>

    <span class="s0">async def </span><span class="s1">inner():</span>
        <span class="s1">task = _core.current_task()</span>
        <span class="s0">assert </span><span class="s1">task.context.get(var) == </span><span class="s4">&quot;before&quot;</span>
        <span class="s0">assert </span><span class="s1">var.get() == </span><span class="s4">&quot;before&quot;</span>
        <span class="s1">var.set(</span><span class="s4">&quot;after&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">var.get() == </span><span class="s4">&quot;after&quot;</span>
        <span class="s0">assert </span><span class="s1">var </span><span class="s0">in </span><span class="s1">task.context</span>
        <span class="s0">assert </span><span class="s1">task.context.get(var) == </span><span class="s4">&quot;after&quot;</span>

    <span class="s1">_core.run(inner)</span>
    <span class="s0">assert </span><span class="s1">var.get() == </span><span class="s4">&quot;before&quot;</span>


<span class="s0">async def </span><span class="s1">test_contextvar_multitask():</span>
    <span class="s1">var = contextvars.ContextVar(</span><span class="s4">&quot;test&quot;</span><span class="s0">, </span><span class="s1">default=</span><span class="s4">&quot;hmmm&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">t1():</span>
        <span class="s0">assert </span><span class="s1">var.get() == </span><span class="s4">&quot;hmmm&quot;</span>
        <span class="s1">var.set(</span><span class="s4">&quot;hmmmm&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">var.get() == </span><span class="s4">&quot;hmmmm&quot;</span>

    <span class="s0">async def </span><span class="s1">t2():</span>
        <span class="s0">assert </span><span class="s1">var.get() == </span><span class="s4">&quot;hmmmm&quot;</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">n:</span>
        <span class="s1">n.start_soon(t1)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">var.get() == </span><span class="s4">&quot;hmmm&quot;</span>
        <span class="s1">var.set(</span><span class="s4">&quot;hmmmm&quot;</span><span class="s1">)</span>
        <span class="s1">n.start_soon(t2)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>


<span class="s0">def </span><span class="s1">test_system_task_contexts():</span>
    <span class="s1">cvar = contextvars.ContextVar(</span><span class="s4">&quot;qwilfish&quot;</span><span class="s1">)</span>
    <span class="s1">cvar.set(</span><span class="s4">&quot;water&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">system_task():</span>
        <span class="s0">assert </span><span class="s1">cvar.get() == </span><span class="s4">&quot;water&quot;</span>

    <span class="s0">async def </span><span class="s1">regular_task():</span>
        <span class="s0">assert </span><span class="s1">cvar.get() == </span><span class="s4">&quot;poison&quot;</span>

    <span class="s0">async def </span><span class="s1">inner():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">cvar.set(</span><span class="s4">&quot;poison&quot;</span><span class="s1">)</span>
            <span class="s1">nursery.start_soon(regular_task)</span>
            <span class="s1">_core.spawn_system_task(system_task)</span>
            <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>

    <span class="s1">_core.run(inner)</span>


<span class="s0">def </span><span class="s1">test_Nursery_init():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">_core._run.Nursery(</span><span class="s0">None, None</span><span class="s1">)</span>


<span class="s0">async def </span><span class="s1">test_Nursery_private_init():</span>
    <span class="s2"># context manager creation should not raise</span>
    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s0">assert False </span><span class="s1">== nursery._closed</span>


<span class="s0">def </span><span class="s1">test_Nursery_subclass():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>

        <span class="s0">class </span><span class="s1">Subclass(_core._run.Nursery):</span>
            <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">test_Cancelled_init():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s0">raise </span><span class="s1">_core.Cancelled</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">_core.Cancelled()</span>

    <span class="s2"># private constructor should not raise</span>
    <span class="s1">_core.Cancelled._create()</span>


<span class="s0">def </span><span class="s1">test_Cancelled_str():</span>
    <span class="s1">cancelled = _core.Cancelled._create()</span>
    <span class="s0">assert </span><span class="s1">str(cancelled) == </span><span class="s4">&quot;Cancelled&quot;</span>


<span class="s0">def </span><span class="s1">test_Cancelled_subclass():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>

        <span class="s0">class </span><span class="s1">Subclass(_core.Cancelled):</span>
            <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">test_CancelScope_subclass():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>

        <span class="s0">class </span><span class="s1">Subclass(_core.CancelScope):</span>
            <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">test_sniffio_integration():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(sniffio.AsyncLibraryNotFoundError):</span>
        <span class="s1">sniffio.current_async_library()</span>

    <span class="s0">async def </span><span class="s1">check_inside_trio():</span>
        <span class="s0">assert </span><span class="s1">sniffio.current_async_library() == </span><span class="s4">&quot;trio&quot;</span>

    <span class="s1">_core.run(check_inside_trio)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(sniffio.AsyncLibraryNotFoundError):</span>
        <span class="s1">sniffio.current_async_library()</span>


<span class="s0">async def </span><span class="s1">test_Task_custom_sleep_data():</span>
    <span class="s1">task = _core.current_task()</span>
    <span class="s0">assert </span><span class="s1">task.custom_sleep_data </span><span class="s0">is None</span>
    <span class="s1">task.custom_sleep_data = </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">task.custom_sleep_data == </span><span class="s3">1</span>
    <span class="s0">await </span><span class="s1">_core.checkpoint()</span>
    <span class="s0">assert </span><span class="s1">task.custom_sleep_data </span><span class="s0">is None</span>


<span class="s1">@types.coroutine</span>
<span class="s0">def </span><span class="s1">async_yield(value):</span>
    <span class="s0">yield </span><span class="s1">value</span>


<span class="s0">async def </span><span class="s1">test_permanently_detach_coroutine_object():</span>
    <span class="s1">task = </span><span class="s0">None</span>
    <span class="s1">pdco_outcome = </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">detachable_coroutine(task_outcome</span><span class="s0">, </span><span class="s1">yield_value):</span>
        <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">nonlocal </span><span class="s1">task</span><span class="s0">, </span><span class="s1">pdco_outcome</span>
        <span class="s1">task = _core.current_task()</span>
        <span class="s1">pdco_outcome = </span><span class="s0">await </span><span class="s1">outcome.acapture(</span>
            <span class="s1">_core.permanently_detach_coroutine_object</span><span class="s0">, </span><span class="s1">task_outcome</span>
        <span class="s1">)</span>
        <span class="s0">await </span><span class="s1">async_yield(yield_value)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(detachable_coroutine</span><span class="s0">, </span><span class="s1">outcome.Value(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;I'm free!&quot;</span><span class="s1">)</span>

    <span class="s2"># If we get here then Trio thinks the task has exited... but the coroutine</span>
    <span class="s2"># is still iterable</span>
    <span class="s0">assert </span><span class="s1">pdco_outcome </span><span class="s0">is None</span>
    <span class="s0">assert </span><span class="s1">task.coro.send(</span><span class="s4">&quot;be free!&quot;</span><span class="s1">) == </span><span class="s4">&quot;I'm free!&quot;</span>
    <span class="s0">assert </span><span class="s1">pdco_outcome == outcome.Value(</span><span class="s4">&quot;be free!&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(StopIteration):</span>
        <span class="s1">task.coro.send(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s2"># Check the exception paths too</span>
    <span class="s1">task = </span><span class="s0">None</span>
    <span class="s1">pdco_outcome = </span><span class="s0">None</span>
    <span class="s0">with </span><span class="s1">pytest.raises(KeyError):</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(detachable_coroutine</span><span class="s0">, </span><span class="s1">outcome.Error(KeyError())</span><span class="s0">, </span><span class="s4">&quot;uh oh&quot;</span><span class="s1">)</span>
    <span class="s1">throw_in = ValueError()</span>
    <span class="s0">assert </span><span class="s1">task.coro.throw(throw_in) == </span><span class="s4">&quot;uh oh&quot;</span>
    <span class="s0">assert </span><span class="s1">pdco_outcome == outcome.Error(throw_in)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(StopIteration):</span>
        <span class="s1">task.coro.send(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">bad_detach():</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery():</span>
            <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
                <span class="s0">await </span><span class="s1">_core.permanently_detach_coroutine_object(outcome.Value(</span><span class="s0">None</span><span class="s1">))</span>
            <span class="s0">assert </span><span class="s4">&quot;open nurser&quot; </span><span class="s0">in </span><span class="s1">str(excinfo.value)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(bad_detach)</span>


<span class="s0">async def </span><span class="s1">test_detach_and_reattach_coroutine_object():</span>
    <span class="s1">unrelated_task = </span><span class="s0">None</span>
    <span class="s1">task = </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">unrelated_coroutine():</span>
        <span class="s0">nonlocal </span><span class="s1">unrelated_task</span>
        <span class="s1">unrelated_task = _core.current_task()</span>

    <span class="s0">async def </span><span class="s1">reattachable_coroutine():</span>
        <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">nonlocal </span><span class="s1">task</span>
        <span class="s1">task = _core.current_task()</span>

        <span class="s0">def </span><span class="s1">abort_fn(_):  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">return </span><span class="s1">_core.Abort.FAILED</span>

        <span class="s1">got = </span><span class="s0">await </span><span class="s1">_core.temporarily_detach_coroutine_object(abort_fn)</span>
        <span class="s0">assert </span><span class="s1">got == </span><span class="s4">&quot;not trio!&quot;</span>

        <span class="s0">await </span><span class="s1">async_yield(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">async_yield(</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError) </span><span class="s0">as </span><span class="s1">excinfo:</span>
            <span class="s0">await </span><span class="s1">_core.reattach_detached_coroutine_object(unrelated_task</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s4">&quot;does not match&quot; </span><span class="s0">in </span><span class="s1">str(excinfo.value)</span>

        <span class="s0">await </span><span class="s1">_core.reattach_detached_coroutine_object(task</span><span class="s0">, </span><span class="s4">&quot;byebye&quot;</span><span class="s1">)</span>

        <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(unrelated_coroutine)</span>
        <span class="s1">nursery.start_soon(reattachable_coroutine)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">unrelated_task </span><span class="s0">is not None</span>
        <span class="s0">assert </span><span class="s1">task </span><span class="s0">is not None</span>

        <span class="s2"># Okay, it's detached. Here's our coroutine runner:</span>
        <span class="s0">assert </span><span class="s1">task.coro.send(</span><span class="s4">&quot;not trio!&quot;</span><span class="s1">) == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s1">task.coro.send(</span><span class="s0">None</span><span class="s1">) == </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s1">task.coro.send(</span><span class="s0">None</span><span class="s1">) == </span><span class="s4">&quot;byebye&quot;</span>

        <span class="s2"># Now it's been reattached, and we can leave the nursery</span>


<span class="s0">async def </span><span class="s1">test_detached_coroutine_cancellation():</span>
    <span class="s1">abort_fn_called = </span><span class="s0">False</span>
    <span class="s1">task = </span><span class="s0">None</span>

    <span class="s0">async def </span><span class="s1">reattachable_coroutine():</span>
        <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s0">nonlocal </span><span class="s1">task</span>
        <span class="s1">task = _core.current_task()</span>

        <span class="s0">def </span><span class="s1">abort_fn(_):</span>
            <span class="s0">nonlocal </span><span class="s1">abort_fn_called</span>
            <span class="s1">abort_fn_called = </span><span class="s0">True</span>
            <span class="s0">return </span><span class="s1">_core.Abort.FAILED</span>

        <span class="s0">await </span><span class="s1">_core.temporarily_detach_coroutine_object(abort_fn)</span>
        <span class="s0">await </span><span class="s1">_core.reattach_detached_coroutine_object(task</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(_core.Cancelled):</span>
            <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(reattachable_coroutine)</span>
        <span class="s0">await </span><span class="s1">wait_all_tasks_blocked()</span>
        <span class="s0">assert </span><span class="s1">task </span><span class="s0">is not None</span>
        <span class="s1">nursery.cancel_scope.cancel()</span>
        <span class="s1">task.coro.send(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">abort_fn_called</span>


<span class="s1">@restore_unraisablehook()</span>
<span class="s0">def </span><span class="s1">test_async_function_implemented_in_C():</span>
    <span class="s2"># These used to crash because we'd try to mutate the coroutine object's</span>
    <span class="s2"># cr_frame, but C functions don't have Python frames.</span>

    <span class="s0">async def </span><span class="s1">agen_fn(record):</span>
        <span class="s0">assert not </span><span class="s1">_core.currently_ki_protected()</span>
        <span class="s1">record.append(</span><span class="s4">&quot;the generator ran&quot;</span><span class="s1">)</span>
        <span class="s0">yield</span>

    <span class="s1">run_record = []</span>
    <span class="s1">agen = agen_fn(run_record)</span>
    <span class="s1">_core.run(agen.__anext__)</span>
    <span class="s0">assert </span><span class="s1">run_record == [</span><span class="s4">&quot;the generator ran&quot;</span><span class="s1">]</span>

    <span class="s0">async def </span><span class="s1">main():</span>
        <span class="s1">start_soon_record = []</span>
        <span class="s1">agen = agen_fn(start_soon_record)</span>
        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(agen.__anext__)</span>
        <span class="s0">assert </span><span class="s1">start_soon_record == [</span><span class="s4">&quot;the generator ran&quot;</span><span class="s1">]</span>

    <span class="s1">_core.run(main)</span>


<span class="s0">async def </span><span class="s1">test_very_deep_cancel_scope_nesting():</span>
    <span class="s2"># This used to crash with a RecursionError in CancelStatus.recalculate</span>
    <span class="s0">with </span><span class="s1">ExitStack() </span><span class="s0">as </span><span class="s1">exit_stack:</span>
        <span class="s1">outermost_scope = _core.CancelScope()</span>
        <span class="s1">exit_stack.enter_context(outermost_scope)</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5000</span><span class="s1">):</span>
            <span class="s1">exit_stack.enter_context(_core.CancelScope())</span>
        <span class="s1">outermost_scope.cancel()</span>


<span class="s0">async def </span><span class="s1">test_cancel_scope_deadline_duplicates():</span>
    <span class="s2"># This exercises an assert in Deadlines._prune, by intentionally creating</span>
    <span class="s2"># duplicate entries in the deadline heap.</span>
    <span class="s1">now = _core.current_time()</span>
    <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cscope:</span>
        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(DEADLINE_HEAP_MIN_PRUNE_THRESHOLD * </span><span class="s3">2</span><span class="s1">):</span>
            <span class="s1">cscope.deadline = now + </span><span class="s3">9998</span>
            <span class="s1">cscope.deadline = now + </span><span class="s3">9999</span>
        <span class="s0">await </span><span class="s1">sleep(</span><span class="s3">0.01</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skipif(</span>
    <span class="s1">sys.implementation.name != </span><span class="s4">&quot;cpython&quot;</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;Only makes sense with refcounting GC&quot;</span>
<span class="s1">)</span>
<span class="s0">async def </span><span class="s1">test_simple_cancel_scope_usage_doesnt_create_cyclic_garbage():</span>
    <span class="s2"># https://github.com/python-trio/trio/issues/1770</span>
    <span class="s1">gc.collect()</span>

    <span class="s0">async def </span><span class="s1">do_a_cancel():</span>
        <span class="s0">with </span><span class="s1">_core.CancelScope() </span><span class="s0">as </span><span class="s1">cscope:</span>
            <span class="s1">cscope.cancel()</span>
            <span class="s0">await </span><span class="s1">sleep_forever()</span>

    <span class="s1">old_flags = gc.get_debug()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">gc.collect()</span>
        <span class="s1">gc.set_debug(gc.DEBUG_SAVEALL)</span>

        <span class="s0">await </span><span class="s1">do_a_cancel()</span>
        <span class="s0">await </span><span class="s1">do_a_cancel()</span>

        <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">nursery.start_soon(do_a_cancel)</span>

        <span class="s1">gc.collect()</span>
        <span class="s0">assert not </span><span class="s1">gc.garbage</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">gc.set_debug(old_flags)</span>
        <span class="s1">gc.garbage.clear()</span>


<span class="s1">@pytest.mark.skipif(</span>
    <span class="s1">sys.implementation.name != </span><span class="s4">&quot;cpython&quot;</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;Only makes sense with refcounting GC&quot;</span>
<span class="s1">)</span>
<span class="s0">async def </span><span class="s1">test_nursery_cancel_doesnt_create_cyclic_garbage():</span>
    <span class="s2"># https://github.com/python-trio/trio/issues/1770#issuecomment-730229423</span>
    <span class="s1">gc.collect()</span>

    <span class="s1">old_flags = gc.get_debug()</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
            <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
                <span class="s1">gc.collect()</span>
                <span class="s1">gc.set_debug(gc.DEBUG_LEAK)</span>
                <span class="s1">nursery.cancel_scope.cancel()</span>

            <span class="s1">gc.collect()</span>
            <span class="s1">gc.set_debug(</span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">assert not </span><span class="s1">gc.garbage</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">gc.set_debug(old_flags)</span>
        <span class="s1">gc.garbage.clear()</span>


<span class="s1">@pytest.mark.skipif(</span>
    <span class="s1">sys.implementation.name != </span><span class="s4">&quot;cpython&quot;</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;Only makes sense with refcounting GC&quot;</span>
<span class="s1">)</span>
<span class="s0">async def </span><span class="s1">test_locals_destroyed_promptly_on_cancel():</span>
    <span class="s1">destroyed = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">finalizer():</span>
        <span class="s0">nonlocal </span><span class="s1">destroyed</span>
        <span class="s1">destroyed = </span><span class="s0">True</span>

    <span class="s0">class </span><span class="s1">A:</span>
        <span class="s0">pass</span>

    <span class="s0">async def </span><span class="s1">task():</span>
        <span class="s1">a = A()</span>
        <span class="s1">weakref.finalize(a</span><span class="s0">, </span><span class="s1">finalizer)</span>
        <span class="s0">await </span><span class="s1">_core.checkpoint()</span>

    <span class="s0">async with </span><span class="s1">_core.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
        <span class="s1">nursery.start_soon(task)</span>
        <span class="s1">nursery.cancel_scope.cancel()</span>
    <span class="s0">assert </span><span class="s1">destroyed</span>
</pre>
</body>
</html>