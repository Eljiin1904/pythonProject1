<html>
<head>
<title>storage.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
storage.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: Storage (experimental)</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">browser</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">network</span>


<span class="s2">class </span><span class="s1">StorageType(enum.Enum):</span>
    <span class="s3">''' 
    Enum of possible storage types. 
    '''</span>
    <span class="s1">APPCACHE = </span><span class="s4">&quot;appcache&quot;</span>
    <span class="s1">COOKIES = </span><span class="s4">&quot;cookies&quot;</span>
    <span class="s1">FILE_SYSTEMS = </span><span class="s4">&quot;file_systems&quot;</span>
    <span class="s1">INDEXEDDB = </span><span class="s4">&quot;indexeddb&quot;</span>
    <span class="s1">LOCAL_STORAGE = </span><span class="s4">&quot;local_storage&quot;</span>
    <span class="s1">SHADER_CACHE = </span><span class="s4">&quot;shader_cache&quot;</span>
    <span class="s1">WEBSQL = </span><span class="s4">&quot;websql&quot;</span>
    <span class="s1">SERVICE_WORKERS = </span><span class="s4">&quot;service_workers&quot;</span>
    <span class="s1">CACHE_STORAGE = </span><span class="s4">&quot;cache_storage&quot;</span>
    <span class="s1">ALL_ = </span><span class="s4">&quot;all&quot;</span>
    <span class="s1">OTHER = </span><span class="s4">&quot;other&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">UsageForType:</span>
    <span class="s3">''' 
    Usage for a storage type. 
    '''</span>
    <span class="s0">#: Name of storage type.</span>
    <span class="s1">storage_type: StorageType</span>

    <span class="s0">#: Storage usage (bytes).</span>
    <span class="s1">usage: float</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'storageType'</span><span class="s1">] = self.storage_type.to_json()</span>
        <span class="s1">json[</span><span class="s4">'usage'</span><span class="s1">] = self.usage</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">storage_type=StorageType.from_json(json[</span><span class="s4">'storageType'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">usage=float(json[</span><span class="s4">'usage'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">TrustTokens:</span>
    <span class="s3">''' 
    Pair of issuer origin and number of available (signed, but not used) Trust 
    Tokens from that issuer. 
    '''</span>
    <span class="s1">issuer_origin: str</span>

    <span class="s1">count: float</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'issuerOrigin'</span><span class="s1">] = self.issuer_origin</span>
        <span class="s1">json[</span><span class="s4">'count'</span><span class="s1">] = self.count</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">issuer_origin=str(json[</span><span class="s4">'issuerOrigin'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">count=float(json[</span><span class="s4">'count'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">clear_data_for_origin(</span>
        <span class="s1">origin: str</span><span class="s2">,</span>
        <span class="s1">storage_types: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Clears storage for origin. 
 
    :param origin: Security origin. 
    :param storage_types: Comma separated list of StorageType to clear. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'origin'</span><span class="s1">] = origin</span>
    <span class="s1">params[</span><span class="s4">'storageTypes'</span><span class="s1">] = storage_types</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.clearDataForOrigin'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_cookies(</span>
        <span class="s1">browser_context_id: typing.Optional[browser.BrowserContextID] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[network.Cookie]]:</span>
    <span class="s3">''' 
    Returns all browser cookies. 
 
    :param browser_context_id: *(Optional)* Browser context to use when called on the browser endpoint. 
    :returns: Array of cookie objects. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">browser_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'browserContextId'</span><span class="s1">] = browser_context_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.getCookies'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[network.Cookie.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'cookies'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">set_cookies(</span>
        <span class="s1">cookies: typing.List[network.CookieParam]</span><span class="s2">,</span>
        <span class="s1">browser_context_id: typing.Optional[browser.BrowserContextID] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Sets given cookies. 
 
    :param cookies: Cookies to be set. 
    :param browser_context_id: *(Optional)* Browser context to use when called on the browser endpoint. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'cookies'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">cookies]</span>
    <span class="s2">if </span><span class="s1">browser_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'browserContextId'</span><span class="s1">] = browser_context_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.setCookies'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">clear_cookies(</span>
        <span class="s1">browser_context_id: typing.Optional[browser.BrowserContextID] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Clears cookies. 
 
    :param browser_context_id: *(Optional)* Browser context to use when called on the browser endpoint. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">browser_context_id </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'browserContextId'</span><span class="s1">] = browser_context_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.clearCookies'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_usage_and_quota(</span>
        <span class="s1">origin: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[float</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">typing.List[UsageForType]]]:</span>
    <span class="s3">''' 
    Returns usage and quota in bytes. 
 
    :param origin: Security origin. 
    :returns: A tuple with the following items: 
 
        0. **usage** - Storage usage (bytes). 
        1. **quota** - Storage quota (bytes). 
        2. **overrideActive** - Whether or not the origin has an active storage quota override 
        3. **usageBreakdown** - Storage usage per type (bytes). 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'origin'</span><span class="s1">] = origin</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.getUsageAndQuota'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">float(json[</span><span class="s4">'usage'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">float(json[</span><span class="s4">'quota'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">bool(json[</span><span class="s4">'overrideActive'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">[UsageForType.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'usageBreakdown'</span><span class="s1">]]</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">override_quota_for_origin(</span>
        <span class="s1">origin: str</span><span class="s2">,</span>
        <span class="s1">quota_size: typing.Optional[float] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Override quota for the specified origin 
 
    **EXPERIMENTAL** 
 
    :param origin: Security origin. 
    :param quota_size: *(Optional)* The quota size (in bytes) to override the original quota with. If this is called multiple times, the overriden quota will be equal to the quotaSize provided in the final call. If this is called without specifying a quotaSize, the quota will be reset to the default value for the specified origin. If this is called multiple times with different origins, the override will be maintained for each origin until it is disabled (called without a quotaSize). 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'origin'</span><span class="s1">] = origin</span>
    <span class="s2">if </span><span class="s1">quota_size </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'quotaSize'</span><span class="s1">] = quota_size</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.overrideQuotaForOrigin'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">track_cache_storage_for_origin(</span>
        <span class="s1">origin: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Registers origin to be notified when an update occurs to its cache storage list. 
 
    :param origin: Security origin. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'origin'</span><span class="s1">] = origin</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.trackCacheStorageForOrigin'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">track_indexed_db_for_origin(</span>
        <span class="s1">origin: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Registers origin to be notified when an update occurs to its IndexedDB. 
 
    :param origin: Security origin. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'origin'</span><span class="s1">] = origin</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.trackIndexedDBForOrigin'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">untrack_cache_storage_for_origin(</span>
        <span class="s1">origin: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Unregisters origin from receiving notifications for cache storage. 
 
    :param origin: Security origin. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'origin'</span><span class="s1">] = origin</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.untrackCacheStorageForOrigin'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">untrack_indexed_db_for_origin(</span>
        <span class="s1">origin: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Unregisters origin from receiving notifications for IndexedDB. 
 
    :param origin: Security origin. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'origin'</span><span class="s1">] = origin</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.untrackIndexedDBForOrigin'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_trust_tokens() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[TrustTokens]]:</span>
    <span class="s3">''' 
    Returns the number of stored Trust Tokens per issuer for the 
    current browsing context. 
 
    **EXPERIMENTAL** 
 
    :returns:  
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.getTrustTokens'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[TrustTokens.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'tokens'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">clear_trust_tokens(</span>
        <span class="s1">issuer_origin: str</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">bool]:</span>
    <span class="s3">''' 
    Removes all Trust Tokens issued by the provided issuerOrigin. 
    Leaves other stored data, including the issuer's Redemption Records, intact. 
 
    **EXPERIMENTAL** 
 
    :param issuer_origin: 
    :returns: True if any tokens were deleted, false otherwise. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'issuerOrigin'</span><span class="s1">] = issuer_origin</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Storage.clearTrustTokens'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">bool(json[</span><span class="s4">'didDeleteTokens'</span><span class="s1">])</span>


<span class="s1">@event_class(</span><span class="s4">'Storage.cacheStorageContentUpdated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CacheStorageContentUpdated:</span>
    <span class="s3">''' 
    A cache's contents have been modified. 
    '''</span>
    <span class="s0">#: Origin to update.</span>
    <span class="s1">origin: str</span>
    <span class="s0">#: Name of cache in origin.</span>
    <span class="s1">cache_name: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; CacheStorageContentUpdated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">origin=str(json[</span><span class="s4">'origin'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">cache_name=str(json[</span><span class="s4">'cacheName'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Storage.cacheStorageListUpdated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CacheStorageListUpdated:</span>
    <span class="s3">''' 
    A cache has been added/deleted. 
    '''</span>
    <span class="s0">#: Origin to update.</span>
    <span class="s1">origin: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; CacheStorageListUpdated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">origin=str(json[</span><span class="s4">'origin'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Storage.indexedDBContentUpdated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">IndexedDBContentUpdated:</span>
    <span class="s3">''' 
    The origin's IndexedDB object store has been modified. 
    '''</span>
    <span class="s0">#: Origin to update.</span>
    <span class="s1">origin: str</span>
    <span class="s0">#: Database to update.</span>
    <span class="s1">database_name: str</span>
    <span class="s0">#: ObjectStore to update.</span>
    <span class="s1">object_store_name: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; IndexedDBContentUpdated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">origin=str(json[</span><span class="s4">'origin'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">database_name=str(json[</span><span class="s4">'databaseName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">object_store_name=str(json[</span><span class="s4">'objectStoreName'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Storage.indexedDBListUpdated'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">IndexedDBListUpdated:</span>
    <span class="s3">''' 
    The origin's IndexedDB database list has been modified. 
    '''</span>
    <span class="s0">#: Origin to update.</span>
    <span class="s1">origin: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; IndexedDBListUpdated:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">origin=str(json[</span><span class="s4">'origin'</span><span class="s1">])</span>
        <span class="s1">)</span>
</pre>
</body>
</html>