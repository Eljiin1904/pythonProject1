<html>
<head>
<title>layer_tree.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
layer_tree.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: LayerTree (experimental)</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">dom</span>


<span class="s2">class </span><span class="s1">LayerId(str):</span>
    <span class="s3">''' 
    Unique Layer identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; LayerId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'LayerId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">class </span><span class="s1">SnapshotId(str):</span>
    <span class="s3">''' 
    Unique snapshot identifier. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; SnapshotId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'SnapshotId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ScrollRect:</span>
    <span class="s3">''' 
    Rectangle where scrolling happens on the main thread. 
    '''</span>
    <span class="s0">#: Rectangle itself.</span>
    <span class="s1">rect: dom.Rect</span>

    <span class="s0">#: Reason for rectangle to force scrolling on the main thread</span>
    <span class="s1">type_: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'rect'</span><span class="s1">] = self.rect.to_json()</span>
        <span class="s1">json[</span><span class="s4">'type'</span><span class="s1">] = self.type_</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">rect=dom.Rect.from_json(json[</span><span class="s4">'rect'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">type_=str(json[</span><span class="s4">'type'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">StickyPositionConstraint:</span>
    <span class="s3">''' 
    Sticky position constraints. 
    '''</span>
    <span class="s0">#: Layout rectangle of the sticky element before being shifted</span>
    <span class="s1">sticky_box_rect: dom.Rect</span>

    <span class="s0">#: Layout rectangle of the containing block of the sticky element</span>
    <span class="s1">containing_block_rect: dom.Rect</span>

    <span class="s0">#: The nearest sticky layer that shifts the sticky box</span>
    <span class="s1">nearest_layer_shifting_sticky_box: typing.Optional[LayerId] = </span><span class="s2">None</span>

    <span class="s0">#: The nearest sticky layer that shifts the containing block</span>
    <span class="s1">nearest_layer_shifting_containing_block: typing.Optional[LayerId] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'stickyBoxRect'</span><span class="s1">] = self.sticky_box_rect.to_json()</span>
        <span class="s1">json[</span><span class="s4">'containingBlockRect'</span><span class="s1">] = self.containing_block_rect.to_json()</span>
        <span class="s2">if </span><span class="s1">self.nearest_layer_shifting_sticky_box </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'nearestLayerShiftingStickyBox'</span><span class="s1">] = self.nearest_layer_shifting_sticky_box.to_json()</span>
        <span class="s2">if </span><span class="s1">self.nearest_layer_shifting_containing_block </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'nearestLayerShiftingContainingBlock'</span><span class="s1">] = self.nearest_layer_shifting_containing_block.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">sticky_box_rect=dom.Rect.from_json(json[</span><span class="s4">'stickyBoxRect'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">containing_block_rect=dom.Rect.from_json(json[</span><span class="s4">'containingBlockRect'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">nearest_layer_shifting_sticky_box=LayerId.from_json(json[</span><span class="s4">'nearestLayerShiftingStickyBox'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'nearestLayerShiftingStickyBox' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">nearest_layer_shifting_containing_block=LayerId.from_json(json[</span><span class="s4">'nearestLayerShiftingContainingBlock'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'nearestLayerShiftingContainingBlock' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PictureTile:</span>
    <span class="s3">''' 
    Serialized fragment of layer picture along with its offset within the layer. 
    '''</span>
    <span class="s0">#: Offset from owning layer left boundary</span>
    <span class="s1">x: float</span>

    <span class="s0">#: Offset from owning layer top boundary</span>
    <span class="s1">y: float</span>

    <span class="s0">#: Base64-encoded snapshot data.</span>
    <span class="s1">picture: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'x'</span><span class="s1">] = self.x</span>
        <span class="s1">json[</span><span class="s4">'y'</span><span class="s1">] = self.y</span>
        <span class="s1">json[</span><span class="s4">'picture'</span><span class="s1">] = self.picture</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">x=float(json[</span><span class="s4">'x'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">y=float(json[</span><span class="s4">'y'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">picture=str(json[</span><span class="s4">'picture'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Layer:</span>
    <span class="s3">''' 
    Information about a compositing layer. 
    '''</span>
    <span class="s0">#: The unique id for this layer.</span>
    <span class="s1">layer_id: LayerId</span>

    <span class="s0">#: Offset from parent layer, X coordinate.</span>
    <span class="s1">offset_x: float</span>

    <span class="s0">#: Offset from parent layer, Y coordinate.</span>
    <span class="s1">offset_y: float</span>

    <span class="s0">#: Layer width.</span>
    <span class="s1">width: float</span>

    <span class="s0">#: Layer height.</span>
    <span class="s1">height: float</span>

    <span class="s0">#: Indicates how many time this layer has painted.</span>
    <span class="s1">paint_count: int</span>

    <span class="s0">#: Indicates whether this layer hosts any content, rather than being used for</span>
    <span class="s0">#: transform/scrolling purposes only.</span>
    <span class="s1">draws_content: bool</span>

    <span class="s0">#: The id of parent (not present for root).</span>
    <span class="s1">parent_layer_id: typing.Optional[LayerId] = </span><span class="s2">None</span>

    <span class="s0">#: The backend id for the node associated with this layer.</span>
    <span class="s1">backend_node_id: typing.Optional[dom.BackendNodeId] = </span><span class="s2">None</span>

    <span class="s0">#: Transformation matrix for layer, default is identity matrix</span>
    <span class="s1">transform: typing.Optional[typing.List[float]] = </span><span class="s2">None</span>

    <span class="s0">#: Transform anchor point X, absent if no transform specified</span>
    <span class="s1">anchor_x: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s0">#: Transform anchor point Y, absent if no transform specified</span>
    <span class="s1">anchor_y: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s0">#: Transform anchor point Z, absent if no transform specified</span>
    <span class="s1">anchor_z: typing.Optional[float] = </span><span class="s2">None</span>

    <span class="s0">#: Set if layer is not visible.</span>
    <span class="s1">invisible: typing.Optional[bool] = </span><span class="s2">None</span>

    <span class="s0">#: Rectangles scrolling on main thread only.</span>
    <span class="s1">scroll_rects: typing.Optional[typing.List[ScrollRect]] = </span><span class="s2">None</span>

    <span class="s0">#: Sticky position constraint information</span>
    <span class="s1">sticky_position_constraint: typing.Optional[StickyPositionConstraint] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'layerId'</span><span class="s1">] = self.layer_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'offsetX'</span><span class="s1">] = self.offset_x</span>
        <span class="s1">json[</span><span class="s4">'offsetY'</span><span class="s1">] = self.offset_y</span>
        <span class="s1">json[</span><span class="s4">'width'</span><span class="s1">] = self.width</span>
        <span class="s1">json[</span><span class="s4">'height'</span><span class="s1">] = self.height</span>
        <span class="s1">json[</span><span class="s4">'paintCount'</span><span class="s1">] = self.paint_count</span>
        <span class="s1">json[</span><span class="s4">'drawsContent'</span><span class="s1">] = self.draws_content</span>
        <span class="s2">if </span><span class="s1">self.parent_layer_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'parentLayerId'</span><span class="s1">] = self.parent_layer_id.to_json()</span>
        <span class="s2">if </span><span class="s1">self.backend_node_id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'backendNodeId'</span><span class="s1">] = self.backend_node_id.to_json()</span>
        <span class="s2">if </span><span class="s1">self.transform </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'transform'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.transform]</span>
        <span class="s2">if </span><span class="s1">self.anchor_x </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'anchorX'</span><span class="s1">] = self.anchor_x</span>
        <span class="s2">if </span><span class="s1">self.anchor_y </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'anchorY'</span><span class="s1">] = self.anchor_y</span>
        <span class="s2">if </span><span class="s1">self.anchor_z </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'anchorZ'</span><span class="s1">] = self.anchor_z</span>
        <span class="s2">if </span><span class="s1">self.invisible </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'invisible'</span><span class="s1">] = self.invisible</span>
        <span class="s2">if </span><span class="s1">self.scroll_rects </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'scrollRects'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.scroll_rects]</span>
        <span class="s2">if </span><span class="s1">self.sticky_position_constraint </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'stickyPositionConstraint'</span><span class="s1">] = self.sticky_position_constraint.to_json()</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">layer_id=LayerId.from_json(json[</span><span class="s4">'layerId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">offset_x=float(json[</span><span class="s4">'offsetX'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">offset_y=float(json[</span><span class="s4">'offsetY'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">width=float(json[</span><span class="s4">'width'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">height=float(json[</span><span class="s4">'height'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">paint_count=int(json[</span><span class="s4">'paintCount'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">draws_content=bool(json[</span><span class="s4">'drawsContent'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">parent_layer_id=LayerId.from_json(json[</span><span class="s4">'parentLayerId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'parentLayerId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">backend_node_id=dom.BackendNodeId.from_json(json[</span><span class="s4">'backendNodeId'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'backendNodeId' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">transform=[float(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'transform'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'transform' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">anchor_x=float(json[</span><span class="s4">'anchorX'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'anchorX' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">anchor_y=float(json[</span><span class="s4">'anchorY'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'anchorY' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">anchor_z=float(json[</span><span class="s4">'anchorZ'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'anchorZ' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">invisible=bool(json[</span><span class="s4">'invisible'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'invisible' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">scroll_rects=[ScrollRect.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'scrollRects'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'scrollRects' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">sticky_position_constraint=StickyPositionConstraint.from_json(json[</span><span class="s4">'stickyPositionConstraint'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'stickyPositionConstraint' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">PaintProfile(list):</span>
    <span class="s3">''' 
    Array of timings, one per paint step. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; typing.List[float]:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: typing.List[float]) -&gt; PaintProfile:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'PaintProfile({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s2">def </span><span class="s1">compositing_reasons(</span>
        <span class="s1">layer_id: LayerId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[typing.List[str]</span><span class="s2">, </span><span class="s1">typing.List[str]]]:</span>
    <span class="s3">''' 
    Provides the reasons why the given layer was composited. 
 
    :param layer_id: The id of the layer for which we want to get the reasons it was composited. 
    :returns: A tuple with the following items: 
 
        0. **compositingReasons** - A list of strings specifying reasons for the given layer to become composited. 
        1. **compositingReasonIds** - A list of strings specifying reason IDs for the given layer to become composited. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'layerId'</span><span class="s1">] = layer_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.compositingReasons'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'compositingReasons'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'compositingReasonIds'</span><span class="s1">]]</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">disable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disables compositing tree inspection. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.disable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">enable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables compositing tree inspection. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.enable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">load_snapshot(</span>
        <span class="s1">tiles: typing.List[PictureTile]</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">SnapshotId]:</span>
    <span class="s3">''' 
    Returns the snapshot identifier. 
 
    :param tiles: An array of tiles composing the snapshot. 
    :returns: The id of the snapshot. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'tiles'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">tiles]</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.loadSnapshot'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">SnapshotId.from_json(json[</span><span class="s4">'snapshotId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">make_snapshot(</span>
        <span class="s1">layer_id: LayerId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">SnapshotId]:</span>
    <span class="s3">''' 
    Returns the layer snapshot identifier. 
 
    :param layer_id: The id of the layer. 
    :returns: The id of the layer snapshot. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'layerId'</span><span class="s1">] = layer_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.makeSnapshot'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">SnapshotId.from_json(json[</span><span class="s4">'snapshotId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">profile_snapshot(</span>
        <span class="s1">snapshot_id: SnapshotId</span><span class="s2">,</span>
        <span class="s1">min_repeat_count: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">min_duration: typing.Optional[float] = </span><span class="s2">None,</span>
        <span class="s1">clip_rect: typing.Optional[dom.Rect] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[PaintProfile]]:</span>
    <span class="s3">''' 
    :param snapshot_id: The id of the layer snapshot. 
    :param min_repeat_count: *(Optional)* The maximum number of times to replay the snapshot (1, if not specified). 
    :param min_duration: *(Optional)* The minimum duration (in seconds) to replay the snapshot. 
    :param clip_rect: *(Optional)* The clip rectangle to apply when replaying the snapshot. 
    :returns: The array of paint profiles, one per run. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'snapshotId'</span><span class="s1">] = snapshot_id.to_json()</span>
    <span class="s2">if </span><span class="s1">min_repeat_count </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'minRepeatCount'</span><span class="s1">] = min_repeat_count</span>
    <span class="s2">if </span><span class="s1">min_duration </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'minDuration'</span><span class="s1">] = min_duration</span>
    <span class="s2">if </span><span class="s1">clip_rect </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'clipRect'</span><span class="s1">] = clip_rect.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.profileSnapshot'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[PaintProfile.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'timings'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">release_snapshot(</span>
        <span class="s1">snapshot_id: SnapshotId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Releases layer snapshot captured by the back-end. 
 
    :param snapshot_id: The id of the layer snapshot. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'snapshotId'</span><span class="s1">] = snapshot_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.releaseSnapshot'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">replay_snapshot(</span>
        <span class="s1">snapshot_id: SnapshotId</span><span class="s2">,</span>
        <span class="s1">from_step: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">to_step: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">scale: typing.Optional[float] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">str]:</span>
    <span class="s3">''' 
    Replays the layer snapshot and returns the resulting bitmap. 
 
    :param snapshot_id: The id of the layer snapshot. 
    :param from_step: *(Optional)* The first step to replay from (replay from the very start if not specified). 
    :param to_step: *(Optional)* The last step to replay to (replay till the end if not specified). 
    :param scale: *(Optional)* The scale to apply while replaying (defaults to 1). 
    :returns: A data: URL for resulting image. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'snapshotId'</span><span class="s1">] = snapshot_id.to_json()</span>
    <span class="s2">if </span><span class="s1">from_step </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'fromStep'</span><span class="s1">] = from_step</span>
    <span class="s2">if </span><span class="s1">to_step </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'toStep'</span><span class="s1">] = to_step</span>
    <span class="s2">if </span><span class="s1">scale </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'scale'</span><span class="s1">] = scale</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.replaySnapshot'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">str(json[</span><span class="s4">'dataURL'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">snapshot_command_log(</span>
        <span class="s1">snapshot_id: SnapshotId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[dict]]:</span>
    <span class="s3">''' 
    Replays the layer snapshot and returns canvas log. 
 
    :param snapshot_id: The id of the layer snapshot. 
    :returns: The array of canvas function calls. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'snapshotId'</span><span class="s1">] = snapshot_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'LayerTree.snapshotCommandLog'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[dict(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'commandLog'</span><span class="s1">]]</span>


<span class="s1">@event_class(</span><span class="s4">'LayerTree.layerPainted'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">LayerPainted:</span>
    <span class="s0">#: The id of the painted layer.</span>
    <span class="s1">layer_id: LayerId</span>
    <span class="s0">#: Clip rectangle.</span>
    <span class="s1">clip: dom.Rect</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; LayerPainted:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">layer_id=LayerId.from_json(json[</span><span class="s4">'layerId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">clip=dom.Rect.from_json(json[</span><span class="s4">'clip'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'LayerTree.layerTreeDidChange'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">LayerTreeDidChange:</span>
    <span class="s0">#: Layer tree, absent if not in the comspositing mode.</span>
    <span class="s1">layers: typing.Optional[typing.List[Layer]]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; LayerTreeDidChange:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">layers=[Layer.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'layers'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'layers' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>
</pre>
</body>
</html>