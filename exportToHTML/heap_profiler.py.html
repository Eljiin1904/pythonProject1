<html>
<head>
<title>heap_profiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
heap_profiler.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: HeapProfiler (experimental)</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">runtime</span>


<span class="s2">class </span><span class="s1">HeapSnapshotObjectId(str):</span>
    <span class="s3">''' 
    Heap snapshot object id. 
    '''</span>
    <span class="s2">def </span><span class="s1">to_json(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: str) -&gt; HeapSnapshotObjectId:</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">return </span><span class="s4">'HeapSnapshotObjectId({})'</span><span class="s1">.format(super().__repr__())</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SamplingHeapProfileNode:</span>
    <span class="s3">''' 
    Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes. 
    '''</span>
    <span class="s0">#: Function location.</span>
    <span class="s1">call_frame: runtime.CallFrame</span>

    <span class="s0">#: Allocations size in bytes for the node excluding children.</span>
    <span class="s1">self_size: float</span>

    <span class="s0">#: Node id. Ids are unique across all profiles collected between startSampling and stopSampling.</span>
    <span class="s1">id_: int</span>

    <span class="s0">#: Child nodes.</span>
    <span class="s1">children: typing.List[SamplingHeapProfileNode]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'callFrame'</span><span class="s1">] = self.call_frame.to_json()</span>
        <span class="s1">json[</span><span class="s4">'selfSize'</span><span class="s1">] = self.self_size</span>
        <span class="s1">json[</span><span class="s4">'id'</span><span class="s1">] = self.id_</span>
        <span class="s1">json[</span><span class="s4">'children'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.children]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">call_frame=runtime.CallFrame.from_json(json[</span><span class="s4">'callFrame'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">self_size=float(json[</span><span class="s4">'selfSize'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">id_=int(json[</span><span class="s4">'id'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">children=[SamplingHeapProfileNode.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'children'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SamplingHeapProfileSample:</span>
    <span class="s3">''' 
    A single sample from a sampling profile. 
    '''</span>
    <span class="s0">#: Allocation size in bytes attributed to the sample.</span>
    <span class="s1">size: float</span>

    <span class="s0">#: Id of the corresponding profile tree node.</span>
    <span class="s1">node_id: int</span>

    <span class="s0">#: Time-ordered sample ordinal number. It is unique across all profiles retrieved</span>
    <span class="s0">#: between startSampling and stopSampling.</span>
    <span class="s1">ordinal: float</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'size'</span><span class="s1">] = self.size</span>
        <span class="s1">json[</span><span class="s4">'nodeId'</span><span class="s1">] = self.node_id</span>
        <span class="s1">json[</span><span class="s4">'ordinal'</span><span class="s1">] = self.ordinal</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">size=float(json[</span><span class="s4">'size'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">node_id=int(json[</span><span class="s4">'nodeId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">ordinal=float(json[</span><span class="s4">'ordinal'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SamplingHeapProfile:</span>
    <span class="s3">''' 
    Sampling profile. 
    '''</span>
    <span class="s1">head: SamplingHeapProfileNode</span>

    <span class="s1">samples: typing.List[SamplingHeapProfileSample]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'head'</span><span class="s1">] = self.head.to_json()</span>
        <span class="s1">json[</span><span class="s4">'samples'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.samples]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">head=SamplingHeapProfileNode.from_json(json[</span><span class="s4">'head'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">samples=[SamplingHeapProfileSample.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'samples'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">add_inspected_heap_object(</span>
        <span class="s1">heap_object_id: HeapSnapshotObjectId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enables console to refer to the node with given id via $x (see Command Line API for more details 
    $x functions). 
 
    :param heap_object_id: Heap snapshot object id to be accessible by means of $x command line API. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'heapObjectId'</span><span class="s1">] = heap_object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.addInspectedHeapObject'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">collect_garbage() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>

    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.collectGarbage'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">disable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>

    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.disable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">enable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>

    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.enable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_heap_object_id(</span>
        <span class="s1">object_id: runtime.RemoteObjectId</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">HeapSnapshotObjectId]:</span>
    <span class="s3">''' 
    :param object_id: Identifier of the object to get heap object id for. 
    :returns: Id of the heap snapshot object corresponding to the passed remote object id. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.getHeapObjectId'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">HeapSnapshotObjectId.from_json(json[</span><span class="s4">'heapSnapshotObjectId'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_object_by_heap_object_id(</span>
        <span class="s1">object_id: HeapSnapshotObjectId</span><span class="s2">,</span>
        <span class="s1">object_group: typing.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">runtime.RemoteObject]:</span>
    <span class="s3">''' 
    :param object_id: 
    :param object_group: *(Optional)* Symbolic group name that can be used to release multiple objects. 
    :returns: Evaluation result. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'objectId'</span><span class="s1">] = object_id.to_json()</span>
    <span class="s2">if </span><span class="s1">object_group </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'objectGroup'</span><span class="s1">] = object_group</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.getObjectByHeapObjectId'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">runtime.RemoteObject.from_json(json[</span><span class="s4">'result'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_sampling_profile() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">SamplingHeapProfile]:</span>
    <span class="s3">''' 
 
 
    :returns: Return the sampling profile being collected. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.getSamplingProfile'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">SamplingHeapProfile.from_json(json[</span><span class="s4">'profile'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">start_sampling(</span>
        <span class="s1">sampling_interval: typing.Optional[float] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    :param sampling_interval: *(Optional)* Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">sampling_interval </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'samplingInterval'</span><span class="s1">] = sampling_interval</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.startSampling'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">start_tracking_heap_objects(</span>
        <span class="s1">track_allocations: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    :param track_allocations: *(Optional)* 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">track_allocations </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'trackAllocations'</span><span class="s1">] = track_allocations</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.startTrackingHeapObjects'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">stop_sampling() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">SamplingHeapProfile]:</span>
    <span class="s3">''' 
 
 
    :returns: Recorded sampling heap profile. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.stopSampling'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">SamplingHeapProfile.from_json(json[</span><span class="s4">'profile'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">stop_tracking_heap_objects(</span>
        <span class="s1">report_progress: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">treat_global_objects_as_roots: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    :param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped. 
    :param treat_global_objects_as_roots: *(Optional)* 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">report_progress </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'reportProgress'</span><span class="s1">] = report_progress</span>
    <span class="s2">if </span><span class="s1">treat_global_objects_as_roots </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'treatGlobalObjectsAsRoots'</span><span class="s1">] = treat_global_objects_as_roots</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.stopTrackingHeapObjects'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">take_heap_snapshot(</span>
        <span class="s1">report_progress: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">treat_global_objects_as_roots: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    :param report_progress: *(Optional)* If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken. 
    :param treat_global_objects_as_roots: *(Optional)* If true, a raw snapshot without artifical roots will be generated 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">report_progress </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'reportProgress'</span><span class="s1">] = report_progress</span>
    <span class="s2">if </span><span class="s1">treat_global_objects_as_roots </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'treatGlobalObjectsAsRoots'</span><span class="s1">] = treat_global_objects_as_roots</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'HeapProfiler.takeHeapSnapshot'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s1">@event_class(</span><span class="s4">'HeapProfiler.addHeapSnapshotChunk'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">AddHeapSnapshotChunk:</span>
    <span class="s1">chunk: str</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; AddHeapSnapshotChunk:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">chunk=str(json[</span><span class="s4">'chunk'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'HeapProfiler.heapStatsUpdate'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">HeapStatsUpdate:</span>
    <span class="s3">''' 
    If heap objects tracking has been started then backend may send update for one or more fragments 
    '''</span>
    <span class="s0">#: An array of triplets. Each triplet describes a fragment. The first integer is the fragment</span>
    <span class="s0">#: index, the second integer is a total count of objects for the fragment, the third integer is</span>
    <span class="s0">#: a total size of the objects for the fragment.</span>
    <span class="s1">stats_update: typing.List[int]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; HeapStatsUpdate:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">stats_update=[int(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'statsUpdate'</span><span class="s1">]]</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'HeapProfiler.lastSeenObjectId'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">LastSeenObjectId:</span>
    <span class="s3">''' 
    If heap objects tracking has been started then backend regularly sends a current value for last 
    seen object id and corresponding timestamp. If the were changes in the heap since last event 
    then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. 
    '''</span>
    <span class="s1">last_seen_object_id: int</span>
    <span class="s1">timestamp: float</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; LastSeenObjectId:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">last_seen_object_id=int(json[</span><span class="s4">'lastSeenObjectId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">timestamp=float(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'HeapProfiler.reportHeapSnapshotProgress'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ReportHeapSnapshotProgress:</span>
    <span class="s1">done: int</span>
    <span class="s1">total: int</span>
    <span class="s1">finished: typing.Optional[bool]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ReportHeapSnapshotProgress:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">done=int(json[</span><span class="s4">'done'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">total=int(json[</span><span class="s4">'total'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">finished=bool(json[</span><span class="s4">'finished'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'finished' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'HeapProfiler.resetProfiles'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ResetProfiles:</span>


    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ResetProfiles:</span>
        <span class="s2">return </span><span class="s1">cls(</span>

        <span class="s1">)</span>
</pre>
</body>
</html>