<html>
<head>
<title>protocol.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
protocol.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
:mod:`websockets.legacy.protocol` handles WebSocket control and data frames. 
 
See `sections 4 to 8 of RFC 6455`_. 
 
.. _sections 4 to 8 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-4 
 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">asyncio</span>
<span class="s2">import </span><span class="s1">codecs</span>
<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">logging</span>
<span class="s2">import </span><span class="s1">random</span>
<span class="s2">import </span><span class="s1">struct</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">AsyncIterable</span><span class="s2">,</span>
    <span class="s1">AsyncIterator</span><span class="s2">,</span>
    <span class="s1">Awaitable</span><span class="s2">,</span>
    <span class="s1">Deque</span><span class="s2">,</span>
    <span class="s1">Dict</span><span class="s2">,</span>
    <span class="s1">Iterable</span><span class="s2">,</span>
    <span class="s1">List</span><span class="s2">,</span>
    <span class="s1">Mapping</span><span class="s2">,</span>
    <span class="s1">Optional</span><span class="s2">,</span>
    <span class="s1">Union</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">..datastructures </span><span class="s2">import </span><span class="s1">Headers</span>
<span class="s2">from </span><span class="s1">..exceptions </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ConnectionClosed</span><span class="s2">,</span>
    <span class="s1">ConnectionClosedError</span><span class="s2">,</span>
    <span class="s1">ConnectionClosedOK</span><span class="s2">,</span>
    <span class="s1">InvalidState</span><span class="s2">,</span>
    <span class="s1">PayloadTooBig</span><span class="s2">,</span>
    <span class="s1">ProtocolError</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">..extensions.base </span><span class="s2">import </span><span class="s1">Extension</span>
<span class="s2">from </span><span class="s1">..frames </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">OP_BINARY</span><span class="s2">,</span>
    <span class="s1">OP_CLOSE</span><span class="s2">,</span>
    <span class="s1">OP_CONT</span><span class="s2">,</span>
    <span class="s1">OP_PING</span><span class="s2">,</span>
    <span class="s1">OP_PONG</span><span class="s2">,</span>
    <span class="s1">OP_TEXT</span><span class="s2">,</span>
    <span class="s1">Opcode</span><span class="s2">,</span>
    <span class="s1">parse_close</span><span class="s2">,</span>
    <span class="s1">prepare_ctrl</span><span class="s2">,</span>
    <span class="s1">prepare_data</span><span class="s2">,</span>
    <span class="s1">serialize_close</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">..typing </span><span class="s2">import </span><span class="s1">Data</span><span class="s2">, </span><span class="s1">Subprotocol</span>
<span class="s2">from </span><span class="s1">.framing </span><span class="s2">import </span><span class="s1">Frame</span>


<span class="s1">__all__ = [</span><span class="s3">&quot;WebSocketCommonProtocol&quot;</span><span class="s1">]</span>

<span class="s1">logger = logging.getLogger(</span><span class="s3">&quot;websockets.protocol&quot;</span><span class="s1">)</span>


<span class="s4"># A WebSocket connection goes through the following four states, in order:</span>


<span class="s2">class </span><span class="s1">State(enum.IntEnum):</span>
    <span class="s1">CONNECTING</span><span class="s2">, </span><span class="s1">OPEN</span><span class="s2">, </span><span class="s1">CLOSING</span><span class="s2">, </span><span class="s1">CLOSED = range(</span><span class="s5">4</span><span class="s1">)</span>


<span class="s4"># In order to ensure consistency, the code always checks the current value of</span>
<span class="s4"># WebSocketCommonProtocol.state before assigning a new value and never yields</span>
<span class="s4"># between the check and the assignment.</span>


<span class="s2">class </span><span class="s1">WebSocketCommonProtocol(asyncio.Protocol):</span>
    <span class="s0">&quot;&quot;&quot; 
    :class:`~asyncio.Protocol` subclass implementing the data transfer phase. 
 
    Once the WebSocket connection is established, during the data transfer 
    phase, the protocol is almost symmetrical between the server side and the 
    client side. :class:`WebSocketCommonProtocol` implements logic that's 
    shared between servers and clients. 
 
    Subclasses such as 
    :class:`~websockets.legacy.server.WebSocketServerProtocol` and 
    :class:`~websockets.legacy.client.WebSocketClientProtocol` implement the 
    opening handshake, which is different between servers and clients. 
 
    &quot;&quot;&quot;</span>

    <span class="s4"># There are only two differences between the client-side and server-side</span>
    <span class="s4"># behavior: masking the payload and closing the underlying TCP connection.</span>
    <span class="s4"># Set is_client = True/False and side = &quot;client&quot;/&quot;server&quot; to pick a side.</span>
    <span class="s1">is_client: bool</span>
    <span class="s1">side: str = </span><span class="s3">&quot;undefined&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">ping_interval: Optional[float] = </span><span class="s5">20</span><span class="s2">,</span>
        <span class="s1">ping_timeout: Optional[float] = </span><span class="s5">20</span><span class="s2">,</span>
        <span class="s1">close_timeout: Optional[float] = </span><span class="s2">None,</span>
        <span class="s1">max_size: Optional[int] = </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">20</span><span class="s2">,</span>
        <span class="s1">max_queue: Optional[int] = </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">5</span><span class="s2">,</span>
        <span class="s1">read_limit: int = </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">16</span><span class="s2">,</span>
        <span class="s1">write_limit: int = </span><span class="s5">2 </span><span class="s1">** </span><span class="s5">16</span><span class="s2">,</span>
        <span class="s1">loop: Optional[asyncio.AbstractEventLoop] = </span><span class="s2">None,</span>
        <span class="s4"># The following arguments are kept only for backwards compatibility.</span>
        <span class="s1">host: Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">port: Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">secure: Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">legacy_recv: bool = </span><span class="s2">False,</span>
        <span class="s1">timeout: Optional[float] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4"># Backwards compatibility: close_timeout used to be called timeout.</span>
        <span class="s2">if </span><span class="s1">timeout </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">timeout = </span><span class="s5">10</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s3">&quot;rename timeout to close_timeout&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
        <span class="s4"># If both are specified, timeout is ignored.</span>
        <span class="s2">if </span><span class="s1">close_timeout </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">close_timeout = timeout</span>

        <span class="s1">self.ping_interval = ping_interval</span>
        <span class="s1">self.ping_timeout = ping_timeout</span>
        <span class="s1">self.close_timeout = close_timeout</span>
        <span class="s1">self.max_size = max_size</span>
        <span class="s1">self.max_queue = max_queue</span>
        <span class="s1">self.read_limit = read_limit</span>
        <span class="s1">self.write_limit = write_limit</span>

        <span class="s2">if </span><span class="s1">loop </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">loop = asyncio.get_event_loop()</span>
        <span class="s1">self.loop = loop</span>

        <span class="s1">self._host = host</span>
        <span class="s1">self._port = port</span>
        <span class="s1">self._secure = secure</span>
        <span class="s1">self.legacy_recv = legacy_recv</span>

        <span class="s4"># Configure read buffer limits. The high-water limit is defined by</span>
        <span class="s4"># ``self.read_limit``. The ``limit`` argument controls the line length</span>
        <span class="s4"># limit and half the buffer limit of :class:`~asyncio.StreamReader`.</span>
        <span class="s4"># That's why it must be set to half of ``self.read_limit``.</span>
        <span class="s1">self.reader = asyncio.StreamReader(limit=read_limit // </span><span class="s5">2</span><span class="s2">, </span><span class="s1">loop=loop)</span>

        <span class="s4"># Copied from asyncio.FlowControlMixin</span>
        <span class="s1">self._paused = </span><span class="s2">False</span>
        <span class="s1">self._drain_waiter: Optional[asyncio.Future[</span><span class="s2">None</span><span class="s1">]] = </span><span class="s2">None</span>

        <span class="s1">self._drain_lock = asyncio.Lock(</span>
            <span class="s1">loop=loop </span><span class="s2">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">) </span><span class="s2">else None</span>
        <span class="s1">)</span>

        <span class="s4"># This class implements the data transfer and closing handshake, which</span>
        <span class="s4"># are shared between the client-side and the server-side.</span>
        <span class="s4"># Subclasses implement the opening handshake and, on success, execute</span>
        <span class="s4"># :meth:`connection_open` to change the state to OPEN.</span>
        <span class="s1">self.state = State.CONNECTING</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s - state = CONNECTING&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>

        <span class="s4"># HTTP protocol parameters.</span>
        <span class="s1">self.path: str</span>
        <span class="s1">self.request_headers: Headers</span>
        <span class="s1">self.response_headers: Headers</span>

        <span class="s4"># WebSocket protocol parameters.</span>
        <span class="s1">self.extensions: List[Extension] = []</span>
        <span class="s1">self.subprotocol: Optional[Subprotocol] = </span><span class="s2">None</span>

        <span class="s4"># The close code and reason are set when receiving a close frame or</span>
        <span class="s4"># losing the TCP connection.</span>
        <span class="s1">self.close_code: int</span>
        <span class="s1">self.close_reason: str</span>

        <span class="s4"># Completed when the connection state becomes CLOSED. Translates the</span>
        <span class="s4"># :meth:`connection_lost` callback to a :class:`~asyncio.Future`</span>
        <span class="s4"># that can be awaited. (Other :class:`~asyncio.Protocol` callbacks are</span>
        <span class="s4"># translated by ``self.stream_reader``).</span>
        <span class="s1">self.connection_lost_waiter: asyncio.Future[</span><span class="s2">None</span><span class="s1">] = loop.create_future()</span>

        <span class="s4"># Queue of received messages.</span>
        <span class="s1">self.messages: Deque[Data] = collections.deque()</span>
        <span class="s1">self._pop_message_waiter: Optional[asyncio.Future[</span><span class="s2">None</span><span class="s1">]] = </span><span class="s2">None</span>
        <span class="s1">self._put_message_waiter: Optional[asyncio.Future[</span><span class="s2">None</span><span class="s1">]] = </span><span class="s2">None</span>

        <span class="s4"># Protect sending fragmented messages.</span>
        <span class="s1">self._fragmented_message_waiter: Optional[asyncio.Future[</span><span class="s2">None</span><span class="s1">]] = </span><span class="s2">None</span>

        <span class="s4"># Mapping of ping IDs to pong waiters, in chronological order.</span>
        <span class="s1">self.pings: Dict[bytes</span><span class="s2">, </span><span class="s1">asyncio.Future[</span><span class="s2">None</span><span class="s1">]] = {}</span>

        <span class="s4"># Task running the data transfer.</span>
        <span class="s1">self.transfer_data_task: asyncio.Task[</span><span class="s2">None</span><span class="s1">]</span>

        <span class="s4"># Exception that occurred during data transfer, if any.</span>
        <span class="s1">self.transfer_data_exc: Optional[BaseException] = </span><span class="s2">None</span>

        <span class="s4"># Task sending keepalive pings.</span>
        <span class="s1">self.keepalive_ping_task: asyncio.Task[</span><span class="s2">None</span><span class="s1">]</span>

        <span class="s4"># Task closing the TCP connection.</span>
        <span class="s1">self.close_connection_task: asyncio.Task[</span><span class="s2">None</span><span class="s1">]</span>

    <span class="s4"># Copied from asyncio.FlowControlMixin</span>
    <span class="s2">async def </span><span class="s1">_drain_helper(self) -&gt; </span><span class="s2">None</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s2">if </span><span class="s1">self.connection_lost_waiter.done():</span>
            <span class="s2">raise </span><span class="s1">ConnectionResetError(</span><span class="s3">&quot;Connection lost&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">self._paused:</span>
            <span class="s2">return</span>
        <span class="s1">waiter = self._drain_waiter</span>
        <span class="s2">assert </span><span class="s1">waiter </span><span class="s2">is None or </span><span class="s1">waiter.cancelled()</span>
        <span class="s1">waiter = self.loop.create_future()</span>
        <span class="s1">self._drain_waiter = waiter</span>
        <span class="s2">await </span><span class="s1">waiter</span>

    <span class="s4"># Copied from asyncio.StreamWriter</span>
    <span class="s2">async def </span><span class="s1">_drain(self) -&gt; </span><span class="s2">None</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s2">if </span><span class="s1">self.reader </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">exc = self.reader.exception()</span>
            <span class="s2">if </span><span class="s1">exc </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">exc</span>
        <span class="s2">if </span><span class="s1">self.transport </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.transport.is_closing():</span>
                <span class="s4"># Yield to the event loop so connection_lost() may be</span>
                <span class="s4"># called.  Without this, _drain_helper() would return</span>
                <span class="s4"># immediately, and code that calls</span>
                <span class="s4">#     write(...); yield from drain()</span>
                <span class="s4"># in a loop would never call connection_lost(), so it</span>
                <span class="s4"># would not see an error when the socket is closed.</span>
                <span class="s2">await </span><span class="s1">asyncio.sleep(</span>
                    <span class="s5">0</span><span class="s2">, </span><span class="s1">loop=self.loop </span><span class="s2">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">) </span><span class="s2">else None</span>
                <span class="s1">)</span>
        <span class="s2">await </span><span class="s1">self._drain_helper()</span>

    <span class="s2">def </span><span class="s1">connection_open(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Callback when the WebSocket opening handshake completes. 
 
        Enter the OPEN state and start the data transfer phase. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># 4.1. The WebSocket Connection is Established.</span>
        <span class="s2">assert </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.CONNECTING</span>
        <span class="s1">self.state = State.OPEN</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s - state = OPEN&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>
        <span class="s4"># Start the task that receives incoming WebSocket messages.</span>
        <span class="s1">self.transfer_data_task = self.loop.create_task(self.transfer_data())</span>
        <span class="s4"># Start the task that sends pings at regular intervals.</span>
        <span class="s1">self.keepalive_ping_task = self.loop.create_task(self.keepalive_ping())</span>
        <span class="s4"># Start the task that eventually closes the TCP connection.</span>
        <span class="s1">self.close_connection_task = self.loop.create_task(self.close_connection())</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">host(self) -&gt; Optional[str]:</span>
        <span class="s1">alternative = </span><span class="s3">&quot;remote_address&quot; </span><span class="s2">if </span><span class="s1">self.is_client </span><span class="s2">else </span><span class="s3">&quot;local_address&quot;</span>
        <span class="s1">warnings.warn(</span><span class="s3">f&quot;use </span><span class="s2">{</span><span class="s1">alternative</span><span class="s2">}</span><span class="s3">[0] instead of host&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
        <span class="s2">return </span><span class="s1">self._host</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">port(self) -&gt; Optional[int]:</span>
        <span class="s1">alternative = </span><span class="s3">&quot;remote_address&quot; </span><span class="s2">if </span><span class="s1">self.is_client </span><span class="s2">else </span><span class="s3">&quot;local_address&quot;</span>
        <span class="s1">warnings.warn(</span><span class="s3">f&quot;use </span><span class="s2">{</span><span class="s1">alternative</span><span class="s2">}</span><span class="s3">[1] instead of port&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
        <span class="s2">return </span><span class="s1">self._port</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">secure(self) -&gt; Optional[bool]:</span>
        <span class="s1">warnings.warn(</span><span class="s3">&quot;don't use secure&quot;</span><span class="s2">, </span><span class="s1">DeprecationWarning)</span>
        <span class="s2">return </span><span class="s1">self._secure</span>

    <span class="s4"># Public API</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">local_address(self) -&gt; Any:</span>
        <span class="s0">&quot;&quot;&quot; 
        Local address of the connection as a ``(host, port)`` tuple. 
 
        When the connection isn't open, ``local_address`` is ``None``. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">transport = self.transport</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">return None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">transport.get_extra_info(</span><span class="s3">&quot;sockname&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">remote_address(self) -&gt; Any:</span>
        <span class="s0">&quot;&quot;&quot; 
        Remote address of the connection as a ``(host, port)`` tuple. 
 
        When the connection isn't open, ``remote_address`` is ``None``. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">transport = self.transport</span>
        <span class="s2">except </span><span class="s1">AttributeError:</span>
            <span class="s2">return None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">transport.get_extra_info(</span><span class="s3">&quot;peername&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">open(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        ``True`` when the connection is usable. 
 
        It may be used to detect disconnections. However, this approach is 
        discouraged per the EAFP_ principle. 
 
        When ``open`` is ``False``, using the connection raises a 
        :exc:`~websockets.exceptions.ConnectionClosed` exception. 
 
        .. _EAFP: https://docs.python.org/3/glossary.html#term-eafp 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.OPEN </span><span class="s2">and not </span><span class="s1">self.transfer_data_task.done()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">closed(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        ``True`` once the connection is closed. 
 
        Be aware that both :attr:`open` and :attr:`closed` are ``False`` during 
        the opening and closing sequences. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.CLOSED</span>

    <span class="s2">async def </span><span class="s1">wait_closed(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Wait until the connection is closed. 
 
        This is identical to :attr:`closed`, except it can be awaited. 
 
        This can make it easier to handle connection termination, regardless 
        of its cause, in tasks that interact with the WebSocket connection. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">await </span><span class="s1">asyncio.shield(self.connection_lost_waiter)</span>

    <span class="s2">async def </span><span class="s1">__aiter__(self) -&gt; AsyncIterator[Data]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Iterate on received messages. 
 
        Exit normally when the connection is closed with code 1000 or 1001. 
 
        Raise an exception in other cases. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s2">yield await </span><span class="s1">self.recv()</span>
        <span class="s2">except </span><span class="s1">ConnectionClosedOK:</span>
            <span class="s2">return</span>

    <span class="s2">async def </span><span class="s1">recv(self) -&gt; Data:</span>
        <span class="s0">&quot;&quot;&quot; 
        Receive the next message. 
 
        Return a :class:`str` for a text frame and :class:`bytes` for a binary 
        frame. 
 
        When the end of the message stream is reached, :meth:`recv` raises 
        :exc:`~websockets.exceptions.ConnectionClosed`. Specifically, it 
        raises :exc:`~websockets.exceptions.ConnectionClosedOK` after a normal 
        connection closure and 
        :exc:`~websockets.exceptions.ConnectionClosedError` after a protocol 
        error or a network failure. 
 
        Canceling :meth:`recv` is safe. There's no risk of losing the next 
        message. The next invocation of :meth:`recv` will return it. This 
        makes it possible to enforce a timeout by wrapping :meth:`recv` in 
        :func:`~asyncio.wait_for`. 
 
        :raises ~websockets.exceptions.ConnectionClosed: when the 
            connection is closed 
        :raises RuntimeError: if two coroutines call :meth:`recv` concurrently 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._pop_message_waiter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span>
                <span class="s3">&quot;cannot call recv while another coroutine &quot;</span>
                <span class="s3">&quot;is already waiting for the next message&quot;</span>
            <span class="s1">)</span>

        <span class="s4"># Don't await self.ensure_open() here:</span>
        <span class="s4"># - messages could be available in the queue even if the connection</span>
        <span class="s4">#   is closed;</span>
        <span class="s4"># - messages could be received before the closing frame even if the</span>
        <span class="s4">#   connection is closing.</span>

        <span class="s4"># Wait until there's a message in the queue (if necessary) or the</span>
        <span class="s4"># connection is closed.</span>
        <span class="s2">while </span><span class="s1">len(self.messages) &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">pop_message_waiter: asyncio.Future[</span><span class="s2">None</span><span class="s1">] = self.loop.create_future()</span>
            <span class="s1">self._pop_message_waiter = pop_message_waiter</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># If asyncio.wait() is canceled, it doesn't cancel</span>
                <span class="s4"># pop_message_waiter and self.transfer_data_task.</span>
                <span class="s2">await </span><span class="s1">asyncio.wait(</span>
                    <span class="s1">[pop_message_waiter</span><span class="s2">, </span><span class="s1">self.transfer_data_task]</span><span class="s2">,</span>
                    <span class="s1">loop=self.loop </span><span class="s2">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">) </span><span class="s2">else None,</span>
                    <span class="s1">return_when=asyncio.FIRST_COMPLETED</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">self._pop_message_waiter = </span><span class="s2">None</span>

            <span class="s4"># If asyncio.wait(...) exited because self.transfer_data_task</span>
            <span class="s4"># completed before receiving a new message, raise a suitable</span>
            <span class="s4"># exception (or return None if legacy_recv is enabled).</span>
            <span class="s2">if not </span><span class="s1">pop_message_waiter.done():</span>
                <span class="s2">if </span><span class="s1">self.legacy_recv:</span>
                    <span class="s2">return None  </span><span class="s4"># type: ignore</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s4"># Wait until the connection is closed to raise</span>
                    <span class="s4"># ConnectionClosed with the correct code and reason.</span>
                    <span class="s2">await </span><span class="s1">self.ensure_open()</span>

        <span class="s4"># Pop a message from the queue.</span>
        <span class="s1">message = self.messages.popleft()</span>

        <span class="s4"># Notify transfer_data().</span>
        <span class="s2">if </span><span class="s1">self._put_message_waiter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._put_message_waiter.set_result(</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s1">self._put_message_waiter = </span><span class="s2">None</span>

        <span class="s2">return </span><span class="s1">message</span>

    <span class="s2">async def </span><span class="s1">send(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">message: Union[Data</span><span class="s2">, </span><span class="s1">Iterable[Data]</span><span class="s2">, </span><span class="s1">AsyncIterable[Data]]</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Send a message. 
 
        A string (:class:`str`) is sent as a `Text frame`_. A bytestring or 
        bytes-like object (:class:`bytes`, :class:`bytearray`, or 
        :class:`memoryview`) is sent as a `Binary frame`_. 
 
        .. _Text frame: https://tools.ietf.org/html/rfc6455#section-5.6 
        .. _Binary frame: https://tools.ietf.org/html/rfc6455#section-5.6 
 
        :meth:`send` also accepts an iterable or an asynchronous iterable of 
        strings, bytestrings, or bytes-like objects. In that case the message 
        is fragmented. Each item is treated as a message fragment and sent in 
        its own frame. All items must be of the same type, or else 
        :meth:`send` will raise a :exc:`TypeError` and the connection will be 
        closed. 
 
        :meth:`send` rejects dict-like objects because this is often an error. 
        If you wish to send the keys of a dict-like object as fragments, call 
        its :meth:`~dict.keys` method and pass the result to :meth:`send`. 
 
        Canceling :meth:`send` is discouraged. Instead, you should close the 
        connection with :meth:`close`. Indeed, there are only two situations 
        where :meth:`send` may yield control to the event loop: 
 
        1. The write buffer is full. If you don't want to wait until enough 
           data is sent, your only alternative is to close the connection. 
           :meth:`close` will likely time out then abort the TCP connection. 
        2. ``message`` is an asynchronous iterator that yields control. 
           Stopping in the middle of a fragmented message will cause a 
           protocol error. Closing the connection has the same effect. 
 
        :raises TypeError: for unsupported inputs 
 
        &quot;&quot;&quot;</span>
        <span class="s2">await </span><span class="s1">self.ensure_open()</span>

        <span class="s4"># While sending a fragmented message, prevent sending other messages</span>
        <span class="s4"># until all fragments are sent.</span>
        <span class="s2">while </span><span class="s1">self._fragmented_message_waiter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">await </span><span class="s1">asyncio.shield(self._fragmented_message_waiter)</span>

        <span class="s4"># Unfragmented message -- this case must be handled first because</span>
        <span class="s4"># strings and bytes-like objects are iterable.</span>

        <span class="s2">if </span><span class="s1">isinstance(message</span><span class="s2">, </span><span class="s1">(str</span><span class="s2">, </span><span class="s1">bytes</span><span class="s2">, </span><span class="s1">bytearray</span><span class="s2">, </span><span class="s1">memoryview)):</span>
            <span class="s1">opcode</span><span class="s2">, </span><span class="s1">data = prepare_data(message)</span>
            <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">True, </span><span class="s1">opcode</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s4"># Catch a common mistake -- passing a dict to send().</span>

        <span class="s2">elif </span><span class="s1">isinstance(message</span><span class="s2">, </span><span class="s1">Mapping):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;data is a dict-like object&quot;</span><span class="s1">)</span>

        <span class="s4"># Fragmented message -- regular iterator.</span>

        <span class="s2">elif </span><span class="s1">isinstance(message</span><span class="s2">, </span><span class="s1">Iterable):</span>

            <span class="s4"># Work around https://github.com/python/mypy/issues/6227</span>
            <span class="s1">message = cast(Iterable[Data]</span><span class="s2">, </span><span class="s1">message)</span>

            <span class="s1">iter_message = iter(message)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">message_chunk = next(iter_message)</span>
            <span class="s2">except </span><span class="s1">StopIteration:</span>
                <span class="s2">return</span>
            <span class="s1">opcode</span><span class="s2">, </span><span class="s1">data = prepare_data(message_chunk)</span>

            <span class="s1">self._fragmented_message_waiter = asyncio.Future()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># First fragment.</span>
                <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">False, </span><span class="s1">opcode</span><span class="s2">, </span><span class="s1">data)</span>

                <span class="s4"># Other fragments.</span>
                <span class="s2">for </span><span class="s1">message_chunk </span><span class="s2">in </span><span class="s1">iter_message:</span>
                    <span class="s1">confirm_opcode</span><span class="s2">, </span><span class="s1">data = prepare_data(message_chunk)</span>
                    <span class="s2">if </span><span class="s1">confirm_opcode != opcode:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;data contains inconsistent types&quot;</span><span class="s1">)</span>
                    <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">False, </span><span class="s1">OP_CONT</span><span class="s2">, </span><span class="s1">data)</span>

                <span class="s4"># Final fragment.</span>
                <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">True, </span><span class="s1">OP_CONT</span><span class="s2">, </span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>

            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s4"># We're half-way through a fragmented message and we can't</span>
                <span class="s4"># complete it. This makes the connection unusable.</span>
                <span class="s1">self.fail_connection(</span><span class="s5">1011</span><span class="s1">)</span>
                <span class="s2">raise</span>

            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">self._fragmented_message_waiter.set_result(</span><span class="s2">None</span><span class="s1">)</span>
                <span class="s1">self._fragmented_message_waiter = </span><span class="s2">None</span>

        <span class="s4"># Fragmented message -- asynchronous iterator</span>

        <span class="s2">elif </span><span class="s1">isinstance(message</span><span class="s2">, </span><span class="s1">AsyncIterable):</span>
            <span class="s4"># aiter_message = aiter(message) without aiter</span>
            <span class="s4"># https://github.com/python/mypy/issues/5738</span>
            <span class="s1">aiter_message = type(message).__aiter__(message)  </span><span class="s4"># type: ignore</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># message_chunk = anext(aiter_message) without anext</span>
                <span class="s4"># https://github.com/python/mypy/issues/5738</span>
                <span class="s1">message_chunk = </span><span class="s2">await </span><span class="s1">type(aiter_message).__anext__(  </span><span class="s4"># type: ignore</span>
                    <span class="s1">aiter_message</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">StopAsyncIteration:</span>
                <span class="s2">return</span>
            <span class="s1">opcode</span><span class="s2">, </span><span class="s1">data = prepare_data(message_chunk)</span>

            <span class="s1">self._fragmented_message_waiter = asyncio.Future()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s4"># First fragment.</span>
                <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">False, </span><span class="s1">opcode</span><span class="s2">, </span><span class="s1">data)</span>

                <span class="s4"># Other fragments.</span>
                <span class="s4"># https://github.com/python/mypy/issues/5738</span>
                <span class="s4"># coverage reports this code as not covered, but it is</span>
                <span class="s4"># exercised by tests - changing it breaks the tests!</span>
                <span class="s2">async for </span><span class="s1">message_chunk </span><span class="s2">in </span><span class="s1">aiter_message:  </span><span class="s4"># type: ignore  # pragma: no cover  # noqa</span>
                    <span class="s1">confirm_opcode</span><span class="s2">, </span><span class="s1">data = prepare_data(message_chunk)</span>
                    <span class="s2">if </span><span class="s1">confirm_opcode != opcode:</span>
                        <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;data contains inconsistent types&quot;</span><span class="s1">)</span>
                    <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">False, </span><span class="s1">OP_CONT</span><span class="s2">, </span><span class="s1">data)</span>

                <span class="s4"># Final fragment.</span>
                <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">True, </span><span class="s1">OP_CONT</span><span class="s2">, </span><span class="s6">b&quot;&quot;</span><span class="s1">)</span>

            <span class="s2">except </span><span class="s1">Exception:</span>
                <span class="s4"># We're half-way through a fragmented message and we can't</span>
                <span class="s4"># complete it. This makes the connection unusable.</span>
                <span class="s1">self.fail_connection(</span><span class="s5">1011</span><span class="s1">)</span>
                <span class="s2">raise</span>

            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s1">self._fragmented_message_waiter.set_result(</span><span class="s2">None</span><span class="s1">)</span>
                <span class="s1">self._fragmented_message_waiter = </span><span class="s2">None</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;data must be bytes, str, or iterable&quot;</span><span class="s1">)</span>

    <span class="s2">async def </span><span class="s1">close(self</span><span class="s2">, </span><span class="s1">code: int = </span><span class="s5">1000</span><span class="s2">, </span><span class="s1">reason: str = </span><span class="s3">&quot;&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Perform the closing handshake. 
 
        :meth:`close` waits for the other end to complete the handshake and 
        for the TCP connection to terminate. As a consequence, there's no need 
        to await :meth:`wait_closed`; :meth:`close` already does it. 
 
        :meth:`close` is idempotent: it doesn't do anything once the 
        connection is closed. 
 
        Wrapping :func:`close` in :func:`~asyncio.create_task` is safe, given 
        that errors during connection termination aren't particularly useful. 
 
        Canceling :meth:`close` is discouraged. If it takes too long, you can 
        set a shorter ``close_timeout``. If you don't want to wait, let the 
        Python process exit, then the OS will close the TCP connection. 
 
        :param code: WebSocket close code 
        :param reason: WebSocket close reason 
 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">await </span><span class="s1">asyncio.wait_for(</span>
                <span class="s1">self.write_close_frame(serialize_close(code</span><span class="s2">, </span><span class="s1">reason))</span><span class="s2">,</span>
                <span class="s1">self.close_timeout</span><span class="s2">,</span>
                <span class="s1">loop=self.loop </span><span class="s2">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">) </span><span class="s2">else None,</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">asyncio.TimeoutError:</span>
            <span class="s4"># If the close frame cannot be sent because the send buffers</span>
            <span class="s4"># are full, the closing handshake won't complete anyway.</span>
            <span class="s4"># Fail the connection to shut down faster.</span>
            <span class="s1">self.fail_connection()</span>

        <span class="s4"># If no close frame is received within the timeout, wait_for() cancels</span>
        <span class="s4"># the data transfer task and raises TimeoutError.</span>

        <span class="s4"># If close() is called multiple times concurrently and one of these</span>
        <span class="s4"># calls hits the timeout, the data transfer task will be cancelled.</span>
        <span class="s4"># Other calls will receive a CancelledError here.</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s4"># If close() is canceled during the wait, self.transfer_data_task</span>
            <span class="s4"># is canceled before the timeout elapses.</span>
            <span class="s2">await </span><span class="s1">asyncio.wait_for(</span>
                <span class="s1">self.transfer_data_task</span><span class="s2">,</span>
                <span class="s1">self.close_timeout</span><span class="s2">,</span>
                <span class="s1">loop=self.loop </span><span class="s2">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">) </span><span class="s2">else None,</span>
            <span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(asyncio.TimeoutError</span><span class="s2">, </span><span class="s1">asyncio.CancelledError):</span>
            <span class="s2">pass</span>

        <span class="s4"># Wait for the close connection task to close the TCP connection.</span>
        <span class="s2">await </span><span class="s1">asyncio.shield(self.close_connection_task)</span>

    <span class="s2">async def </span><span class="s1">ping(self</span><span class="s2">, </span><span class="s1">data: Optional[Data] = </span><span class="s2">None</span><span class="s1">) -&gt; Awaitable[</span><span class="s2">None</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Send a ping. 
 
        Return a :class:`~asyncio.Future` that will be completed when the 
        corresponding pong is received. You can ignore it if you don't intend 
        to wait. 
 
        A ping may serve as a keepalive or as a check that the remote endpoint 
        received all messages up to this point:: 
 
            pong_waiter = await ws.ping() 
            await pong_waiter  # only if you want to wait for the pong 
 
        By default, the ping contains four random bytes. This payload may be 
        overridden with the optional ``data`` argument which must be a string 
        (which will be encoded to UTF-8) or a bytes-like object. 
 
        Canceling :meth:`ping` is discouraged. If :meth:`ping` doesn't return 
        immediately, it means the write buffer is full. If you don't want to 
        wait, you should close the connection. 
 
        Canceling the :class:`~asyncio.Future` returned by :meth:`ping` has no 
        effect. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">await </span><span class="s1">self.ensure_open()</span>

        <span class="s2">if </span><span class="s1">data </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">data = prepare_ctrl(data)</span>

        <span class="s4"># Protect against duplicates if a payload is explicitly set.</span>
        <span class="s2">if </span><span class="s1">data </span><span class="s2">in </span><span class="s1">self.pings:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;already waiting for a pong with the same data&quot;</span><span class="s1">)</span>

        <span class="s4"># Generate a unique random payload otherwise.</span>
        <span class="s2">while </span><span class="s1">data </span><span class="s2">is None or </span><span class="s1">data </span><span class="s2">in </span><span class="s1">self.pings:</span>
            <span class="s1">data = struct.pack(</span><span class="s3">&quot;!I&quot;</span><span class="s2">, </span><span class="s1">random.getrandbits(</span><span class="s5">32</span><span class="s1">))</span>

        <span class="s1">self.pings[data] = self.loop.create_future()</span>

        <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">True, </span><span class="s1">OP_PING</span><span class="s2">, </span><span class="s1">data)</span>

        <span class="s2">return </span><span class="s1">asyncio.shield(self.pings[data])</span>

    <span class="s2">async def </span><span class="s1">pong(self</span><span class="s2">, </span><span class="s1">data: Data = </span><span class="s6">b&quot;&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Send a pong. 
 
        An unsolicited pong may serve as a unidirectional heartbeat. 
 
        The payload may be set with the optional ``data`` argument which must 
        be a string (which will be encoded to UTF-8) or a bytes-like object. 
 
        Canceling :meth:`pong` is discouraged for the same reason as 
        :meth:`ping`. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">await </span><span class="s1">self.ensure_open()</span>

        <span class="s1">data = prepare_ctrl(data)</span>

        <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">True, </span><span class="s1">OP_PONG</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s4"># Private methods - no guarantees.</span>

    <span class="s2">def </span><span class="s1">connection_closed_exc(self) -&gt; ConnectionClosed:</span>
        <span class="s1">exception: ConnectionClosed</span>
        <span class="s2">if </span><span class="s1">self.close_code == </span><span class="s5">1000 </span><span class="s2">or </span><span class="s1">self.close_code == </span><span class="s5">1001</span><span class="s1">:</span>
            <span class="s1">exception = ConnectionClosedOK(self.close_code</span><span class="s2">, </span><span class="s1">self.close_reason)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">exception = ConnectionClosedError(self.close_code</span><span class="s2">, </span><span class="s1">self.close_reason)</span>
        <span class="s4"># Chain to the exception that terminated data transfer, if any.</span>
        <span class="s1">exception.__cause__ = self.transfer_data_exc</span>
        <span class="s2">return </span><span class="s1">exception</span>

    <span class="s2">async def </span><span class="s1">ensure_open(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Check that the WebSocket connection is open. 
 
        Raise :exc:`~websockets.exceptions.ConnectionClosed` if it isn't. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># Handle cases from most common to least common for performance.</span>
        <span class="s2">if </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.OPEN:</span>
            <span class="s4"># If self.transfer_data_task exited without a closing handshake,</span>
            <span class="s4"># self.close_connection_task may be closing the connection, going</span>
            <span class="s4"># straight from OPEN to CLOSED.</span>
            <span class="s2">if </span><span class="s1">self.transfer_data_task.done():</span>
                <span class="s2">await </span><span class="s1">asyncio.shield(self.close_connection_task)</span>
                <span class="s2">raise </span><span class="s1">self.connection_closed_exc()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.CLOSED:</span>
            <span class="s2">raise </span><span class="s1">self.connection_closed_exc()</span>

        <span class="s2">if </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.CLOSING:</span>
            <span class="s4"># If we started the closing handshake, wait for its completion to</span>
            <span class="s4"># get the proper close code and reason. self.close_connection_task</span>
            <span class="s4"># will complete within 4 or 5 * close_timeout after close(). The</span>
            <span class="s4"># CLOSING state also occurs when failing the connection. In that</span>
            <span class="s4"># case self.close_connection_task will complete even faster.</span>
            <span class="s2">await </span><span class="s1">asyncio.shield(self.close_connection_task)</span>
            <span class="s2">raise </span><span class="s1">self.connection_closed_exc()</span>

        <span class="s4"># Control may only reach this point in buggy third-party subclasses.</span>
        <span class="s2">assert </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.CONNECTING</span>
        <span class="s2">raise </span><span class="s1">InvalidState(</span><span class="s3">&quot;WebSocket connection isn't established yet&quot;</span><span class="s1">)</span>

    <span class="s2">async def </span><span class="s1">transfer_data(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Read incoming messages and put them in a queue. 
 
        This coroutine runs in a task until the closing handshake is started. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s1">message = </span><span class="s2">await </span><span class="s1">self.read_message()</span>

                <span class="s4"># Exit the loop when receiving a close frame.</span>
                <span class="s2">if </span><span class="s1">message </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">break</span>

                <span class="s4"># Wait until there's room in the queue (if necessary).</span>
                <span class="s2">if </span><span class="s1">self.max_queue </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">while </span><span class="s1">len(self.messages) &gt;= self.max_queue:</span>
                        <span class="s1">self._put_message_waiter = self.loop.create_future()</span>
                        <span class="s2">try</span><span class="s1">:</span>
                            <span class="s2">await </span><span class="s1">asyncio.shield(self._put_message_waiter)</span>
                        <span class="s2">finally</span><span class="s1">:</span>
                            <span class="s1">self._put_message_waiter = </span><span class="s2">None</span>

                <span class="s4"># Put the message in the queue.</span>
                <span class="s1">self.messages.append(message)</span>

                <span class="s4"># Notify recv().</span>
                <span class="s2">if </span><span class="s1">self._pop_message_waiter </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">self._pop_message_waiter.set_result(</span><span class="s2">None</span><span class="s1">)</span>
                    <span class="s1">self._pop_message_waiter = </span><span class="s2">None</span>

        <span class="s2">except </span><span class="s1">asyncio.CancelledError </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">self.transfer_data_exc = exc</span>
            <span class="s4"># If fail_connection() cancels this task, avoid logging the error</span>
            <span class="s4"># twice and failing the connection again.</span>
            <span class="s2">raise</span>

        <span class="s2">except </span><span class="s1">ProtocolError </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">self.transfer_data_exc = exc</span>
            <span class="s1">self.fail_connection(</span><span class="s5">1002</span><span class="s1">)</span>

        <span class="s2">except </span><span class="s1">(ConnectionError</span><span class="s2">, </span><span class="s1">TimeoutError</span><span class="s2">, </span><span class="s1">EOFError) </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s4"># Reading data with self.reader.readexactly may raise:</span>
            <span class="s4"># - most subclasses of ConnectionError if the TCP connection</span>
            <span class="s4">#   breaks, is reset, or is aborted;</span>
            <span class="s4"># - TimeoutError if the TCP connection times out;</span>
            <span class="s4"># - IncompleteReadError, a subclass of EOFError, if fewer</span>
            <span class="s4">#   bytes are available than requested.</span>
            <span class="s1">self.transfer_data_exc = exc</span>
            <span class="s1">self.fail_connection(</span><span class="s5">1006</span><span class="s1">)</span>

        <span class="s2">except </span><span class="s1">UnicodeDecodeError </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">self.transfer_data_exc = exc</span>
            <span class="s1">self.fail_connection(</span><span class="s5">1007</span><span class="s1">)</span>

        <span class="s2">except </span><span class="s1">PayloadTooBig </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s1">self.transfer_data_exc = exc</span>
            <span class="s1">self.fail_connection(</span><span class="s5">1009</span><span class="s1">)</span>

        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
            <span class="s4"># This shouldn't happen often because exceptions expected under</span>
            <span class="s4"># regular circumstances are handled above. If it does, consider</span>
            <span class="s4"># catching and handling more exceptions.</span>
            <span class="s1">logger.error(</span><span class="s3">&quot;Error in data transfer&quot;</span><span class="s2">, </span><span class="s1">exc_info=</span><span class="s2">True</span><span class="s1">)</span>

            <span class="s1">self.transfer_data_exc = exc</span>
            <span class="s1">self.fail_connection(</span><span class="s5">1011</span><span class="s1">)</span>

    <span class="s2">async def </span><span class="s1">read_message(self) -&gt; Optional[Data]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Read a single message from the connection. 
 
        Re-assemble data frames if the message is fragmented. 
 
        Return ``None`` when the closing handshake is started. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">frame = </span><span class="s2">await </span><span class="s1">self.read_data_frame(max_size=self.max_size)</span>

        <span class="s4"># A close frame was received.</span>
        <span class="s2">if </span><span class="s1">frame </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>

        <span class="s2">if </span><span class="s1">frame.opcode == OP_TEXT:</span>
            <span class="s1">text = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">frame.opcode == OP_BINARY:</span>
            <span class="s1">text = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s4"># frame.opcode == OP_CONT</span>
            <span class="s2">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;unexpected opcode&quot;</span><span class="s1">)</span>

        <span class="s4"># Shortcut for the common case - no fragmentation</span>
        <span class="s2">if </span><span class="s1">frame.fin:</span>
            <span class="s2">return </span><span class="s1">frame.data.decode(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s2">if </span><span class="s1">text </span><span class="s2">else </span><span class="s1">frame.data</span>

        <span class="s4"># 5.4. Fragmentation</span>
        <span class="s1">chunks: List[Data] = []</span>
        <span class="s1">max_size = self.max_size</span>
        <span class="s2">if </span><span class="s1">text:</span>
            <span class="s1">decoder_factory = codecs.getincrementaldecoder(</span><span class="s3">&quot;utf-8&quot;</span><span class="s1">)</span>
            <span class="s1">decoder = decoder_factory(errors=</span><span class="s3">&quot;strict&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">max_size </span><span class="s2">is None</span><span class="s1">:</span>

                <span class="s2">def </span><span class="s1">append(frame: Frame) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                    <span class="s2">nonlocal </span><span class="s1">chunks</span>
                    <span class="s1">chunks.append(decoder.decode(frame.data</span><span class="s2">, </span><span class="s1">frame.fin))</span>

            <span class="s2">else</span><span class="s1">:</span>

                <span class="s2">def </span><span class="s1">append(frame: Frame) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                    <span class="s2">nonlocal </span><span class="s1">chunks</span><span class="s2">, </span><span class="s1">max_size</span>
                    <span class="s1">chunks.append(decoder.decode(frame.data</span><span class="s2">, </span><span class="s1">frame.fin))</span>
                    <span class="s2">assert </span><span class="s1">isinstance(max_size</span><span class="s2">, </span><span class="s1">int)</span>
                    <span class="s1">max_size -= len(frame.data)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">max_size </span><span class="s2">is None</span><span class="s1">:</span>

                <span class="s2">def </span><span class="s1">append(frame: Frame) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                    <span class="s2">nonlocal </span><span class="s1">chunks</span>
                    <span class="s1">chunks.append(frame.data)</span>

            <span class="s2">else</span><span class="s1">:</span>

                <span class="s2">def </span><span class="s1">append(frame: Frame) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                    <span class="s2">nonlocal </span><span class="s1">chunks</span><span class="s2">, </span><span class="s1">max_size</span>
                    <span class="s1">chunks.append(frame.data)</span>
                    <span class="s2">assert </span><span class="s1">isinstance(max_size</span><span class="s2">, </span><span class="s1">int)</span>
                    <span class="s1">max_size -= len(frame.data)</span>

        <span class="s1">append(frame)</span>

        <span class="s2">while not </span><span class="s1">frame.fin:</span>
            <span class="s1">frame = </span><span class="s2">await </span><span class="s1">self.read_data_frame(max_size=max_size)</span>
            <span class="s2">if </span><span class="s1">frame </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;incomplete fragmented message&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">frame.opcode != OP_CONT:</span>
                <span class="s2">raise </span><span class="s1">ProtocolError(</span><span class="s3">&quot;unexpected opcode&quot;</span><span class="s1">)</span>
            <span class="s1">append(frame)</span>

        <span class="s4"># mypy cannot figure out that chunks have the proper type.</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s3">&quot;&quot; </span><span class="s2">if </span><span class="s1">text </span><span class="s2">else </span><span class="s6">b&quot;&quot;</span><span class="s1">).join(chunks)  </span><span class="s4"># type: ignore</span>

    <span class="s2">async def </span><span class="s1">read_data_frame(self</span><span class="s2">, </span><span class="s1">max_size: Optional[int]) -&gt; Optional[Frame]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Read a single data frame from the connection. 
 
        Process control frames received before the next data frame. 
 
        Return ``None`` if a close frame is encountered before any data frame. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># 6.2. Receiving Data</span>
        <span class="s2">while True</span><span class="s1">:</span>
            <span class="s1">frame = </span><span class="s2">await </span><span class="s1">self.read_frame(max_size)</span>

            <span class="s4"># 5.5. Control Frames</span>
            <span class="s2">if </span><span class="s1">frame.opcode == OP_CLOSE:</span>
                <span class="s4"># 7.1.5.  The WebSocket Connection Close Code</span>
                <span class="s4"># 7.1.6.  The WebSocket Connection Close Reason</span>
                <span class="s1">self.close_code</span><span class="s2">, </span><span class="s1">self.close_reason = parse_close(frame.data)</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s4"># Echo the original data instead of re-serializing it with</span>
                    <span class="s4"># serialize_close() because that fails when the close frame</span>
                    <span class="s4"># is empty and parse_close() synthetizes a 1005 close code.</span>
                    <span class="s2">await </span><span class="s1">self.write_close_frame(frame.data)</span>
                <span class="s2">except </span><span class="s1">ConnectionClosed:</span>
                    <span class="s4"># It doesn't really matter if the connection was closed</span>
                    <span class="s4"># before we could send back a close frame.</span>
                    <span class="s2">pass</span>
                <span class="s2">return None</span>

            <span class="s2">elif </span><span class="s1">frame.opcode == OP_PING:</span>
                <span class="s4"># Answer pings.</span>
                <span class="s1">ping_hex = frame.data.hex() </span><span class="s2">or </span><span class="s3">&quot;[empty]&quot;</span>
                <span class="s1">logger.debug(</span>
                    <span class="s3">&quot;%s - received ping, sending pong: %s&quot;</span><span class="s2">, </span><span class="s1">self.side</span><span class="s2">, </span><span class="s1">ping_hex</span>
                <span class="s1">)</span>
                <span class="s2">await </span><span class="s1">self.pong(frame.data)</span>

            <span class="s2">elif </span><span class="s1">frame.opcode == OP_PONG:</span>
                <span class="s4"># Acknowledge pings on solicited pongs.</span>
                <span class="s2">if </span><span class="s1">frame.data </span><span class="s2">in </span><span class="s1">self.pings:</span>
                    <span class="s1">logger.debug(</span>
                        <span class="s3">&quot;%s - received solicited pong: %s&quot;</span><span class="s2">,</span>
                        <span class="s1">self.side</span><span class="s2">,</span>
                        <span class="s1">frame.data.hex() </span><span class="s2">or </span><span class="s3">&quot;[empty]&quot;</span><span class="s2">,</span>
                    <span class="s1">)</span>
                    <span class="s4"># Acknowledge all pings up to the one matching this pong.</span>
                    <span class="s1">ping_id = </span><span class="s2">None</span>
                    <span class="s1">ping_ids = []</span>
                    <span class="s2">for </span><span class="s1">ping_id</span><span class="s2">, </span><span class="s1">ping </span><span class="s2">in </span><span class="s1">self.pings.items():</span>
                        <span class="s1">ping_ids.append(ping_id)</span>
                        <span class="s2">if not </span><span class="s1">ping.done():</span>
                            <span class="s1">ping.set_result(</span><span class="s2">None</span><span class="s1">)</span>
                        <span class="s2">if </span><span class="s1">ping_id == frame.data:</span>
                            <span class="s2">break</span>
                    <span class="s2">else</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
                        <span class="s2">assert False, </span><span class="s3">&quot;ping_id is in self.pings&quot;</span>
                    <span class="s4"># Remove acknowledged pings from self.pings.</span>
                    <span class="s2">for </span><span class="s1">ping_id </span><span class="s2">in </span><span class="s1">ping_ids:</span>
                        <span class="s2">del </span><span class="s1">self.pings[ping_id]</span>
                    <span class="s1">ping_ids = ping_ids[:-</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">ping_ids:</span>
                        <span class="s1">pings_hex = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(</span>
                            <span class="s1">ping_id.hex() </span><span class="s2">or </span><span class="s3">&quot;[empty]&quot; </span><span class="s2">for </span><span class="s1">ping_id </span><span class="s2">in </span><span class="s1">ping_ids</span>
                        <span class="s1">)</span>
                        <span class="s1">plural = </span><span class="s3">&quot;s&quot; </span><span class="s2">if </span><span class="s1">len(ping_ids) &gt; </span><span class="s5">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
                        <span class="s1">logger.debug(</span>
                            <span class="s3">&quot;%s - acknowledged previous ping%s: %s&quot;</span><span class="s2">,</span>
                            <span class="s1">self.side</span><span class="s2">,</span>
                            <span class="s1">plural</span><span class="s2">,</span>
                            <span class="s1">pings_hex</span><span class="s2">,</span>
                        <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">logger.debug(</span>
                        <span class="s3">&quot;%s - received unsolicited pong: %s&quot;</span><span class="s2">,</span>
                        <span class="s1">self.side</span><span class="s2">,</span>
                        <span class="s1">frame.data.hex() </span><span class="s2">or </span><span class="s3">&quot;[empty]&quot;</span><span class="s2">,</span>
                    <span class="s1">)</span>

            <span class="s4"># 5.6. Data Frames</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">frame</span>

    <span class="s2">async def </span><span class="s1">read_frame(self</span><span class="s2">, </span><span class="s1">max_size: Optional[int]) -&gt; Frame:</span>
        <span class="s0">&quot;&quot;&quot; 
        Read a single frame from the connection. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">frame = </span><span class="s2">await </span><span class="s1">Frame.read(</span>
            <span class="s1">self.reader.readexactly</span><span class="s2">,</span>
            <span class="s1">mask=</span><span class="s2">not </span><span class="s1">self.is_client</span><span class="s2">,</span>
            <span class="s1">max_size=max_size</span><span class="s2">,</span>
            <span class="s1">extensions=self.extensions</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s &lt; %r&quot;</span><span class="s2">, </span><span class="s1">self.side</span><span class="s2">, </span><span class="s1">frame)</span>
        <span class="s2">return </span><span class="s1">frame</span>

    <span class="s2">async def </span><span class="s1">write_frame(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">fin: bool</span><span class="s2">, </span><span class="s1">opcode: int</span><span class="s2">, </span><span class="s1">data: bytes</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">_expected_state: int = State.OPEN</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4"># Defensive assertion for protocol compliance.</span>
        <span class="s2">if </span><span class="s1">self.state </span><span class="s2">is not </span><span class="s1">_expected_state:  </span><span class="s4"># pragma: no cover</span>
            <span class="s2">raise </span><span class="s1">InvalidState(</span>
                <span class="s3">f&quot;Cannot write to a WebSocket in the </span><span class="s2">{</span><span class="s1">self.state.name</span><span class="s2">} </span><span class="s3">state&quot;</span>
            <span class="s1">)</span>

        <span class="s1">frame = Frame(fin</span><span class="s2">, </span><span class="s1">Opcode(opcode)</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s &gt; %r&quot;</span><span class="s2">, </span><span class="s1">self.side</span><span class="s2">, </span><span class="s1">frame)</span>
        <span class="s1">frame.write(</span>
            <span class="s1">self.transport.write</span><span class="s2">, </span><span class="s1">mask=self.is_client</span><span class="s2">, </span><span class="s1">extensions=self.extensions</span>
        <span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s4"># drain() cannot be called concurrently by multiple coroutines:</span>
            <span class="s4"># http://bugs.python.org/issue29930. Remove this lock when no</span>
            <span class="s4"># version of Python where this bugs exists is supported anymore.</span>
            <span class="s2">async with </span><span class="s1">self._drain_lock:</span>
                <span class="s4"># Handle flow control automatically.</span>
                <span class="s2">await </span><span class="s1">self._drain()</span>
        <span class="s2">except </span><span class="s1">ConnectionError:</span>
            <span class="s4"># Terminate the connection if the socket died.</span>
            <span class="s1">self.fail_connection()</span>
            <span class="s4"># Wait until the connection is closed to raise ConnectionClosed</span>
            <span class="s4"># with the correct code and reason.</span>
            <span class="s2">await </span><span class="s1">self.ensure_open()</span>

    <span class="s2">async def </span><span class="s1">write_close_frame(self</span><span class="s2">, </span><span class="s1">data: bytes = </span><span class="s6">b&quot;&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Write a close frame if and only if the connection state is OPEN. 
 
        This dedicated coroutine must be used for writing close frames to 
        ensure that at most one close frame is sent on a given connection. 
 
        &quot;&quot;&quot;</span>
        <span class="s4"># Test and set the connection state before sending the close frame to</span>
        <span class="s4"># avoid sending two frames in case of concurrent calls.</span>
        <span class="s2">if </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.OPEN:</span>
            <span class="s4"># 7.1.3. The WebSocket Closing Handshake is Started</span>
            <span class="s1">self.state = State.CLOSING</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;%s - state = CLOSING&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>

            <span class="s4"># 7.1.2. Start the WebSocket Closing Handshake</span>
            <span class="s2">await </span><span class="s1">self.write_frame(</span><span class="s2">True, </span><span class="s1">OP_CLOSE</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">_expected_state=State.CLOSING)</span>

    <span class="s2">async def </span><span class="s1">keepalive_ping(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Send a Ping frame and wait for a Pong frame at regular intervals. 
 
        This coroutine exits when the connection terminates and one of the 
        following happens: 
 
        - :meth:`ping` raises :exc:`ConnectionClosed`, or 
        - :meth:`close_connection` cancels :attr:`keepalive_ping_task`. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.ping_interval </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">while True</span><span class="s1">:</span>
                <span class="s2">await </span><span class="s1">asyncio.sleep(</span>
                    <span class="s1">self.ping_interval</span><span class="s2">,</span>
                    <span class="s1">loop=self.loop </span><span class="s2">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">) </span><span class="s2">else None,</span>
                <span class="s1">)</span>

                <span class="s4"># ping() raises CancelledError if the connection is closed,</span>
                <span class="s4"># when close_connection() cancels self.keepalive_ping_task.</span>

                <span class="s4"># ping() raises ConnectionClosed if the connection is lost,</span>
                <span class="s4"># when connection_lost() calls abort_pings().</span>

                <span class="s1">pong_waiter = </span><span class="s2">await </span><span class="s1">self.ping()</span>

                <span class="s2">if </span><span class="s1">self.ping_timeout </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s2">try</span><span class="s1">:</span>
                        <span class="s2">await </span><span class="s1">asyncio.wait_for(</span>
                            <span class="s1">pong_waiter</span><span class="s2">,</span>
                            <span class="s1">self.ping_timeout</span><span class="s2">,</span>
                            <span class="s1">loop=self.loop </span><span class="s2">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">) </span><span class="s2">else None,</span>
                        <span class="s1">)</span>
                    <span class="s2">except </span><span class="s1">asyncio.TimeoutError:</span>
                        <span class="s1">logger.debug(</span><span class="s3">&quot;%s ! timed out waiting for pong&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>
                        <span class="s1">self.fail_connection(</span><span class="s5">1011</span><span class="s1">)</span>
                        <span class="s2">break</span>

        <span class="s4"># Remove this branch when dropping support for Python &lt; 3.8</span>
        <span class="s4"># because CancelledError no longer inherits Exception.</span>
        <span class="s2">except </span><span class="s1">asyncio.CancelledError:</span>
            <span class="s2">raise</span>

        <span class="s2">except </span><span class="s1">ConnectionClosed:</span>
            <span class="s2">pass</span>

        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s1">logger.warning(</span><span class="s3">&quot;Unexpected exception in keepalive ping task&quot;</span><span class="s2">, </span><span class="s1">exc_info=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">async def </span><span class="s1">close_connection(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        7.1.1. Close the WebSocket Connection 
 
        When the opening handshake succeeds, :meth:`connection_open` starts 
        this coroutine in a task. It waits for the data transfer phase to 
        complete then it closes the TCP connection cleanly. 
 
        When the opening handshake fails, :meth:`fail_connection` does the 
        same. There's no data transfer phase in that case. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s4"># Wait for the data transfer phase to complete.</span>
            <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;transfer_data_task&quot;</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">await </span><span class="s1">self.transfer_data_task</span>
                <span class="s2">except </span><span class="s1">asyncio.CancelledError:</span>
                    <span class="s2">pass</span>

            <span class="s4"># Cancel the keepalive ping task.</span>
            <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;keepalive_ping_task&quot;</span><span class="s1">):</span>
                <span class="s1">self.keepalive_ping_task.cancel()</span>

            <span class="s4"># A client should wait for a TCP close from the server.</span>
            <span class="s2">if </span><span class="s1">self.is_client </span><span class="s2">and </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;transfer_data_task&quot;</span><span class="s1">):</span>
                <span class="s2">if await </span><span class="s1">self.wait_for_connection_lost():</span>
                    <span class="s4"># Coverage marks this line as a partially executed branch.</span>
                    <span class="s4"># I supect a bug in coverage. Ignore it for now.</span>
                    <span class="s2">return  </span><span class="s4"># pragma: no cover</span>
                <span class="s1">logger.debug(</span><span class="s3">&quot;%s ! timed out waiting for TCP close&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>

            <span class="s4"># Half-close the TCP connection if possible (when there's no TLS).</span>
            <span class="s2">if </span><span class="s1">self.transport.can_write_eof():</span>
                <span class="s1">logger.debug(</span><span class="s3">&quot;%s x half-closing TCP connection&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>
                <span class="s1">self.transport.write_eof()</span>

                <span class="s2">if await </span><span class="s1">self.wait_for_connection_lost():</span>
                    <span class="s4"># Coverage marks this line as a partially executed branch.</span>
                    <span class="s4"># I supect a bug in coverage. Ignore it for now.</span>
                    <span class="s2">return  </span><span class="s4"># pragma: no cover</span>
                <span class="s1">logger.debug(</span><span class="s3">&quot;%s ! timed out waiting for TCP close&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>

        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s4"># The try/finally ensures that the transport never remains open,</span>
            <span class="s4"># even if this coroutine is canceled (for example).</span>

            <span class="s4"># If connection_lost() was called, the TCP connection is closed.</span>
            <span class="s4"># However, if TLS is enabled, the transport still needs closing.</span>
            <span class="s4"># Else asyncio complains: ResourceWarning: unclosed transport.</span>
            <span class="s2">if </span><span class="s1">self.connection_lost_waiter.done() </span><span class="s2">and </span><span class="s1">self.transport.is_closing():</span>
                <span class="s2">return</span>

            <span class="s4"># Close the TCP connection. Buffers are flushed asynchronously.</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;%s x closing TCP connection&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>
            <span class="s1">self.transport.close()</span>

            <span class="s2">if await </span><span class="s1">self.wait_for_connection_lost():</span>
                <span class="s2">return</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;%s ! timed out waiting for TCP close&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>

            <span class="s4"># Abort the TCP connection. Buffers are discarded.</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;%s x aborting TCP connection&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>
            <span class="s1">self.transport.abort()</span>

            <span class="s4"># connection_lost() is called quickly after aborting.</span>
            <span class="s4"># Coverage marks this line as a partially executed branch.</span>
            <span class="s4"># I supect a bug in coverage. Ignore it for now.</span>
            <span class="s2">await </span><span class="s1">self.wait_for_connection_lost()  </span><span class="s4"># pragma: no cover</span>

    <span class="s2">async def </span><span class="s1">wait_for_connection_lost(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Wait until the TCP connection is closed or ``self.close_timeout`` elapses. 
 
        Return ``True`` if the connection is closed and ``False`` otherwise. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self.connection_lost_waiter.done():</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">await </span><span class="s1">asyncio.wait_for(</span>
                    <span class="s1">asyncio.shield(self.connection_lost_waiter)</span><span class="s2">,</span>
                    <span class="s1">self.close_timeout</span><span class="s2">,</span>
                    <span class="s1">loop=self.loop </span><span class="s2">if </span><span class="s1">sys.version_info[:</span><span class="s5">2</span><span class="s1">] &lt; (</span><span class="s5">3</span><span class="s2">, </span><span class="s5">8</span><span class="s1">) </span><span class="s2">else None,</span>
                <span class="s1">)</span>
            <span class="s2">except </span><span class="s1">asyncio.TimeoutError:</span>
                <span class="s2">pass</span>
        <span class="s4"># Re-check self.connection_lost_waiter.done() synchronously because</span>
        <span class="s4"># connection_lost() could run between the moment the timeout occurs</span>
        <span class="s4"># and the moment this coroutine resumes running.</span>
        <span class="s2">return </span><span class="s1">self.connection_lost_waiter.done()</span>

    <span class="s2">def </span><span class="s1">fail_connection(self</span><span class="s2">, </span><span class="s1">code: int = </span><span class="s5">1006</span><span class="s2">, </span><span class="s1">reason: str = </span><span class="s3">&quot;&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        7.1.7. Fail the WebSocket Connection 
 
        This requires: 
 
        1. Stopping all processing of incoming data, which means cancelling 
           :attr:`transfer_data_task`. The close code will be 1006 unless a 
           close frame was received earlier. 
 
        2. Sending a close frame with an appropriate code if the opening 
           handshake succeeded and the other side is likely to process it. 
 
        3. Closing the connection. :meth:`close_connection` takes care of 
           this once :attr:`transfer_data_task` exits after being canceled. 
 
        (The specification describes these steps in the opposite order.) 
 
        &quot;&quot;&quot;</span>
        <span class="s1">logger.debug(</span>
            <span class="s3">&quot;%s ! failing %s WebSocket connection with code %d&quot;</span><span class="s2">,</span>
            <span class="s1">self.side</span><span class="s2">,</span>
            <span class="s1">self.state.name</span><span class="s2">,</span>
            <span class="s1">code</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s4"># Cancel transfer_data_task if the opening handshake succeeded.</span>
        <span class="s4"># cancel() is idempotent and ignored if the task is done already.</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;transfer_data_task&quot;</span><span class="s1">):</span>
            <span class="s1">self.transfer_data_task.cancel()</span>

        <span class="s4"># Send a close frame when the state is OPEN (a close frame was already</span>
        <span class="s4"># sent if it's CLOSING), except when failing the connection because of</span>
        <span class="s4"># an error reading from or writing to the network.</span>
        <span class="s4"># Don't send a close frame if the connection is broken.</span>
        <span class="s2">if </span><span class="s1">code != </span><span class="s5">1006 </span><span class="s2">and </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.OPEN:</span>

            <span class="s1">frame_data = serialize_close(code</span><span class="s2">, </span><span class="s1">reason)</span>

            <span class="s4"># Write the close frame without draining the write buffer.</span>

            <span class="s4"># Keeping fail_connection() synchronous guarantees it can't</span>
            <span class="s4"># get stuck and simplifies the implementation of the callers.</span>
            <span class="s4"># Not drainig the write buffer is acceptable in this context.</span>

            <span class="s4"># This duplicates a few lines of code from write_close_frame()</span>
            <span class="s4"># and write_frame().</span>

            <span class="s1">self.state = State.CLOSING</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;%s - state = CLOSING&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>

            <span class="s1">frame = Frame(</span><span class="s2">True, </span><span class="s1">OP_CLOSE</span><span class="s2">, </span><span class="s1">frame_data)</span>
            <span class="s1">logger.debug(</span><span class="s3">&quot;%s &gt; %r&quot;</span><span class="s2">, </span><span class="s1">self.side</span><span class="s2">, </span><span class="s1">frame)</span>
            <span class="s1">frame.write(</span>
                <span class="s1">self.transport.write</span><span class="s2">, </span><span class="s1">mask=self.is_client</span><span class="s2">, </span><span class="s1">extensions=self.extensions</span>
            <span class="s1">)</span>

        <span class="s4"># Start close_connection_task if the opening handshake didn't succeed.</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;close_connection_task&quot;</span><span class="s1">):</span>
            <span class="s1">self.close_connection_task = self.loop.create_task(self.close_connection())</span>

    <span class="s2">def </span><span class="s1">abort_pings(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Raise ConnectionClosed in pending keepalive pings. 
 
        They'll never receive a pong once the connection is closed. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s1">self.state </span><span class="s2">is </span><span class="s1">State.CLOSED</span>
        <span class="s1">exc = self.connection_closed_exc()</span>

        <span class="s2">for </span><span class="s1">ping </span><span class="s2">in </span><span class="s1">self.pings.values():</span>
            <span class="s1">ping.set_exception(exc)</span>
            <span class="s4"># If the exception is never retrieved, it will be logged when ping</span>
            <span class="s4"># is garbage-collected. This is confusing for users.</span>
            <span class="s4"># Given that ping is done (with an exception), canceling it does</span>
            <span class="s4"># nothing, but it prevents logging the exception.</span>
            <span class="s1">ping.cancel()</span>

        <span class="s2">if </span><span class="s1">self.pings:</span>
            <span class="s1">pings_hex = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(ping_id.hex() </span><span class="s2">or </span><span class="s3">&quot;[empty]&quot; </span><span class="s2">for </span><span class="s1">ping_id </span><span class="s2">in </span><span class="s1">self.pings)</span>
            <span class="s1">plural = </span><span class="s3">&quot;s&quot; </span><span class="s2">if </span><span class="s1">len(self.pings) &gt; </span><span class="s5">1 </span><span class="s2">else </span><span class="s3">&quot;&quot;</span>
            <span class="s1">logger.debug(</span>
                <span class="s3">&quot;%s - aborted pending ping%s: %s&quot;</span><span class="s2">, </span><span class="s1">self.side</span><span class="s2">, </span><span class="s1">plural</span><span class="s2">, </span><span class="s1">pings_hex</span>
            <span class="s1">)</span>

    <span class="s4"># asyncio.Protocol methods</span>

    <span class="s2">def </span><span class="s1">connection_made(self</span><span class="s2">, </span><span class="s1">transport: asyncio.BaseTransport) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Configure write buffer limits. 
 
        The high-water limit is defined by ``self.write_limit``. 
 
        The low-water limit currently defaults to ``self.write_limit // 4`` in 
        :meth:`~asyncio.WriteTransport.set_write_buffer_limits`, which should 
        be all right for reasonable use cases of this library. 
 
        This is the earliest point where we can get hold of the transport, 
        which means it's the best point for configuring it. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s - event = connection_made(%s)&quot;</span><span class="s2">, </span><span class="s1">self.side</span><span class="s2">, </span><span class="s1">transport)</span>

        <span class="s1">transport = cast(asyncio.Transport</span><span class="s2">, </span><span class="s1">transport)</span>
        <span class="s1">transport.set_write_buffer_limits(self.write_limit)</span>
        <span class="s1">self.transport = transport</span>

        <span class="s4"># Copied from asyncio.StreamReaderProtocol</span>
        <span class="s1">self.reader.set_transport(transport)</span>

    <span class="s2">def </span><span class="s1">connection_lost(self</span><span class="s2">, </span><span class="s1">exc: Optional[Exception]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        7.1.4. The WebSocket Connection is Closed. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s - event = connection_lost(%s)&quot;</span><span class="s2">, </span><span class="s1">self.side</span><span class="s2">, </span><span class="s1">exc)</span>
        <span class="s1">self.state = State.CLOSED</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s - state = CLOSED&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;close_code&quot;</span><span class="s1">):</span>
            <span class="s1">self.close_code = </span><span class="s5">1006</span>
        <span class="s2">if not </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;close_reason&quot;</span><span class="s1">):</span>
            <span class="s1">self.close_reason = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">logger.debug(</span>
            <span class="s3">&quot;%s x code = %d, reason = %s&quot;</span><span class="s2">,</span>
            <span class="s1">self.side</span><span class="s2">,</span>
            <span class="s1">self.close_code</span><span class="s2">,</span>
            <span class="s1">self.close_reason </span><span class="s2">or </span><span class="s3">&quot;[no reason]&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.abort_pings()</span>
        <span class="s4"># If self.connection_lost_waiter isn't pending, that's a bug, because:</span>
        <span class="s4"># - it's set only here in connection_lost() which is called only once;</span>
        <span class="s4"># - it must never be canceled.</span>
        <span class="s1">self.connection_lost_waiter.set_result(</span><span class="s2">None</span><span class="s1">)</span>

        <span class="s2">if True</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>

            <span class="s4"># Copied from asyncio.StreamReaderProtocol</span>
            <span class="s2">if </span><span class="s1">self.reader </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">exc </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">self.reader.feed_eof()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.reader.set_exception(exc)</span>

            <span class="s4"># Copied from asyncio.FlowControlMixin</span>
            <span class="s4"># Wake up the writer if currently paused.</span>
            <span class="s2">if not </span><span class="s1">self._paused:</span>
                <span class="s2">return</span>
            <span class="s1">waiter = self._drain_waiter</span>
            <span class="s2">if </span><span class="s1">waiter </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">return</span>
            <span class="s1">self._drain_waiter = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">waiter.done():</span>
                <span class="s2">return</span>
            <span class="s2">if </span><span class="s1">exc </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">waiter.set_result(</span><span class="s2">None</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">waiter.set_exception(exc)</span>

    <span class="s2">def </span><span class="s1">pause_writing(self) -&gt; </span><span class="s2">None</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s2">assert not </span><span class="s1">self._paused</span>
        <span class="s1">self._paused = </span><span class="s2">True</span>

    <span class="s2">def </span><span class="s1">resume_writing(self) -&gt; </span><span class="s2">None</span><span class="s1">:  </span><span class="s4"># pragma: no cover</span>
        <span class="s2">assert </span><span class="s1">self._paused</span>
        <span class="s1">self._paused = </span><span class="s2">False</span>

        <span class="s1">waiter = self._drain_waiter</span>
        <span class="s2">if </span><span class="s1">waiter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._drain_waiter = </span><span class="s2">None</span>
            <span class="s2">if not </span><span class="s1">waiter.done():</span>
                <span class="s1">waiter.set_result(</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">data_received(self</span><span class="s2">, </span><span class="s1">data: bytes) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s - event = data_received(&lt;%d bytes&gt;)&quot;</span><span class="s2">, </span><span class="s1">self.side</span><span class="s2">, </span><span class="s1">len(data))</span>
        <span class="s1">self.reader.feed_data(data)</span>

    <span class="s2">def </span><span class="s1">eof_received(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Close the transport after receiving EOF. 
 
        The WebSocket protocol has its own closing handshake: endpoints close 
        the TCP or TLS connection after sending and receiving a close frame. 
 
        As a consequence, they never need to write after receiving EOF, so 
        there's no reason to keep the transport open by returning ``True``. 
 
        Besides, that doesn't work on TLS connections. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">logger.debug(</span><span class="s3">&quot;%s - event = eof_received()&quot;</span><span class="s2">, </span><span class="s1">self.side)</span>
        <span class="s1">self.reader.feed_eof()</span>
</pre>
</body>
</html>