<html>
<head>
<title>geometry.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
geometry.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
 This module contains the 'base' GEOSGeometry object -- all GEOS Geometries 
 inherit from this object. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">ctypes </span><span class="s2">import </span><span class="s1">addressof</span><span class="s2">, </span><span class="s1">byref</span><span class="s2">, </span><span class="s1">c_double</span>

<span class="s2">from </span><span class="s1">django.contrib.gis </span><span class="s2">import </span><span class="s1">gdal</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geometry </span><span class="s2">import </span><span class="s1">hex_regex</span><span class="s2">, </span><span class="s1">json_regex</span><span class="s2">, </span><span class="s1">wkt_regex</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geos </span><span class="s2">import </span><span class="s1">prototypes </span><span class="s2">as </span><span class="s1">capi</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geos.base </span><span class="s2">import </span><span class="s1">GEOSBase</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geos.coordseq </span><span class="s2">import </span><span class="s1">GEOSCoordSeq</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geos.error </span><span class="s2">import </span><span class="s1">GEOSException</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geos.libgeos </span><span class="s2">import </span><span class="s1">GEOM_PTR</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geos.mutable_list </span><span class="s2">import </span><span class="s1">ListMixin</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geos.prepared </span><span class="s2">import </span><span class="s1">PreparedGeometry</span>
<span class="s2">from </span><span class="s1">django.contrib.gis.geos.prototypes.io </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ewkb_w</span><span class="s2">, </span><span class="s1">wkb_r</span><span class="s2">, </span><span class="s1">wkb_w</span><span class="s2">, </span><span class="s1">wkt_r</span><span class="s2">, </span><span class="s1">wkt_w</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">django.utils.deconstruct </span><span class="s2">import </span><span class="s1">deconstructible</span>
<span class="s2">from </span><span class="s1">django.utils.encoding </span><span class="s2">import </span><span class="s1">force_bytes</span><span class="s2">, </span><span class="s1">force_str</span>


<span class="s2">class </span><span class="s1">GEOSGeometryBase(GEOSBase):</span>

    <span class="s1">_GEOS_CLASSES = </span><span class="s2">None</span>

    <span class="s1">ptr_type = GEOM_PTR</span>
    <span class="s1">destructor = capi.destroy_geom</span>
    <span class="s1">has_cs = </span><span class="s2">False  </span><span class="s3"># Only Point, LineString, LinearRing have coordinate sequences</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">ptr</span><span class="s2">, </span><span class="s1">cls):</span>
        <span class="s1">self._ptr = ptr</span>

        <span class="s3"># Setting the class type (e.g., Point, Polygon, etc.)</span>
        <span class="s2">if </span><span class="s1">type(self) </span><span class="s2">in </span><span class="s1">(GEOSGeometryBase</span><span class="s2">, </span><span class="s1">GEOSGeometry):</span>
            <span class="s2">if </span><span class="s1">cls </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">GEOSGeometryBase._GEOS_CLASSES </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s3"># Inner imports avoid import conflicts with GEOSGeometry.</span>
                    <span class="s2">from </span><span class="s1">.collections </span><span class="s2">import </span><span class="s1">(</span>
                        <span class="s1">GeometryCollection</span><span class="s2">, </span><span class="s1">MultiLineString</span><span class="s2">, </span><span class="s1">MultiPoint</span><span class="s2">,</span>
                        <span class="s1">MultiPolygon</span><span class="s2">,</span>
                    <span class="s1">)</span>
                    <span class="s2">from </span><span class="s1">.linestring </span><span class="s2">import </span><span class="s1">LinearRing</span><span class="s2">, </span><span class="s1">LineString</span>
                    <span class="s2">from </span><span class="s1">.point </span><span class="s2">import </span><span class="s1">Point</span>
                    <span class="s2">from </span><span class="s1">.polygon </span><span class="s2">import </span><span class="s1">Polygon</span>
                    <span class="s1">GEOSGeometryBase._GEOS_CLASSES = {</span>
                        <span class="s4">0</span><span class="s1">: Point</span><span class="s2">,</span>
                        <span class="s4">1</span><span class="s1">: LineString</span><span class="s2">,</span>
                        <span class="s4">2</span><span class="s1">: LinearRing</span><span class="s2">,</span>
                        <span class="s4">3</span><span class="s1">: Polygon</span><span class="s2">,</span>
                        <span class="s4">4</span><span class="s1">: MultiPoint</span><span class="s2">,</span>
                        <span class="s4">5</span><span class="s1">: MultiLineString</span><span class="s2">,</span>
                        <span class="s4">6</span><span class="s1">: MultiPolygon</span><span class="s2">,</span>
                        <span class="s4">7</span><span class="s1">: GeometryCollection</span><span class="s2">,</span>
                    <span class="s1">}</span>
                <span class="s1">cls = GEOSGeometryBase._GEOS_CLASSES[self.geom_typeid]</span>
            <span class="s1">self.__class__ = cls</span>
        <span class="s1">self._post_init()</span>

    <span class="s2">def </span><span class="s1">_post_init(self):</span>
        <span class="s0">&quot;Perform post-initialization setup.&quot;</span>
        <span class="s3"># Setting the coordinate sequence for the geometry (will be None on</span>
        <span class="s3"># geometries that do not have coordinate sequences)</span>
        <span class="s1">self._cs = GEOSCoordSeq(capi.get_cs(self.ptr)</span><span class="s2">, </span><span class="s1">self.hasz) </span><span class="s2">if </span><span class="s1">self.has_cs </span><span class="s2">else None</span>

    <span class="s2">def </span><span class="s1">__copy__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a clone because the copy of a GEOSGeometry may contain an 
        invalid pointer location if the original is garbage collected. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.clone()</span>

    <span class="s2">def </span><span class="s1">__deepcopy__(self</span><span class="s2">, </span><span class="s1">memodict):</span>
        <span class="s0">&quot;&quot;&quot; 
        The `deepcopy` routine is used by the `Node` class of django.utils.tree; 
        thus, the protocol routine needs to be implemented to return correct 
        copies (clones) of these GEOS objects, which use C pointers. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.clone()</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s0">&quot;EWKT is used for the string representation.&quot;</span>
        <span class="s2">return </span><span class="s1">self.ewkt</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">&quot;Short-hand representation because WKT may be very large.&quot;</span>
        <span class="s2">return </span><span class="s5">'&lt;%s object at %s&gt;' </span><span class="s1">% (self.geom_type</span><span class="s2">, </span><span class="s1">hex(addressof(self.ptr)))</span>

    <span class="s3"># Pickling support</span>
    <span class="s2">def </span><span class="s1">_to_pickle_wkb(self):</span>
        <span class="s2">return </span><span class="s1">bytes(self.wkb)</span>

    <span class="s2">def </span><span class="s1">_from_pickle_wkb(self</span><span class="s2">, </span><span class="s1">wkb):</span>
        <span class="s2">return </span><span class="s1">wkb_r().read(memoryview(wkb))</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s3"># The pickled state is simply a tuple of the WKB (in string form)</span>
        <span class="s3"># and the SRID.</span>
        <span class="s2">return </span><span class="s1">self._to_pickle_wkb()</span><span class="s2">, </span><span class="s1">self.srid</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s3"># Instantiating from the tuple state that was pickled.</span>
        <span class="s1">wkb</span><span class="s2">, </span><span class="s1">srid = state</span>
        <span class="s1">ptr = self._from_pickle_wkb(wkb)</span>
        <span class="s2">if not </span><span class="s1">ptr:</span>
            <span class="s2">raise </span><span class="s1">GEOSException(</span><span class="s5">'Invalid Geometry loaded from pickled state.'</span><span class="s1">)</span>
        <span class="s1">self.ptr = ptr</span>
        <span class="s1">self._post_init()</span>
        <span class="s1">self.srid = srid</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_from_wkb(cls</span><span class="s2">, </span><span class="s1">wkb):</span>
        <span class="s2">return </span><span class="s1">wkb_r().read(wkb)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">from_ewkt(ewkt):</span>
        <span class="s1">ewkt = force_bytes(ewkt)</span>
        <span class="s1">srid = </span><span class="s2">None</span>
        <span class="s1">parts = ewkt.split(</span><span class="s6">b';'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">len(parts) == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s1">srid_part</span><span class="s2">, </span><span class="s1">wkt = parts</span>
            <span class="s1">match = re.match(</span><span class="s6">br'SRID=(?P&lt;srid&gt;\-?\d+)'</span><span class="s2">, </span><span class="s1">srid_part)</span>
            <span class="s2">if not </span><span class="s1">match:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'EWKT has invalid SRID part.'</span><span class="s1">)</span>
            <span class="s1">srid = int(match[</span><span class="s5">'srid'</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">wkt = ewkt</span>
        <span class="s2">if not </span><span class="s1">wkt:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Expected WKT but got an empty string.'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">GEOSGeometry(GEOSGeometry._from_wkt(wkt)</span><span class="s2">, </span><span class="s1">srid=srid)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_from_wkt(wkt):</span>
        <span class="s2">return </span><span class="s1">wkt_r().read(wkt)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_gml(cls</span><span class="s2">, </span><span class="s1">gml_string):</span>
        <span class="s2">return </span><span class="s1">gdal.OGRGeometry.from_gml(gml_string).geos</span>

    <span class="s3"># Comparison operators</span>
    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Equivalence testing, a Geometry may be compared with another Geometry 
        or an EWKT representation. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">other = GEOSGeometry.from_ewkt(other)</span>
            <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">GEOSException):</span>
                <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">GEOSGeometry) </span><span class="s2">and </span><span class="s1">self.srid == other.srid </span><span class="s2">and </span><span class="s1">self.equals_exact(other)</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash((self.srid</span><span class="s2">, </span><span class="s1">self.wkt))</span>

    <span class="s3"># ### Geometry set-like operations ###</span>
    <span class="s3"># Thanks to Sean Gillies for inspiration:</span>
    <span class="s3">#  http://lists.gispython.org/pipermail/community/2007-July/001034.html</span>
    <span class="s3"># g = g1 | g2</span>
    <span class="s2">def </span><span class="s1">__or__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return the union of this Geometry and the other.&quot;</span>
        <span class="s2">return </span><span class="s1">self.union(other)</span>

    <span class="s3"># g = g1 &amp; g2</span>
    <span class="s2">def </span><span class="s1">__and__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return the intersection of this Geometry and the other.&quot;</span>
        <span class="s2">return </span><span class="s1">self.intersection(other)</span>

    <span class="s3"># g = g1 - g2</span>
    <span class="s2">def </span><span class="s1">__sub__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return the difference this Geometry and the other.&quot;</span>
        <span class="s2">return </span><span class="s1">self.difference(other)</span>

    <span class="s3"># g = g1 ^ g2</span>
    <span class="s2">def </span><span class="s1">__xor__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return the symmetric difference of this Geometry and the other.&quot;</span>
        <span class="s2">return </span><span class="s1">self.sym_difference(other)</span>

    <span class="s3"># #### Coordinate Sequence Routines ####</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">coord_seq(self):</span>
        <span class="s0">&quot;Return a clone of the coordinate sequence for this Geometry.&quot;</span>
        <span class="s2">if </span><span class="s1">self.has_cs:</span>
            <span class="s2">return </span><span class="s1">self._cs.clone()</span>

    <span class="s3"># #### Geometry Info ####</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">geom_type(self):</span>
        <span class="s0">&quot;Return a string representing the Geometry type, e.g. 'Polygon'&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_type(self.ptr).decode()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">geom_typeid(self):</span>
        <span class="s0">&quot;Return an integer representing the Geometry type.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_typeid(self.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">num_geom(self):</span>
        <span class="s0">&quot;Return the number of geometries in the Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.get_num_geoms(self.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">num_coords(self):</span>
        <span class="s0">&quot;Return the number of coordinates in the Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.get_num_coords(self.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">num_points(self):</span>
        <span class="s0">&quot;Return the number points, or coordinates, in the Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">self.num_coords</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">dims(self):</span>
        <span class="s0">&quot;Return the dimension of this Geometry (0=point, 1=line, 2=surface).&quot;</span>
        <span class="s2">return </span><span class="s1">capi.get_dims(self.ptr)</span>

    <span class="s2">def </span><span class="s1">normalize(self):</span>
        <span class="s0">&quot;Convert this Geometry to normal form (or canonical form).&quot;</span>
        <span class="s1">capi.geos_normalize(self.ptr)</span>

    <span class="s3"># #### Unary predicates ####</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">empty(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a boolean indicating whether the set of points in this Geometry 
        are empty. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_isempty(self.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">hasz(self):</span>
        <span class="s0">&quot;Return whether the geometry has a 3D dimension.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_hasz(self.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ring(self):</span>
        <span class="s0">&quot;Return whether or not the geometry is a ring.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_isring(self.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">simple(self):</span>
        <span class="s0">&quot;Return false if the Geometry isn't simple.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_issimple(self.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">valid(self):</span>
        <span class="s0">&quot;Test the validity of this Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_isvalid(self.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">valid_reason(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a string containing the reason for any invalidity. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_isvalidreason(self.ptr).decode()</span>

    <span class="s3"># #### Binary predicates. ####</span>
    <span class="s2">def </span><span class="s1">contains(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return true if other.within(this) returns true.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_contains(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s2">def </span><span class="s1">covers(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return True if the DE-9IM Intersection Matrix for the two geometries is 
        T*****FF*, *T****FF*, ***T**FF*, or ****T*FF*. If either geometry is 
        empty, return False. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_covers(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s2">def </span><span class="s1">crosses(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the DE-9IM intersection matrix for the two Geometries 
        is T*T****** (for a point and a curve,a point and an area or a line and 
        an area) 0******** (for two curves). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_crosses(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s2">def </span><span class="s1">disjoint(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the DE-9IM intersection matrix for the two Geometries 
        is FF*FF****. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_disjoint(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s2">def </span><span class="s1">equals(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the DE-9IM intersection matrix for the two Geometries 
        is T*F**FFF*. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_equals(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s2">def </span><span class="s1">equals_exact(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the two Geometries are exactly equal, up to a 
        specified tolerance. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_equalsexact(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr</span><span class="s2">, </span><span class="s1">float(tolerance))</span>

    <span class="s2">def </span><span class="s1">intersects(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return true if disjoint return false.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_intersects(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s2">def </span><span class="s1">overlaps(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the DE-9IM intersection matrix for the two Geometries 
        is T*T***T** (for two points or two surfaces) 1*T***T** (for two curves). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_overlaps(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s2">def </span><span class="s1">relate_pattern(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">pattern):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the elements in the DE-9IM intersection matrix for the 
        two Geometries match the elements in pattern. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(pattern</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or </span><span class="s1">len(pattern) &gt; </span><span class="s4">9</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">GEOSException(</span><span class="s5">'invalid intersection matrix pattern'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">capi.geos_relatepattern(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr</span><span class="s2">, </span><span class="s1">force_bytes(pattern))</span>

    <span class="s2">def </span><span class="s1">touches(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the DE-9IM intersection matrix for the two Geometries 
        is FT*******, F**T***** or F***T****. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_touches(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s2">def </span><span class="s1">within(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return true if the DE-9IM intersection matrix for the two Geometries 
        is T*F**F***. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_within(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr)</span>

    <span class="s3"># #### SRID Routines ####</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">srid(self):</span>
        <span class="s0">&quot;Get the SRID for the geometry. Return None if no SRID is set.&quot;</span>
        <span class="s1">s = capi.geos_get_srid(self.ptr)</span>
        <span class="s2">if </span><span class="s1">s == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">s</span>

    <span class="s1">@srid.setter</span>
    <span class="s2">def </span><span class="s1">srid(self</span><span class="s2">, </span><span class="s1">srid):</span>
        <span class="s0">&quot;Set the SRID for the geometry.&quot;</span>
        <span class="s1">capi.geos_set_srid(self.ptr</span><span class="s2">, </span><span class="s4">0 </span><span class="s2">if </span><span class="s1">srid </span><span class="s2">is None else </span><span class="s1">srid)</span>

    <span class="s3"># #### Output Routines ####</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ewkt(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the EWKT (SRID + WKT) of the Geometry. 
        &quot;&quot;&quot;</span>
        <span class="s1">srid = self.srid</span>
        <span class="s2">return </span><span class="s5">'SRID=%s;%s' </span><span class="s1">% (srid</span><span class="s2">, </span><span class="s1">self.wkt) </span><span class="s2">if </span><span class="s1">srid </span><span class="s2">else </span><span class="s1">self.wkt</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">wkt(self):</span>
        <span class="s0">&quot;Return the WKT (Well-Known Text) representation of this Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">wkt_w(dim=</span><span class="s4">3 </span><span class="s2">if </span><span class="s1">self.hasz </span><span class="s2">else </span><span class="s4">2</span><span class="s2">, </span><span class="s1">trim=</span><span class="s2">True</span><span class="s1">).write(self).decode()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">hex(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the WKB of this Geometry in hexadecimal form. Please note 
        that the SRID is not included in this representation because it is not 
        a part of the OGC specification (use the `hexewkb` property instead). 
        &quot;&quot;&quot;</span>
        <span class="s3"># A possible faster, all-python, implementation:</span>
        <span class="s3">#  str(self.wkb).encode('hex')</span>
        <span class="s2">return </span><span class="s1">wkb_w(dim=</span><span class="s4">3 </span><span class="s2">if </span><span class="s1">self.hasz </span><span class="s2">else </span><span class="s4">2</span><span class="s1">).write_hex(self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">hexewkb(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the EWKB of this Geometry in hexadecimal form. This is an 
        extension of the WKB specification that includes SRID value that are 
        a part of this geometry. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">ewkb_w(dim=</span><span class="s4">3 </span><span class="s2">if </span><span class="s1">self.hasz </span><span class="s2">else </span><span class="s4">2</span><span class="s1">).write_hex(self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">json(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return GeoJSON representation of this Geometry. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.ogr.json</span>
    <span class="s1">geojson = json</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">wkb(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the WKB (Well-Known Binary) representation of this Geometry 
        as a Python buffer.  SRID and Z values are not included, use the 
        `ewkb` property instead. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">wkb_w(</span><span class="s4">3 </span><span class="s2">if </span><span class="s1">self.hasz </span><span class="s2">else </span><span class="s4">2</span><span class="s1">).write(self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ewkb(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the EWKB representation of this Geometry as a Python buffer. 
        This is an extension of the WKB specification that includes any SRID 
        value that are a part of this geometry. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">ewkb_w(</span><span class="s4">3 </span><span class="s2">if </span><span class="s1">self.hasz </span><span class="s2">else </span><span class="s4">2</span><span class="s1">).write(self)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">kml(self):</span>
        <span class="s0">&quot;Return the KML representation of this Geometry.&quot;</span>
        <span class="s1">gtype = self.geom_type</span>
        <span class="s2">return </span><span class="s5">'&lt;%s&gt;%s&lt;/%s&gt;' </span><span class="s1">% (gtype</span><span class="s2">, </span><span class="s1">self.coord_seq.kml</span><span class="s2">, </span><span class="s1">gtype)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">prepared(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a PreparedGeometry corresponding to this geometry -- it is 
        optimized for the contains, intersects, and covers operations. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">PreparedGeometry(self)</span>

    <span class="s3"># #### GDAL-specific output routines ####</span>
    <span class="s2">def </span><span class="s1">_ogr_ptr(self):</span>
        <span class="s2">return </span><span class="s1">gdal.OGRGeometry._from_wkb(self.wkb)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ogr(self):</span>
        <span class="s0">&quot;Return the OGR Geometry for this Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">gdal.OGRGeometry(self._ogr_ptr()</span><span class="s2">, </span><span class="s1">self.srs)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">srs(self):</span>
        <span class="s0">&quot;Return the OSR SpatialReference for SRID of this Geometry.&quot;</span>
        <span class="s2">if </span><span class="s1">self.srid:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">gdal.SpatialReference(self.srid)</span>
            <span class="s2">except </span><span class="s1">(gdal.GDALException</span><span class="s2">, </span><span class="s1">gdal.SRSException):</span>
                <span class="s2">pass</span>
        <span class="s2">return None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">crs(self):</span>
        <span class="s0">&quot;Alias for `srs` property.&quot;</span>
        <span class="s2">return </span><span class="s1">self.srs</span>

    <span class="s2">def </span><span class="s1">transform(self</span><span class="s2">, </span><span class="s1">ct</span><span class="s2">, </span><span class="s1">clone=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Requires GDAL. Transform the geometry according to the given 
        transformation object, which may be an integer SRID, and WKT or 
        PROJ string. By default, transform the geometry in-place and return 
        nothing. However if the `clone` keyword is set, don't modify the 
        geometry and return a transformed clone instead. 
        &quot;&quot;&quot;</span>
        <span class="s1">srid = self.srid</span>

        <span class="s2">if </span><span class="s1">ct == srid:</span>
            <span class="s3"># short-circuit where source &amp; dest SRIDs match</span>
            <span class="s2">if </span><span class="s1">clone:</span>
                <span class="s2">return </span><span class="s1">self.clone()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return</span>

        <span class="s2">if </span><span class="s1">isinstance(ct</span><span class="s2">, </span><span class="s1">gdal.CoordTransform):</span>
            <span class="s3"># We don't care about SRID because CoordTransform presupposes</span>
            <span class="s3"># source SRS.</span>
            <span class="s1">srid = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">srid </span><span class="s2">is None or </span><span class="s1">srid &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">GEOSException(</span><span class="s5">&quot;Calling transform() with no SRID set is not supported&quot;</span><span class="s1">)</span>

        <span class="s3"># Creating an OGR Geometry, which is then transformed.</span>
        <span class="s1">g = gdal.OGRGeometry(self._ogr_ptr()</span><span class="s2">, </span><span class="s1">srid)</span>
        <span class="s1">g.transform(ct)</span>
        <span class="s3"># Getting a new GEOS pointer</span>
        <span class="s1">ptr = g._geos_ptr()</span>
        <span class="s2">if </span><span class="s1">clone:</span>
            <span class="s3"># User wants a cloned transformed geometry returned.</span>
            <span class="s2">return </span><span class="s1">GEOSGeometry(ptr</span><span class="s2">, </span><span class="s1">srid=g.srid)</span>
        <span class="s2">if </span><span class="s1">ptr:</span>
            <span class="s3"># Reassigning pointer, and performing post-initialization setup</span>
            <span class="s3"># again due to the reassignment.</span>
            <span class="s1">capi.destroy_geom(self.ptr)</span>
            <span class="s1">self.ptr = ptr</span>
            <span class="s1">self._post_init()</span>
            <span class="s1">self.srid = g.srid</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">GEOSException(</span><span class="s5">'Transformed WKB was invalid.'</span><span class="s1">)</span>

    <span class="s3"># #### Topology Routines ####</span>
    <span class="s2">def </span><span class="s1">_topology(self</span><span class="s2">, </span><span class="s1">gptr):</span>
        <span class="s0">&quot;Return Geometry from the given pointer.&quot;</span>
        <span class="s2">return </span><span class="s1">GEOSGeometry(gptr</span><span class="s2">, </span><span class="s1">srid=self.srid)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">boundary(self):</span>
        <span class="s0">&quot;Return the boundary as a newly allocated Geometry object.&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_boundary(self.ptr))</span>

    <span class="s2">def </span><span class="s1">buffer(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">quadsegs=</span><span class="s4">8</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a geometry that represents all points whose distance from this 
        Geometry is less than or equal to distance. Calculations are in the 
        Spatial Reference System of this Geometry. The optional third parameter sets 
        the number of segment used to approximate a quarter circle (defaults to 8). 
        (Text from PostGIS documentation at ch. 6.1.3) 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_buffer(self.ptr</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">quadsegs))</span>

    <span class="s2">def </span><span class="s1">buffer_with_style(self</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">quadsegs=</span><span class="s4">8</span><span class="s2">, </span><span class="s1">end_cap_style=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">join_style=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mitre_limit=</span><span class="s4">5.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Same as buffer() but allows customizing the style of the buffer. 
 
        End cap style can be round (1), flat (2), or square (3). 
        Join style can be round (1), mitre (2), or bevel (3). 
        Mitre ratio limit only affects mitered join style. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(</span>
            <span class="s1">capi.geos_bufferwithstyle(self.ptr</span><span class="s2">, </span><span class="s1">width</span><span class="s2">, </span><span class="s1">quadsegs</span><span class="s2">, </span><span class="s1">end_cap_style</span><span class="s2">, </span><span class="s1">join_style</span><span class="s2">, </span><span class="s1">mitre_limit)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">centroid(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The centroid is equal to the centroid of the set of component Geometries 
        of highest dimension (since the lower-dimension geometries contribute zero 
        &quot;weight&quot; to the centroid). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_centroid(self.ptr))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">convex_hull(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the smallest convex Polygon that contains all the points 
        in the Geometry. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_convexhull(self.ptr))</span>

    <span class="s2">def </span><span class="s1">difference(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a Geometry representing the points making up this Geometry 
        that do not make up other. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_difference(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">envelope(self):</span>
        <span class="s0">&quot;Return the envelope for this geometry (a polygon).&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_envelope(self.ptr))</span>

    <span class="s2">def </span><span class="s1">intersection(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return a Geometry representing the points shared by this Geometry and other.&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_intersection(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">point_on_surface(self):</span>
        <span class="s0">&quot;Compute an interior point of this Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_pointonsurface(self.ptr))</span>

    <span class="s2">def </span><span class="s1">relate(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return the DE-9IM intersection matrix for this Geometry and the other.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_relate(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr).decode()</span>

    <span class="s2">def </span><span class="s1">simplify(self</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">preserve_topology=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the Geometry, simplified using the Douglas-Peucker algorithm 
        to the specified tolerance (higher tolerance =&gt; less points).  If no 
        tolerance provided, defaults to 0. 
 
        By default, don't preserve topology - e.g. polygons can be split, 
        collapse to lines or disappear holes can be created or disappear, and 
        lines can cross. By specifying preserve_topology=True, the result will 
        have the same dimension and number of components as the input. This is 
        significantly slower. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">preserve_topology:</span>
            <span class="s2">return </span><span class="s1">self._topology(capi.geos_preservesimplify(self.ptr</span><span class="s2">, </span><span class="s1">tolerance))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._topology(capi.geos_simplify(self.ptr</span><span class="s2">, </span><span class="s1">tolerance))</span>

    <span class="s2">def </span><span class="s1">sym_difference(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a set combining the points in this Geometry not in other, 
        and the points in other not in this Geometry. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_symdifference(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">unary_union(self):</span>
        <span class="s0">&quot;Return the union of all the elements of this geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_unary_union(self.ptr))</span>

    <span class="s2">def </span><span class="s1">union(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;Return a Geometry representing all the points in this Geometry and other.&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_union(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr))</span>

    <span class="s3"># #### Other Routines ####</span>
    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">area(self):</span>
        <span class="s0">&quot;Return the area of the Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_area(self.ptr</span><span class="s2">, </span><span class="s1">byref(c_double()))</span>

    <span class="s2">def </span><span class="s1">distance(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the distance between the closest points on this Geometry 
        and the other. Units will be in those of the coordinate system of 
        the Geometry. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">GEOSGeometry):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">'distance() works only on other GEOS Geometries.'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">capi.geos_distance(self.ptr</span><span class="s2">, </span><span class="s1">other.ptr</span><span class="s2">, </span><span class="s1">byref(c_double()))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">extent(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the extent of this geometry as a 4-tuple, consisting of 
        (xmin, ymin, xmax, ymax). 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.point </span><span class="s2">import </span><span class="s1">Point</span>
        <span class="s1">env = self.envelope</span>
        <span class="s2">if </span><span class="s1">isinstance(env</span><span class="s2">, </span><span class="s1">Point):</span>
            <span class="s1">xmin</span><span class="s2">, </span><span class="s1">ymin = env.tuple</span>
            <span class="s1">xmax</span><span class="s2">, </span><span class="s1">ymax = xmin</span><span class="s2">, </span><span class="s1">ymin</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xmin</span><span class="s2">, </span><span class="s1">ymin = env[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">xmax</span><span class="s2">, </span><span class="s1">ymax = env[</span><span class="s4">0</span><span class="s1">][</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">(xmin</span><span class="s2">, </span><span class="s1">ymin</span><span class="s2">, </span><span class="s1">xmax</span><span class="s2">, </span><span class="s1">ymax)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">length(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the length of this Geometry (e.g., 0 for point, or the 
        circumference of a Polygon). 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_length(self.ptr</span><span class="s2">, </span><span class="s1">byref(c_double()))</span>

    <span class="s2">def </span><span class="s1">clone(self):</span>
        <span class="s0">&quot;Clone this Geometry.&quot;</span>
        <span class="s2">return </span><span class="s1">GEOSGeometry(capi.geom_clone(self.ptr))</span>


<span class="s2">class </span><span class="s1">LinearGeometryMixin:</span>
    <span class="s0">&quot;&quot;&quot; 
    Used for LineString and MultiLineString. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">interpolate(self</span><span class="s2">, </span><span class="s1">distance):</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_interpolate(self.ptr</span><span class="s2">, </span><span class="s1">distance))</span>

    <span class="s2">def </span><span class="s1">interpolate_normalized(self</span><span class="s2">, </span><span class="s1">distance):</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_interpolate_normalized(self.ptr</span><span class="s2">, </span><span class="s1">distance))</span>

    <span class="s2">def </span><span class="s1">project(self</span><span class="s2">, </span><span class="s1">point):</span>
        <span class="s2">from </span><span class="s1">.point </span><span class="s2">import </span><span class="s1">Point</span>
        <span class="s2">if not </span><span class="s1">isinstance(point</span><span class="s2">, </span><span class="s1">Point):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">'locate_point argument must be a Point'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">capi.geos_project(self.ptr</span><span class="s2">, </span><span class="s1">point.ptr)</span>

    <span class="s2">def </span><span class="s1">project_normalized(self</span><span class="s2">, </span><span class="s1">point):</span>
        <span class="s2">from </span><span class="s1">.point </span><span class="s2">import </span><span class="s1">Point</span>
        <span class="s2">if not </span><span class="s1">isinstance(point</span><span class="s2">, </span><span class="s1">Point):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">'locate_point argument must be a Point'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">capi.geos_project_normalized(self.ptr</span><span class="s2">, </span><span class="s1">point.ptr)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">merged(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the line merge of this Geometry. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._topology(capi.geos_linemerge(self.ptr))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">closed(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return whether or not this Geometry is closed. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">capi.geos_isclosed(self.ptr)</span>


<span class="s1">@deconstructible</span>
<span class="s2">class </span><span class="s1">GEOSGeometry(GEOSGeometryBase</span><span class="s2">, </span><span class="s1">ListMixin):</span>
    <span class="s0">&quot;A class that, generally, encapsulates a GEOS geometry.&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">geo_input</span><span class="s2">, </span><span class="s1">srid=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        The base constructor for GEOS geometry objects. It may take the 
        following inputs: 
 
         * strings: 
            - WKT 
            - HEXEWKB (a PostGIS-specific canonical form) 
            - GeoJSON (requires GDAL) 
         * buffer: 
            - WKB 
 
        The `srid` keyword specifies the Source Reference Identifier (SRID) 
        number for this Geometry. If not provided, it defaults to None. 
        &quot;&quot;&quot;</span>
        <span class="s1">input_srid = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">isinstance(geo_input</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s1">geo_input = force_str(geo_input)</span>
        <span class="s2">if </span><span class="s1">isinstance(geo_input</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">wkt_m = wkt_regex.match(geo_input)</span>
            <span class="s2">if </span><span class="s1">wkt_m:</span>
                <span class="s3"># Handle WKT input.</span>
                <span class="s2">if </span><span class="s1">wkt_m[</span><span class="s5">'srid'</span><span class="s1">]:</span>
                    <span class="s1">input_srid = int(wkt_m[</span><span class="s5">'srid'</span><span class="s1">])</span>
                <span class="s1">g = self._from_wkt(force_bytes(wkt_m[</span><span class="s5">'wkt'</span><span class="s1">]))</span>
            <span class="s2">elif </span><span class="s1">hex_regex.match(geo_input):</span>
                <span class="s3"># Handle HEXEWKB input.</span>
                <span class="s1">g = wkb_r().read(force_bytes(geo_input))</span>
            <span class="s2">elif </span><span class="s1">json_regex.match(geo_input):</span>
                <span class="s3"># Handle GeoJSON input.</span>
                <span class="s1">ogr = gdal.OGRGeometry.from_json(geo_input)</span>
                <span class="s1">g = ogr._geos_ptr()</span>
                <span class="s1">input_srid = ogr.srid</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'String input unrecognized as WKT EWKT, and HEXEWKB.'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(geo_input</span><span class="s2">, </span><span class="s1">GEOM_PTR):</span>
            <span class="s3"># When the input is a pointer to a geometry (GEOM_PTR).</span>
            <span class="s1">g = geo_input</span>
        <span class="s2">elif </span><span class="s1">isinstance(geo_input</span><span class="s2">, </span><span class="s1">memoryview):</span>
            <span class="s3"># When the input is a buffer (WKB).</span>
            <span class="s1">g = wkb_r().read(geo_input)</span>
        <span class="s2">elif </span><span class="s1">isinstance(geo_input</span><span class="s2">, </span><span class="s1">GEOSGeometry):</span>
            <span class="s1">g = capi.geom_clone(geo_input.ptr)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">'Improper geometry input type: %s' </span><span class="s1">% type(geo_input))</span>

        <span class="s2">if not </span><span class="s1">g:</span>
            <span class="s2">raise </span><span class="s1">GEOSException(</span><span class="s5">'Could not initialize GEOS Geometry with given input.'</span><span class="s1">)</span>

        <span class="s1">input_srid = input_srid </span><span class="s2">or </span><span class="s1">capi.geos_get_srid(g) </span><span class="s2">or None</span>
        <span class="s2">if </span><span class="s1">input_srid </span><span class="s2">and </span><span class="s1">srid </span><span class="s2">and </span><span class="s1">input_srid != srid:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Input geometry already has SRID: %d.' </span><span class="s1">% input_srid)</span>

        <span class="s1">super().__init__(g</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s3"># Set the SRID, if given.</span>
        <span class="s1">srid = input_srid </span><span class="s2">or </span><span class="s1">srid</span>
        <span class="s2">if </span><span class="s1">srid </span><span class="s2">and </span><span class="s1">isinstance(srid</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s1">self.srid = srid</span>
</pre>
</body>
</html>