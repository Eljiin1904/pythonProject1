<html>
<head>
<title>test_guest_mode.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_guest_mode.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">asyncio</span>
<span class="s0">import </span><span class="s1">contextvars</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">traceback</span>
<span class="s0">import </span><span class="s1">queue</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">math </span><span class="s0">import </span><span class="s1">inf</span>
<span class="s0">import </span><span class="s1">signal</span>
<span class="s0">import </span><span class="s1">socket</span>
<span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">time</span>

<span class="s0">import </span><span class="s1">trio</span>
<span class="s0">import </span><span class="s1">trio.testing</span>
<span class="s0">from </span><span class="s1">.tutil </span><span class="s0">import </span><span class="s1">gc_collect_harder</span><span class="s0">, </span><span class="s1">buggy_pypy_asyncgens</span><span class="s0">, </span><span class="s1">restore_unraisablehook</span>
<span class="s0">from </span><span class="s1">..._util </span><span class="s0">import </span><span class="s1">signal_raise</span>

<span class="s2"># The simplest possible &quot;host&quot; loop.</span>
<span class="s2"># Nice features:</span>
<span class="s2"># - we can run code &quot;outside&quot; of trio using the schedule function passed to</span>
<span class="s2">#   our main</span>
<span class="s2"># - final result is returned</span>
<span class="s2"># - any unhandled exceptions cause an immediate crash</span>
<span class="s0">def </span><span class="s1">trivial_guest_run(trio_fn</span><span class="s0">, </span><span class="s1">**start_guest_run_kwargs):</span>
    <span class="s1">todo = queue.Queue()</span>

    <span class="s1">host_thread = threading.current_thread()</span>

    <span class="s0">def </span><span class="s1">run_sync_soon_threadsafe(fn):</span>
        <span class="s0">if </span><span class="s1">host_thread </span><span class="s0">is </span><span class="s1">threading.current_thread():  </span><span class="s2"># pragma: no cover</span>
            <span class="s1">crash = partial(</span>
                <span class="s1">pytest.fail</span><span class="s0">, </span><span class="s3">&quot;run_sync_soon_threadsafe called from host thread&quot;</span>
            <span class="s1">)</span>
            <span class="s1">todo.put((</span><span class="s3">&quot;run&quot;</span><span class="s0">, </span><span class="s1">crash))</span>
        <span class="s1">todo.put((</span><span class="s3">&quot;run&quot;</span><span class="s0">, </span><span class="s1">fn))</span>

    <span class="s0">def </span><span class="s1">run_sync_soon_not_threadsafe(fn):</span>
        <span class="s0">if </span><span class="s1">host_thread </span><span class="s0">is not </span><span class="s1">threading.current_thread():  </span><span class="s2"># pragma: no cover</span>
            <span class="s1">crash = partial(</span>
                <span class="s1">pytest.fail</span><span class="s0">, </span><span class="s3">&quot;run_sync_soon_not_threadsafe called from worker thread&quot;</span>
            <span class="s1">)</span>
            <span class="s1">todo.put((</span><span class="s3">&quot;run&quot;</span><span class="s0">, </span><span class="s1">crash))</span>
        <span class="s1">todo.put((</span><span class="s3">&quot;run&quot;</span><span class="s0">, </span><span class="s1">fn))</span>

    <span class="s0">def </span><span class="s1">done_callback(outcome):</span>
        <span class="s1">todo.put((</span><span class="s3">&quot;unwrap&quot;</span><span class="s0">, </span><span class="s1">outcome))</span>

    <span class="s1">trio.lowlevel.start_guest_run(</span>
        <span class="s1">trio_fn</span><span class="s0">,</span>
        <span class="s1">run_sync_soon_not_threadsafe</span><span class="s0">,</span>
        <span class="s1">run_sync_soon_threadsafe=run_sync_soon_threadsafe</span><span class="s0">,</span>
        <span class="s1">run_sync_soon_not_threadsafe=run_sync_soon_not_threadsafe</span><span class="s0">,</span>
        <span class="s1">done_callback=done_callback</span><span class="s0">,</span>
        <span class="s1">**start_guest_run_kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">while True</span><span class="s1">:</span>
            <span class="s1">op</span><span class="s0">, </span><span class="s1">obj = todo.get()</span>
            <span class="s0">if </span><span class="s1">op == </span><span class="s3">&quot;run&quot;</span><span class="s1">:</span>
                <span class="s1">obj()</span>
            <span class="s0">elif </span><span class="s1">op == </span><span class="s3">&quot;unwrap&quot;</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">obj.unwrap()</span>
            <span class="s0">else</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
                <span class="s0">assert False</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s2"># Make sure that exceptions raised here don't capture these, so that</span>
        <span class="s2"># if an exception does cause us to abandon a run then the Trio state</span>
        <span class="s2"># has a chance to be GC'ed and warn about it.</span>
        <span class="s0">del </span><span class="s1">todo</span><span class="s0">, </span><span class="s1">run_sync_soon_threadsafe</span><span class="s0">, </span><span class="s1">done_callback</span>


<span class="s0">def </span><span class="s1">test_guest_trivial():</span>
    <span class="s0">async def </span><span class="s1">trio_return(in_host):</span>
        <span class="s0">await </span><span class="s1">trio.sleep(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s3">&quot;ok&quot;</span>

    <span class="s0">assert </span><span class="s1">trivial_guest_run(trio_return) == </span><span class="s3">&quot;ok&quot;</span>

    <span class="s0">async def </span><span class="s1">trio_fail(in_host):</span>
        <span class="s0">raise </span><span class="s1">KeyError(</span><span class="s3">&quot;whoopsiedaisy&quot;</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;whoopsiedaisy&quot;</span><span class="s1">):</span>
        <span class="s1">trivial_guest_run(trio_fail)</span>


<span class="s0">def </span><span class="s1">test_guest_can_do_io():</span>
    <span class="s0">async def </span><span class="s1">trio_main(in_host):</span>
        <span class="s1">record = []</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b = trio.socket.socketpair()</span>
        <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
            <span class="s0">async with </span><span class="s1">trio.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>

                <span class="s0">async def </span><span class="s1">do_receive():</span>
                    <span class="s1">record.append(</span><span class="s0">await </span><span class="s1">a.recv(</span><span class="s4">1</span><span class="s1">))</span>

                <span class="s1">nursery.start_soon(do_receive)</span>
                <span class="s0">await </span><span class="s1">trio.testing.wait_all_tasks_blocked()</span>

                <span class="s0">await </span><span class="s1">b.send(</span><span class="s5">b&quot;x&quot;</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">record == [</span><span class="s5">b&quot;x&quot;</span><span class="s1">]</span>

    <span class="s1">trivial_guest_run(trio_main)</span>


<span class="s0">def </span><span class="s1">test_host_can_directly_wake_trio_task():</span>
    <span class="s0">async def </span><span class="s1">trio_main(in_host):</span>
        <span class="s1">ev = trio.Event()</span>
        <span class="s1">in_host(ev.set)</span>
        <span class="s0">await </span><span class="s1">ev.wait()</span>
        <span class="s0">return </span><span class="s3">&quot;ok&quot;</span>

    <span class="s0">assert </span><span class="s1">trivial_guest_run(trio_main) == </span><span class="s3">&quot;ok&quot;</span>


<span class="s0">def </span><span class="s1">test_host_altering_deadlines_wakes_trio_up():</span>
    <span class="s0">def </span><span class="s1">set_deadline(cscope</span><span class="s0">, </span><span class="s1">new_deadline):</span>
        <span class="s1">cscope.deadline = new_deadline</span>

    <span class="s0">async def </span><span class="s1">trio_main(in_host):</span>
        <span class="s0">with </span><span class="s1">trio.CancelScope() </span><span class="s0">as </span><span class="s1">cscope:</span>
            <span class="s1">in_host(</span><span class="s0">lambda</span><span class="s1">: set_deadline(cscope</span><span class="s0">, </span><span class="s1">-inf))</span>
            <span class="s0">await </span><span class="s1">trio.sleep_forever()</span>
        <span class="s0">assert </span><span class="s1">cscope.cancelled_caught</span>

        <span class="s0">with </span><span class="s1">trio.CancelScope() </span><span class="s0">as </span><span class="s1">cscope:</span>
            <span class="s2"># also do a change that doesn't affect the next deadline, just to</span>
            <span class="s2"># exercise that path</span>
            <span class="s1">in_host(</span><span class="s0">lambda</span><span class="s1">: set_deadline(cscope</span><span class="s0">, </span><span class="s4">1e6</span><span class="s1">))</span>
            <span class="s1">in_host(</span><span class="s0">lambda</span><span class="s1">: set_deadline(cscope</span><span class="s0">, </span><span class="s1">-inf))</span>
            <span class="s0">await </span><span class="s1">trio.sleep(</span><span class="s4">999</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">cscope.cancelled_caught</span>

        <span class="s0">return </span><span class="s3">&quot;ok&quot;</span>

    <span class="s0">assert </span><span class="s1">trivial_guest_run(trio_main) == </span><span class="s3">&quot;ok&quot;</span>


<span class="s0">def </span><span class="s1">test_warn_set_wakeup_fd_overwrite():</span>
    <span class="s0">assert </span><span class="s1">signal.set_wakeup_fd(-</span><span class="s4">1</span><span class="s1">) == -</span><span class="s4">1</span>

    <span class="s0">async def </span><span class="s1">trio_main(in_host):</span>
        <span class="s0">return </span><span class="s3">&quot;ok&quot;</span>

    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = socket.socketpair()</span>
    <span class="s0">with </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b:</span>
        <span class="s1">a.setblocking(</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s2"># Warn if there's already a wakeup fd</span>
        <span class="s1">signal.set_wakeup_fd(a.fileno())</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;signal handling code.*collided&quot;</span><span class="s1">):</span>
                <span class="s0">assert </span><span class="s1">trivial_guest_run(trio_main) == </span><span class="s3">&quot;ok&quot;</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">signal.set_wakeup_fd(-</span><span class="s4">1</span><span class="s1">) == a.fileno()</span>

        <span class="s1">signal.set_wakeup_fd(a.fileno())</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;signal handling code.*collided&quot;</span><span class="s1">):</span>
                <span class="s0">assert </span><span class="s1">(</span>
                    <span class="s1">trivial_guest_run(trio_main</span><span class="s0">, </span><span class="s1">host_uses_signal_set_wakeup_fd=</span><span class="s0">False</span><span class="s1">)</span>
                    <span class="s1">== </span><span class="s3">&quot;ok&quot;</span>
                <span class="s1">)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">signal.set_wakeup_fd(-</span><span class="s4">1</span><span class="s1">) == a.fileno()</span>

        <span class="s2"># Don't warn if there isn't already a wakeup fd</span>
        <span class="s0">with </span><span class="s1">pytest.warns(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">as </span><span class="s1">record:</span>
            <span class="s0">assert </span><span class="s1">trivial_guest_run(trio_main) == </span><span class="s3">&quot;ok&quot;</span>
        <span class="s2"># Apparently this is how you assert 'there were no RuntimeWarnings'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
            <span class="s1">record.pop(RuntimeWarning)</span>

        <span class="s0">with </span><span class="s1">pytest.warns(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">as </span><span class="s1">record:</span>
            <span class="s0">assert </span><span class="s1">(</span>
                <span class="s1">trivial_guest_run(trio_main</span><span class="s0">, </span><span class="s1">host_uses_signal_set_wakeup_fd=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">== </span><span class="s3">&quot;ok&quot;</span>
            <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
            <span class="s1">record.pop(RuntimeWarning)</span>

        <span class="s2"># If there's already a wakeup fd, but we've been told to trust it,</span>
        <span class="s2"># then it's left alone and there's no warning</span>
        <span class="s1">signal.set_wakeup_fd(a.fileno())</span>
        <span class="s0">try</span><span class="s1">:</span>

            <span class="s0">async def </span><span class="s1">trio_check_wakeup_fd_unaltered(in_host):</span>
                <span class="s1">fd = signal.set_wakeup_fd(-</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s0">assert </span><span class="s1">fd == a.fileno()</span>
                <span class="s1">signal.set_wakeup_fd(fd)</span>
                <span class="s0">return </span><span class="s3">&quot;ok&quot;</span>

            <span class="s0">with </span><span class="s1">pytest.warns(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">as </span><span class="s1">record:</span>
                <span class="s0">assert </span><span class="s1">(</span>
                    <span class="s1">trivial_guest_run(</span>
                        <span class="s1">trio_check_wakeup_fd_unaltered</span><span class="s0">,</span>
                        <span class="s1">host_uses_signal_set_wakeup_fd=</span><span class="s0">True,</span>
                    <span class="s1">)</span>
                    <span class="s1">== </span><span class="s3">&quot;ok&quot;</span>
                <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
                <span class="s1">record.pop(RuntimeWarning)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">signal.set_wakeup_fd(-</span><span class="s4">1</span><span class="s1">) == a.fileno()</span>


<span class="s0">def </span><span class="s1">test_host_wakeup_doesnt_trigger_wait_all_tasks_blocked():</span>
    <span class="s2"># This is designed to hit the branch in unrolled_run where:</span>
    <span class="s2">#   idle_primed=True</span>
    <span class="s2">#   runner.runq is empty</span>
    <span class="s2">#   events is Truth-y</span>
    <span class="s2"># ...and confirm that in this case, wait_all_tasks_blocked does not get</span>
    <span class="s2"># triggered.</span>
    <span class="s0">def </span><span class="s1">set_deadline(cscope</span><span class="s0">, </span><span class="s1">new_deadline):</span>
        <span class="s1">print(</span><span class="s3">f&quot;setting deadline </span><span class="s0">{</span><span class="s1">new_deadline</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">cscope.deadline = new_deadline</span>

    <span class="s0">async def </span><span class="s1">trio_main(in_host):</span>
        <span class="s0">async def </span><span class="s1">sit_in_wait_all_tasks_blocked(watb_cscope):</span>
            <span class="s0">with </span><span class="s1">watb_cscope:</span>
                <span class="s2"># Overall point of this test is that this</span>
                <span class="s2"># wait_all_tasks_blocked should *not* return normally, but</span>
                <span class="s2"># only by cancellation.</span>
                <span class="s0">await </span><span class="s1">trio.testing.wait_all_tasks_blocked(cushion=</span><span class="s4">9999</span><span class="s1">)</span>
                <span class="s0">assert False  </span><span class="s2"># pragma: no cover</span>
            <span class="s0">assert </span><span class="s1">watb_cscope.cancelled_caught</span>

        <span class="s0">async def </span><span class="s1">get_woken_by_host_deadline(watb_cscope):</span>
            <span class="s0">with </span><span class="s1">trio.CancelScope() </span><span class="s0">as </span><span class="s1">cscope:</span>
                <span class="s1">print(</span><span class="s3">&quot;scheduling stuff to happen&quot;</span><span class="s1">)</span>
                <span class="s2"># Altering the deadline from the host, to something in the</span>
                <span class="s2"># future, will cause the run loop to wake up, but then</span>
                <span class="s2"># discover that there is nothing to do and go back to sleep.</span>
                <span class="s2"># This should *not* trigger wait_all_tasks_blocked.</span>
                <span class="s2">#</span>
                <span class="s2"># So the 'before_io_wait' here will wait until we're blocking</span>
                <span class="s2"># with the wait_all_tasks_blocked primed, and then schedule a</span>
                <span class="s2"># deadline change. The critical test is that this should *not*</span>
                <span class="s2"># wake up 'sit_in_wait_all_tasks_blocked'.</span>
                <span class="s2">#</span>
                <span class="s2"># The after we've had a chance to wake up</span>
                <span class="s2"># 'sit_in_wait_all_tasks_blocked', we want the test to</span>
                <span class="s2"># actually end. So in after_io_wait we schedule a second host</span>
                <span class="s2"># call to tear things down.</span>
                <span class="s0">class </span><span class="s1">InstrumentHelper:</span>
                    <span class="s0">def </span><span class="s1">__init__(self):</span>
                        <span class="s1">self.primed = </span><span class="s0">False</span>

                    <span class="s0">def </span><span class="s1">before_io_wait(self</span><span class="s0">, </span><span class="s1">timeout):</span>
                        <span class="s1">print(</span><span class="s3">f&quot;before_io_wait(</span><span class="s0">{</span><span class="s1">timeout</span><span class="s0">}</span><span class="s3">)&quot;</span><span class="s1">)</span>
                        <span class="s0">if </span><span class="s1">timeout == </span><span class="s4">9999</span><span class="s1">:  </span><span class="s2"># pragma: no branch</span>
                            <span class="s0">assert not </span><span class="s1">self.primed</span>
                            <span class="s1">in_host(</span><span class="s0">lambda</span><span class="s1">: set_deadline(cscope</span><span class="s0">, </span><span class="s4">1e9</span><span class="s1">))</span>
                            <span class="s1">self.primed = </span><span class="s0">True</span>

                    <span class="s0">def </span><span class="s1">after_io_wait(self</span><span class="s0">, </span><span class="s1">timeout):</span>
                        <span class="s0">if </span><span class="s1">self.primed:  </span><span class="s2"># pragma: no branch</span>
                            <span class="s1">print(</span><span class="s3">&quot;instrument triggered&quot;</span><span class="s1">)</span>
                            <span class="s1">in_host(</span><span class="s0">lambda</span><span class="s1">: cscope.cancel())</span>
                            <span class="s1">trio.lowlevel.remove_instrument(self)</span>

                <span class="s1">trio.lowlevel.add_instrument(InstrumentHelper())</span>
                <span class="s0">await </span><span class="s1">trio.sleep_forever()</span>
            <span class="s0">assert </span><span class="s1">cscope.cancelled_caught</span>
            <span class="s1">watb_cscope.cancel()</span>

        <span class="s0">async with </span><span class="s1">trio.open_nursery() </span><span class="s0">as </span><span class="s1">nursery:</span>
            <span class="s1">watb_cscope = trio.CancelScope()</span>
            <span class="s1">nursery.start_soon(sit_in_wait_all_tasks_blocked</span><span class="s0">, </span><span class="s1">watb_cscope)</span>
            <span class="s0">await </span><span class="s1">trio.testing.wait_all_tasks_blocked()</span>
            <span class="s1">nursery.start_soon(get_woken_by_host_deadline</span><span class="s0">, </span><span class="s1">watb_cscope)</span>

        <span class="s0">return </span><span class="s3">&quot;ok&quot;</span>

    <span class="s0">assert </span><span class="s1">trivial_guest_run(trio_main) == </span><span class="s3">&quot;ok&quot;</span>


<span class="s1">@restore_unraisablehook()</span>
<span class="s0">def </span><span class="s1">test_guest_warns_if_abandoned():</span>
    <span class="s2"># This warning is emitted from the garbage collector. So we have to make</span>
    <span class="s2"># sure that our abandoned run is garbage. The easiest way to do this is to</span>
    <span class="s2"># put it into a function, so that we're sure all the local state,</span>
    <span class="s2"># traceback frames, etc. are garbage once it returns.</span>
    <span class="s0">def </span><span class="s1">do_abandoned_guest_run():</span>
        <span class="s0">async def </span><span class="s1">abandoned_main(in_host):</span>
            <span class="s1">in_host(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s4">1 </span><span class="s1">/ </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">trio.sleep(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ZeroDivisionError):</span>
            <span class="s1">trivial_guest_run(abandoned_main)</span>

    <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Trio guest run got abandoned&quot;</span><span class="s1">):</span>
        <span class="s1">do_abandoned_guest_run()</span>
        <span class="s1">gc_collect_harder()</span>

        <span class="s2"># If you have problems some day figuring out what's holding onto a</span>
        <span class="s2"># reference to the unrolled_run generator and making this test fail,</span>
        <span class="s2"># then this might be useful to help track it down. (It assumes you</span>
        <span class="s2"># also hack start_guest_run so that it does 'global W; W =</span>
        <span class="s2"># weakref(unrolled_run_gen)'.)</span>
        <span class="s2">#</span>
        <span class="s2"># import gc</span>
        <span class="s2"># print(trio._core._run.W)</span>
        <span class="s2"># targets = [trio._core._run.W()]</span>
        <span class="s2"># for i in range(15):</span>
        <span class="s2">#     new_targets = []</span>
        <span class="s2">#     for target in targets:</span>
        <span class="s2">#         new_targets += gc.get_referrers(target)</span>
        <span class="s2">#         new_targets.remove(targets)</span>
        <span class="s2">#     print(&quot;#####################&quot;)</span>
        <span class="s2">#     print(f&quot;depth {i}: {len(new_targets)}&quot;)</span>
        <span class="s2">#     print(new_targets)</span>
        <span class="s2">#     targets = new_targets</span>

        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
            <span class="s1">trio.current_time()</span>


<span class="s0">def </span><span class="s1">aiotrio_run(trio_fn</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">pass_not_threadsafe=</span><span class="s0">True, </span><span class="s1">**start_guest_run_kwargs):</span>
    <span class="s1">loop = asyncio.new_event_loop()</span>

    <span class="s0">async def </span><span class="s1">aio_main():</span>
        <span class="s1">trio_done_fut = loop.create_future()</span>

        <span class="s0">def </span><span class="s1">trio_done_callback(main_outcome):</span>
            <span class="s1">print(</span><span class="s3">f&quot;trio_fn finished: </span><span class="s0">{</span><span class="s1">main_outcome</span><span class="s0">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">trio_done_fut.set_result(main_outcome)</span>

        <span class="s0">if </span><span class="s1">pass_not_threadsafe:</span>
            <span class="s1">start_guest_run_kwargs[</span><span class="s3">&quot;run_sync_soon_not_threadsafe&quot;</span><span class="s1">] = loop.call_soon</span>

        <span class="s1">trio.lowlevel.start_guest_run(</span>
            <span class="s1">trio_fn</span><span class="s0">,</span>
            <span class="s1">run_sync_soon_threadsafe=loop.call_soon_threadsafe</span><span class="s0">,</span>
            <span class="s1">done_callback=trio_done_callback</span><span class="s0">,</span>
            <span class="s1">**start_guest_run_kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">(</span><span class="s0">await </span><span class="s1">trio_done_fut).unwrap()</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">loop.run_until_complete(aio_main())</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">loop.close()</span>


<span class="s0">def </span><span class="s1">test_guest_mode_on_asyncio():</span>
    <span class="s0">async def </span><span class="s1">trio_main():</span>
        <span class="s1">print(</span><span class="s3">&quot;trio_main!&quot;</span><span class="s1">)</span>

        <span class="s1">to_trio</span><span class="s0">, </span><span class="s1">from_aio = trio.open_memory_channel(float(</span><span class="s3">&quot;inf&quot;</span><span class="s1">))</span>
        <span class="s1">from_trio = asyncio.Queue()</span>

        <span class="s1">aio_task = asyncio.ensure_future(aio_pingpong(from_trio</span><span class="s0">, </span><span class="s1">to_trio))</span>

        <span class="s2"># Make sure we have at least one tick where we don't need to go into</span>
        <span class="s2"># the thread</span>
        <span class="s0">await </span><span class="s1">trio.sleep(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">from_trio.put_nowait(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0">async for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">from_aio:</span>
            <span class="s1">print(</span><span class="s3">f&quot;trio got: </span><span class="s0">{</span><span class="s1">n</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">from_trio.put_nowait(n + </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">n &gt;= </span><span class="s4">10</span><span class="s1">:</span>
                <span class="s1">aio_task.cancel()</span>
                <span class="s0">return </span><span class="s3">&quot;trio-main-done&quot;</span>

    <span class="s0">async def </span><span class="s1">aio_pingpong(from_trio</span><span class="s0">, </span><span class="s1">to_trio):</span>
        <span class="s1">print(</span><span class="s3">&quot;aio_pingpong!&quot;</span><span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">while True</span><span class="s1">:</span>
                <span class="s1">n = </span><span class="s0">await </span><span class="s1">from_trio.get()</span>
                <span class="s1">print(</span><span class="s3">f&quot;aio got: </span><span class="s0">{</span><span class="s1">n</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s1">to_trio.send_nowait(n + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">asyncio.CancelledError:</span>
            <span class="s0">raise</span>
        <span class="s0">except</span><span class="s1">:  </span><span class="s2"># pragma: no cover</span>
            <span class="s1">traceback.print_exc()</span>
            <span class="s0">raise</span>

    <span class="s0">assert </span><span class="s1">(</span>
        <span class="s1">aiotrio_run(</span>
            <span class="s1">trio_main</span><span class="s0">,</span>
            <span class="s2"># Not all versions of asyncio we test on can actually be trusted,</span>
            <span class="s2"># but this test doesn't care about signal handling, and it's</span>
            <span class="s2"># easier to just avoid the warnings.</span>
            <span class="s1">host_uses_signal_set_wakeup_fd=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">== </span><span class="s3">&quot;trio-main-done&quot;</span>
    <span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">(</span>
        <span class="s1">aiotrio_run(</span>
            <span class="s1">trio_main</span><span class="s0">,</span>
            <span class="s2"># Also check that passing only call_soon_threadsafe works, via the</span>
            <span class="s2"># fallback path where we use it for everything.</span>
            <span class="s1">pass_not_threadsafe=</span><span class="s0">False,</span>
            <span class="s1">host_uses_signal_set_wakeup_fd=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">== </span><span class="s3">&quot;trio-main-done&quot;</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_guest_mode_internal_errors(monkeypatch</span><span class="s0">, </span><span class="s1">recwarn):</span>
    <span class="s0">with </span><span class="s1">monkeypatch.context() </span><span class="s0">as </span><span class="s1">m:</span>

        <span class="s0">async def </span><span class="s1">crash_in_run_loop(in_host):</span>
            <span class="s1">m.setattr(</span><span class="s3">&quot;trio._core._run.GLOBAL_RUN_CONTEXT.runner.runq&quot;</span><span class="s0">, </span><span class="s3">&quot;HI&quot;</span><span class="s1">)</span>
            <span class="s0">await </span><span class="s1">trio.sleep(</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(trio.TrioInternalError):</span>
            <span class="s1">trivial_guest_run(crash_in_run_loop)</span>

    <span class="s0">with </span><span class="s1">monkeypatch.context() </span><span class="s0">as </span><span class="s1">m:</span>

        <span class="s0">async def </span><span class="s1">crash_in_io(in_host):</span>
            <span class="s1">m.setattr(</span><span class="s3">&quot;trio._core._run.TheIOManager.get_events&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">await </span><span class="s1">trio.sleep(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(trio.TrioInternalError):</span>
            <span class="s1">trivial_guest_run(crash_in_io)</span>

    <span class="s0">with </span><span class="s1">monkeypatch.context() </span><span class="s0">as </span><span class="s1">m:</span>

        <span class="s0">async def </span><span class="s1">crash_in_worker_thread_io(in_host):</span>
            <span class="s1">t = threading.current_thread()</span>
            <span class="s1">old_get_events = trio._core._run.TheIOManager.get_events</span>

            <span class="s0">def </span><span class="s1">bad_get_events(*args):</span>
                <span class="s0">if </span><span class="s1">threading.current_thread() </span><span class="s0">is not </span><span class="s1">t:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;oh no!&quot;</span><span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">old_get_events(*args)</span>

            <span class="s1">m.setattr(</span><span class="s3">&quot;trio._core._run.TheIOManager.get_events&quot;</span><span class="s0">, </span><span class="s1">bad_get_events)</span>

            <span class="s0">await </span><span class="s1">trio.sleep(</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(trio.TrioInternalError):</span>
            <span class="s1">trivial_guest_run(crash_in_worker_thread_io)</span>

    <span class="s1">gc_collect_harder()</span>


<span class="s0">def </span><span class="s1">test_guest_mode_ki():</span>
    <span class="s0">assert </span><span class="s1">signal.getsignal(signal.SIGINT) </span><span class="s0">is </span><span class="s1">signal.default_int_handler</span>

    <span class="s2"># Check SIGINT in Trio func and in host func</span>
    <span class="s0">async def </span><span class="s1">trio_main(in_host):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt):</span>
            <span class="s1">signal_raise(signal.SIGINT)</span>

        <span class="s2"># Host SIGINT should get injected into Trio</span>
        <span class="s1">in_host(partial(signal_raise</span><span class="s0">, </span><span class="s1">signal.SIGINT))</span>
        <span class="s0">await </span><span class="s1">trio.sleep(</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">trivial_guest_run(trio_main)</span>
    <span class="s0">assert </span><span class="s1">excinfo.value.__context__ </span><span class="s0">is None</span>
    <span class="s2"># Signal handler should be restored properly on exit</span>
    <span class="s0">assert </span><span class="s1">signal.getsignal(signal.SIGINT) </span><span class="s0">is </span><span class="s1">signal.default_int_handler</span>

    <span class="s2"># Also check chaining in the case where KI is injected after main exits</span>
    <span class="s1">final_exc = KeyError(</span><span class="s3">&quot;whoa&quot;</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">trio_main_raising(in_host):</span>
        <span class="s1">in_host(partial(signal_raise</span><span class="s0">, </span><span class="s1">signal.SIGINT))</span>
        <span class="s0">raise </span><span class="s1">final_exc</span>

    <span class="s0">with </span><span class="s1">pytest.raises(KeyboardInterrupt) </span><span class="s0">as </span><span class="s1">excinfo:</span>
        <span class="s1">trivial_guest_run(trio_main_raising)</span>
    <span class="s0">assert </span><span class="s1">excinfo.value.__context__ </span><span class="s0">is </span><span class="s1">final_exc</span>

    <span class="s0">assert </span><span class="s1">signal.getsignal(signal.SIGINT) </span><span class="s0">is </span><span class="s1">signal.default_int_handler</span>


<span class="s0">def </span><span class="s1">test_guest_mode_autojump_clock_threshold_changing():</span>
    <span class="s2"># This is super obscure and probably no-one will ever notice, but</span>
    <span class="s2"># technically mutating the MockClock.autojump_threshold from the host</span>
    <span class="s2"># should wake up the guest, so let's test it.</span>

    <span class="s1">clock = trio.testing.MockClock()</span>

    <span class="s1">DURATION = </span><span class="s4">120</span>

    <span class="s0">async def </span><span class="s1">trio_main(in_host):</span>
        <span class="s0">assert </span><span class="s1">trio.current_time() == </span><span class="s4">0</span>
        <span class="s1">in_host(</span><span class="s0">lambda</span><span class="s1">: setattr(clock</span><span class="s0">, </span><span class="s3">&quot;autojump_threshold&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s0">await </span><span class="s1">trio.sleep(DURATION)</span>
        <span class="s0">assert </span><span class="s1">trio.current_time() == DURATION</span>

    <span class="s1">start = time.monotonic()</span>
    <span class="s1">trivial_guest_run(trio_main</span><span class="s0">, </span><span class="s1">clock=clock)</span>
    <span class="s1">end = time.monotonic()</span>
    <span class="s2"># Should be basically instantaneous, but we'll leave a generous buffer to</span>
    <span class="s2"># account for any CI weirdness</span>
    <span class="s0">assert </span><span class="s1">end - start &lt; DURATION / </span><span class="s4">2</span>


<span class="s1">@pytest.mark.skipif(buggy_pypy_asyncgens</span><span class="s0">, </span><span class="s1">reason=</span><span class="s3">&quot;PyPy 7.2 is buggy&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.xfail(</span>
    <span class="s1">sys.implementation.name == </span><span class="s3">&quot;pypy&quot; </span><span class="s0">and </span><span class="s1">sys.version_info &gt;= (</span><span class="s4">3</span><span class="s0">, </span><span class="s4">7</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">reason=</span><span class="s3">&quot;async generator issue under investigation&quot;</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@restore_unraisablehook()</span>
<span class="s0">def </span><span class="s1">test_guest_mode_asyncgens():</span>
    <span class="s0">import </span><span class="s1">sniffio</span>

    <span class="s1">record = set()</span>

    <span class="s0">async def </span><span class="s1">agen(label):</span>
        <span class="s0">assert </span><span class="s1">sniffio.current_async_library() == label</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s4">1</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">library = sniffio.current_async_library()</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">await </span><span class="s1">sys.modules[library].sleep(</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">trio.Cancelled:</span>
                <span class="s0">pass</span>
            <span class="s1">record.add((label</span><span class="s0">, </span><span class="s1">library))</span>

    <span class="s0">async def </span><span class="s1">iterate_in_aio():</span>
        <span class="s2"># &quot;trio&quot; gets inherited from our Trio caller if we don't set this</span>
        <span class="s1">sniffio.current_async_library_cvar.set(</span><span class="s3">&quot;asyncio&quot;</span><span class="s1">)</span>
        <span class="s0">await </span><span class="s1">agen(</span><span class="s3">&quot;asyncio&quot;</span><span class="s1">).asend(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s0">async def </span><span class="s1">trio_main():</span>
        <span class="s1">task = asyncio.ensure_future(iterate_in_aio())</span>
        <span class="s1">done_evt = trio.Event()</span>
        <span class="s1">task.add_done_callback(</span><span class="s0">lambda </span><span class="s1">_: done_evt.set())</span>
        <span class="s0">with </span><span class="s1">trio.fail_after(</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s0">await </span><span class="s1">done_evt.wait()</span>

        <span class="s0">await </span><span class="s1">agen(</span><span class="s3">&quot;trio&quot;</span><span class="s1">).asend(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s1">gc_collect_harder()</span>

    <span class="s2"># Ensure we don't pollute the thread-level context if run under</span>
    <span class="s2"># an asyncio without contextvars support (3.6)</span>
    <span class="s1">context = contextvars.copy_context()</span>
    <span class="s1">context.run(aiotrio_run</span><span class="s0">, </span><span class="s1">trio_main</span><span class="s0">, </span><span class="s1">host_uses_signal_set_wakeup_fd=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">record == {(</span><span class="s3">&quot;asyncio&quot;</span><span class="s0">, </span><span class="s3">&quot;asyncio&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">&quot;trio&quot;</span><span class="s0">, </span><span class="s3">&quot;trio&quot;</span><span class="s1">)}</span>
</pre>
</body>
</html>