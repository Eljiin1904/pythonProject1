<html>
<head>
<title>memory.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
memory.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: Memory (experimental)</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>

<span class="s2">class </span><span class="s1">PressureLevel(enum.Enum):</span>
    <span class="s3">''' 
    Memory pressure level. 
    '''</span>
    <span class="s1">MODERATE = </span><span class="s4">&quot;moderate&quot;</span>
    <span class="s1">CRITICAL = </span><span class="s4">&quot;critical&quot;</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s2">return </span><span class="s1">self.value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(json)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SamplingProfileNode:</span>
    <span class="s3">''' 
    Heap profile sample. 
    '''</span>
    <span class="s0">#: Size of the sampled allocation.</span>
    <span class="s1">size: float</span>

    <span class="s0">#: Total bytes attributed to this sample.</span>
    <span class="s1">total: float</span>

    <span class="s0">#: Execution stack at the point of allocation.</span>
    <span class="s1">stack: typing.List[str]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'size'</span><span class="s1">] = self.size</span>
        <span class="s1">json[</span><span class="s4">'total'</span><span class="s1">] = self.total</span>
        <span class="s1">json[</span><span class="s4">'stack'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.stack]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">size=float(json[</span><span class="s4">'size'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">total=float(json[</span><span class="s4">'total'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">stack=[str(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'stack'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">SamplingProfile:</span>
    <span class="s3">''' 
    Array of heap profile samples. 
    '''</span>
    <span class="s1">samples: typing.List[SamplingProfileNode]</span>

    <span class="s1">modules: typing.List[Module]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'samples'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.samples]</span>
        <span class="s1">json[</span><span class="s4">'modules'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.modules]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">samples=[SamplingProfileNode.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'samples'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">modules=[Module.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'modules'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Module:</span>
    <span class="s3">''' 
    Executable module information 
    '''</span>
    <span class="s0">#: Name of the module.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: UUID of the module.</span>
    <span class="s1">uuid: str</span>

    <span class="s0">#: Base address where the module is loaded into memory. Encoded as a decimal</span>
    <span class="s0">#: or hexadecimal (0x prefixed) string.</span>
    <span class="s1">base_address: str</span>

    <span class="s0">#: Size of the module in bytes.</span>
    <span class="s1">size: float</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'uuid'</span><span class="s1">] = self.uuid</span>
        <span class="s1">json[</span><span class="s4">'baseAddress'</span><span class="s1">] = self.base_address</span>
        <span class="s1">json[</span><span class="s4">'size'</span><span class="s1">] = self.size</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">uuid=str(json[</span><span class="s4">'uuid'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">base_address=str(json[</span><span class="s4">'baseAddress'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">size=float(json[</span><span class="s4">'size'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">get_dom_counters() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[int</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">int]]:</span>
    <span class="s3">''' 
 
 
    :returns: A tuple with the following items: 
 
        0. **documents** -  
        1. **nodes** -  
        2. **jsEventListeners** -  
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.getDOMCounters'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">int(json[</span><span class="s4">'documents'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">int(json[</span><span class="s4">'nodes'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">int(json[</span><span class="s4">'jsEventListeners'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">prepare_for_leak_detection() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>

    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.prepareForLeakDetection'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">forcibly_purge_java_script_memory() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Simulate OomIntervention by purging V8 memory. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.forciblyPurgeJavaScriptMemory'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">set_pressure_notifications_suppressed(</span>
        <span class="s1">suppressed: bool</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enable/disable suppressing memory pressure notifications in all processes. 
 
    :param suppressed: If true, memory pressure notifications will be suppressed. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'suppressed'</span><span class="s1">] = suppressed</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.setPressureNotificationsSuppressed'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">simulate_pressure_notification(</span>
        <span class="s1">level: PressureLevel</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Simulate a memory pressure notification in all processes. 
 
    :param level: Memory pressure level of the notification. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'level'</span><span class="s1">] = level.to_json()</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.simulatePressureNotification'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">start_sampling(</span>
        <span class="s1">sampling_interval: typing.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">suppress_randomness: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Start collecting native memory profile. 
 
    :param sampling_interval: *(Optional)* Average number of bytes between samples. 
    :param suppress_randomness: *(Optional)* Do not randomize intervals between samples. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">sampling_interval </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'samplingInterval'</span><span class="s1">] = sampling_interval</span>
    <span class="s2">if </span><span class="s1">suppress_randomness </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'suppressRandomness'</span><span class="s1">] = suppress_randomness</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.startSampling'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">stop_sampling() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Stop collecting native memory profile. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.stopSampling'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_all_time_sampling_profile() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">SamplingProfile]:</span>
    <span class="s3">''' 
    Retrieve native memory allocations profile 
    collected since renderer process startup. 
 
    :returns:  
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.getAllTimeSamplingProfile'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">SamplingProfile.from_json(json[</span><span class="s4">'profile'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_browser_sampling_profile() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">SamplingProfile]:</span>
    <span class="s3">''' 
    Retrieve native memory allocations profile 
    collected since browser process startup. 
 
    :returns:  
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.getBrowserSamplingProfile'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">SamplingProfile.from_json(json[</span><span class="s4">'profile'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">get_sampling_profile() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">SamplingProfile]:</span>
    <span class="s3">''' 
    Retrieve native memory allocations profile collected since last 
    ``startSampling`` call. 
 
    :returns:  
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Memory.getSamplingProfile'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">SamplingProfile.from_json(json[</span><span class="s4">'profile'</span><span class="s1">])</span>
</pre>
</body>
</html>