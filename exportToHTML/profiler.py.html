<html>
<head>
<title>profiler.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
profiler.py</font>
</center></td></tr></table>
<pre><span class="s0"># DO NOT EDIT THIS FILE!</span>
<span class="s0">#</span>
<span class="s0"># This file is generated from the CDP specification. If you need to make</span>
<span class="s0"># changes, edit the generator and regenerate all of the modules.</span>
<span class="s0">#</span>
<span class="s0"># CDP domain: Profiler</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>
<span class="s2">from </span><span class="s1">.util </span><span class="s2">import </span><span class="s1">event_class</span><span class="s2">, </span><span class="s1">T_JSON_DICT</span>
<span class="s2">from </span><span class="s1">dataclasses </span><span class="s2">import </span><span class="s1">dataclass</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">typing</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">debugger</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">runtime</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ProfileNode:</span>
    <span class="s3">''' 
    Profile node. Holds callsite information, execution statistics and child nodes. 
    '''</span>
    <span class="s0">#: Unique id of the node.</span>
    <span class="s1">id_: int</span>

    <span class="s0">#: Function location.</span>
    <span class="s1">call_frame: runtime.CallFrame</span>

    <span class="s0">#: Number of samples where this node was on top of the call stack.</span>
    <span class="s1">hit_count: typing.Optional[int] = </span><span class="s2">None</span>

    <span class="s0">#: Child node ids.</span>
    <span class="s1">children: typing.Optional[typing.List[int]] = </span><span class="s2">None</span>

    <span class="s0">#: The reason of being not optimized. The function may be deoptimized or marked as don't</span>
    <span class="s0">#: optimize.</span>
    <span class="s1">deopt_reason: typing.Optional[str] = </span><span class="s2">None</span>

    <span class="s0">#: An array of source position ticks.</span>
    <span class="s1">position_ticks: typing.Optional[typing.List[PositionTickInfo]] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'id'</span><span class="s1">] = self.id_</span>
        <span class="s1">json[</span><span class="s4">'callFrame'</span><span class="s1">] = self.call_frame.to_json()</span>
        <span class="s2">if </span><span class="s1">self.hit_count </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'hitCount'</span><span class="s1">] = self.hit_count</span>
        <span class="s2">if </span><span class="s1">self.children </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'children'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.children]</span>
        <span class="s2">if </span><span class="s1">self.deopt_reason </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'deoptReason'</span><span class="s1">] = self.deopt_reason</span>
        <span class="s2">if </span><span class="s1">self.position_ticks </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'positionTicks'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.position_ticks]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">id_=int(json[</span><span class="s4">'id'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">call_frame=runtime.CallFrame.from_json(json[</span><span class="s4">'callFrame'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">hit_count=int(json[</span><span class="s4">'hitCount'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'hitCount' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">children=[int(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'children'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'children' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">deopt_reason=str(json[</span><span class="s4">'deoptReason'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'deoptReason' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">position_ticks=[PositionTickInfo.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'positionTicks'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'positionTicks' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">Profile:</span>
    <span class="s3">''' 
    Profile. 
    '''</span>
    <span class="s0">#: The list of profile nodes. First item is the root node.</span>
    <span class="s1">nodes: typing.List[ProfileNode]</span>

    <span class="s0">#: Profiling start timestamp in microseconds.</span>
    <span class="s1">start_time: float</span>

    <span class="s0">#: Profiling end timestamp in microseconds.</span>
    <span class="s1">end_time: float</span>

    <span class="s0">#: Ids of samples top nodes.</span>
    <span class="s1">samples: typing.Optional[typing.List[int]] = </span><span class="s2">None</span>

    <span class="s0">#: Time intervals between adjacent samples in microseconds. The first delta is relative to the</span>
    <span class="s0">#: profile startTime.</span>
    <span class="s1">time_deltas: typing.Optional[typing.List[int]] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'nodes'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.nodes]</span>
        <span class="s1">json[</span><span class="s4">'startTime'</span><span class="s1">] = self.start_time</span>
        <span class="s1">json[</span><span class="s4">'endTime'</span><span class="s1">] = self.end_time</span>
        <span class="s2">if </span><span class="s1">self.samples </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'samples'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.samples]</span>
        <span class="s2">if </span><span class="s1">self.time_deltas </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">json[</span><span class="s4">'timeDeltas'</span><span class="s1">] = [i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.time_deltas]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">nodes=[ProfileNode.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'nodes'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">start_time=float(json[</span><span class="s4">'startTime'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">end_time=float(json[</span><span class="s4">'endTime'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">samples=[int(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'samples'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'samples' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
            <span class="s1">time_deltas=[int(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'timeDeltas'</span><span class="s1">]] </span><span class="s2">if </span><span class="s4">'timeDeltas' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PositionTickInfo:</span>
    <span class="s3">''' 
    Specifies a number of samples attributed to a certain source position. 
    '''</span>
    <span class="s0">#: Source line number (1-based).</span>
    <span class="s1">line: int</span>

    <span class="s0">#: Number of samples attributed to the source line.</span>
    <span class="s1">ticks: int</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'line'</span><span class="s1">] = self.line</span>
        <span class="s1">json[</span><span class="s4">'ticks'</span><span class="s1">] = self.ticks</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">line=int(json[</span><span class="s4">'line'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">ticks=int(json[</span><span class="s4">'ticks'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CoverageRange:</span>
    <span class="s3">''' 
    Coverage data for a source range. 
    '''</span>
    <span class="s0">#: JavaScript script source offset for the range start.</span>
    <span class="s1">start_offset: int</span>

    <span class="s0">#: JavaScript script source offset for the range end.</span>
    <span class="s1">end_offset: int</span>

    <span class="s0">#: Collected execution count of the source range.</span>
    <span class="s1">count: int</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'startOffset'</span><span class="s1">] = self.start_offset</span>
        <span class="s1">json[</span><span class="s4">'endOffset'</span><span class="s1">] = self.end_offset</span>
        <span class="s1">json[</span><span class="s4">'count'</span><span class="s1">] = self.count</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">start_offset=int(json[</span><span class="s4">'startOffset'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">end_offset=int(json[</span><span class="s4">'endOffset'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">count=int(json[</span><span class="s4">'count'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">FunctionCoverage:</span>
    <span class="s3">''' 
    Coverage data for a JavaScript function. 
    '''</span>
    <span class="s0">#: JavaScript function name.</span>
    <span class="s1">function_name: str</span>

    <span class="s0">#: Source ranges inside the function with coverage data.</span>
    <span class="s1">ranges: typing.List[CoverageRange]</span>

    <span class="s0">#: Whether coverage data for this function has block granularity.</span>
    <span class="s1">is_block_coverage: bool</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'functionName'</span><span class="s1">] = self.function_name</span>
        <span class="s1">json[</span><span class="s4">'ranges'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.ranges]</span>
        <span class="s1">json[</span><span class="s4">'isBlockCoverage'</span><span class="s1">] = self.is_block_coverage</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">function_name=str(json[</span><span class="s4">'functionName'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">ranges=[CoverageRange.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'ranges'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">is_block_coverage=bool(json[</span><span class="s4">'isBlockCoverage'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ScriptCoverage:</span>
    <span class="s3">''' 
    Coverage data for a JavaScript script. 
    '''</span>
    <span class="s0">#: JavaScript script id.</span>
    <span class="s1">script_id: runtime.ScriptId</span>

    <span class="s0">#: JavaScript script name or url.</span>
    <span class="s1">url: str</span>

    <span class="s0">#: Functions contained in the script that has coverage data.</span>
    <span class="s1">functions: typing.List[FunctionCoverage]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'scriptId'</span><span class="s1">] = self.script_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s1">json[</span><span class="s4">'functions'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.functions]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">script_id=runtime.ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">functions=[FunctionCoverage.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'functions'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">TypeObject:</span>
    <span class="s3">''' 
    Describes a type collected during runtime. 
    '''</span>
    <span class="s0">#: Name of a type collected with type profiling.</span>
    <span class="s1">name: str</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">TypeProfileEntry:</span>
    <span class="s3">''' 
    Source offset and types for a parameter or return value. 
    '''</span>
    <span class="s0">#: Source offset of the parameter or end of function for return values.</span>
    <span class="s1">offset: int</span>

    <span class="s0">#: The types for this parameter or return value.</span>
    <span class="s1">types: typing.List[TypeObject]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'offset'</span><span class="s1">] = self.offset</span>
        <span class="s1">json[</span><span class="s4">'types'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.types]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">offset=int(json[</span><span class="s4">'offset'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">types=[TypeObject.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'types'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ScriptTypeProfile:</span>
    <span class="s3">''' 
    Type profile data collected during runtime for a JavaScript script. 
    '''</span>
    <span class="s0">#: JavaScript script id.</span>
    <span class="s1">script_id: runtime.ScriptId</span>

    <span class="s0">#: JavaScript script name or url.</span>
    <span class="s1">url: str</span>

    <span class="s0">#: Type profile entries for parameters and return values of the functions in the script.</span>
    <span class="s1">entries: typing.List[TypeProfileEntry]</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'scriptId'</span><span class="s1">] = self.script_id.to_json()</span>
        <span class="s1">json[</span><span class="s4">'url'</span><span class="s1">] = self.url</span>
        <span class="s1">json[</span><span class="s4">'entries'</span><span class="s1">] = [i.to_json() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.entries]</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">script_id=runtime.ScriptId.from_json(json[</span><span class="s4">'scriptId'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">url=str(json[</span><span class="s4">'url'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">entries=[TypeProfileEntry.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'entries'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">CounterInfo:</span>
    <span class="s3">''' 
    Collected counter information. 
    '''</span>
    <span class="s0">#: Counter name.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: Counter value.</span>
    <span class="s1">value: int</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=int(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">RuntimeCallCounterInfo:</span>
    <span class="s3">''' 
    Runtime call counter information. 
    '''</span>
    <span class="s0">#: Counter name.</span>
    <span class="s1">name: str</span>

    <span class="s0">#: Counter value.</span>
    <span class="s1">value: float</span>

    <span class="s0">#: Counter time in seconds.</span>
    <span class="s1">time: float</span>

    <span class="s2">def </span><span class="s1">to_json(self):</span>
        <span class="s1">json = dict()</span>
        <span class="s1">json[</span><span class="s4">'name'</span><span class="s1">] = self.name</span>
        <span class="s1">json[</span><span class="s4">'value'</span><span class="s1">] = self.value</span>
        <span class="s1">json[</span><span class="s4">'time'</span><span class="s1">] = self.time</span>
        <span class="s2">return </span><span class="s1">json</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json):</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">name=str(json[</span><span class="s4">'name'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">value=float(json[</span><span class="s4">'value'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">time=float(json[</span><span class="s4">'time'</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">disable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>

    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.disable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">enable() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>

    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.enable'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_best_effort_coverage() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[ScriptCoverage]]:</span>
    <span class="s3">''' 
    Collect coverage data for the current isolate. The coverage data may be incomplete due to 
    garbage collection. 
 
    :returns: Coverage data for the current isolate. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.getBestEffortCoverage'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[ScriptCoverage.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">set_sampling_interval(</span>
        <span class="s1">interval: int</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. 
 
    :param interval: New sampling interval in microseconds. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s1">params[</span><span class="s4">'interval'</span><span class="s1">] = interval</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.setSamplingInterval'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">start() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>

    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.start'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">start_precise_coverage(</span>
        <span class="s1">call_count: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">detailed: typing.Optional[bool] = </span><span class="s2">None,</span>
        <span class="s1">allow_triggered_updates: typing.Optional[bool] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">float]:</span>
    <span class="s3">''' 
    Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code 
    coverage may be incomplete. Enabling prevents running optimized code and resets execution 
    counters. 
 
    :param call_count: *(Optional)* Collect accurate call counts beyond simple 'covered' or 'not covered'. 
    :param detailed: *(Optional)* Collect block-based coverage. 
    :param allow_triggered_updates: *(Optional)* Allow the backend to send updates on its own initiative 
    :returns: Monotonically increasing time (in seconds) when the coverage update was taken in the backend. 
    '''</span>
    <span class="s1">params: T_JSON_DICT = dict()</span>
    <span class="s2">if </span><span class="s1">call_count </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'callCount'</span><span class="s1">] = call_count</span>
    <span class="s2">if </span><span class="s1">detailed </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'detailed'</span><span class="s1">] = detailed</span>
    <span class="s2">if </span><span class="s1">allow_triggered_updates </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">params[</span><span class="s4">'allowTriggeredUpdates'</span><span class="s1">] = allow_triggered_updates</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.startPreciseCoverage'</span><span class="s2">,</span>
        <span class="s4">'params'</span><span class="s1">: params</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">float(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">start_type_profile() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enable type profile. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.startTypeProfile'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">stop() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">Profile]:</span>
    <span class="s3">''' 
 
 
    :returns: Recorded profile. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.stop'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">Profile.from_json(json[</span><span class="s4">'profile'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">stop_precise_coverage() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disable precise code coverage. Disabling releases unnecessary execution count records and allows 
    executing optimized code. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.stopPreciseCoverage'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">stop_type_profile() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disable type profile. Disabling releases type profile data collected so far. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.stopTypeProfile'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">take_precise_coverage() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.Tuple[typing.List[ScriptCoverage]</span><span class="s2">, </span><span class="s1">float]]:</span>
    <span class="s3">''' 
    Collect coverage data for the current isolate, and resets execution counters. Precise code 
    coverage needs to have started. 
 
    :returns: A tuple with the following items: 
 
        0. **result** - Coverage data for the current isolate. 
        1. **timestamp** - Monotonically increasing time (in seconds) when the coverage update was taken in the backend. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.takePreciseCoverage'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s1">[ScriptCoverage.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">float(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">take_type_profile() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[ScriptTypeProfile]]:</span>
    <span class="s3">''' 
    Collect type profile. 
 
    **EXPERIMENTAL** 
 
    :returns: Type profile for all scripts since startTypeProfile() was turned on. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.takeTypeProfile'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[ScriptTypeProfile.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">enable_counters() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enable counters collection. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.enableCounters'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">disable_counters() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disable counters collection. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.disableCounters'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_counters() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[CounterInfo]]:</span>
    <span class="s3">''' 
    Retrieve counters. 
 
    **EXPERIMENTAL** 
 
    :returns: Collected counters information. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.getCounters'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[CounterInfo.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span>


<span class="s2">def </span><span class="s1">enable_runtime_call_stats() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Enable run time call stats collection. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.enableRuntimeCallStats'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">disable_runtime_call_stats() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,None</span><span class="s1">]:</span>
    <span class="s3">''' 
    Disable run time call stats collection. 
 
    **EXPERIMENTAL** 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.disableRuntimeCallStats'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>


<span class="s2">def </span><span class="s1">get_runtime_call_stats() -&gt; typing.Generator[T_JSON_DICT</span><span class="s2">,</span><span class="s1">T_JSON_DICT</span><span class="s2">,</span><span class="s1">typing.List[RuntimeCallCounterInfo]]:</span>
    <span class="s3">''' 
    Retrieve run time call stats. 
 
    **EXPERIMENTAL** 
 
    :returns: Collected runtime call counter information. 
    '''</span>
    <span class="s1">cmd_dict: T_JSON_DICT = {</span>
        <span class="s4">'method'</span><span class="s1">: </span><span class="s4">'Profiler.getRuntimeCallStats'</span><span class="s2">,</span>
    <span class="s1">}</span>
    <span class="s1">json = </span><span class="s2">yield </span><span class="s1">cmd_dict</span>
    <span class="s2">return </span><span class="s1">[RuntimeCallCounterInfo.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span>


<span class="s1">@event_class(</span><span class="s4">'Profiler.consoleProfileFinished'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ConsoleProfileFinished:</span>
    <span class="s1">id_: str</span>
    <span class="s0">#: Location of console.profileEnd().</span>
    <span class="s1">location: debugger.Location</span>
    <span class="s1">profile: Profile</span>
    <span class="s0">#: Profile title passed as an argument to console.profile().</span>
    <span class="s1">title: typing.Optional[str]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ConsoleProfileFinished:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">id_=str(json[</span><span class="s4">'id'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">location=debugger.Location.from_json(json[</span><span class="s4">'location'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">profile=Profile.from_json(json[</span><span class="s4">'profile'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">title=str(json[</span><span class="s4">'title'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'title' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Profiler.consoleProfileStarted'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">ConsoleProfileStarted:</span>
    <span class="s3">''' 
    Sent when new profile recording is started using console.profile() call. 
    '''</span>
    <span class="s1">id_: str</span>
    <span class="s0">#: Location of console.profile().</span>
    <span class="s1">location: debugger.Location</span>
    <span class="s0">#: Profile title passed as an argument to console.profile().</span>
    <span class="s1">title: typing.Optional[str]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; ConsoleProfileStarted:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">id_=str(json[</span><span class="s4">'id'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">location=debugger.Location.from_json(json[</span><span class="s4">'location'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">title=str(json[</span><span class="s4">'title'</span><span class="s1">]) </span><span class="s2">if </span><span class="s4">'title' </span><span class="s2">in </span><span class="s1">json </span><span class="s2">else None</span>
        <span class="s1">)</span>


<span class="s1">@event_class(</span><span class="s4">'Profiler.preciseCoverageDeltaUpdate'</span><span class="s1">)</span>
<span class="s1">@dataclass</span>
<span class="s2">class </span><span class="s1">PreciseCoverageDeltaUpdate:</span>
    <span class="s3">''' 
    **EXPERIMENTAL** 
 
    Reports coverage delta since the last poll (either from an event like this, or from 
    ``takePreciseCoverage`` for the current isolate. May only be sent if precise code 
    coverage has been started. This event can be trigged by the embedder to, for example, 
    trigger collection of coverage data immediatelly at a certain point in time. 
    '''</span>
    <span class="s0">#: Monotonically increasing time (in seconds) when the coverage update was taken in the backend.</span>
    <span class="s1">timestamp: float</span>
    <span class="s0">#: Identifier for distinguishing coverage events.</span>
    <span class="s1">occassion: str</span>
    <span class="s0">#: Coverage data for the current isolate.</span>
    <span class="s1">result: typing.List[ScriptCoverage]</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_json(cls</span><span class="s2">, </span><span class="s1">json: T_JSON_DICT) -&gt; PreciseCoverageDeltaUpdate:</span>
        <span class="s2">return </span><span class="s1">cls(</span>
            <span class="s1">timestamp=float(json[</span><span class="s4">'timestamp'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">occassion=str(json[</span><span class="s4">'occassion'</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">result=[ScriptCoverage.from_json(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">json[</span><span class="s4">'result'</span><span class="s1">]]</span>
        <span class="s1">)</span>
</pre>
</body>
</html>